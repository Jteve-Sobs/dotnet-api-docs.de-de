<Type Name="String" FullName="System.String">
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Text als Sequenz von UTF-16-Codeeinheiten dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Eine Zeichenfolge ist eine sequenzielle Auflistung von Zeichen, die zum Darstellen von Text verwendet wird. Ein <xref:System.String> -Objekt ist eine sequenzielle <xref:System.Char?displayProperty=nameWithType> Auflistung von-Objekten, die eine <xref:System.Char?displayProperty=nameWithType> Zeichenfolge darstellen. ein-Objekt entspricht einer UTF-16-Code Einheit. Der Wert des <xref:System.String> -Objekts ist der Inhalt der sequenziellen Auflistung von <xref:System.Char?displayProperty=nameWithType> -Objekten, und dieser Wert ist unveränderlich (d. h., er ist schreibgeschützt). Weitere Informationen zur Unveränderlichkeit von Zeichen folgen finden Sie im Abschnitt [Unveränderlichkeit und StringBuilder-Klasse](#Immutability) weiter unten in diesem Thema. Die maximale Größe <xref:System.String> eines-Objekts im Arbeitsspeicher beträgt 2 GB oder ungefähr 1 Milliarde Zeichen.  
  
[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 In diesem Abschnitt  
  
 [Instanziieren eines String-Objekts](#Instantiation)   
 [Char-Objekte und Unicode-Zeichen](#Characters)   
 [Zeichen folgen und der Unicode-Standard](#Unicode)   
 [Zeichen folgen und eingebettete NULL-Zeichen](#EmbeddedNulls)   
 [Zeichen folgen und Indizes](#Indexes)   
 [NULL-Zeichen folgen und leere Zeichen folgen](#Nulls)   
 [Unveränderlichkeit und die StringBuilder-Klasse](#Immutability)   
 [Ordinal im Vergleich zu Kultur abhängigen Vorgängen](#CultureSensitive)   
 [Ebnet](#Normalization)   
 [Zeichen folgen Vorgänge nach Kategorie](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Instanziieren eines String-Objekts  
 Sie können ein <xref:System.String> -Objekt auf folgende Weise instanziieren:  
  
-   Durch Zuweisen eines Zeichenfolgenliterals zu einer <xref:System.String> Variablen. Dies ist die am häufigsten verwendete Methode zum Erstellen einer Zeichenfolge. Im folgenden Beispiel wird die Zuweisung verwendet, um mehrere Zeichen folgen zu erstellen. Beachten Sie, C#dass in, da der umgekehrte\\Schrägstrich () ein Escapezeichen ist, literale umgekehrte Schrägstriche in einer Zeichenfolge mit Escapezeichen versehen werden müssen oder die gesamte Zeichenfolge lauten @-quotedmuss.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp-interactive[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   Durch Aufrufen eines <xref:System.String> Klassenkonstruktors. Im folgenden Beispiel werden Zeichen folgen durch Aufrufen mehrerer Klassenkonstruktoren instanziiert. Beachten Sie, dass einige der Konstruktoren Zeiger auf Zeichen Arrays oder signierte Byte Arrays als Parameter enthalten. Der Visual Basic unterstützt keine Aufrufe dieser Konstruktoren. Ausführliche Informationen zu <xref:System.String> Konstruktoren finden Sie in der <xref:System.String.%23ctor%2A> Zusammenfassung des Konstruktors.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   Verwenden Sie den Operator für die Zeichen folgen Verkettung ( C# + in und & oder + in Visual Basic), um eine einzelne Zeichenfolge aus <xref:System.String> einer beliebigen Kombination aus-Instanzen und Zeichen folgen literalen zu erstellen. Das folgende Beispiel veranschaulicht die Verwendung des Operators Operator für Zeichen folgen Verkettung.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp-interactive[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   Durch Abrufen einer Eigenschaft oder Aufrufen einer Methode, die eine Zeichenfolge zurückgibt. Im folgenden Beispiel wird die-Methode <xref:System.String> der-Klasse verwendet, um eine Teil Zeichenfolge aus einer größeren Zeichenfolge zu extrahieren.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp-interactive[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   Durch Aufrufen einer Formatierungs Methode, um einen Wert oder ein Objekt in seine Zeichen folgen Darstellung zu konvertieren. Im folgenden Beispiel wird die Funktion für die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) verwendet, um die Zeichen folgen Darstellung von zwei-Objekten in eine Zeichenfolge einzubetten.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Char-Objekte und Unicode-Zeichen  
 Jedes Zeichen in einer Zeichenfolge wird durch einen Unicode-Skalarwert definiert, auch als Unicode-Codepunkt oder als Ordnungszahl (numerisch) des Unicode-Zeichens bezeichnet. Jeder Codepunkt wird mithilfe der UTF-16-Codierung codiert, und der numerische Wert jedes Elements der Codierung wird durch ein <xref:System.Char> -Objekt dargestellt.  
  
> [!NOTE]
>  Beachten Sie, dass es <xref:System.String> möglich ist, ein- <xref:System.String> Objekt zu erstellen, das keine wohlgeformte Unicode-Zeichenfolge ist, da eine-Instanz aus einer sequenziellen Auflistung von UTF-16-Code Einheiten besteht. Beispielsweise ist es möglich, eine Zeichenfolge zu erstellen, die ein niedriges Ersatz Zeichen ohne entsprechendes hohes Ersatz Zeichen enthält. Obwohl einige Methoden, z. b. die Methoden zum Codieren und Decodieren von Objekten im <xref:System.Text> -Namespace, Prüfungen durchführen können, um sicherzustellen, dass Zeichen folgen wohl geformt sind, <xref:System.String> stellen Klassenmember nicht sicher, dass eine Zeichenfolge wohl geformt ist.  
  
 Ein einzelnes <xref:System.Char> -Objekt stellt in der Regel einen einzelnen Codepunkt dar, d. h. <xref:System.Char> , der numerische Wert von entspricht dem Codepunkt. Beispielsweise ist der Codepunkt für das Zeichen "a" U + 0061. Ein Codepunkt benötigt jedoch möglicherweise mehr als ein codiertes Element (mehr als <xref:System.Char> ein Objekt). Der Unicode-Standard definiert zwei Typen von Zeichen, die mehreren <xref:System.Char> Objekten entsprechen: graphemes und zusätzliche Unicode-Code Punkte, die Zeichen in den zusätzlichen Unicode-Ebenen entsprechen.  
  
-   Ein graphemgruppen wird durch ein Basiszeichen gefolgt von einem oder mehreren kombinierten Zeichen dargestellt. Beispielsweise wird das Zeichen ä durch ein <xref:System.Char> -Objekt dargestellt, dessen Codepunkt u + 0061 ist, gefolgt von einem <xref:System.Char> -Objekt, dessen Codepunkt u + 0308 ist. Dieses Zeichen kann auch durch ein einzelnes <xref:System.Char> Objekt mit dem Codepunkt U + 00E4 definiert werden. Wie im folgenden Beispiel gezeigt, gibt ein Kultur abhängiger Vergleich auf Gleichheit an, dass diese beiden Darstellungen gleich sind, obwohl es sich bei einem normalen Ordinalvergleich nicht um handelt. Wenn die beiden Zeichen folgen jedoch normalisiert werden, gibt ein Ordinalvergleich auch an, dass Sie gleich sind. (Weitere Informationen zum Normalisieren von Zeichen folgen finden Sie im Abschnitt zur [Normalisierung](#Normalization) .)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Ein zusätzlicher Unicode-Codepunkt (ein Ersatz Zeichenpaar) wird durch <xref:System.Char> ein-Objekt dargestellt, dessen Codepunkt ein hohes Ersatz <xref:System.Char> Zeichen gefolgt von einem-Objekt ist, dessen Codepunkt ein niedriges Ersatz Zeichen ist. Die Code Einheiten der hohen Surrogates reichen von u + D800 und bis u + DBFF. Die Code Einheiten von niedrigen Surrogates reichen von u + DC00 und bis u + DFFF. Ersatzpaare werden verwendet, um Zeichen in den zusätzlichen 16-Unicode-Ebenen darzustellen. Das folgende Beispiel erstellt ein Ersatz Zeichen und übergibt es an die <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> -Methode, um zu bestimmen, ob es sich um ein Ersatz Zeichenpaar handelt.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp-interactive[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Zeichen folgen und der Unicode-Standard  
 Zeichen in einer Zeichenfolge werden durch UTF-16-codierte Code Einheiten dargestellt, <xref:System.Char> die-Werten entsprechen.  
  
 Jedem Zeichen in einer Zeichenfolge ist eine zugeordnete Unicode-Zeichen Kategorie zugeordnet, die von der <xref:System.Globalization.UnicodeCategory> -Enumeration in .net dargestellt wird. Die Kategorie eines Zeichens oder Ersatz Zeichen Paars kann durch Aufrufen der <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> -Methode bestimmt werden.  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 Außerdem unterstützt .NET den Zeichen folgen Vergleich und die Sortierung basierend auf dem Unicode-Standard. In Versionen der .NET Framework über das [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]-.NET Framework eine eigene Tabelle mit Zeichen folgen Daten verwaltet. Dies gilt auch für Versionen der .NET Framework, beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] unter Windows 7. Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)] , das in Windows 8 und höheren Versionen des Windows-Betriebssystems ausgeführt wird, delegiert die Runtime Zeichen folgen Vergleichs-und Sortierungs Vorgänge an das Betriebssystem. In .net Core werden Zeichen folgen Vergleich und Sortier Informationen von [internationalen Komponenten für Unicode](http://site.icu-project.org/) -Bibliotheken bereitgestellt. In der folgenden Tabelle sind die Versionen von .net und die Versionen des Unicode-Standards aufgeführt, auf denen der Zeichen Vergleich und die Sortierung basieren.  
  
|.NET-Version|Version des Unicode-Standards|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[The Unicode Standard, Version 4.0.0 (Der Unicode-Standard, Version 4.0.0)](https://www.unicode.org/versions/Unicode4.0.0/)|  
|Der .NET Framework 2,0|[The Unicode Standard, Version 5.0.0 (Der Unicode-Standard, Version 5.0.0)](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[The Unicode Standard, Version 5.0.0 (Der Unicode-Standard, Version 5.0.0)](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[The Unicode Standard, Version 5.0.0 (Der Unicode-Standard, Version 5.0.0)](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]und höher unter Windows 7|[The Unicode Standard, Version 5.0.0 (Der Unicode-Standard, Version 5.0.0)](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]und höher unter Windows 8 und höheren Windows-Betriebssystemen|[The Unicode Standard, Version 6.3.0 (Der Unicode-Standard, Version 6.3.0)](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET Core (alle Versionen)|Hängt von der Version des Unicode-Standards ab, die vom zugrunde liegenden Betriebssystem unterstützt wird.|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Zeichen folgen und eingebettete NULL-Zeichen  
 In .net kann ein <xref:System.String> -Objekt eingebettete NULL-Zeichen enthalten, die als Teil der Länge der Zeichenfolge gezählt werden. In einigen Sprachen, wie z. b. C++C und, gibt ein NULL-Zeichen jedoch das Ende einer Zeichenfolge an. Er wird nicht als Teil der Zeichenfolge betrachtet und nicht als Teil der Länge der Zeichenfolge gezählt. Dies bedeutet, dass die folgenden allgemeinen Annahmen, die C++ c und Programmierer oder Bibliotheken, die C++ in c geschrieben wurden, nicht notwendigerweise gültig sind, wenn <xref:System.String> Sie auf-Objekte angewendet werden:  
  
-   Der von der-Funktion `strlen` oder `wcslen` der-Funktion zurückgegebene <xref:System.String.Length%2A?displayProperty=nameWithType>Wert ist nicht notwendigerweise gleich.  
  
-   Die von der `strcpy_s` -Funktion oder `wcscpy_s` der-Funktion erstellte Zeichenfolge ist nicht notwendigerweise identisch mit <xref:System.String.Copy%2A?displayProperty=nameWithType> der von der-Methode erstellten Zeichenfolge.  
  
 Stellen Sie sicher, dass System eigener C++ C-Code und Code <xref:System.String> , der Objekte instanziiert, <xref:System.String> und Code, der Objekte über den Platt Form Aufruf weiterleitet, nicht davon ausgehen, dass ein eingebettetes NULL-Zeichen das Ende der Zeichenfolge markiert.  
  
 Eingebettete NULL-Zeichen in einer Zeichenfolge werden auch anders behandelt, wenn eine Zeichenfolge sortiert (oder verglichen) wird und wenn eine Zeichenfolge durchsucht wird. NULL-Zeichen werden ignoriert, wenn Kultur abhängige Vergleiche zwischen zwei Zeichen folgen durchgeführt werden, einschließlich Vergleiche mit der invarianten Kultur. Sie werden nur bei ordinalvergleichen ohne Berücksichtigung der Groß-/Kleinschreibung berücksichtigt. Auf der anderen Seite werden eingebettete NULL-Zeichen immer berücksichtigt, wenn eine Zeichenfolge mit Methoden <xref:System.String.Contains%2A>wie <xref:System.String.StartsWith%2A>, und <xref:System.String.IndexOf%2A>durchsucht wird.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Zeichen folgen und Indizes  
 Ein Index ist die Position eines <xref:System.Char> -Objekts (kein Unicode-Zeichen) in einer. <xref:System.String> Ein Index ist eine Null basierte, nicht negative Zahl, die von der ersten Position in der Zeichenfolge beginnt, die Indexposition 0 (null) ist. Eine Reihe von Suchmethoden, z <xref:System.String.IndexOf%2A> . b. und <xref:System.String.LastIndexOf%2A>, geben den Index eines Zeichens oder einer Teil Zeichenfolge in der Zeichen folgen Instanz zurück.  
  
 Mit <xref:System.String.Chars%2A> der-Eigenschaft können Sie <xref:System.Char> über die Indexposition in der Zeichenfolge auf einzelne Objekte zugreifen. Da es <xref:System.String.Chars%2A> sich bei der Eigenschaft um die Standard Eigenschaft (in Visual Basic) oder den Indexer (in C#) handelt, können <xref:System.Char> Sie auf die einzelnen Objekte in einer Zeichenfolge zugreifen, indem Sie Code wie den folgenden verwenden. Dieser Code sucht nach Leerzeichen oder Interpunktions Zeichen in einer Zeichenfolge, um zu bestimmen, wie viele Wörter in der Zeichenfolge enthalten sind.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp-interactive[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Da die <xref:System.String> -Klasse die <xref:System.Collections.IEnumerable> -Schnittstelle implementiert, können Sie auch die <xref:System.Char> -Objekte in einer Zeichenfolge durch `foreach` laufen, indem Sie ein-Konstrukt verwenden, wie im folgenden Beispiel gezeigt.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp-interactive[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Aufeinanderfolgende Indexwerte entsprechen möglicherweise nicht aufeinander folgenden Unicode-Zeichen, da ein Unicode-Zeichen möglicherweise als mehr <xref:System.Char> als ein Objekt codiert ist. Vor allem kann eine Zeichenfolge mehrstufige Text Einheiten enthalten, die durch ein Basiszeichen, gefolgt von einem oder mehreren kombinierten Zeichen oder Ersatz Zeichen Paaren, gebildet werden. Verwenden Sie die <xref:System.Globalization.StringInfo?displayProperty=nameWithType> Klassen und, um <xref:System.Char> mit Unicode-Zeichen anstelle <xref:System.Globalization.TextElementEnumerator> von-Objekten zu arbeiten. Das folgende Beispiel veranschaulicht den Unterschied zwischen Code, der <xref:System.Char> mit Objekten und Code funktioniert, der mit Unicode-Zeichen funktioniert. Er vergleicht die Anzahl der Zeichen oder Textelemente in jedem Wort eines Satzes. Die Zeichenfolge enthält zwei Sequenzen eines Basis Zeichens gefolgt von einem kombinierten Zeichen.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp-interactive[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 In diesem Beispiel werden Textelemente mithilfe der <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> -Methode und der <xref:System.Globalization.TextElementEnumerator> -Klasse verwendet, um alle Textelemente in einer Zeichenfolge aufzulisten. Sie können auch ein Array mit dem Start Index der einzelnen Textelemente abrufen, indem Sie die <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> -Methode aufrufen.  
  
 Weitere Informationen zum Arbeiten mit Text Einheiten anstelle einzelner <xref:System.Char> Werte finden Sie in der <xref:System.Globalization.StringInfo> -Klasse.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>NULL-Zeichen folgen und leere Zeichen folgen  
 Eine Zeichenfolge, die deklariert wurde, aber keinem Wert zugewiesen wurde, `null`ist. Der Versuch, Methoden für diese Zeichenfolge aufzurufen, löst eine <xref:System.NullReferenceException>aus. Eine NULL-Zeichenfolge unterscheidet sich von einer leeren Zeichenfolge. Dies ist eine Zeichenfolge, <xref:System.String.Empty?displayProperty=nameWithType>deren Wert "" oder ist. In einigen Fällen wird eine Ausnahme ausgelöst, wenn entweder eine NULL-Zeichenfolge oder eine leere Zeichenfolge als Argument in einem Methoden Befehl übergeben wird. Wenn Sie z. b. eine NULL- <xref:System.Int32.Parse%2A?displayProperty=nameWithType> Zeichenfolge an <xref:System.ArgumentNullException>die-Methode übergeben, wird eine ausgelöst <xref:System.FormatException>. durch das Übergeben einer leeren Zeichenfolge wird In anderen Fällen kann ein Methoden Argument entweder eine NULL-Zeichenfolge oder eine leere Zeichenfolge sein. Wenn Sie z. b. eine <xref:System.IFormattable> Implementierung für eine-Klasse bereitstellen, möchten Sie sowohl eine NULL-Zeichenfolge als auch eine leere Zeichenfolge mit dem allgemeinen Format Bezeichner "G" gleichsetzen.  
  
 Die <xref:System.String> -Klasse enthält die folgenden zwei Hilfsmethoden, mit denen Sie testen können, ob `null` eine Zeichenfolge oder eine leere Zeichenfolge ist:  
  
-   <xref:System.String.IsNullOrEmpty%2A>, das angibt, ob eine Zeichenfolge `null` entweder ist oder <xref:System.String.Empty?displayProperty=nameWithType>gleich ist. Mit dieser Methode entfällt die Notwendigkeit, Code wie den folgenden zu verwenden:  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, das angibt, ob eine Zeichen `null`Folge ist <xref:System.String.Empty?displayProperty=nameWithType>, ist oder ausschließlich aus Leerzeichen besteht. Mit dieser Methode entfällt die Notwendigkeit, Code wie den folgenden zu verwenden:  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 Im folgenden Beispiel wird die <xref:System.String.IsNullOrEmpty%2A> -Methode in <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> der Implementierung einer Benutzer `Temperature` definierten-Klasse verwendet. Die-Methode unterstützt die Format Zeichenfolgen "G", "C", "F" und "K". Wenn eine leere Format Zeichenfolge oder eine Format Zeichenfolge, deren Wert `null` an die Methode übermittelt wird, der Wert in die Format Zeichenfolge "G" geändert wird.  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Unveränderlichkeit und die StringBuilder-Klasse  
 Ein <xref:System.String> -Objekt wird als unveränderlich (schreibgeschützt) bezeichnet, da der Wert nicht geändert werden kann, nachdem er erstellt wurde. Methoden, die zum Ändern eines <xref:System.String> -Objekts angezeigt werden, <xref:System.String> geben tatsächlich ein neues-Objekt zurück, das die Änderung enthält.  
  
 Da Zeichen folgen unveränderlich sind, kann es bei Routinen zur Zeichen folgen Bearbeitung, die wiederholte Ergänzungen oder Löschungen für eine einzelne Zeichenfolge ausführen, zu einer erheblichen Leistungs Einbuße kommen. Im folgenden Code wird z. b. ein Zufallszahlengenerator verwendet, um eine Zeichenfolge mit 1000 Zeichen im Bereich 0x0001 bis 0x052f zu erstellen. Obwohl im Code die Zeichen folgen Verkettung verwendet wird, um ein neues Zeichen an die vorhandene Zeichenfolge mit `str`dem Namen anzufügen, wird <xref:System.String> für jeden Verkettungs Vorgang tatsächlich ein neues-Objekt erstellt.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 Sie können die <xref:System.Text.StringBuilder> -Klasse anstelle der <xref:System.String> -Klasse für Vorgänge verwenden, die mehrere Änderungen am Wert einer Zeichenfolge vornehmen. Im Gegensatz zu Instanzen <xref:System.String> der- <xref:System.Text.StringBuilder> Klasse sind Objekte änderbar; beim Verketten, anfügen oder Löschen von Teil Zeichenfolgen aus einer Zeichenfolge werden die Vorgänge für eine einzelne Zeichenfolge ausgeführt. Wenn Sie die Änderung des Werts eines <xref:System.Text.StringBuilder> -Objekts abgeschlossen haben, können Sie die zugehörige- <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> Methode zum Konvertieren in eine Zeichenfolge aufzurufen. Im folgenden Beispiel wird die <xref:System.String> , die im vorherigen Beispiel verwendet wurde, zum Verketten von 1000 zufälligen Zeichen im Bereich mit 0x0001 bis 0x052f <xref:System.Text.StringBuilder> mit einem-Objekt ersetzt.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Ordinal im Vergleich zu Kultur abhängigen Vorgängen  
 Member der- <xref:System.String> Klasse führen entweder Ordnungszahl-oder Kultur abhängige (linguistische) Vorgänge für <xref:System.String> ein-Objekt aus. Ein ordinalvorgang wirkt sich auf den numerischen Wert der <xref:System.Char> einzelnen-Objekte aus. Ein Kultur abhängiger Vorgang wirkt sich auf den Wert des <xref:System.String> -Objekts aus und berücksichtigt kulturspezifische Regeln für Groß-und Kleinschreibung, Sortierung, Formatierung und-Formatierung. Kultur abhängige Vorgänge werden im Kontext einer explizit deklarierten Kultur oder der impliziten aktuellen Kultur ausgeführt. Die zwei Arten von Vorgängen können sehr unterschiedliche Ergebnisse liefern, wenn Sie für dieselbe Zeichenfolge ausgeführt werden.  
  
.NET unterstützt auch Kultur unabhängige linguistische Zeichen folgen Operationen mit der invarianten Kultur<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>(), die auf den Kultur Einstellungen der englischen Sprache unabhängig von der Region locker basiert. Anders als <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> bei anderen Einstellungen ist es garantiert, dass die Einstellungen der invarianten Kultur auf einem einzelnen Computer, von System zu System und über Versionen von .net konsistent bleiben. Die invariante Kultur kann als eine Art schwarzes Feld angesehen werden, das die Stabilität von Zeichen folgen vergleichen und Reihenfolge in allen Kulturen gewährleistet.  
  
> [!IMPORTANT]
>  Wenn Ihre Anwendung eine Sicherheits Entscheidung über einen symbolischen Bezeichner, z. b. einen Dateinamen oder eine Named Pipe, oder über persistente Daten, z. b. die textbasierten Daten in einer XML-Datei, trifft, sollte der Vorgang anstelle eines Kultur abhängigen Vergleichs einen Ordinalvergleich verwenden. Der Grund hierfür ist, dass ein Kultur abhängiger Vergleich abhängig von der geltenden Kultur zu unterschiedlichen Ergebnissen führen kann, während ein Ordinalvergleich nur von dem binären Wert der verglichenen Zeichen abhängig ist.  
  
> [!IMPORTANT]
>  Die meisten Methoden, die Zeichen folgen Operationen ausführen, beinhalten eine-über <xref:System.StringComparison>Ladung mit einem Parameter vom Typ, mit dem Sie angeben können, ob die Methode einen Ordinalwert oder Kultur abhängigen Vorgang ausführt. Im Allgemeinen sollten Sie diese Überladung aufrufen, um den Zweck des Methoden Aufrufes zu löschen. Bewährte Methoden und Anleitungen zur Verwendung von Ordinalzahl-und Kultur abhängigen Operationen für Zeichen folgen finden [Sie unter Bewährte Methoden für die Verwendung](~/docs/standard/base-types/best-practices-strings.md)von Zeichen folgen.  
  
 Vorgänge für [die](#casing)Groß-/Kleinschreibung, das Auswerten [und formatieren](#parsing), das [vergleichen und Sortieren](#comparison)sowie das [Testen auf Gleichheit](#equality) können entweder Ordnungszahl oder Kultur abhängig sein. In den folgenden Abschnitten wird jede Kategorie des Vorgangs erläutert.  
  
> [!TIP]
>  Sie sollten immer eine-Methoden Überladung aufrufen, die den Zweck des Methoden Aufrufes als Klartext macht. Anstatt z. b. <xref:System.String.Compare%28System.String%2CSystem.String%29> die-Methode zum Ausführen eines Kultur abhängigen Vergleichs zweier Zeichen folgen mithilfe der Konventionen der aktuellen Kultur aufzurufen, sollten Sie die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> - <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> Methode mit dem Wert für das `comparisonType` gestritten. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  

Sie können die aus mehreren Textdateien bestehenden [Sorting Weight Tables](https://www.microsoft.com/download/details.aspx?id=10921) herunterladen. Diese Textdateien enthalten Informationen zur Gewichtung der Zeichen, die bei Sortier- und Vergleichsvorgängen unter Windows-Betriebssystemen verwendet werden, sowie die [Default Unicode Collation Element Table](https://www.unicode.org/Public/UCA/latest/allkeys.txt), die Sortiergewichtungstabelle für Linux und macOS.

<a name="casing"></a>   
### <a name="casing"></a>He  
 Regeln für die Groß-und Kleinschreibung bestimmen, wie die Groß Schreibung eines Unicode-Zeichens geändert beispielsweise von Kleinbuchstaben in Großbuchstaben. Häufig wird ein Schreibvorgang vor einem Zeichen folgen Vergleich durchgeführt. Beispielsweise kann eine Zeichenfolge in einen Großbuchstaben konvertiert werden, damit Sie mit einer anderen Großbuchstaben-Zeichenfolge verglichen werden kann. Sie können die Zeichen in einer Zeichenfolge in Kleinbuchstaben konvertieren, indem <xref:System.String.ToLower%2A> Sie <xref:System.String.ToLowerInvariant%2A> die-Methode oder die-Methode aufrufen, und Sie können Sie <xref:System.String.ToUpper%2A> durch <xref:System.String.ToUpperInvariant%2A> Aufrufen der-oder-Methode in einen Großbuchstaben konvertieren. Darüber hinaus können Sie die <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> -Methode verwenden, um eine Zeichenfolge in einen Großbuchstaben zu konvertieren.  

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]  
  
 Schreibvorgänge können auf den Regeln der aktuellen Kultur, einer angegebenen Kultur oder der invarianten Kultur basieren. Da Fall Zuordnungen je nach verwendeter Kultur variieren können, kann das Ergebnis von Schreibvorgängen je nach Kultur variieren. Die tatsächlichen Unterschiede bei der Groß-/Kleinschreibung sind drei Arten:  
  
-   Unterschiede bei der Groß-/Kleinschreibung von lateinischen Großbuchstaben i (u + 0049), Latin Small Letter i (u + 0069), Latin Capital Letter i (u + 0130) und Latin Small Letter DOTLESS i (u + 0131). In den neutralen Kulturen tr-tr (Türkisch (Türkei)) und AZ-Latn-AZ (Aserbaidschan, Latin) und in den neutralen Kulturen tr, AZ und AZ-Latn ist die Entsprechung von lateinischen Großbuchstaben i "lateinisch Kleinbuchstabe i" und "Großbuchstaben" Äquivalent von "Latin Small Letter i". Lateinisch Großbuchstabe I mit dem Punkt oben. In allen anderen Kulturen, einschließlich der invarianten Kultur, lateinisch kleiner Buchstabe i und lateinischen Großbuchstaben, verwende ich Kleinbuchstaben und Entsprechungen in Großbuchstaben.  
  
     Das folgende Beispiel veranschaulicht, wie ein Zeichen folgen Vergleich, der zum Verhindern des Dateisystem Zugriffs entworfen wurde, fehlschlagen kann, wenn er auf einen Kultur abhängigen Groß-/Kleinschreibung (Die Konventionen für die Groß-und Kleinschreibung der invarianten Kultur sollten verwendet werden.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Unterschiede in den Fall Zuordnungen zwischen der invarianten Kultur und allen anderen Kulturen. In diesen Fällen wird mit den Regeln für die Groß-/Kleinschreibung der invarianten Kultur ein Zeichen in groß-oder Kleinbuchstaben geändert, um das gleiche Zeichen zurückgegeben. Für alle anderen Kulturen wird ein anderes Zeichen zurückgegeben. Einige der betroffenen Zeichen sind in der folgenden Tabelle aufgeführt.  
  
    |Zeichen|Bei Änderung in|Rückgabe|  
    |---------------|-------------------|-------------|  
    |MICRON-ZEICHEN (U + 00B5)|Großbuchstaben|GRIECHISCHER GROSSBUCHSTABE MU (U +-39C)|  
    |LATEINISCHER GROSSBUCHSTABE I MIT EINEM VORANGEHENDEN PUNKT (U + 0130)|Kleinbuchstaben|LATEINISCH KLEINER BUCHSTABE I (U + 0069)|  
    |LATIN SMALL LETTER DOTLESS I (U + 0131)|Großbuchstaben|LATEINISCH GROSSBUCHSTABE I (U + 0049)|  
    |LATIN SMALL LETTER LONG S (U + 017F)|Großbuchstaben|LATEINISCHE GROSSBUCHSTABEN S (U + 0053)|  
    |LATEINISCH GROSSBUCHSTABE D MIT KLEINEM BUCHSTABEN Z MIT CARON (U + 01C5)|Kleinbuchstaben|LATIN SMALL LETTER DZ WITH CARON (U + 01C6)|  
    |KOMBINIEREN VON GREEK YPOGEGRAMMENI (U + 0345)|Großbuchstaben|GRIECHISCHER GROSSBUCHSTABE IOTA (U + 0399)|  
  
-   Unterschiede bei den Zuordnungen von Groß-/Kleinschreibung aus zwei Buchstaben im ASCII-Zeichenbereich. In den meisten Kulturen ist ein aus zwei Buchstaben gemischtes Paar aus Groß-oder Kleinbuchstaben gleichwertig. Dies gilt nicht für die folgenden zwei buchstabenden Paare in den folgenden Kulturen, da Sie in jedem Fall mit einem Digraph verglichen werden:  
  
    -   "LJ" und "NJ" in der HR-HR-Kultur (Kroatisch (Kroatien)).  
  
    -   "ch" in den Kulturen "CS-CZ (Tschechisch (Tschechische Republik)" und "SK-SK" (Slowakisch (Slowakei)).  
  
    -   "AA" in der Kultur "da-DK (Dänisch (Dänemark)").  
  
    -   "CS", "DZ", "dzs", "NY", "SZ", "tY" und "zS" in der Kultur "hu-hu (ungarisch)".  
  
    -   "ch" und "ll" in der Kultur "es-ES_tradnl (Spanisch (Spanien, Traditionelle Sortierung)").  
  
    -   "ch", "GI", "KH", "ng" "NH", "pH", "qU", "th" und "tr" in der Kultur vi-VN (Vietnamese (Vietnam)).  
  
     Es ist jedoch ungewöhnlich, dass eine Situation auftritt, in der ein Kultur abhängiger Vergleich dieser Paare Probleme verursacht, da diese Paare in festgelegten Zeichen folgen oder bezeichnerfällen nicht üblich sind.  
  
 Im folgenden Beispiel werden einige der Unterschiede zwischen den Regeln für die Groß-und Kleinschreibung beim Umwandeln von Zeichen folgen in Großbuchstaben veranschaulicht.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>Auswerten und formatieren  
 Formatierung und Verarbeitung sind umgekehrte Vorgänge. Formatierungs Regeln legen fest, wie ein Wert (z. b. ein Datum und eine Uhrzeit oder eine Zahl) in seine Zeichen folgen Darstellung konvertiert werden, wohingegen durch die durch das Durchsetzen von Regeln festgelegt wird, wie eine Zeichen folgen Darstellung in einen-Wert konvertiert werden soll Sowohl Formatierungs-als auch Erteilungs Regeln sind von kulturellen Konventionen abhängig. Im folgenden Beispiel wird die Mehrdeutigkeit veranschaulicht, die bei der Interpretation einer kulturspezifischen Datums Zeichenfolge auftreten kann. Ohne die Konventionen der Kultur zu kennen, die zum Entwickeln einer Datums Zeichenfolge verwendet wurde, ist es nicht möglich zu wissen, ob 03/01/2011, 3/1/2011 und 01/03/2011 den 3. Januar 2011 oder den 1. März 2011 darstellen.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 Wie im folgenden Beispiel gezeigt, kann eine einzelne Zeichenfolge abhängig von der Kultur, deren Konventionen im Analyse-Vorgang verwendet werden, unterschiedliche Datumsangaben liefern.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Zeichen folgen Vergleich und Sortierung  
 Konventionen zum Vergleichen und Sortieren von Zeichen folgen variieren von Kultur zu Kultur. Die Sortierreihenfolge kann z. b. auf der Phonetik oder der visuellen Darstellung von Zeichen basieren. In ostasiatischen Sprachen werden Zeichen anhand der Anzahl der Striche und der Radikale der Ideogramme sortiert. Die Sortierung hängt außerdem von der Reihenfolge ab, die das Alphabet der jeweiligen Sprache bzw. Kultur aufweist. Im Dänischen gibt es beispielsweise das Zeichen "Æ", das im Alphabet nach dem Zeichen "Z" einsortiert ist. Außerdem kann bei vergleichen die Groß-/Kleinschreibung beachtet werden, und die Groß-/Kleinschreibung unterscheidet sich in manchen Fällen von der Kultur. Beim Ordinalvergleich werden dagegen die Unicode-Code Punkte von einzelnen Zeichen in einer Zeichenfolge beim Vergleichen und Sortieren von Zeichen folgen verwendet.  
  
 Sortierregeln bestimmen die alphabetische Reihenfolge von Unicode-Zeichen und die Art und Weise, wie zwei Zeichen folgen miteinander verglichen werden. Die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> -Methode vergleicht z. b. zwei Zeichen folgen <xref:System.StringComparison> auf der Grundlage des-Parameters. Wenn der-Parameterwert <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>ist, führt die-Methode einen linguistischen Vergleich durch, der die Konventionen der aktuellen Kultur verwendet. Wenn <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>der Parameterwert ist, führt die Methode einen Ordinalvergleich durch. Folglich wird wie im folgenden Beispiel gezeigt, wenn die aktuelle Kultur "US" ist. Der erste Aufrufe <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> der-Methode (mit Kultur sensiblem Vergleich) berücksichtigt "a" kleiner als "a", aber der zweite Aufrufe derselben Methode (mit Ordinalvergleich) berücksichtigt "a" größer als "a".  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET unterstützt Wort-, Zeichen folgen-und ordinalsortier Regeln:  
  
-   Bei einer Wortsortierung wird ein kulturabhängiger Vergleich von Zeichenfolgen durchgeführt, bei dem bestimmten nicht alphanumerischen Unicode-Zeichen u. U. bestimmte Gewichtungen zugeordnet sind. Dem Bindestrich (-) kann z. b. eine sehr geringe Gewichtung zugewiesen werden, sodass "Coop" und "Co-op" in einer sortierten Liste nebeneinander angezeigt werden. Eine Liste der <xref:System.String> Methoden, die zwei Zeichen folgen mithilfe von Wort Sortierregeln vergleichen, finden Sie im Abschnitt [Zeichen folgen Vorgänge nach Kategorie](#ByCategory) .  
  
-   Eine Zeichen folgen Sortierung führt auch einen Kultur abhängigen Vergleich durch. Sie ähnelt einem Wort Sort, mit dem Unterschied, dass es keine besonderen Fälle gibt und alle nicht alphanumerischen Symbole vor allen alphanumerischen Unicode-Zeichen stehen. Zwei Zeichen folgen können mithilfe von Zeichen folgen Sortierregeln verglichen werden <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> , indem die-Methoden Überladungen aufgerufen werden, die über einen <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType> `options` -Parameter verfügen, der den Wert hat. Beachten Sie, dass dies die einzige Methode ist, die .net zum Vergleichen von zwei Zeichen folgen mithilfe von Zeichen folgen Sortierregeln bereitstellt.  
  
-   Eine Ordinalsortierung vergleicht Zeichenfolgen anhand des numerischen Werts jedes <xref:System.Char>-Objekts in der Zeichenfolge. Bei einem Ordinalvergleich wird die Groß-/Kleinschreibung nicht beachtet, da die Kleinbuchstaben-und Großbuchstaben Versionen eines Zeichens verschiedene Code Punkte aufweisen. Wenn die Groß-/Kleinschreibung jedoch nicht wichtig ist, können Sie einen Ordinalvergleich angeben, der Case ignoriert. Dies entspricht dem Umwandeln der Zeichenfolge in Großbuchstaben unter Verwendung der invarianten Kultur und der anschließenden Durchführung eines Ordinalvergleichs für das Ergebnis. Eine Liste der <xref:System.String> Methoden, die zwei Zeichen folgen mithilfe von ordinalen Sortierregeln vergleichen, finden Sie im Abschnitt [Zeichen folgen Vorgänge nach Kategorie](#ByCategory) .  
  
 Ein Kultur abhängiger Vergleich ist ein beliebiger Vergleich, der explizit oder <xref:System.Globalization.CultureInfo> implizit ein-Objekt verwendet, einschließlich der invarianten Kultur, <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> die durch die-Eigenschaft angegeben wird. Die implizite Kultur ist die aktuelle Kultur, die durch die <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> -Eigenschaft und die- <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> Eigenschaft angegeben wird. Es gibt eine beträchtliche Variation in der Sortierreihenfolge von alphabetischen Zeichen (d. h. <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> Zeichen, `true`für die die-Eigenschaft zurückgibt) über Kulturen hinweg. Sie können einen Kultur abhängigen Vergleich angeben, der die Konventionen einer bestimmten Kultur verwendet, indem Sie ein <xref:System.Globalization.CultureInfo> -Objekt an eine Zeichen folgen Vergleichsmethode <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>wie bereitstellen. Sie können einen Kultur abhängigen Vergleich angeben, der die Konventionen der aktuellen <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>Kultur verwendet, indem Sie, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> <xref:System.Globalization.CompareOptions> oder einen beliebigen Member der-Enumeration <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> außer oder <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> einem entsprechenden Überladung der <xref:System.String.Compare%2A> -Methode. Ein Kultur abhängiger Vergleich ist in der Regel für die Sortierung geeignet, während ein Ordinalvergleich nicht erfolgt. Ein Ordinalvergleich ist im allgemeinen geeignet, um zu bestimmen, ob zwei Zeichen folgen gleich sind (d. h. zum Bestimmen der Identität), während ein Kultur abhängiger Vergleich nicht ist.  
  
 Im folgenden Beispiel wird der Unterschied zwischen Kultur sensitiven und ordinalen Vergleichen veranschaulicht. Im Beispiel werden die drei Zeichen folgen "Apple", "Æble" und "aeble" mithilfe von ordinalvergleichen und den Konventionen der Kulturen "da-DK" und "en-US" ausgewertet (bei denen es sich um die Standard <xref:System.String.Compare%2A> Kultur handelt, wenn die-Methode aufgerufen wird). Da die dänische Sprache das Zeichen "Æ" als einzelnen Buchstaben behandelt und Sie nach "Z" im Alphabet sortiert, ist die Zeichenfolge "Æble" größer als "Apple". "Æble" gilt jedoch nicht als äquivalent zu "aeble", sodass "Æble" auch größer als "aeble" ist. Die Kultur "en-US" enthält nicht den Buchstaben "Æ", sondern behandelt Sie als äquivalent zu "AE", in dem erläutert wird, warum "Æble" kleiner als "Apple", aber gleich "aeble" ist. Bei einem Ordinalvergleich wird "Apple" als "Æble" und "Æble" als "aeble" betrachtet.  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Verwenden Sie die folgenden allgemeinen Richtlinien, um eine geeignete Sortier-oder Zeichen folgen Vergleichsmethode auszuwählen:  
  
-   Wenn Sie möchten, dass die Zeichen folgen anhand der Kultur des Benutzers sortiert werden, sollten Sie Sie nach den Konventionen der aktuellen Kultur sortieren. Wenn sich die Kultur des Benutzers ändert, ändert sich auch die Reihenfolge der sortierten Zeichen folgen entsprechend. Beispielsweise sollte eine thesaurusanwendung die Wörter immer basierend auf der Kultur des Benutzers sortieren.  
  
-   Wenn Sie möchten, dass die Zeichen folgen basierend auf den Konventionen einer bestimmten Kultur sortiert werden, sollten Sie diese sortieren, indem <xref:System.Globalization.CultureInfo> Sie ein-Objekt, das diese Kultur darstellt, einer Vergleichsmethode bereitstellen. Beispielsweise möchten Sie in einer Anwendung, die Studenten eine bestimmte Sprache vermitteln soll, Zeichen folgen basierend auf den Konventionen einer der Kulturen, die diese Sprache sprechen, geordnet werden.  
  
-   Wenn Sie möchten, dass die Reihenfolge der Zeichen folgen zwischen Kulturen unverändert bleibt, sollten Sie Sie nach den Konventionen der invarianten Kultur sortieren oder einen Ordinalvergleich verwenden. Beispielsweise verwenden Sie eine Ordinalsortierung, um die Namen von Dateien, Prozessen, Mutexen oder Named Pipes zu organisieren.  
  
-   Bei einem Vergleich, bei dem eine Sicherheits Entscheidung besteht (z. b., ob ein Benutzername gültig ist), sollten Sie immer einen ordinaltest auf Gleichheit durch <xref:System.String.Equals%2A> führen, indem Sie eine Überladung der-Methode aufrufen.  
  
> [!NOTE]
>  Die für den Zeichen folgen Vergleich verwendeten Kultur abhängigen Sortier-und Schreibregeln sind von der .NET-Version abhängig. In den .NET Framework 4,5 und höheren Versionen, die unter [!INCLUDE[win8](~/includes/win8-md.md)] dem Betriebssystem ausgeführt werden, entspricht die Sortierung, die Groß-/Kleinschreibung, die Normalisierung und Unicode-Zeichen Informationen dem Unicode-Standard 6,0. Unter anderen Windows-Betriebssystemen entspricht Sie dem Unicode-Standard 5,0. Unter .net Core hängt dies von der Version des Unicode-Standards ab, der vom zugrunde liegenden Betriebssystem unterstützt wird. 
  
 Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortier Regeln finden Sie <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> im Thema. Weitere Empfehlungen zur Verwendung der einzelnen Regeln finden Sie unter [bewährte Methoden für die Verwendung](~/docs/standard/base-types/best-practices-strings.md)von Zeichen folgen.  
  
 Normalerweise werden keine Zeichen folgen Vergleichsmethoden wie <xref:System.String.Compare%2A> direkt aufgerufen, um die Sortierreihenfolge von Zeichen folgen zu bestimmen. Stattdessen werden Vergleichsmethoden durch Sortiermethoden wie <xref:System.Array.Sort%2A?displayProperty=nameWithType> oder <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>aufgerufen. Im folgenden Beispiel werden vier verschiedene Sortiervorgänge durchführen (Wort Sortierung mit der aktuellen Kultur, Wort Sortierung mithilfe der invarianten Kultur, Ordinalsortierung und Zeichen folgen Sortierung mithilfe der invarianten Kultur), ohne explizit eine Zeichen folgen Vergleichsmethode Aufrufs zu verwenden. Obwohl Sie den zu verwendenden Vergleichstyp angeben. Beachten Sie, dass jeder Sortiertyp eine eindeutige Reihenfolge von Zeichen folgen im Array erzeugt.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  Intern verwendet .net Sortierschlüssel, um einen Kultur abhängigen Zeichen folgen Vergleich zu unterstützen. Jedem Zeichen in einer Zeichenfolge sind mehrere Sortiergewichtungskategorien zugeordnet, darunter nach Skript, alphabetischer Folge, Groß-/Kleinschreibung und diakritischer Gewichtung. Ein Sortierschlüssel, der durch die <xref:System.Globalization.SortKey> -Klasse dargestellt wird, stellt ein Repository dieser Gewichtungen für eine bestimmte Zeichenfolge bereit. Wenn Ihre APP eine große Anzahl von Such-oder Sortiervorgängen für denselben Satz von Zeichen folgen ausführt, können Sie die Leistung verbessern, indem Sie Sortierschlüssel für alle verwendeten Zeichen folgen erstellen und speichern. Wenn eine Sortier-oder Vergleichsoperation erforderlich ist, verwenden Sie die Sortierschlüssel anstelle der Zeichen folgen. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Globalization.SortKey>-Klasse.  
  
 Wenn Sie keine Zeichen folgen Vergleichs Konvention angeben, werden beim Sortieren von <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> Methoden wie z. b. eine Kultur abhängige Sortierung für Zeichen folgen durchgeführt. Im folgenden Beispiel wird veranschaulicht, wie sich das Ändern der aktuellen Kultur auf die Reihenfolge sortierter Zeichen folgen in einem Array auswirkt. Es wird ein Array mit drei Zeichen folgen erstellt. Zuerst wird die `System.Threading.Thread.CurrentThread.CurrentCulture`-Eigenschaft auf "en-US" festgelegt, und die <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>-Methode wird aufgerufen. Die sich daraus ergebende Sortierreihenfolge basiert auf den Sortierkonventionen für die Kultur Englisch (USA). Als Nächstes wird die `System.Threading.Thread.CurrentThread.CurrentCulture`-Eigenschaft auf "da-DK" festgelegt und die <xref:System.Array.Sort%2A?displayProperty=nameWithType>-Methode erneut aufgerufen. Die sich daraus ergebende Sortierreihenfolge unterscheidet sich von den Ergebnissen für "en-US", da die Sortierkonventionen für "Dänisch (Dänemark)" verwendet werden.  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Wenn Sie den Hauptzweck beim Vergleichen von Zeichen folgen bestimmen, ob Sie gleich sind, sollten Sie <xref:System.String.Equals%2A?displayProperty=nameWithType> die-Methode aufzurufen. In der Regel sollten Sie <xref:System.String.Equals%2A> verwenden, um einen Ordinalvergleich durchzuführen. Die <xref:System.String.Compare%2A?displayProperty=nameWithType> -Methode dient primär zum Sortieren von Zeichen folgen.  
  
 Zeichen folgen Suchmethoden, z <xref:System.String.StartsWith%2A?displayProperty=nameWithType> . <xref:System.String.IndexOf%2A?displayProperty=nameWithType>b. und, können auch Kultur abhängige oder ordinale Zeichen folgen Vergleiche durchführen. Im folgenden Beispiel werden die Unterschiede zwischen Ordinalzahl-und Kultur abhängigen vergleichen <xref:System.String.IndexOf%2A> mithilfe der-Methode veranschaulicht. Bei einer Kultur abhängigen Suche, bei der es sich bei der aktuellen Kultur um Englisch (USA) handelt, wird die Teil Zeichenfolge "OE" als mit der Ligaturen "." betrachtet. Da ein weicher Bindestrich (U + 00ad) ein Zeichen mit einer Breite von NULL ist, behandelt die Suche den Soft-Bindestrich <xref:System.String.Empty> als äquivalent zu und findet eine Übereinstimmung am Anfang der Zeichenfolge. Eine Ordinalsuche findet dagegen in keinem Fall eine Entsprechung.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Suchen von Zeichenfolgen  
 Zeichen folgen Suchmethoden, z <xref:System.String.StartsWith%2A?displayProperty=nameWithType> . <xref:System.String.IndexOf%2A?displayProperty=nameWithType>b. und, können auch Kultur abhängige oder ordinale Zeichen folgen Vergleiche durchführen, um zu bestimmen, ob ein Zeichen oder eine Teil Zeichenfolge in einer angegebenen Zeichenfolge gefunden wird.  
  
 Die Suchmethoden in der <xref:System.String> -Klasse, die nach einem einzelnen Zeichen, z. <xref:System.String.IndexOf%2A> b. der-Methode, oder einem Zeichensatz (z. <xref:System.String.IndexOfAny%2A> b. der-Methode) suchen, führen eine Ordinalsuche durch. Um eine Kultur abhängige Suche nach einem Zeichen durchzuführen, müssen Sie eine <xref:System.Globalization.CompareInfo> Methode <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> wie oder <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>aufgerufen haben. Beachten Sie, dass die Ergebnisse der Suche nach einem Zeichen mit Ordinalzahl und Kultur sensiblem Vergleich sehr unterschiedlich sein können. Beispielsweise kann eine Suche nach einem vorzusammen gesetzten Unicode-Zeichen, wie z. b. die Ligaturen "Æ" (u + 00c6), jedes Vorkommen der zugehörigen Komponenten in der richtigen Reihenfolge, z. b. "AE" (u + 041u + 0045), abhängig von der Kultur entsprechen. Das folgende Beispiel veranschaulicht den Unterschied zwischen <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> der <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> -Methode und der-Methode bei der Suche nach einem einzelnen Zeichen. Die Ligaturen "æ" (U + 00e6) wurde in der Zeichenfolge "Luftbild" gefunden, wenn die Konventionen der Kultur "en-US" verwendet werden, aber nicht, wenn die Konventionen der da-DK-Kultur verwendet werden oder wenn ein Ordinalvergleich durchgeführt wird.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 Auf der anderen Seite <xref:System.String> führen Klassen Methoden, die anstelle eines Zeichens nach einer Zeichenfolge suchen, eine Kultur abhängige Suche durch, wenn die Suchoptionen nicht explizit durch einen Parameter des Typs <xref:System.StringComparison>angegeben werden. Die einzige Ausnahme ist <xref:System.String.Contains%2A>, bei der eine Ordinalsuche durchführt.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Testen auf Gleichheit  
 Verwenden Sie <xref:System.String.Compare%2A?displayProperty=nameWithType> die-Methode, um die Beziehung zwischen zwei Zeichen folgen in der Sortierreihenfolge zu bestimmen. In der Regel handelt es sich hierbei um einen Kultur abhängigen Vorgang. Im Gegensatz dazu wird die <xref:System.String.Equals%2A?displayProperty=nameWithType> -Methode aufgerufen, um auf Gleichheit zu prüfen. Da der Test auf Gleichheit normalerweise die Benutzereingaben mit einer bekannten Zeichenfolge vergleicht (z. b. ein gültiger Benutzername, ein Kennwort oder ein Dateisystempfad), handelt es sich in der Regel um einen ordinalvorgang.  
  
> [!WARNING]
>  Es ist möglich, auf Gleichheit zu testen, indem <xref:System.String.Compare%2A?displayProperty=nameWithType> Sie die-Methode aufrufen und ermitteln, ob der Rückgabewert 0 (null) ist. Diese Vorgehensweise wird jedoch nicht empfohlen. Um zu ermitteln, ob zwei Zeichen folgen gleich sind, sollten Sie eine der über Ladungen <xref:System.String.Equals%2A?displayProperty=nameWithType> der-Methode aufzurufen. Die bevorzugte Überladung, die aufgerufen werden soll <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> , ist entweder die <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> Instanzmethode oder die statische Methode <xref:System.StringComparison?displayProperty=nameWithType> , da beide Methoden einen Parameter enthalten, der den Typ des Vergleichs explizit angibt.  
  
 Das folgende Beispiel veranschaulicht die Gefahr der Durchführung eines Kultur abhängigen Vergleichs auf Gleichheit, wenn stattdessen eine Ordinalzahl verwendet wird. In diesem Fall besteht der Zweck des Codes darin, den Dateisystem Zugriff über URLs zu verweigern, die mit "file://" oder "file://" beginnen, indem Sie einen Vergleich des Anfangs einer URL mit der Zeichenfolge "file://" ohne Beachtung der Groß-/Kleinschreibung durchführen. Wenn jedoch ein Kultur abhängiger Vergleich mithilfe der türkischen Kultur (Türkei) für eine URL durchgeführt wird, die mit "file://" beginnt, schlägt der Vergleich der Gleichheit fehl, da die Entsprechung von "i" in Großbuchstaben "i" anstelle von "i" lautet. Folglich ist der Zugriff auf Dateisysteme versehentlich zulässig. Wenn dagegen ein Ordinalvergleich durchgeführt wird, ist der Vergleich der Gleichheit erfolgreich, und der Dateisystem Zugriff wird verweigert.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Normalisierung  
 Einige Unicode-Zeichen verfügen über mehrere Darstellungen. Beispielsweise kann jeder der folgenden Code Punkte den Buchstaben "ắ" darstellen:  
  
-   U + 1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Mehrere Darstellungen eines einzelnen Zeichens erschweren das suchen, sortieren, vergleichen und andere Zeichen folgen Operationen.  
  
 Der Unicode-Standard definiert einen Prozess, der als Normalisierung bezeichnet wird und eine binäre Darstellung eines Unicode-Zeichens für eine der entsprechenden binären Darstellungen zurückgibt. Bei der Normalisierung können mehrere Algorithmen verwendet werden, die als normalisierungs Formulare bezeichnet werden. .NET unterstützt Unicode-Normalisierungsformen C, D, KC und KD. Wenn Zeichen folgen in dieselbe normalisierungs Form normalisiert wurden, können Sie mithilfe eines Ordinalvergleichs verglichen werden.  
  
 Ein Ordinalvergleich ist ein binärer Vergleich des Unicode-skalarwerts der <xref:System.Char> entsprechenden Objekte in den einzelnen Zeichen folgen. Die <xref:System.String> -Klasse enthält eine Reihe von Methoden, die einen Ordinalvergleich durchführen können, einschließlich der folgenden:  
  
-   Jede Überladung der <xref:System.String.Compare%2A>Methoden <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, und <xref:System.String.LastIndexOf%2A> , die einen <xref:System.StringComparison> -Parameter enthält. Die-Methode führt einen Ordinalvergleich durch, wenn Sie für <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> diesen <xref:System.StringComparison.OrdinalIgnoreCase> Parameter einen Wert von oder angeben.  
  
-   Die über Ladungen <xref:System.String.CompareOrdinal%2A> der-Methode.  
  
-   Methoden, die standardmäßig einen Ordinalvergleich verwenden, <xref:System.String.Contains%2A>z <xref:System.String.Replace%2A>. b <xref:System.String.Split%2A>., und.  
  
-   Methoden, die nach einem <xref:System.Char> Wert oder nach den Elementen in einem <xref:System.Char> Array in einer Zeichen folgen Instanz suchen. Zu diesen Methoden <xref:System.String.IndexOf%28System.Char%29> gehören <xref:System.String.Split%28System.Char%5B%5D%29>und.  
  
 Sie können bestimmen, ob eine Zeichenfolge in die normalisierungs Form C normalisiert <xref:System.String.IsNormalized?displayProperty=nameWithType> wird, indem Sie die-Methode <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> aufrufen, oder Sie können die-Methode aufrufen, um zu bestimmen, ob eine Zeichenfolge in eine angegebene normalisierungs Form normalisiert wird Sie können auch die <xref:System.String.Normalize?displayProperty=nameWithType> -Methode zum Konvertieren einer Zeichenfolge in eine normalisierungs Form C oder die <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> -Methode zum Konvertieren einer Zeichenfolge in eine angegebene normalisierungs Form aufzurufen. Schritt-für-Schritt-Informationen zum normalisieren und Vergleichen von Zeichen folgen finden Sie <xref:System.String.Normalize> unter <xref:System.String.Normalize%28System.Text.NormalizationForm%29> den Methoden und.  
  
 Das folgende einfache Beispiel veranschaulicht die Normalisierung von Zeichen folgen. Er definiert den Buchstaben "ố" in drei verschiedenen Arten in drei verschiedenen Zeichen folgen und verwendet einen Ordinalvergleich für Gleichheit, um zu bestimmen, ob jede Zeichenfolge von den beiden anderen Zeichen folgen abweicht. Anschließend konvertiert Sie jede Zeichenfolge in die unterstützten Normalisierungsformen und führt erneut einen Ordinalvergleich der einzelnen Zeichen folgen in einer angegebenen normalisierungs Form durch. In jedem Fall zeigt der zweite Test auf Gleichheit, dass die Zeichen folgen gleich sind.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Weitere Informationen zu normalisierungs-und normalisierungs Formularen <xref:System.Text.NormalizationForm?displayProperty=nameWithType>finden Sie unter sowie [unter #15 des Unicode-Standard Anhangs: Unicode-normalisierungs Formulare](https://unicode.org/reports/tr15/) und die häufig gestellten Fragen zur [Normalisierung](https://www.unicode.org/faq/normalization.html) auf der Unicode.org-Website.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Zeichen folgen Vorgänge nach Kategorie  
 Die <xref:System.String> -Klasse stellt Member zum Vergleichen von Zeichen folgen, zum Testen von Zeichen folgen auf Gleichheit, zum Suchen von Zeichen oder Teil Zeichenfolgen in einer Zeichenfolge, zum Ändern einer Zeichenfolge, zum Extrahieren von Teil Zeichenfolgen aus einer Zeichenfolge, zum Kombinieren von Zeichen folgen eine Zeichenfolge wird normalisiert.  
  
### <a name="comparing-strings"></a>Vergleichen von Zeichenfolgen  
 Sie können Zeichen folgen vergleichen, um ihre relative Position in der Sortierreihenfolge zu <xref:System.String> ermitteln, indem Sie die folgenden Methoden verwenden:  
  
-   <xref:System.String.Compare%2A>gibt eine ganze Zahl zurück, die die Beziehung zwischen einer Zeichenfolge und einer zweiten Zeichenfolge in der Sortierreihenfolge angibt.  
  
-   <xref:System.String.CompareOrdinal%2A>gibt eine ganze Zahl zurück, die die Beziehung zwischen einer Zeichenfolge und einer zweiten Zeichenfolge auf Grundlage eines Vergleichs ihrer Code Punkte angibt.  
  
-   <xref:System.String.CompareTo%2A>gibt eine ganze Zahl zurück, die die Beziehung der aktuellen Zeichen folgen Instanz zu einer zweiten Zeichenfolge in der Sortierreihenfolge angibt. Die <xref:System.String.CompareTo%28System.String%29> -Methode stellt <xref:System.IComparable> die <xref:System.IComparable%601> -und- <xref:System.String> Implementierungen für die-Klasse bereit.  
  
### <a name="testing-strings-for-equality"></a>Testen von Zeichen folgen auf Gleichheit  
 Die <xref:System.String.Equals%2A> -Methode wird aufgerufen, um zu bestimmen, ob zwei Zeichen folgen gleich sind. Mit der <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Instanz und <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> den statischen über Ladungen können Sie angeben, ob der Vergleich Kultur abhängig ist, und ob die Groß-/Kleinschreibung berücksichtigt wird. Die meisten Gleichheits Tests sind Ordinalzahlen, und Vergleiche auf Gleichheit, die den Zugriff auf eine System Ressource bestimmen (z. b. ein Dateisystem Objekt), sollten immer eine Ordinalzahl sein.  
  
### <a name="finding-characters-in-a-string"></a>Suchen von Zeichen in einer Zeichenfolge  
 Die <xref:System.String> -Klasse enthält zwei Arten von Suchmethoden:  
  
-   Methoden, die einen <xref:System.Boolean> Wert zurückgeben, um anzugeben, ob eine bestimmte Teil Zeichenfolge in einer Zeichen folgen Instanz vorhanden ist. Hierzu gehören die <xref:System.String.Contains%2A>Methoden <xref:System.String.EndsWith%2A>, und <xref:System.String.StartsWith%2A> .  
  
-   Methoden, die die Anfangsposition einer Teil Zeichenfolge in einer Zeichen folgen Instanz angeben. Hierzu gehören die <xref:System.String.IndexOf%2A>Methoden <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, und <xref:System.String.LastIndexOfAny%2A> .  
  
> [!WARNING]
>  Wenn Sie eine Zeichenfolge nach einem bestimmten Muster und nicht nach einer bestimmten Teil Zeichenfolge durchsuchen möchten, sollten Sie reguläre Ausdrücke verwenden. Weitere Informationen finden Sie unter [reguläre Ausdrücke in .net](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Ändern einer Zeichenfolge  
 Die <xref:System.String> -Klasse enthält die folgenden Methoden, um den Wert einer Zeichenfolge zu ändern:  
  
-   <xref:System.String.Insert%2A>Fügt eine Zeichenfolge in die <xref:System.String> aktuelle-Instanz ein.  
  
-   <xref:System.String.PadLeft%2A>Fügt ein oder mehrere Vorkommen eines angegebenen Zeichens am Anfang einer Zeichenfolge ein.  
  
-   <xref:System.String.PadRight%2A>Fügt ein oder mehrere Vorkommen eines angegebenen Zeichens am Ende einer Zeichenfolge ein.  
  
-   <xref:System.String.Remove%2A>Löscht eine Teil Zeichenfolge aus <xref:System.String> der aktuellen Instanz.  
  
-   <xref:System.String.Replace%2A>ersetzt eine Teil Zeichenfolge durch eine andere Teil Zeichenfolge in der aktuellen <xref:System.String> Instanz.  
  
-   <xref:System.String.ToLower%2A>und <xref:System.String.ToLowerInvariant%2A> konvertieren alle Zeichen in einer Zeichenfolge in Kleinbuchstaben.  
  
-   <xref:System.String.ToUpper%2A>und <xref:System.String.ToUpperInvariant%2A> konvertieren alle Zeichen in einer Zeichenfolge in Großbuchstaben.  
  
-   <xref:System.String.Trim%2A>entfernt alle Vorkommen eines Zeichens am Anfang und am Ende einer Zeichenfolge.  
  
-   <xref:System.String.TrimEnd%2A>entfernt alle Vorkommen eines Zeichens am Ende einer Zeichenfolge.  
  
-   <xref:System.String.TrimStart%2A>entfernt alle Vorkommen eines Zeichens am Anfang einer Zeichenfolge.  
  
> [!IMPORTANT]
>  Alle Methoden für Zeichen folgen Änderungen geben <xref:System.String> ein neues-Objekt zurück. Der Wert der aktuellen Instanz wird nicht geändert.  
  
### <a name="extracting-substrings-from-a-string"></a>Extrahieren von Teil Zeichenfolgen aus einer Zeichenfolge  
 Die <xref:System.String.Split%2A?displayProperty=nameWithType> -Methode trennt eine einzelne Zeichenfolge in mehrere Zeichen folgen. Über Ladungen der-Methode ermöglichen es Ihnen, mehrere Trennzeichen anzugeben, um die maximale Anzahl von Teil Zeichenfolgen zu bestimmen, die von der Methode extrahiert werden, und um zu bestimmen, ob leere Zeichen folgen, die bei angrenzenden Trennzeichen auftreten, in den zurückgegebenen Zeichen folgen enthalten sind.  
  
### <a name="combining-strings"></a>Verbinden von Zeichen folgen  
 Die folgenden <xref:System.String> Methoden können für die Verkettung von Zeichen folgen verwendet werden:  
  
-   <xref:System.String.Concat%2A>kombiniert mindestens eine Teil Zeichenfolge zu einer einzelnen Zeichenfolge.  
  
-   <xref:System.String.Join%2A>Verkettet eine oder mehrere Teil Zeichenfolgen zu einem einzelnen Element und fügt zwischen den einzelnen Teil Zeichenfolgen ein Trennzeichen hinzu.  
  
### <a name="formatting-values"></a>Formatieren von Werten  
 Die <xref:System.String.Format%2A?displayProperty=nameWithType> -Methode verwendet die Funktion für die kombinierte Formatierung, um einen oder mehrere Platzhalter in einer Zeichenfolge durch die Zeichen folgen Darstellung eines Objekts oder Werts zu ersetzen. Die <xref:System.String.Format%2A> -Methode wird häufig für folgende Aufgaben verwendet:  
  
-   , Um die Zeichen folgen Darstellung eines numerischen Werts in eine Zeichenfolge einzubetten.  
  
-   , Um die Zeichen folgen Darstellung eines Datums-und Uhrzeitwerts in eine Zeichenfolge einzubetten.  
  
-   , Um die Zeichen folgen Darstellung eines Enumerationswerts in eine Zeichenfolge einzubetten.  
  
-   Zum Einbetten der Zeichen folgen Darstellung eines Objekts, das <xref:System.IFormattable> die-Schnittstelle unterstützt, in eine Zeichenfolge.  
  
-   , Um eine Teil Zeichenfolge in einem Feld innerhalb einer größeren Zeichenfolge nach rechts zu begründen oder linksbündig zu begründen.  
  
 Ausführliche Informationen zu Formatierungs Vorgängen und Beispielen finden Sie <xref:System.String.Format%2A> in der Übersicht über die Überladung.  
  
### <a name="copying-a-string"></a>Kopieren einer Zeichenfolge  
 Sie können die folgenden <xref:System.String> Methoden zum Erstellen einer Kopie einer Zeichenfolge aufzurufen:  
  
-   <xref:System.String.Clone%2A>Gibt einen Verweis auf ein vorhandenes <xref:System.String> -Objekt zurück.  
  
-   <xref:System.String.Copy%2A>erstellt eine Kopie einer vorhandenen Zeichenfolge.  
  
-   <xref:System.String.CopyTo%2A>kopiert einen Teil einer Zeichenfolge in ein Zeichen Array.  
  
### <a name="normalizing-a-string"></a>Normalisieren einer Zeichenfolge  
 In Unicode kann ein einzelnes Zeichen über mehrere Code Punkte verfügen. Bei der Normalisierung werden diese äquivalenten Zeichen in dieselbe binäre Darstellung konvertiert. Die <xref:System.String.Normalize%2A?displayProperty=nameWithType> -Methode führt die Normalisierung aus, <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> und die-Methode bestimmt, ob eine Zeichenfolge normalisiert ist.  
  
 Weitere Informationen und ein Beispiel finden Sie im Abschnitt [Normalisierung](#Normalization) weiter oben in diesem Thema.  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/download/details.aspx?id=10921">Sortieren von Gewichtungs Tabellen für Windows-Betriebssysteme</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">Standardmäßige Unicode-Sortierungs Element Tabelle für Linux und macOS</related>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In diesem Abschnitt  
  
 [Syntax für überladene Konstruktoren](#Syntax)   
 [Metern](#Params)   
 [Ausnahmen](#Exceptions)   
 [Welche Methode rufe ich auf?](#Tasks)   
 [Erstellen von Zeichen folgen](#Creating_Strings)   
 [Behandeln wiederholter Zeichen folgen](#Repetitive)   
 Beispiele für das Instanziieren von Zeichen folgen:   
 [Verwenden der Zeichen folgen Zuweisung](#Ctor1_Example)  
 [Verwenden eines Zeichen Arrays](#Ctor2_Example)  
 [Verwenden eines Teils eines Zeichen Arrays und Wiederholen eines einzelnen Zeichens](#Ctor3_Example)  
 [Verwenden eines Zeigers auf ein Zeichen Array](#Ctor4_Example)  
 [Verwenden eines Zeigers und eines Bereichs eines Arrays](#Ctor5_Example)  
 [Verwenden eines Zeigers auf ein Bytearray mit Vorzeichen](#Ctor6_Example)  
[Versionsinformationen](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Syntax für überladene Konstruktoren  
 Zeichenfolgenkonstruktoren werden in zwei Kategorien unterteilt: solche ohne Zeiger Parameter und solche mit Zeiger Parametern. Die Konstruktoren, die Zeiger verwenden, sind nicht CLS-kompatibel. Darüber hinaus unterstützt Visual Basic nicht die Verwendung von Zeigern und C# erfordert Code, der Zeiger verwendet, um in einem unsicheren Kontext ausgeführt zu werden. Weitere Informationen finden Sie unter [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 Weitere Anleitungen zum Auswählen einer Überladung finden [Sie unter welche Methode rufe ich auf?](#Tasks)  
  
 `String(Char[] value)`  
 Initialisiert die neue-Instanz mit dem Wert, der durch ein Array von Unicode-Zeichen angegeben wird. Dieser Konstruktor kopiert Unicode-Zeichen ([z](#Ctor2_Example). b.).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Initialisiert die neue-Instanz mit dem Wert, der durch ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge ([z](#Ctor3_Example). b.) angegeben wird.  
  
 `String(Char c, Int32 count)`  
 Initialisiert die neue Instanz mit dem Wert, der durch ein angegebenes Unicode-Zeichen angegeben wird, das[so oft wie](#Ctor3_Example)angegeben wiederholt wird (Beispiel).  
  
 `String(char* value)`  
 **(Nicht CLS-kompatibel)** Initialisiert die neue-Instanz mit dem Wert, der durch einen Zeiger auf ein Array von Unicode-Zeichen angegeben wird, das durch ein NULL-Zeichen (U + 0000 oder ' \ 0 ') beendet wird. ([Beispiel](#Ctor4_Example)).  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Nicht CLS-kompatibel)** Initialisiert die neue-Instanz mit dem Wert, der durch einen Zeiger auf ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge angegeben wird. Der-Konstruktor kopiert die Unicode- `value` Zeichen ab dem `startIndex` Index und endet bei `startIndex` index  +  `length` -1 ([z](#Ctor5_Example). b.).  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
 `String(SByte* value)`  
 **(Nicht CLS-kompatibel)** Initialisiert die neue-Instanz mit dem Wert, der durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen angegeben wird. Es wird davon ausgegangen, dass das Array eine Zeichenfolge darstellt, die mithilfe der aktuellen System Codepage codiert ist <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>(d. h. die durch angegebene Codierung). Der Konstruktor verarbeitet Zeichen ab `value` dem vom Zeiger angegebenen Speicherort, bis ein NULL-Zeichen (0x00) erreicht ist ([Beispiel](#Ctor6_Example)).  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Nicht CLS-kompatibel)** Initialisiert die neue-Instanz mit dem Wert, der durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays und eine Länge angegeben wird.  Es wird davon ausgegangen, dass das Array eine Zeichenfolge darstellt, die mithilfe der aktuellen System Codepage codiert ist <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>(d. h. die durch angegebene Codierung). Der-Konstruktor verarbeitet Zeichen ab dem Wert `startIndex` , beginnend bei `startIndex` und endet  +  bei `length` -1 ([z](#Ctor6_Example). b.).  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Nicht CLS-kompatibel)** Initialisiert die neue-Instanz mit dem Wert, der durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, eine Startposition innerhalb dieses Arrays, eine <xref:System.Text.Encoding> Länge und ein-Objekt angegeben wird.  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parameter  
 Im folgenden finden Sie eine komplette Liste der Parameter <xref:System.String> , die von Konstruktoren verwendet werden, die keinen Zeiger Parameter enthalten. Informationen zu den von den einzelnen über Ladungen verwendeten Parametern finden Sie in der obigen Überladungs Syntax.  
  
|Parameter|Typ|Beschreibung|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Ein Array von Unicode-Zeichen.|  
|`c`|<xref:System.Char>|Ein Unicode-Zeichen.|  
|`startIndex`|<xref:System.Int32>|Die Anfangsposition in `value` des ersten Zeichens in der neuen Zeichenfolge.<br /><br /> Standardwert: 0|  
|`length`|<xref:System.Int32>|Die Anzahl der Zeichen in `value` , die in der neuen Zeichenfolge enthalten sein sollen.<br /><br /> Standardwert:<xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|Gibt an, wie oft das `c` Zeichen in der neuen Zeichenfolge wiederholt wird. Wenn `count` 0 (null) ist, ist <xref:System.String.Empty?displayProperty=nameWithType>der Wert des neuen-Objekts.|  
  
 Im folgenden finden Sie eine komplette Liste der Parameter <xref:System.String> , die von Konstruktoren verwendet werden, die einen Zeiger Parameter enthalten. Informationen zu den von den einzelnen über Ladungen verwendeten Parametern finden Sie in der obigen Überladungs Syntax.  
  
|Parameter|Typ|Beschreibung|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> - oder -<br /><br /> <xref:System.SByte>\*|Ein Zeiger auf ein mit Null endendes Array von Unicode-Zeichen oder ein Array von 8-Bit-Ganzzahlen mit Vorzeichen. Wenn `value` oder `null` ein leeres Array ist, ist <xref:System.String.Empty?displayProperty=nameWithType>der Wert der neuen Zeichenfolge.|  
|`startIndex`|<xref:System.Int32>|Der Index des Array Elements, das das erste Zeichen in der neuen Zeichenfolge definiert.<br /><br /> Standardwert: 0|  
|`length`|<xref:System.Int32>|Die Anzahl der Array Elemente, die zum Erstellen der neuen Zeichenfolge verwendet werden sollen. Wenn die Länge 0 (null) ist, erstellt der Konstruktor eine <xref:System.String.Empty?displayProperty=nameWithType>Zeichenfolge, deren Wert ist.<br /><br /> Standardwert:<xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Ein-Objekt, das angibt `value` , wie das Array codiert wird.<br /><br /> Standardwert: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>oder die aktuelle ANSI-Codepage des Systems.|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Ausnahmen  
 Im folgenden finden Sie eine Liste der Ausnahmen, die von Konstruktoren ausgelöst werden, die keine Zeiger Parameter enthalten.  
  
|Ausnahme|Bedingung|Ausgelöst von|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` ist `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length` oder`count` ist kleiner als 0 (null).<br /><br /> - oder -<br /><br /> Die Summe von `startIndex` und `length` ist größer als die Anzahl von Elementen in `value`.<br /><br /> - oder -<br /><br /> `count` ist kleiner als Null.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Im folgenden finden Sie eine Liste der Ausnahmen, die von Konstruktoren ausgelöst werden, die Zeiger Parameter einschließen.  
  
|Ausnahme|Bedingung|Ausgelöst von|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value`Gibt ein Array an, das ein ungültiges Unicode-Zeichen enthält.<br /><br /> - oder -<br /><br /> `value`oder `value` gibteineAdresse`startIndex` an, die kleiner als 64K ist.  + <br /><br /> - oder -<br /><br /> Eine neue <xref:System.String> Instanz konnte nicht aus dem `value` Bytearray initialisiert werden `value` , da die Standard Code Page Codierung nicht verwendet.|Alle Konstruktoren mit Zeigern.|  
|<xref:System.ArgumentNullException>|`value` ist NULL.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|Der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.<br /><br /> - oder -<br /><br /> `startIndex` oder `length` ist kleiner als 0 (null), `value` + `startIndex` verursacht einen Zeigerüberlauf oder der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.<br /><br /> - oder -<br /><br /> Die Länge der neuen Zeichenfolge ist zu groß, um zuzuordnen.|Alle Konstruktoren mit Zeigern.|  
|<xref:System.AccessViolationException>|`value`, oder `value`  +  -1 +  , gibt eine ungültige Adresse an. `startIndex` `length`|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Welche Methode rufe ich auf?  
  
|Beschreibung|Anrufen oder verwenden|  
|--------|-----------------|  
|Erstellen Sie eine Zeichenfolge.|Zuweisung eines Zeichenfolgenliterals oder einer vorhandenen Zeichenfolge ([Beispiel](#Ctor1_Example))|  
|Erstellen Sie eine Zeichenfolge aus einem gesamten Zeichen Array.|<xref:System.String.%23ctor%28System.Char%5B%5D%29>([Beispiel](#Ctor2_Example))|  
|Erstellen Sie eine Zeichenfolge aus einem Teil eines Zeichen Arrays.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>([Beispiel](#Ctor3_Example))|  
|Erstellen Sie eine Zeichenfolge, die das gleiche Zeichen mehrmals wiederholt.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>([Beispiel](#Ctor3_Example))|  
|Erstellen Sie eine Zeichenfolge aus einem Zeiger auf ein Unicode-oder ein breit Zeichen Array.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Erstellen Sie mithilfe des-Zeigers eine Zeichenfolge aus einem Teil eines Unicode-oder Wide Character-Arrays.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Erstellen Sie eine Zeichenfolge C++ `char` aus einem-Array.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> - oder -<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Erstellen Sie eine Zeichenfolge aus ASCII-Zeichen.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Erstellen von Zeichen folgen  
 Das am häufigsten verwendete Verfahren zum programmgesteuerten Erstellen von Zeichen folgen ist eine einfache Zuweisung, wie in [diesem Beispiel](#Ctor1_Example)veranschaulicht. Die <xref:System.String> -Klasse enthält auch vier Typen von Konstruktorüberladungen, mit denen Sie Zeichen folgen aus den folgenden Werten erstellen können:  
  
-   Aus einem Zeichen Array (ein Array von UTF-16-codierten Zeichen). Sie können ein neues <xref:System.String> -Objekt aus den Zeichen im gesamten Array oder einem Teil davon erstellen. Der <xref:System.String.%23ctor%28System.Char%5B%5D%29> Konstruktor kopiert alle Zeichen im Array in die neue Zeichenfolge. Der <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Konstruktor kopiert die Zeichen aus dem `startIndex` Index in `startIndex` den Index  +  `length` -1 in die neue Zeichenfolge. Wenn `length` 0 (null) ist, ist <xref:System.String.Empty?displayProperty=nameWithType>der Wert der neuen Zeichenfolge.  
  
     Wenn Ihr Code Zeichen folgen mit dem gleichen Wert wiederholt instanziiert, können Sie die Anwendungsleistung verbessern, indem Sie eine alternative Möglichkeit zum Erstellen von Zeichen folgen verwenden. Weitere Informationen finden Sie unter [Behandeln von Wiederkehr](#Repetitive)enden Zeichen folgen.  
  
-   Von einem einzelnen Zeichen, das NULL, einmal oder mehrmals dupliziert wird, indem der <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> -Konstruktor verwendet wird. Wenn `count` 0 (null) ist, ist <xref:System.String.Empty?displayProperty=nameWithType>der Wert der neuen Zeichenfolge.  
  
-   Von einem Zeiger auf ein mit Null endendes Zeichen Array, mithilfe des <xref:System.String.%23ctor%28System.Char%2A%29> - <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> oder-Konstruktors. Das gesamte Array oder ein angegebener Bereich kann verwendet werden, um die Zeichenfolge zu initialisieren. Der-Konstruktor kopiert eine Sequenz von Unicode-Zeichen, beginnend beim angegebenen Zeiger oder vom angegebenen Zeiger `startIndex` Plus und setzt das Ende des Arrays oder für `length` Zeichen fort. Wenn `value` ein NULL-Zeiger ist `length` oder 0 (null) ist, erstellt der Konstruktor eine <xref:System.String.Empty?displayProperty=nameWithType>Zeichenfolge, deren Wert ist. Wenn der Kopiervorgang bis zum Ende des Arrays verläuft und das Array nicht auf NULL endet, ist das konstruktorverhalten System abhängig. Eine solche Bedingung kann eine Zugriffsverletzung verursachen.  
  
     Wenn das Array eingebettete NULL-Zeichen (U + 0000 oder ' \ 0 ') enthält und <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> die-Überladung aufgerufen wird, enthält `length` die Zeichen folgen Instanz Zeichen, einschließlich der eingebetteten Nullen. Das folgende Beispiel zeigt, was geschieht, wenn ein Zeiger auf ein Array mit 10 Elementen, das zwei NULL-Zeichen enthält <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> , an die-Methode übermittelt wird. Da es sich bei der Adresse um den Anfang des Arrays handelt und alle Elemente im Array der Zeichenfolge hinzugefügt werden sollen, instanziiert der Konstruktor eine Zeichenfolge mit zehn Zeichen, einschließlich zwei eingebetteter Nullen. Wenn das gleiche Array hingegen an den <xref:System.String.%23ctor%28System.Char%2A%29> Konstruktor übergeben wird, ist das Ergebnis eine Zeichenfolge mit vier Zeichen, die das erste Null-Zeichen nicht enthält.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     Das Array muss Unicode-Zeichen enthalten. In C++bedeutet dies, dass das Zeichen Array entweder als verwalteter <xref:System.Char>[]-Typ oder als nicht verwalteter`wchar_t`[]-Typ definiert werden muss.  
  
     Wenn die <xref:System.String.%23ctor%28System.Char%2A%29> Überladung aufgerufen wird und das Array nicht mit NULL endet, oder wenn die <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Überladung aufgerufen wird `startIndex`und  +  `length`-1 einen Bereich enthält, der außerhalb des für die Zeichenfolge zugeordneten Arbeitsspeichers liegt, das Verhalten des Konstruktors ist System abhängig, und es kann eine Zugriffsverletzung auftreten. Außerdem können Aufrufe des <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> -Konstruktors auf dem Intel Itanium-Prozessor eine <xref:System.DataMisalignedException> -Ausnahme auslösen. Wenn dies auftritt, müssen Sie <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> stattdessen den-Befehl verwenden.  
  
-   Von einem Zeiger auf ein Bytearray mit Vorzeichen. Das gesamte Array oder ein angegebener Bereich kann verwendet werden, um die Zeichenfolge zu initialisieren. Die Byte Sequenz kann mit der Standard Code Page Codierung interpretiert werden, oder es kann eine Codierung im konstruktorbefehl angegeben werden. , Wenn der Konstruktor versucht, eine Zeichenfolge aus einem ganzen Array zu instanziieren, das nicht mit NULL endet, oder, wenn der Bereich `value` des `value` Arrays von bis  +   +  `startIndex` `startIndex`  +  `length` -1 befindet sich außerhalb des für das Array zugeordneten Arbeitsspeichers, das Verhalten dieses Konstruktors ist System abhängig, und es kann eine Zugriffsverletzung auftreten.  
  
     Die drei Konstruktoren, die ein Bytearray mit Vorzeichen als Parameter enthalten, werden in erster C++ `char` Linie so entworfen, dass ein Array in eine Zeichenfolge konvertiert wird, wie im folgenden Beispiel gezeigt:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Wenn das Array NULL Zeichen (' \ 0 ') oder Bytes enthält, deren Wert 0 ist, und <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> die-Überladung aufgerufen wird, enthält `length` die Zeichen folgen Instanz Zeichen, einschließlich der eingebetteten Nullen. Das folgende Beispiel zeigt, was geschieht, wenn ein Zeiger auf ein Array mit 10 Elementen, das zwei NULL-Zeichen enthält <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> , an die-Methode übermittelt wird. Da es sich bei der Adresse um den Anfang des Arrays handelt und alle Elemente im Array der Zeichenfolge hinzugefügt werden sollen, instanziiert der Konstruktor eine Zeichenfolge mit zehn Zeichen, einschließlich zwei eingebetteter Nullen. Wenn das gleiche Array hingegen an den <xref:System.String.%23ctor%28System.SByte%2A%29> Konstruktor übergeben wird, ist das Ergebnis eine Zeichenfolge mit vier Zeichen, die das erste Null-Zeichen nicht enthält.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Da der <xref:System.String.%23ctor%28System.SByte%2A%29> - <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> Konstruktor und `value` der-Konstruktor mit der standardmäßigen ANSI-Codepage interpretieren, können beim Aufrufen dieser Konstruktoren mit identischen Byte Arrays Zeichen folgen erstellt werden, die unterschiedliche Werte für verschiedene Systeme aufweisen.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Behandeln wiederholter Zeichen folgen  
 Apps, die Text Ströme analysieren oder decodieren, verwenden häufig den <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> -Konstruktor oder <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> die-Methode, um Zeichen folgen in eine Zeichenfolge zu konvertieren. Wiederholtes Erstellen neuer Zeichen folgen mit demselben Wert, anstatt eine Zeichenfolge zu erstellen und wieder zu verwenden, verschwendet Arbeitsspeicher. Wenn Sie wahrscheinlich den gleichen Zeichen folgen Wert wiederholt durch Aufrufen des <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Konstruktors erstellen, können Sie stattdessen eine Nachschlage Tabelle verwenden, auch wenn Sie nicht im Voraus wissen, welche identischen Zeichen folgen Werte Sie verwenden können.  
  
 Angenommen, Sie lesen und analysieren einen Datenstrom aus einer Datei, die XML-Tags und-Attribute enthält. Wenn Sie den Stream analysieren, stoßen Sie wiederholt auf bestimmte Token (d. h. Zeichen folgen, die eine symbolische Bedeutung haben). Token, die den Zeichen folgen "0", "1", "true" und "false" entsprechen, treten wahrscheinlich häufig in einem XML-Stream auf.  
  
 Anstatt jedes Token in eine neue Zeichenfolge zu wandeln, können Sie ein <xref:System.Xml.NameTable?displayProperty=nameWithType> -Objekt erstellen, um häufig auftretende Zeichen folgen zu speichern. Das <xref:System.Xml.NameTable> -Objekt verbessert die Leistung, da gespeicherte Zeichen folgen abgerufen werden, ohne temporären Arbeitsspeicher zuzuordnen. Wenn Sie ein Token finden, verwenden Sie <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> die-Methode, um das Token aus der Tabelle abzurufen. Wenn das Token vorhanden ist, gibt die Methode die entsprechende Zeichenfolge zurück. Wenn das Token nicht vorhanden ist, verwenden Sie <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> die-Methode, um das Token in die Tabelle einzufügen und die entsprechende Zeichenfolge zu erhalten.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Beispiel 1: Verwenden der Zeichen folgen Zuweisung  
 Im folgenden Beispiel wird eine neue Zeichenfolge durch Zuweisen eines Zeichenfolgenliterals erstellt. Es wird eine zweite Zeichenfolge erstellt, indem der Wert der ersten Zeichenfolge zugewiesen wird. Dies sind die beiden gängigsten Methoden, um ein neues <xref:System.String> -Objekt zu instanziieren.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Beispiel 2: Verwenden eines Zeichen Arrays  
 Im folgenden Beispiel wird veranschaulicht, wie ein neues <xref:System.String> -Objekt aus einem Zeichen Array erstellt wird.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Beispiel 3: Verwenden eines Teils eines Zeichen Arrays und Wiederholen eines einzelnen Zeichens  
 Im folgenden Beispiel wird veranschaulicht, wie ein neues <xref:System.String> -Objekt aus einem Teil eines Zeichen Arrays erstellt wird und wie ein neues <xref:System.String> -Objekt erstellt wird, das mehrere Vorkommen eines einzelnen Zeichens enthält.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Beispiel 4: Verwenden eines Zeigers auf ein Zeichen Array  
 Im folgenden Beispiel wird veranschaulicht, wie ein neues <xref:System.String> -Objekt aus einem Zeiger auf ein Zeichen Array erstellt wird. Das C# Beispiel muss mithilfe des `/unsafe` -Compilerschalters kompiliert werden.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Beispiel 5: Instanziieren einer Zeichenfolge aus einem Zeiger und einem Bereich eines Arrays  
 Im folgenden Beispiel werden die Elemente eines Zeichen Arrays für einen Punkt oder ein Ausrufezeichen untersucht. Wenn eine Zeichenfolge gefunden wird, wird eine Zeichenfolge aus den Zeichen im Array instanziiert, die dem Interpunktions Zeichen vorangestellt ist. Wenn dies nicht der Fall ist, wird eine Zeichenfolge mit dem gesamten Inhalt des Arrays instanziiert. Das C# Beispiel muss mithilfe des `/unsafe` -Compilerschalters kompiliert werden.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Beispiel 6: Instanziieren einer Zeichenfolge von einem Zeiger auf ein Bytearray mit Vorzeichen  
 Im folgenden Beispiel wird veranschaulicht, wie Sie eine Instanz der <xref:System.String> -Klasse mit dem <xref:System.String.%23ctor%28System.SByte%2A%29> -Konstruktor erstellen können.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Versionsinformationen  
 .NET Framework  
 Alle über Ladungen werden in unterstützt: 4,5, 4, 3,5, 3,0, 2,0, 1,1, 1,0  
  
 .NET Framework Client Profile  
 Alle über Ladungen werden in unterstützt: 4, 3,5 SP1  
  
 Portable Klassenbibliothek  
 Alle über Ladungen ohne <xref:System.SByte> `*` Parameter werden unterstützt.  
  
 .NET für Windows Store-Apps  
 Alle über Ladungen ohne <xref:System.SByte> `*` -Parameter werden in unterstützt: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein mit Null endendes Array von Unicode-Zeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von Unicode-Zeichen bestimmt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String` Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A> Konstruktors.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> gibt ein Array an, das ein ungültiges Unicode-Zeichen enthält, oder <paramref name="value" /> gibt eine Adresse kleiner als 64000 an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Ein Array von Unicode-Zeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem durch ein Array von Unicode-Zeichen angegebenen Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String` Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A> Konstruktors.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein mit NULL endendes Array von 8-Bit-Ganzzahlen mit Vorzeichen. Die Ganzzahlen werden mit der aktuellen Systemcodeseiten-Codierung interpretiert (d.h. der durch <see cref="P:System.Text.Encoding.Default" /> angegebenen Codierung).</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen angegebenen Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String` Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A> Konstruktors.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Eine neue Instanz von <see cref="T:System.String" /> konnte nicht mit <paramref name="value" /> initialisiert werden, wobei angenommen wurde, dass <paramref name="value" /> in ANSI codiert ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der neuen zu initialisierenden Zeichenfolge, die durch das NULL-Abschlusszeichen von <paramref name="value" /> bestimmt wird, ist zu groß für die Zuordnung.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" /> gibt eine ungültige Adresse an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Ein Unicode-Zeichen.</param>
        <param name="count">Die Anzahl des Vorkommens von <paramref name="c" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch ein angegebenes so oft wie angegeben wiederholtes Unicode-Zeichen bestimmt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String` Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A> Konstruktors.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein Array von Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition in <paramref name="value" />.</param>
        <param name="length">Die Anzahl der aus <paramref name="value" /> zu verwendenden Zeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von Unicode-Zeichen, durch die Position des ersten Zeichens innerhalb dieses Arrays und durch eine Länge bestimmt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String` Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A> Konstruktors.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0 (null), <paramref name="value" /> + <paramref name="startIndex" /> verursacht einen Zeigerüberlauf oder der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> gibt ein Array an, das ein ungültiges Unicode-Zeichen enthält, oder <paramref name="value" /> + <paramref name="startIndex" /> gibt eine Adresse kleiner als 64000 an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein Array von Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition in <paramref name="value" />.</param>
        <param name="length">Die Anzahl der aus <paramref name="value" /> zu verwendenden Zeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge bestimmt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String` Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A> Konstruktors.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.  
  
- oder - 
Die Summe von <paramref name="startIndex" /> und <paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen. Die Ganzzahlen werden mit der aktuellen Systemcodeseiten-Codierung interpretiert (d.h. der durch <see cref="P:System.Text.Encoding.Default" /> angegebenen Codierung).</param>
        <param name="startIndex">Die Anfangsposition in <paramref name="value" />.</param>
        <param name="length">Die Anzahl der aus <paramref name="value" /> zu verwendenden Zeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays und die Länge angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String` Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A> Konstruktors.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.  
  
- oder - 
Die durch <paramref name="value" /> + <paramref name="startIndex" /> angegebene Adresse ist für die aktuelle Plattform zu groß, d.h., bei der Berechnung der Adresse ist ein Überlauf aufgetreten.  
  
- oder - 
Die Länge der zu initialisierenden neuen Zeichenfolge ist zu groß und kann daher nicht zugeordnet werden.</exception>
        <exception cref="T:System.ArgumentException">Die durch <paramref name="value" /> + <paramref name="startIndex" /> angegebene Adresse ist kleiner als 64K.  
  
- oder - 
Eine neue Instanz von <see cref="T:System.String" /> konnte nicht mit <paramref name="value" /> initialisiert werden, wobei angenommen wurde, dass <paramref name="value" /> in ANSI codiert ist.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> und <paramref name="length" /> geben zusammen eine ungültige Adresse an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen.</param>
        <param name="startIndex">Die Anfangsposition in <paramref name="value" />.</param>
        <param name="length">Die Anzahl der aus <paramref name="value" /> zu verwendenden Zeichen.</param>
        <param name="enc">Ein Objekt, das angibt, wie das Array codiert ist, auf das <paramref name="value" /> verweist. Wenn <paramref name="enc" /><see langword="null" /> ist, wird von ANSI-Codierung ausgegangen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays, eine Länge und ein <see cref="T:System.Text.Encoding" />-Objekt angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String` Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A> Konstruktors.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.  
  
- oder - 
Die durch <paramref name="value" /> + <paramref name="startIndex" /> angegebene Adresse ist für die aktuelle Plattform zu groß, d.h., bei der Berechnung der Adresse ist ein Überlauf aufgetreten.  
  
- oder - 
Die Länge der zu initialisierenden neuen Zeichenfolge ist zu groß und kann daher nicht zugeordnet werden.</exception>
        <exception cref="T:System.ArgumentException">Die durch <paramref name="value" /> + <paramref name="startIndex" /> angegebene Adresse ist kleiner als 64K.  
  
- oder - 
Eine neue Instanz von <see cref="T:System.String" /> konnte nicht mit <paramref name="value" /> initialisiert werden, wobei angenommen wurde, dass <paramref name="value" /> entsprechend der Angabe durch <paramref name="enc" /> codiert ist.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> und <paramref name="length" /> geben zusammen eine ungültige Adresse an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Index) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[Index] { char get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Index) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Eine Position in der aktuellen Zeichenfolge.</param>
        <summary>Ruft das <see cref="T:System.Char" />-Objekt an einer angegebenen Zeichenposition innerhalb des aktuellen <see cref="T:System.String" />-Objekts ab.</summary>
        <value>Das Objekt an der <paramref name="index" />-Position.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `index` -Parameter ist NULL basiert.  
  
 Diese Eigenschaft gibt das <xref:System.Char> -Objekt an der durch den `index` -Parameter angegebenen Position zurück. Ein Unicode-Zeichen kann jedoch durch mehr als eins <xref:System.Char>dargestellt werden. Verwenden Sie <xref:System.Globalization.StringInfo?displayProperty=nameWithType> die-Klasse, um mit Unicode- <xref:System.Char> Zeichen anstelle von-Objekten zu arbeiten. Weitere Informationen finden Sie im Abschnitt "Char-Objekte und Unicode-Zeichen" in <xref:System.String> der Übersicht über die-Klasse.  
  
 In C#handelt es <xref:System.String.Chars%2A> sich bei der Eigenschaft um einen Indexer. In Visual Basic ist dies die Standard Eigenschaft <xref:System.String> der-Klasse. Auf <xref:System.Char> jedes Objekt in der Zeichenfolge kann mithilfe von Code wie dem folgenden zugegriffen werden.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie diesen Indexer in einer Routine verwenden können, um eine Zeichenfolge zu validieren.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> ist größer oder gleich der Länge dieses Objekts oder kleiner als 0 (null).</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public string this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Chars(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(range As Range) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[Range] { System::String ^ get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Range) : string" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Verweis auf diese Instanz von <see cref="T:System.String" />zurück.</summary>
        <returns>Diese Instanz von <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert ist keine unabhängige Kopie dieser Instanz. Es handelt sich einfach um eine weitere Ansicht der gleichen Daten. Verwenden Sie <xref:System.String.Copy%2A> die <xref:System.String.CopyTo%2A> -Methode oder die- <xref:System.String> Methode, um ein separates-Objekt mit demselben Wert wie diese Instanz zu erstellen.  
  
 Da die <xref:System.String.Clone%2A> -Methode einfach die vorhandene Zeichen folgen Instanz zurückgibt, gibt es kaum einen Grund, Sie direkt aufzurufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Überladungen der Methode <xref:System.String.Compare%2A> geben eine 32-Bit-Ganzzahl mit Vorzeichen zurück, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
|Wert|Bedingung|  
|-----------|---------------|  
|Kleiner als 0 (null)|Die erste Teil Zeichenfolge steht in der Sortierreihenfolge vor der zweiten Teil Zeichenfolge.|  
|Zero|Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder `length` ist 0 (null).|  
|Größer als 0 (null)|Die erste Teil Zeichenfolge folgt der zweiten Teil Zeichenfolge in der Sortierreihenfolge.|  
  
> [!WARNING]
>  Wenn möglich, sollten Sie eine über <xref:System.String.Compare%2A> Ladung der-Methode aufrufen, die einen <xref:System.StringComparison> -Parameter enthält. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> tritt in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" /> auf.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge hinter <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich verwendet die aktuelle Kultur, um kulturspezifische Informationen wie z. b. Regeln für die Groß-/Kleinschreibung und die alphabetische Reihenfolge einzelner Zeichen abzurufen. Eine Kultur könnte z. b. angeben, dass bestimmte Zeichenkombinationen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen, oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vorangestellt sind. Befolgen Sie diese Anweisungen.  
  
 Der Vergleich erfolgt mithilfe von Wort Sortierregeln. Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>finden Sie unter.  
  
> [!WARNING]
>  Beim Vergleichen von Zeichen folgen sollten Sie die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode verwenden, die erfordert, dass Sie den Typ des Zeichen folgen Vergleichs, der von der Methode verwendet wird, explizit angeben. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 Ein oder beide Vergleiche können sein `null`. Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Zeichen folgen verglichen wurden. Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet. Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.  
  
 Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind. In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden. Der richtige Code hierfür lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Compare%28System.String%2CSystem.String%29> -Methode aufgerufen, um drei Sätze von Zeichen folgen zu vergleichen.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 Im folgenden Beispiel zeigt die `ReverseStringComparer` -Klasse, wie Sie mit der <xref:System.String.Compare%2A> -Methode zwei Zeichen folgen auswerten können.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.String)" /> -Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt. Wenn z. b. der folgende Code in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, gibt ein Kultur abhängiger Vergleich von "Animal" mit "Ani-mal" (mit einem weichen Bindestrich oder U + 00ad) an, dass die beiden Zeichen folgen äquivalent sind.  
  
[! Code-csharp[System. String. Compare # 21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [! Code-vb[System. String. Compare # 21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
Um Ignorable-Zeichen in einem Zeichen folgen Vergleich zu erkennen <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> , müssen Sie die-Methode aufrufen <see cref="F:System.Globalization.CompareOptions.Ordinal" /> und <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> einen Wert `comparisonType` von oder für den-Parameter angeben.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <param name="ignoreCase"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> tritt in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" /> auf.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge hinter <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich verwendet die aktuelle Kultur, um kulturspezifische Informationen wie z. b. Regeln für die Groß-/Kleinschreibung und die alphabetische Reihenfolge einzelner Zeichen abzurufen. Eine Kultur könnte z. b. angeben, dass bestimmte Zeichenkombinationen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen, oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vorangestellt sind. Befolgen Sie diese Anweisungen.  
  
 Der Vergleich erfolgt mithilfe von Wort Sortierregeln. Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>finden Sie unter.  
  
> [!WARNING]
>  Beim Vergleichen von Zeichen folgen sollten Sie die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode verwenden, die erfordert, dass Sie den Typ des Zeichen folgen Vergleichs, der von der Methode verwendet wird, explizit angeben. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 Ein oder beide Vergleiche können sein `null`. Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Zeichen folgen verglichen wurden. Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet. Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.  
  
 Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind. In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden. Der richtige Code hierfür lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> dass die-Methode der <xref:System.String.ToUpper%2A> Verwendung <xref:System.String.ToLower%2A> von oder beim Vergleichen von Zeichen folgen entspricht.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> -Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt. Wenn z. b. der folgende Code in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, gibt ein Kultur abhängiger Vergleich von "Animal" mit der Groß-/Kleinschreibung, der die Groß-/Kleinschreibung beachtet, an, dass die beiden Zeichen folgen äquivalent sind.  
  
[! Code-csharp[System. String. Compare # 22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [! Code-vb[System. String. Compare # 22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
Um Ignorable-Zeichen in einem Zeichen folgen Vergleich zu erkennen <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> , müssen Sie die-Methode aufrufen <see cref="F:System.Globalization.CompareOptions.Ordinal" /> und <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> einen Wert <paramref name="comparisonType" /> von oder für den-Parameter angeben.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte gemäß den angegebenen Vergleichsregeln und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> befindet sich in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge hinter <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `comparisonType` -Parameter gibt an, ob beim Vergleich die aktuelle oder invariante Kultur verwendet werden soll, ob die Groß-/Kleinschreibung der Vergleichs Elemente berücksichtigt oder ignoriert werden soll oder ob Wort-Sortierregeln (Kultur abhängig) oder Ordinalzahl (Kultur unabhängig) verwendet werden sollen.  
  
 Ein oder beide Vergleiche können sein `null`. Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Zeichen folgen verglichen wurden. Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet. Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.  
  
 Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind. In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden. Der richtige Code hierfür lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei Versionen des Buchstabens "I" verglichen. Die Ergebnisse sind von der Auswahl der Kultur betroffen, unabhängig davon, ob die Groß-/Kleinschreibung ignoriert wird und ob ein Ordinalvergleich durchgeführt wird.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.StringComparison" /> wird nicht unterstützt.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> -Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt. Um Ignorable-Zeichen im Vergleich zu erkennen, geben Sie den <see cref="F:System.StringComparison.Ordinal" /> Wert <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> oder für <paramref name="comparisonType" /> den-Parameter an.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <param name="ignoreCase"><see langword="true" /> , wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <param name="culture">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt und der Vergleich durch kulturspezifische Informationen beeinflusst wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> tritt in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" /> auf.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge hinter <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der-Vergleich verwendet `culture` den-Parameter, um kulturspezifische Informationen wie z. b. Regeln für die Groß-und Kleinschreibung von einzelnen Zeichen zu erhalten. Eine Kultur könnte z. b. angeben, dass bestimmte Zeichenkombinationen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen, oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vorangestellt sind. Befolgen Sie diese Anweisungen.  
  
 Der Vergleich erfolgt mithilfe von Wort Sortierregeln. Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>finden Sie unter.  
  
 Ein oder beide Vergleiche können sein `null`. Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Zeichen folgen verglichen wurden. Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet. Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.  
  
 Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind. In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden. Der richtige Code hierfür lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie sich die Kultur auf einen Vergleich auswirken kann. In der Kultur der Tschechischen Republik ist "ch" ein einzelnes Zeichen, das größer als "d" ist. In englischer Sprache USA Kultur besteht "ch" aus zwei Zeichen, und "c" ist kleiner als "d".  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> -Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt. Wenn z. b. der folgende Code in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, gibt ein Vergleich von "Animal" mit "Ani-mal" (mit einem weichen Bindestrich oder U + 00ad), der die invariante Kultur verwendet, eine Entsprechung für die beiden Zeichen folgen an.  
  
[! Code-csharp[System. String. Compare # 23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [! Code-vb[System. String. Compare # 23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
Um Ignorable-Zeichen in einem Zeichen folgen Vergleich zu erkennen <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> , müssen Sie die-Methode aufrufen <see cref="F:System.Globalization.CompareOptions.Ordinal" /> und <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> einen Wert <paramref name="options" /> von oder für den-Parameter angeben.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <param name="culture">Die Kultur, die kulturspezifische Vergleichsinformationen liefert.</param>
        <param name="options">Die beim Ausführen des Vergleichs zu verwendenden Optionen (z. B. Ignorieren von Groß- und Kleinschreibung oder Symbolen).</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte mit den festgelegten Vergleichsoptionen und kulturspezifischen Informationen, die den Vergleich beeinflussen, und gibt eine ganze Zahl zurück, die die Beziehung der beiden Zeichenfolgen zueinander in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung zwischen <paramref name="strA" /> und <paramref name="strB" /> angibt, wie in der folgenden Tabelle veranschaulicht wird. 
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> tritt in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" /> auf.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge hinter <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der-Vergleich verwendet `culture` den-Parameter, um kulturspezifische Informationen zu erhalten, z. b. Regeln für die Groß-und Kleinschreibung von einzelnen Zeichen. Beispielsweise könnte eine bestimmte Kultur angeben, dass bestimmte Kombinationen von Zeichen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vor oder folgen Sie diesem.  
  
> [!CAUTION]
>  Die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> -Methode ist hauptsächlich für die Verwendung in Sortier-oder Alphabetisierungs Vorgängen vorgesehen. Er sollte nicht verwendet werden, wenn der primäre Zweck des Methoden Aufrufes ist, zu bestimmen, ob zwei Zeichen folgen äquivalent sind (d. h., wenn der Zweck des Methoden Aufrufes ist, auf einen Rückgabewert von NULL zu testen). Um zu ermitteln, ob zwei Zeichen folgen äquivalent sind <xref:System.String.Equals%2A> , müssen Sie die-Methode aufruft.  
  
 Der Vergleich kann weiter durch den `options` -Parameter angegeben werden, der aus einem oder mehreren Membern <xref:System.Globalization.CompareOptions> der-Enumeration besteht. Da der Zweck dieser Methode jedoch darin besteht, einen Kultur abhängigen Zeichen folgen Vergleich durchzuführen, haben <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> die <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> Werte und keine Auswirkung.  
  
 Entweder oder beide Vergleiche können sein `null`. Definitionsgemäß vergleichen eine beliebige Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithType>, einschließlich, einen Vergleich von einem NULL-Verweis und zwei NULL-Verweise gleich einander.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Zeichen folgen verglichen wurden. Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei Zeichen folgen auf drei verschiedene Arten verglichen: die Verwendung des linguistischen Vergleichs für die Kultur "en-US". Verwenden von linguistischer Berücksichtigung der Groß-/Kleinschreibung für die Kultur "en-US" und einen Ordinalvergleich verwenden. Es veranschaulicht, wie die drei Vergleichsmethoden drei verschiedene Ergebnisse verursachen.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> ist kein <see cref="T:System.Globalization.CompareOptions" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Die <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> -Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt. Um Ignorable-Zeichen im Vergleich zu erkennen, geben Sie den <see cref="F:System.Globalization.CompareOptions.Ordinal" /> Wert <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> oder für <paramref name="options" /> den-Parameter an.</para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Position der Teilzeichenfolge innerhalb von <paramref name="strA" />.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Position der Teilzeichenfolge innerhalb von <paramref name="strB" />.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.  
  
 </description></item><item><term> Zero 
 </term><description> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <paramref name="length" /> ist 0 (null).  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zu vergleichenden Teil Zeichenfolgen `indexA` , die `strB` in `indexB` `strA` at und in zu vergleichen sind. Und sind NULL basiert, d. h. das erste Zeichen in `strA` und `strB` befindet sich an der Position 0 (null). `indexB` `indexA` Die Länge der ersten Teil Zeichenfolge ist gleich der Länge von `strA` minus `indexA` plus eins. Die Länge der zweiten Teil Zeichenfolge ist gleich der Länge von `strB` minus `indexB` plus eins.  
  
 Die Anzahl der zu vergleichenden Zeichen ist geringer als die Länge der beiden Teil Zeichenfolgen, `length`und. Die `indexA`Parameter `indexB`, und`length` dürfen nicht negativ sein.  
  
 Der Vergleich verwendet die aktuelle Kultur, um kulturspezifische Informationen wie z. b. Regeln für die Groß-/Kleinschreibung und die alphabetische Reihenfolge einzelner Zeichen abzurufen. Eine Kultur könnte z. b. angeben, dass bestimmte Zeichenkombinationen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen, oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vorangestellt sind. Befolgen Sie diese Anweisungen.  
  
 Der Vergleich erfolgt mithilfe von Wort Sortierregeln. Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>finden Sie unter.  
  
> [!WARNING]
>  Beim Vergleichen von Zeichen folgen sollten Sie die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> -Methode verwenden, die erfordert, dass Sie den Typ des Zeichen folgen Vergleichs, der von der Methode verwendet wird, explizit angeben. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 Ein oder beide Vergleiche können sein `null`. Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Teil Zeichenfolgen verglichen wurden. Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet. Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.  
  
 Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind. In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden. Der richtige Code hierfür lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei Teil Zeichenfolgen verglichen.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- oder - 
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- oder - 
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
- oder - 
Entweder <paramref name="indexA" /> oder <paramref name="indexB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> -Methode berücksichtigt diese Zeichen nicht, wenn Sie einen linguistischen oder Kultur abhängigen Vergleich durchführt. Um Ignorable-Zeichen im Vergleich zu erkennen, müssen <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> Sie die-Methode aufrufen und <see cref="F:System.Globalization.CompareOptions.Ordinal" /> den <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> Wert oder <paramref name="comparisonType" /> für den-Parameter angeben.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Position der Teilzeichenfolge innerhalb von <paramref name="strA" />.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Position der Teilzeichenfolge innerhalb von <paramref name="strB" />.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <param name="ignoreCase"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <summary>Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.  
  
 </description></item><item><term> Zero 
 </term><description> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <paramref name="length" /> ist 0 (null).  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Teil Zeichenfolgen, die `strA` mit `indexA`verglichen werden sollen `strB` , `indexB`und in um. Und sind NULL basiert, d. h. das erste Zeichen in `strA` und `strB` befindet sich an der Position 0 (null). `indexB` `indexA` Die Länge der ersten Teil Zeichenfolge ist gleich der Länge von `strA` minus `indexA` plus eins. Die Länge der zweiten Teil Zeichenfolge ist gleich der Länge von `strB` minus `indexB` plus eins.  
  
 Die Anzahl der zu vergleichenden Zeichen ist geringer als die Länge der beiden Teil Zeichenfolgen, `length`und. Die `indexA`Parameter `indexB`, und`length` dürfen nicht negativ sein.  
  
 Der Vergleich verwendet die aktuelle Kultur, um kulturspezifische Informationen wie z. b. Regeln für die Groß-/Kleinschreibung und die alphabetische Reihenfolge einzelner Zeichen abzurufen. Eine Kultur könnte z. b. angeben, dass bestimmte Zeichenkombinationen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen, oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vorangestellt sind. Befolgen Sie diese Anweisungen.  
  
 Der Vergleich erfolgt mithilfe von Wort Sortierregeln. Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>finden Sie unter.  
  
> [!WARNING]
>  Beim Vergleichen von Zeichen folgen sollten Sie die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> -Methode verwenden, die erfordert, dass Sie den Typ des Zeichen folgen Vergleichs, der von der Methode verwendet wird, explizit angeben. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 Ein oder beide Vergleiche können sein `null`. Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Teil Zeichenfolgen verglichen wurden. Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet. Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.  
  
 Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind. In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 Der Pfadname muss invarianten Weise verglichen werden. Der richtige Code hierfür ist wie folgt.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei Vergleiche zweier Teil Zeichenfolgen durchführt, die sich nur in Groß-und Kleinschreibung Der erste Vergleich ignoriert die Groß-und Kleinschreibung.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- oder - 
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- oder - 
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
- oder - 
Entweder <paramref name="indexA" /> oder <paramref name="indexB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> -Methode berücksichtigt diese Zeichen nicht, wenn Sie einen linguistischen oder Kultur abhängigen Vergleich durchführt. Um Ignorable-Zeichen im Vergleich zu erkennen, müssen <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> Sie die-Methode aufrufen und <see cref="F:System.Globalization.CompareOptions.Ordinal" /> den <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> Wert oder <paramref name="comparisonType" /> für den-Parameter angeben.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Position der Teilzeichenfolge innerhalb von <paramref name="strA" />.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Position der Teilzeichenfolge innerhalb von <paramref name="strB" />.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</param>
        <summary>Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten gemäß den angegebenen Vergleichsregeln und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.  
  
 </description></item><item><term> Zero 
 </term><description> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder der <paramref name="length" />-Parameter ist 0 (null).  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zu vergleichenden Teil Zeichenfolgen `indexA` , die `strB` in `indexB` `strA` at und in zu vergleichen sind. Und sind `indexB` Null basiert, d. h. das erste Zeichen in `strA` und `strB` befindet sich an der Position 0 (null) und nicht in der Position 1. `indexA` Die Länge der ersten Teil Zeichenfolge ist gleich der Länge von `strA` minus `indexA` plus eins. Die Länge der zweiten Teil Zeichenfolge ist gleich der Länge von `strB` minus `indexB` plus eins.  
  
 Die Anzahl der zu vergleichenden Zeichen ist geringer als die Länge der beiden Teil Zeichenfolgen, `length`und. Die `indexA`Parameter `indexB`, und`length` dürfen nicht negativ sein.  
  
 Der `comparisonType` -Parameter gibt an, ob beim Vergleich die aktuelle oder invariante Kultur verwendet werden soll, ob die Groß-/Kleinschreibung der Vergleichs Elemente berücksichtigt oder ignoriert werden soll oder ob Wort-Sortierregeln (Kultur abhängig) oder Ordinalzahl (Kultur unabhängig) verwendet werden sollen.  
  
 Ein oder beide Vergleiche können sein `null`. Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Teil Zeichenfolgen verglichen wurden. Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet. Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.  
  
 Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind. In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden. Der richtige Code hierfür lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei Teil Zeichenfolgen verglichen.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- oder - 
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- oder - 
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
- oder - 
Entweder <paramref name="indexA" /> oder <paramref name="indexB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> -Methode berücksichtigt diese Zeichen nicht, wenn Sie einen linguistischen oder Kultur abhängigen Vergleich durchführt. Um Ignorable-Zeichen im Vergleich zu erkennen, geben Sie den <see cref="F:System.StringComparison.Ordinal" /> Wert <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> oder für <paramref name="comparisonType" /> den-Parameter an.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Position der Teilzeichenfolge innerhalb von <paramref name="strA" />.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Position der Teilzeichenfolge innerhalb von <paramref name="strB" />.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <param name="ignoreCase"><see langword="true" /> , wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <param name="culture">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</param>
        <summary>Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt und der Vergleich durch kulturspezifische Informationen beeinflusst wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Vergleichswerten angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.  
  
 </description></item><item><term> Zero 
 </term><description> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <paramref name="length" /> ist 0 (null).  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Teil Zeichenfolgen, die `strA` mit `indexA`verglichen werden sollen `strB` , `indexB`und in um. Und sind `indexB` Null basiert, d. h. das erste Zeichen in `strA` und `strB` befindet sich an der Position 0 (null) und nicht in der Position 1. `indexA` Die Länge der ersten Teil Zeichenfolge ist gleich der Länge von `strA` minus `indexA` plus eins. Die Länge der zweiten Teil Zeichenfolge ist gleich der Länge von `strB` minus `indexB` plus eins.  
  
 Die Anzahl der zu vergleichenden Zeichen ist geringer als die Länge der beiden Teil Zeichenfolgen, `length`und. Die `indexA`Parameter `indexB`, und`length` dürfen nicht negativ sein.  
  
 Der-Vergleich verwendet `culture` den-Parameter, um kulturspezifische Informationen wie z. b. Regeln für die Groß-und Kleinschreibung von einzelnen Zeichen zu erhalten. Eine Kultur könnte z. b. angeben, dass bestimmte Zeichenkombinationen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen, oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vorangestellt sind. Befolgen Sie diese Anweisungen.  
  
 Der Vergleich erfolgt mithilfe von Wort Sortierregeln. Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>finden Sie unter.  
  
 Ein oder beide Vergleiche können sein `null`. Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Teil Zeichenfolgen verglichen wurden. Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet. Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.  
  
 Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind. In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden. Der richtige Code hierfür lautet wie folgt:  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei Teil Zeichenfolgen mit verschiedenen Kulturen verglichen und die Groß-/Kleinschreibung der Teil Zeichenfolgen ignoriert. Die Auswahl der Kultur wirkt sich darauf aus, wie der Buchstabe "I" verglichen wird.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- oder - 
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- oder - 
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
- oder - 
Entweder <paramref name="strA" /> oder <paramref name="strB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> -Methode berücksichtigt diese Zeichen nicht, wenn Sie einen linguistischen oder Kultur abhängigen Vergleich durchführt. Um Ignorable-Zeichen im Vergleich zu erkennen, müssen <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Sie die-Methode aufrufen und <see cref="F:System.Globalization.CompareOptions.Ordinal" /> den <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> Wert oder <paramref name="options" /> für den-Parameter angeben.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Anfangsposition der Teilzeichenfolge innerhalb des <paramref name="strA" />-Parameters.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Anfangsposition der Teilzeichenfolge innerhalb des <paramref name="strB" />-Parameters.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <param name="culture">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</param>
        <param name="options">Die beim Ausführen des Vergleichs zu verwendenden Optionen (z. B. Ignorieren von Groß- und Kleinschreibung oder Symbolen).</param>
        <summary>Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten mit den festgelegten Vergleichsoptionen und kulturspezifischen Informationen, die den Vergleich beeinflussen, und gibt eine ganze Zahl zurück, die die Beziehung der beiden Teilzeichenfolgen zueinander in der Sortierreihenfolge angibt.</summary>
        <returns>Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Teilzeichenfolgen angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.  
  
 </description></item><item><term> Zero 
 </term><description> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <paramref name="length" /> ist 0 (null).  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Teil Zeichenfolgen, die `strA` in der `indexA` Position und `strB` in an `indexB`der Position verglichen werden sollen. Die Länge der ersten Teil Zeichenfolge ist die Länge `strA` von `indexA`minus. Die Länge der zweiten Teil Zeichenfolge ist die Länge `strB` von `indexB`minus.  
  
 Die Anzahl der zu vergleichenden Zeichen ist geringer als die Länge der beiden Teil Zeichenfolgen, `length`und. Die `indexA`Parameter `indexB`, und`length` dürfen nicht negativ sein.  
  
 Der-Vergleich verwendet `culture` den-Parameter, um kulturspezifische Informationen zu erhalten, z. b. Regeln für die Groß-und Kleinschreibung von einzelnen Zeichen. Beispielsweise könnte eine bestimmte Kultur angeben, dass bestimmte Kombinationen von Zeichen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vor oder folgen Sie diesem.  
  
> [!CAUTION]
>  Die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> -Methode ist hauptsächlich für die Verwendung in Sortier-oder Alphabetisierungs Vorgängen vorgesehen. Er sollte nicht verwendet werden, wenn der primäre Zweck des Methoden Aufrufes ist, zu bestimmen, ob zwei Teil Zeichenfolgen äquivalent sind (d. h., wenn der Zweck des Methoden Aufrufes ist, auf einen Rückgabewert von NULL zu testen). Um zu ermitteln, ob zwei Zeichen folgen äquivalent sind <xref:System.String.Equals%2A> , müssen Sie die-Methode aufruft.  
  
 Eine oder beide von `strA` und `strB` können sein `null`. Definitionsgemäß vergleichen eine beliebige Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithType>, einschließlich, einen Vergleich von einem NULL-Verweis und zwei NULL-Verweise gleich einander.  
  
 Der Vergleich kann weiter durch den `options` -Parameter angegeben werden, der aus einem oder mehreren Membern <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> der-Enumeration besteht. Da der Zweck dieser Methode jedoch darin besteht, einen Kultur abhängigen Zeichen folgen Vergleich durchzuführen, haben <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> die <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> Werte und keine Auswirkung.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Teil Zeichenfolgen verglichen wurden. Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet. Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> -Methode verwendet, um die Nachnamen von zwei Personen zu vergleichen. Anschließend werden Sie in alphabetischer Reihenfolge aufgelistet.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> ist kein <see cref="T:System.Globalization.CompareOptions" />-Wert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see langword=".Length" />.  
  
- oder - 
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see langword=".Length" />.  
  
- oder - 
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
- oder - 
Entweder <paramref name="strA" /> oder <paramref name="strB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> -Methode berücksichtigt diese Zeichen nicht, wenn Sie einen linguistischen oder Kultur abhängigen Vergleich durchführt. Um Ignorable-Zeichen im Vergleich zu erkennen, geben Sie den <see cref="F:System.Globalization.CompareOptions.Ordinal" /> Wert <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> oder für <paramref name="options" /> den-Parameter an.</para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht zwei <see cref="T:System.String" />-Objekte, indem die numerischen Werte der entsprechenden <see cref="T:System.Char" />-Objekte in den Zeichenfolgen ausgewertet werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <summary>Vergleicht zwei <see cref="T:System.String" />-Objekte, indem die numerischen Werte der entsprechenden <see cref="T:System.Char" />-Objekte in den Zeichenfolgen ausgewertet werden.</summary>
        <returns>Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Vergleichswerten angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="strA" /> ist kleiner als <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> und <paramref name="strB" /> sind gleich.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="strA" /> ist größer als <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Vergleich unter Berücksichtigung von ordinalsortierungs Regeln durch. Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>finden Sie unter. Um einen Vergleich ohne Beachtung der Groß-/Kleinschreibung mithilfe von ordinalsortierungs Regeln `comparisonType` durchzuführen, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>müssen Sie die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode mit dem-Argument  
  
 Da <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> eine statische Methode ist, `strA` kann `strB` und sein `null`. Wenn beide Werte sind `null`, gibt die Methode 0 (null) zurück, was darauf `strA` hinweist `strB` , dass und gleich sind. Wenn nur einer der-Werte ist `null`, betrachtet die Methode den Wert ungleich NULL als größer.  
  
   
  
## Examples  
 Das folgende Beispiel führt einen Ordinalvergleich zweier Zeichen folgen durch, die sich nur in Groß-/Kleinschreibung unterscheiden  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Der Anfangsindex der Teilzeichenfolge in <paramref name="strA" />.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Der Anfangsindex der Teilzeichenfolge in <paramref name="strB" />.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <summary>Vergleicht Teilzeichenfolgen zweier angegebener <see cref="T:System.String" />-Objekte, indem die numerischen Werte der entsprechenden <see cref="T:System.Char" />-Objekte in den Teilzeichenfolgen ausgewertet werden.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist kleiner als die Teilzeichenfolge in <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description> Die Teilzeichenfolgen sind gleich, oder <paramref name="length" /> ist 0.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist größer als die Teilzeichenfolge in <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `indexA`Parameter `indexB`, und`length` dürfen nicht negativ sein.  
  
 Die Anzahl der verglichenen Zeichen ist kleiner als die Länge `strA` von `indexA`Less, die Länge `strB` von `indexB`less und `length`.  
  
 Diese Methode führt einen Vergleich unter Berücksichtigung von ordinalsortierungs Regeln durch. Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>finden Sie unter. Um einen Vergleich ohne Beachtung der Groß-/Kleinschreibung mithilfe von ordinalsortierungs Regeln `comparisonType` durchzuführen, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>müssen Sie die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> -Methode mit dem-Argument  
  
 Da <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> eine statische Methode ist, `strA` kann `strB` und sein `null`. Wenn beide Werte sind `null`, gibt die Methode 0 (null) zurück, was darauf `strA` hinweist `strB` , dass und gleich sind. Wenn nur einer der-Werte ist `null`, betrachtet die Methode den Wert ungleich NULL als größer.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht <xref:System.String.CompareOrdinal%2A> , <xref:System.String.Compare%2A> dass und verschiedene Sortier Reihenfolgen verwenden.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strA" /> ist nicht <see langword="null" /> und <paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- oder - 
 <paramref name="strB" /> ist nicht <see langword="null" /> und <paramref name="indexB" /> ist größer als <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
- oder - 
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt oder <see cref="T:System.String" /> und gibt eine ganze Zahl zurück, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene Objekt oder <see cref="T:System.String" /> aufgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beide über Ladungen der- <xref:System.String.CompareTo%2A> Methode führen Kultur abhängige Vergleiche mit Unterscheidung nach Groß-/Kleinschreibung durch. Sie können diese Methode nicht verwenden, um Kultur unabhängige oder ordinale Vergleiche auszuführen. Aus Gründen der Übersichtlichkeit des Codes wird empfohlen <xref:System.String.CompareTo%2A> , die-Methode <xref:System.String.Compare%2A> zu vermeiden und stattdessen die-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Ein Objekt, das als <see cref="T:System.String" /> ausgewertet wird.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen <see cref="T:System.Object" /> und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene <see cref="T:System.Object" /> aufgeführt wird.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie der <paramref name="value" />-Parameter aufgeführt wird.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz geht <paramref name="value" /> voran.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz hat in der Sortierreihenfolge dieselbe Position wie <paramref name="value" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Diese Instanz folgt <paramref name="value" />.  
  
- oder - 
 <paramref name="value" /> ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`muss ein <xref:System.String> -Objekt sein.  
  
> [!CAUTION]
>  Die <xref:System.String.CompareTo%2A> -Methode wurde primär für die Verwendung in Sortier-oder alphabetisierungsvorgängen entwickelt. Er sollte nicht verwendet werden, wenn der primäre Zweck des Methoden Aufrufes ist, zu bestimmen, ob zwei Zeichen folgen äquivalent sind. Um zu ermitteln, ob zwei Zeichen folgen äquivalent sind <xref:System.String.Equals%2A> , müssen Sie die-Methode aufruft.  
  
 Diese Methode führt einen Vergleich mit der aktuellen Kultur durch (Unterscheidung nach Groß-/Kleinschreibung und Kultur sensitiv). Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>finden Sie unter.  
  
 Weitere Informationen zum Verhalten dieser Methode finden Sie im Abschnitt "Hinweise" der <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> -Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.CompareTo%2A> -Methode mit <xref:System.Object>einer verwendet. Da versucht wird, eine <xref:System.String> -Instanz mit einem `TestClass` -Objekt zu vergleichen, löst die Methode eine <xref:System.ArgumentException>aus.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> ist keine <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.CompareTo(System.Object)" /> -Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt. Wenn z. b. der folgende Code in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, gibt ein Vergleich von "Animal" mit "Ani-mal" (mit einem weichen Bindestrich oder U + 00ad) an, dass die beiden Zeichen folgen äquivalent sind.  
  
[! Code-csharp[System. String. CompareTo # 1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [! Code-vb[System. String. CompareTo # 1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
Um Ignorable-Zeichen in einem Zeichen folgen Vergleich zu erkennen <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> , wird die-Methode aufgerufen.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen <see cref="T:System.String" />-Objekt und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie die angegebene Zeichenfolge aufgeführt wird.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie der <paramref name="strB" />-Parameter aufgeführt wird.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz geht <paramref name="strB" /> voran.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz hat in der Sortierreihenfolge dieselbe Position wie <paramref name="strB" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Diese Instanz folgt <paramref name="strB" />.  
  
- oder - 
 <paramref name="strB" /> ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Vergleich mit der aktuellen Kultur durch (Unterscheidung nach Groß-/Kleinschreibung und Kultur sensitiv). Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>finden Sie unter.  
  
> [!CAUTION]
>  Die <xref:System.String.CompareTo%2A> -Methode wurde primär für die Verwendung in Sortier-oder alphabetisierungsvorgängen entwickelt. Er sollte nicht verwendet werden, wenn der primäre Zweck des Methoden Aufrufes ist, zu bestimmen, ob zwei Zeichen folgen äquivalent sind. Um zu ermitteln, ob zwei Zeichen folgen äquivalent sind <xref:System.String.Equals%2A> , müssen Sie die-Methode aufruft.  
  
 Weitere Informationen zum Verhalten dieser Methode finden Sie im Abschnitt "Hinweise" der <xref:System.String.Compare%28System.String%2CSystem.String%29> -Methode.  
  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> -Schnittstelle und führt eine etwas <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> bessere Leistung als die-Methode aus, da Sie nicht `strB` bestimmen muss, ob das Argument ein änderbarer Werttyp ist, der geschachtelt werden muss, und seine -Parameter von <xref:System.Object> einem- <xref:System.String>zu einem-.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.CompareTo%2A> -Methode verwendet, um die aktuelle Zeichen folgen Instanz mit einer anderen Zeichenfolge zu vergleichen.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 Im folgenden Beispiel werden generische und nicht generische Versionen der CompareTo-Methode für verschiedene Wert-und Verweis Typen veranschaulicht.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.CompareTo(System.String)" /> -Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt. Wenn z. b. der folgende Code in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, gibt ein Vergleich von "Animal" mit "Ani-mal" (mit einem weichen Bindestrich oder U + 00ad) an, dass die beiden Zeichen folgen äquivalent sind.  
  
[! Code-csharp[System. String. CompareTo # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [! Code-vb[System. String. CompareTo # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
Um Ignorable-Zeichen in einem Zeichen folgen Vergleich zu erkennen <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> , wird die-Methode aufgerufen.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verkettet eine oder mehrere Instanzen von <see cref="T:System.String" /> oder die <see cref="T:System.String" />-Darstellungen der Werte einer oder mehrerer Instanzen von <see cref="T:System.Object" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!NOTE]
>  Sie können auch den Zeichen folgen Verkettungs Operator ihrer Sprache verwenden, z `+` . C#b. `&` in `+` , oder und in Visual Basic, um Zeichen folgen zu verketten. Beide Compiler übersetzen den Verkettungs Operator in einen-aufruber einer der über Ladungen `String.Concat`von. 

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values">Ein Auflistungsobjekt, das <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementiert und dessen generisches Typargument <see cref="T:System.String" /> ist.</param>
        <summary>Verkettet die Member einer erstellten <see cref="T:System.Collections.Generic.IEnumerable`1" />-Auflistung vom Typ <see cref="T:System.String" />.</summary>
        <returns>Die verketteten Zeichenfolgen in <paramref name="values" /> oder <see cref="F:System.String.Empty" />, wenn <paramref name="values" /> ein leeres <see langword="IEnumerable(Of String)" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die-Methode verkettet jedes Objekt in `values`. es fügt keine Trennzeichen hinzu. Um ein Trennzeichen zwischen den einzelnen Membern von `values`anzugeben, wird <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> die-Methode aufgerufen.  
  
 Eine <xref:System.String.Empty> Zeichenfolge wird anstelle eines beliebigen null-Elements in `values`verwendet.  
  
 Wenn `values` ein leeres `IEnumerable(Of String)`ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurückgegeben. Wenn `values` <xref:System.ArgumentNullException> ist `null`, löst die Methode eine Ausnahme aus.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>ist eine Hilfsmethode, mit der Sie jedes Element in einer `IEnumerable(Of String)` Auflistung verketten können, ohne zuvor die Elemente in ein Zeichen folgen Array umzuwandeln. Dies ist besonders nützlich bei LINQ-Abfrage Ausdrücken (Language-Integrated Query). Im folgenden Beispiel wird ein `List(Of String)` -Objekt, das entweder die Groß-oder Kleinbuchstaben des Alphabets enthält, an einen Lambda-Ausdruck weitergeleitet, der Buchstaben auswählt, die gleich oder größer als ein bestimmter Buchstabe (im Beispiel "M") sind. Die `IEnumerable(Of String)` Auflistung, die von der <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> -Methode zurückgegeben wird, <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> wird an die-Methode übermittelt, um das Ergebnis als eine einzelne Zeichenfolge anzuzeigen.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Sieb des Eratosthenes-Algorithmus zum Berechnen der Primzahlen, die kleiner oder gleich 100 sind, verwendet. Das Ergebnis wird einem <xref:System.Collections.Generic.List%601> -Objekt vom Typ <xref:System.String>zugewiesen, das dann an die <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> -Methode weitergeleitet wird.  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Das darzustellende Objekt oder <see langword="null" />.</param>
        <summary>Erstellt die Zeichenfolgendarstellung eines angegebenen Objekts.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts von <paramref name="arg0" /> oder <see cref="F:System.String.Empty" />, wenn <paramref name="arg0" /> <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Concat%28System.Object%29> -Methode `arg0` stellt eine Zeichenfolge dar, indem Sie die `ToString` Parameter lose-Methode aufrufen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Concat%2A> Methode.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Ein Objektarray, das die zu verkettenden Elemente enthält.</param>
        <summary>Verkettet die Zeichenfolgendarstellungen der Elemente in einem angegebenen <see cref="T:System.Object" />-Array.</summary>
        <returns>Die verketteten Zeichenfolgendarstellungen der Werte der Elemente in <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die-Methode verkettet jedes Objekt in `args` , indem die Parameter lose `ToString` -Methode dieses Objekts aufgerufen wird. es fügt keine Trennzeichen hinzu.  
  
 <xref:System.String.Empty?displayProperty=nameWithType>wird anstelle eines NULL-Objekts im-Array verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung <xref:System.String.Concat%2A> der-Methode mit einem <xref:System.Object> -Array.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Nicht genügend Arbeitsspeicher.</exception>
        <block subset="none" type="usage"><para>Diese Methode wird nicht von C++ Code aufgerufen. Der C++ Compiler löst Aufrufe von <see cref="Overload:System.String.Concat" /> auf, die vier oder mehr Objekt Parameter als Aufruf von <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />haben.</para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Ein Array von Zeichenfolgeninstanzen.</param>
        <summary>Verkettet die Elemente eines angegebenen <see cref="T:System.String" />-Arrays.</summary>
        <returns>Die verketteten Elemente von <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die-Methode verkettet jedes Objekt in `values`. es fügt keine Trennzeichen hinzu.  
  
 Anstelle <xref:System.String.Empty> von Null-Objekten im Array wird eine Zeichenfolge verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung <xref:System.String.Concat%2A> der-Methode mit einem <xref:System.String> -Array.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Nicht genügend Arbeitsspeicher.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Das erste zu verkettende Objekt.</param>
        <param name="arg1">Das zweite zu verkettende Objekt.</param>
        <summary>Verkettet die Zeichenfolgendarstellungen zweier angegebener Objekte.</summary>
        <returns>Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="arg0" /> und <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `arg0` -Methode verkettet und `arg1` durch Aufrufen der Parameter losen `ToString` -Methode von `arg0` und `arg1`. Sie fügt keine Trennzeichen hinzu.  
  
 <xref:System.String.Empty?displayProperty=nameWithType>wird anstelle von NULL-Argumenten verwendet.  
  
 Wenn eines der Argumente ein Array Verweis ist, verkettet die Methode eine Zeichenfolge, die dieses Array anstelle der zugehörigen Member (z. b. "System. String []") darstellt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Concat%2A> Methode.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">Die erste zu verkettende schreibgeschützte Zeichenspanne.</param>
        <param name="str1">Die zweite zu verkettende schreibgeschützte Zeichenspanne.</param>
        <summary>Verkettet die Zeichenfolgendarstellung von zwei angegebenen schreibgeschützten Zeichenspannen.</summary>
        <returns>Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="str0" /> und <paramref name="str1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Die erste zu verkettende Zeichenfolge.</param>
        <param name="str1">Die zweite zu verkettende Zeichenfolge.</param>
        <summary>Verkettet zwei angegebene Instanzen von <see cref="T:System.String" />.</summary>
        <returns>Die Verkettung von <paramref name="str0" /> und <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `str0` -Methode verkettet und `str1`und fügt keine Trennzeichen hinzu.  
  
 Anstelle <xref:System.String.Empty> eines NULL-Arguments wird eine Zeichenfolge verwendet.  
  
## Examples  
 Im folgenden Beispiel werden die ersten, mittleren und Nachnamen einer Person verkettet.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Das erste zu verkettende Objekt.</param>
        <param name="arg1">Das zweite zu verkettende Objekt.</param>
        <param name="arg2">Das dritte zu verkettende Objekt.</param>
        <summary>Verkettet die Zeichenfolgendarstellungen von drei angegebenen Objekten.</summary>
        <returns>Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="arg0" />, <paramref name="arg1" /> und <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die-Methode verkettet `arg0`, `arg1`und, `arg2` indem die Parameter lose `ToString` -Methode der einzelnen-Objekte aufgerufen wird. Sie fügt keine Trennzeichen hinzu.  
  
 <xref:System.String.Empty?displayProperty=nameWithType>wird anstelle von NULL-Argumenten verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Concat%2A> Methode.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">Die erste zu verkettende schreibgeschützte Zeichenspanne.</param>
        <param name="str1">Die zweite zu verkettende schreibgeschützte Zeichenspanne.</param>
        <param name="str2">Die dritte zu verkettende schreibgeschützte Zeichenspanne.</param>
        <summary>Verkettet die Zeichenfolgendarstellung von drei angegebenen schreibgeschützten Zeichenspannen.</summary>
        <returns>Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="str0" />, <paramref name="str1" /> und <paramref name="str2" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Die erste zu verkettende Zeichenfolge.</param>
        <param name="str1">Die zweite zu verkettende Zeichenfolge.</param>
        <param name="str2">Die dritte zu verkettende Zeichenfolge.</param>
        <summary>Verkettet zwei angegebene Instanzen von <see cref="T:System.String" />.</summary>
        <returns>Die Verkettung von <paramref name="str0" />, <paramref name="str1" /> und <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die-Methode verkettet `str0`, `str1`und und `str2`fügt keine Trennzeichen hinzu.  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Concat%2A> -Methode verwendet, um drei Zeichen folgen zu verketten, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">Das erste zu verkettende Objekt.</param>
        <param name="arg1">Das zweite zu verkettende Objekt.</param>
        <param name="arg2">Das dritte zu verkettende Objekt.</param>
        <param name="arg3">Das vierte zu verkettende Objekt.</param>
        <summary>Verkettet die Zeichenfolgenentsprechungen von vier angegebenen Objekten sowie aller in einer optionalen Parameterliste variabler Länger angegebenen Objekte.</summary>
        <returns>Die verkettete Zeichenfolgendarstellung aller Werte in der Parameterliste.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese API ist nicht CLS-kompatibel. Die CLS-kompatible Alternative ist <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. Der C# -und der-Visual Basic Compiler lösen einen aufzurufenden Rückruf dieser Methode <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>automatisch als-Aufrufe von auf.  
  
 Die-Methode verkettet jedes Objekt in der Parameterliste, indem es die Parameter lose `ToString` -Methode aufruft. es fügt keine Trennzeichen hinzu.  
  
 <xref:System.String.Empty?displayProperty=nameWithType>wird anstelle von NULL-Argumenten verwendet.  
  
> [!NOTE]
>  Der letzte Parameter der <xref:System.String.Concat%2A> -Methode ist eine optionale durch Trennzeichen getrennte Liste mit einem oder mehreren zusätzlichen Objekten, die verkettet werden sollen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> -Methode verwendet wird, um eine Liste von Variablen Parametern zu verketten. In diesem Fall wird die-Methode mit neun Parametern aufgerufen.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Diese Methode ist mit dem <see langword="vararg" /> -Schlüsselwort gekennzeichnet, was bedeutet, dass Sie eine Variable Anzahl von Parametern unterstützt. Die-Methode kann aus Visual C++aufgerufen werden, Sie kann jedoch nicht von C# oder Visual Basic Code aufgerufen werden. Der C# -und der-Visual Basic Compiler lösen <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> Aufrufe von als <see cref="M:System.String.Concat(System.Object[])" />Aufrufe von auf.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">Die erste zu verkettende schreibgeschützte Zeichenspanne.</param>
        <param name="str1">Die zweite zu verkettende schreibgeschützte Zeichenspanne.</param>
        <param name="str2">Die dritte zu verkettende schreibgeschützte Zeichenspanne.</param>
        <param name="str3">Die vierte zu verkettende schreibgeschützte Zeichenspanne.</param>
        <summary>Verkettet die Zeichenfolgendarstellung von vier angegebenen schreibgeschützten Zeichenspannen.</summary>
        <returns>Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> und <paramref name="str3" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Die erste zu verkettende Zeichenfolge.</param>
        <param name="str1">Die zweite zu verkettende Zeichenfolge.</param>
        <param name="str2">Die dritte zu verkettende Zeichenfolge.</param>
        <param name="str3">Die vierte zu verkettende Zeichenfolge.</param>
        <summary>Verkettet zwei angegebene Instanzen von <see cref="T:System.String" />.</summary>
        <returns>Die Verkettung von <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> und <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die-Methode verkettet `str0` `str2`, `str1`, und `str3`. Sie fügt keine Trennzeichen hinzu.  
  
## Examples  
 Im folgenden Beispiel wird ein Array aus aus vier Buchstaben bestehenden Wörtern definiert und die einzelnen Buchstaben in einem Zeichen folgen Array gespeichert, um Sie zu verscheinigen. Anschließend wird die <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> -Methode aufgerufen, um die verwornielten Wörter erneut zuzuweisen.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Member von <paramref name="values" />.</typeparam>
        <param name="values">Ein Auflistungsobjekt, das die <see cref="T:System.Collections.Generic.IEnumerable`1" />-Schnittstelle implementiert.</param>
        <summary>Verkettet die Member einer <see cref="T:System.Collections.Generic.IEnumerable`1" />-Implementierung.</summary>
        <returns>Die verketteten Zeichenfolgen in <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die-Methode verkettet jedes Objekt in `values`. es fügt keine Trennzeichen hinzu.  
  
 Anstelle <xref:System.String.Empty> eines NULL-Arguments wird eine Zeichenfolge verwendet.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>ist eine Hilfsmethode, mit der Sie jedes Element in einer <xref:System.Collections.Generic.IEnumerable%601> Auflistung verketten können, ohne dass die Elemente zuvor in Zeichen folgen umgerechnet werden. Dies ist besonders nützlich mit LINQ-Abfrage Ausdrücken (Language-Integrated Query), wie im Beispiel veranschaulicht. Die Zeichen folgen Darstellung der einzelnen Objekte in <xref:System.Collections.Generic.IEnumerable%601> der Auflistung wird durch Aufrufen der- `ToString` Methode dieses Objekts abgeleitet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sehr einfache `Animal` Klasse definiert, die den Namen eines Tieres und die Reihenfolge enthält, zu der er gehört. Anschließend wird ein <xref:System.Collections.Generic.List%601> -Objekt definiert, das eine Reihe `Animal` von-Objekten enthalten soll. Die <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> -Erweiterungsmethode wird aufgerufen, um `Animal` die Objekte `Order` zu extrahieren, deren-Eigenschaft "Rodent" entspricht. Das Ergebnis wird an die <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> -Methode übermittelt und in der Konsole angezeigt.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Das zu suchende Zeichen.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebenes Zeichen in dieser Zeichenfolge vorkommt.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter innerhalb dieser Zeichenfolge auftritt, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine angegebene untergeordnete Zeichenfolge in dieser Zeichenfolge vorkommt.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter in dieser Zeichenfolge vorkommt oder <paramref name="value" /> eine leere Zeichenfolge ("") ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung und Kultur unabhängige) aus. Die Suche beginnt an der ersten Zeichenposition dieser Zeichenfolge und wird mit der letzten Zeichenposition fortgesetzt.  
  
 Sie können eine benutzerdefinierte Methode erstellen, um zu bestimmen, ob eine Zeichenfolge eine angegebene Teil Zeichenfolge enthält, die einen anderen als einen Ordinalvergleich verwendet (z. b. einen Kultur abhängigen Vergleich oder einen ordinalen Vergleich). Im folgenden Beispiel wird ein solcher Ansatz veranschaulicht. Es definiert eine <xref:System.String> Erweiterungsmethode, die einen <xref:System.StringComparison> -Parameter enthält und angibt, ob eine Zeichenfolge eine Teil Zeichenfolge enthält, wenn die angegebene Form des Zeichen folgen Vergleichs verwendet wird.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 Im folgenden Beispiel wird dann die `Contains` -Erweiterungsmethode aufgerufen, um zu bestimmen, ob eine Teil Zeichenfolge in einer Zeichenfolge gefunden wird, wenn Ordinalvergleich verwendet wird und die Groß-/Kleinschreibung nicht beachtet  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Wenn Sie an der Position der Teil Zeichenfolge `value` in der aktuellen Instanz interessiert sind, können Sie die <xref:System.String.IndexOf%2A> -Methode aufzurufen, um die Anfangsposition des ersten Vorkommens abzurufen, oder Sie können die <xref:System.String.LastIndexOf%2A> -Methode aufzurufen, um die Anfangsposition des Letztes vorkommen. Das Beispiel enthält einen aufzurufenden- <xref:System.String.IndexOf%28System.String%29> Methode, wenn eine Teil Zeichenfolge in einer Zeichen folgen Instanz gefunden wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob die Zeichenfolge "Fox" eine Teil Zeichenfolge eines vertrauten Angebots ist. Wenn "Fox" in der Zeichenfolge gefunden wird, wird auch die Startposition angezeigt.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Das zu suchende Zeichen.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</param>
        <summary>Gibt mithilfe der festgelegten Vergleichsregeln einen Wert zurück, der angibt, ob ein angegebenes Zeichen innerhalb der Zeichenfolge auftritt.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter innerhalb dieser Zeichenfolge auftritt, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</param>
        <summary>Gibt mithilfe der festgelegten Vergleichsregeln einen Wert zurück, der angibt, ob eine angegebene Zeichenfolge innerhalb der Zeichenfolge auftritt.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter in dieser Zeichenfolge vorkommt oder <paramref name="value" /> eine leere Zeichenfolge ("") ist; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">Die zu kopierende Zeichenfolge.</param>
        <summary>Erstellt eine neue Instanz von <see cref="T:System.String" /> mit demselben Wert wie eine angegebene Instanz von <see cref="T:System.String" />.</summary>
        <returns>Eine neue Zeichenfolge mit demselben Wert wie <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Die `Copy` -Methode gibt <xref:System.String> ein-Objekt zurück, das denselben Wert wie die ursprüngliche Zeichenfolge aufweist, aber einen anderen Objekt Verweis darstellt. Dies unterscheidet sich von einer Zuweisungs Operation, bei der einer zusätzlichen Objektvariablen ein vorhandener Zeichen folgen Verweis zugewiesen wird.

> [!IMPORTANT]
>  Ab .net Core 3,0 ist diese Methode veraltet. Es wird jedoch nicht empfohlen, die Verwendung in einer .NET-Implementierung zu verwenden. Insbesondere aufgrund von Änderungen in der Zeichen folgen Internalisierung in .net Core 3,0 wird in einigen Fällen die `Copy` -Methode keine neue Zeichenfolge erstellen, sondern lediglich einen Verweis auf eine vorhandene Internpool vorhanden-Zeichenfolge zurückgeben.   

Abhängig davon, warum die `Copy` -Methode aufgerufen werden soll, gibt es eine Reihe von Alternativen:

- Wenn eine andere Zeichen folgen Instanz in einem Vorgang verwendet werden soll, der die Zeichenfolge ändert, verwenden Sie die ursprüngliche Zeichen folgen Instanz. Da Zeichen folgen unveränderlich sind, wird durch den Zeichen folgen Vorgang eine neue Zeichen folgen Instanz erstellt, und die ursprüngliche Zeichenfolge bleibt unverändert. In diesem Fall sollten Sie den neuen Zeichen folgen Verweis nicht der ursprünglichen Zeichen folgen Variablen zuweisen. Dies wird im folgenden Beispiel veranschaulicht.

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#1)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#1)]  
  
   Wenn in diesem Fall die `Copy` -Methode aufgerufen wird, um eine neue Zeichenfolge vor dem Aufrufen der <xref:System.String.Substring%2A> -Methode zu erstellen, wird eine neue Zeichen folgen Instanz erstellt. 

- Wenn Sie einen änderbaren Puffer mit dem gleichen Inhalt wie die ursprüngliche Zeichenfolge erstellen möchten, rufen Sie <xref:System.String.ToCharArray%2A?displayProperty=nameWithType> den <xref:System.Text.StringBuilder.%23ctor(System.String)?displayProperty=nameWithType> -Konstruktor oder den-Konstruktor auf. Beispiel:

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#2)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#2)]  

- Wenn Sie eine änderbare Kopie der Zeichenfolge erstellen möchten, sodass Sie unsicheren Code verwenden können, um den Inhalt der Zeichenfolge zu <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> ändern, verwenden Sie die-Methode. Im folgenden Beispiel wird die <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> -Methode verwendet, um einen Zeiger auf den Speicherort einer kopierten Zeichenfolge im nicht verwalteten Speicher zu erhalten, den Unicode-Codepunkt jedes Zeichens in der Zeichenfolge um eins zu erhöhen und die resultierende Zeichenfolge zurück in eine verwaltete Zeichenfolge zu kopieren.

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Der Index des ersten Zeichens in dieser Instanz, das kopiert werden soll.</param>
        <param name="destination">Ein Array von Unicode-Zeichen, in das Zeichen in dieser Instanz kopiert werden.</param>
        <param name="destinationIndex">Der Index in <paramref name="destination" />, bei dem der Kopiervorgang beginnt.</param>
        <param name="count">Die Anzahl der Zeichen in dieser Instanz, die nach <paramref name="destination" /> kopiert werden sollen.</param>
        <summary>Kopiert eine angegebene Anzahl von Zeichen von einer angegebenen Position in dieser Instanz an eine angegebene Position in einem Array von Unicode-Zeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert `count` Zeichen von der `sourceIndex` Position dieser Instanz an die `destinationIndex` Position des `destination` Zeichen Arrays. Diese Methode ändert nicht die Größe des `destination` Zeichen Arrays. Sie muss über eine ausreichende Anzahl von Elementen verfügen, um die kopierten Zeichen aufnehmen zu können <xref:System.ArgumentOutOfRangeException>, oder die Methode löst eine aus.  
  
 `sourceIndex`und `destinationIndex` sind NULL basiert.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.CopyTo%2A> Methode.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" /> oder <paramref name="count" /> ist ein negativer Wert. 
- oder - 
 <paramref name="sourceIndex" /> identifiziert keine Position in der aktuellen Instanz.  
  
- oder - 
 <paramref name="destinationIndex" /> identifiziert keinen gültigen Index im <paramref name="destination" />-Array.  
  
- oder - 
 <paramref name="count" /> ist größer als die Länge der Teilzeichenfolge von <paramref name="sourceIndex" /> bis zum Ende dieser Instanz 
- oder - 
 <paramref name="count" /> ist größer als die Länge des Teilarrays von <paramref name="destinationIndex" /> bis zum Ende des <paramref name="destination" /> -Arrays.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt die leere Zeichenfolge dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieses Felds ist die Zeichenfolge mit der Länge 0 (null).  
  
 Im Anwendungscode wird dieses Feld am häufigsten in Zuweisungen verwendet, um eine Zeichen folgen Variable in eine leere Zeichenfolge zu initialisieren. Verwenden Sie die `null` <xref:System.String.Empty?displayProperty=nameWithType> -Methode,umzutesten,obderWerteinerZeichenfolge<xref:System.String.IsNullOrEmpty%2A> entweder oder ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob das Ende dieser Zeichenfolgeninstanz mit einer angegebenen Zeichenfolge übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob das Ende dieser Zeichenfolgeninstanz mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns><see langword="true" />, wenn <paramref name="value" /> mit dem Ende dieser Instanz übereinstimmt; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht `value` mit der Teil Zeichenfolge am Ende dieser Instanz, die dieselbe Länge wie `value`hat, und gibt eine Angabe darüber zurück, ob Sie gleich sind. Muss gleich sein, `value` muss ein Verweis auf dieselbe Instanz sein oder mit dem Ende dieser Instanz übereinstimmen.  
  
 Diese Methode führt einen Vergleich mit der aktuellen Kultur durch (Unterscheidung nach Groß-/Kleinschreibung und Kultur sensitiv).  
  
   
  
## Examples  
 Im folgenden Beispiel wird angegeben, ob jede Zeichenfolge in einem Array mit einem-Zeitraum (".") endet.  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 Im folgenden Beispiel wird eine `StripEndTags` -Methode definiert, <xref:System.String.EndsWith%28System.String%29> die die-Methode verwendet, um HTML-Endtags vom Ende einer Zeile zu entfernen. Beachten Sie, `StripEndTags` dass die-Methode rekursiv aufgerufen wird, um sicherzustellen, dass mehrere HTML-Endtags am Ende der Zeile entfernt werden.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen. Um zu ermitteln, ob eine Zeichenfolge mit einer bestimmten Teil Zeichenfolge endet, indem die Regeln <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> <see cref="F:System.StringComparison.CurrentCulture" /> für den Zeichen folgen Vergleich der aktuellen Kultur verwendet werden, müssen <paramref name="comparisonType" /> Sie die-Methoden Überladung mit dem Wert für den Parameter aufrufen</para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</param>
        <param name="comparisonType">Einer der Enumerationswerte, die bestimmen, wie diese Zeichenfolge und <paramref name="value" /> verglichen werden.</param>
        <summary>Bestimmt, ob das Ende dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Vergleichsoption mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter mit dem Ende dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.EndsWith%2A> -Methode vergleicht `value` den-Parameter mit der Teil Zeichenfolge am Ende dieser Zeichenfolge und gibt einen Wert zurück, der angibt, ob Sie gleich sind. Muss gleich sein, `value` muss ein Verweis auf dieselbe Zeichenfolge sein, muss eine leere Zeichenfolge ("") sein oder mit dem Ende dieser Zeichenfolge übereinstimmen. Der Typ des Vergleichs, der von <xref:System.String.EndsWith%2A> der-Methode ausgeführt wird, hängt `comparisonType` vom Wert des-Parameters ab.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge mit einer bestimmten Teil Zeichenfolge endet. Die Ergebnisse sind von der Auswahl der Kultur betroffen, unabhängig davon, ob die Groß-/Kleinschreibung ignoriert wird und ob ein Ordinalvergleich durchgeführt wird.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</param>
        <param name="ignoreCase"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <param name="culture">Kulturinformationen, die bestimmen, wie diese Instanz und <paramref name="value" /> verglichen werden. Wenn <paramref name="culture" /> <see langword="null" /> ist, wird die aktuelle Kultur verwendet.</param>
        <summary>Bestimmt, ob das Ende dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Kultur mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter mit dem Ende dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht den `value` -Parameter mit der Teil Zeichenfolge am Ende dieser Zeichenfolge, die dieselbe Länge `value`wie hat, und gibt einen Wert zurück, der angibt, ob Sie gleich sind. Muss gleich sein, `value` muss ein Verweis auf dieselbe Instanz sein oder mit dem Ende dieser Zeichenfolge übereinstimmen.  
  
 Diese Methode führt einen (Kultur abhängigen) Wort Vergleich unter Verwendung der angegebenen Groß-und Kleinschreibung aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge am Ende einer anderen Zeichenfolge auftritt. Die <xref:System.String.EndsWith%2A> -Methode wird mehrmals unter Berücksichtigung der Groß-/Kleinschreibung, Unterscheidung nach Groß-/Kleinschreibung und verschiedener Kulturen aufgerufen, die die Ergebnisse der Suche beeinflussen.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Enumeration von <see cref="T:System.Text.Rune" /> aus der Zeichenfolge zurück.</summary>
        <returns>Ein Rune-Zeichenfolgenenumerator.</returns>
        <remarks>
          <format type="text/markdown">
        

### Remarks

Ungültige Sequenzen werden in der-Enumeration <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>durch dargestellt.

               </format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob zwei <see cref="T:System.String" />-Objekte denselben Wert haben.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob diese Instanz und ein angegebenes Objekt, das ebenfalls ein <see cref="T:System.String" />-Objekt sein muss, denselben Wert haben.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> ein <see cref="T:System.String" /> ist und denselben Wert wie diese Instanz hat; andernfalls <see langword="false" />.  Wenn <paramref name="obj" /> gleich <see langword="null" /> ist, gibt die Methode <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung und Kultur unabhängige) aus.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Equals%2A> Methode.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob diese Instanz und ein anderes angegebenes <see cref="T:System.String" />-Objekt denselben Wert haben.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter und diese Instanz denselben Wert haben, andernfalls <see langword="false" />. Wenn <paramref name="value" /> gleich <see langword="null" /> ist, gibt die Methode <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung und Kultur unabhängige) aus.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Equals%2A> Methode. Dabei wird das Wort "file" mit dem Titel "file" mit einem äquivalenten Wort, der Entsprechung in Kleinbuchstaben, der Entsprechung in Großbuchstaben und einem Wort, das lateinische Small Letter DOTLESS i (u + 0131) anstelle von Latin Small Letter i (u + 0069) enthält. Da die <xref:System.String.Equals%28System.String%29> Methode einen Ordinalvergleich ausführt, gibt nur der Vergleich mit einem identischen Wort `true`zurück.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="b">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene <see cref="T:System.String" />-Objekte denselben Wert haben.</summary>
        <returns><see langword="true" />, wenn <paramref name="a" /> und <paramref name="b" /> denselben Wert haben, andernfalls <see langword="false" />. Wenn <paramref name="a" /> und <paramref name="b" /> <see langword="null" /> sind, gibt diese Methode <see langword="true" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung und Kultur unabhängige) aus.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Equals%2A> Methode.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</param>
        <param name="comparisonType">Einer der Enumerationswerte, die angeben, wie die Zeichenfolgen verglichen werden.</param>
        <summary>Bestimmt, ob diese Zeichenfolge und ein angegebenes <see cref="T:System.String" />-Objekt denselben Wert haben. Ein Parameter gibt die Kultur, Berücksichtigung von Groß- und Kleinschreibung und Sortierregeln, die für den Vergleich verwendet werden.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter und diese Zeichenfolge denselben Wert haben; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `comparisonType` -Parameter gibt an, ob der Vergleich die aktuelle oder die invariante Kultur verwenden soll, die Groß-/Kleinschreibung der beiden zu vergleichenden Zeichen folgen berücksichtigt oder ignoriert oder ob Wort-oder ordinalsortier Regeln verwendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Zeichen folgen Array erstellt, das aus einem Großbuchstaben "i", einem Kleinbuchstaben "i" und einem DOTLESS-"ı" besteht. Anschließend wird die <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> -Methode aufgerufen, um Sie mit jedem möglichen <xref:System.StringComparison> Enumerationswert zu vergleichen.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 Im folgenden Beispiel werden vier Sätze von Wörtern mit jedem Member der <xref:System.StringComparison> -Enumeration verglichen.  Die Vergleiche verwenden die Konventionen der Kulturen Englisch (USA) und Sami (Upper Sweden). Beachten Sie, dass die Zeichen folgen "enzyklopäædia" und "Enzyklopädie" in der Kultur "en-US", aber nicht in der Kultur "Sami (Nordschweden)" gleichwertig betrachtet werden.  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="b">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für den Vergleich angibt.</param>
        <summary>Bestimmt, ob zwei angegebene <see cref="T:System.String" />-Objekte denselben Wert haben. Ein Parameter gibt die Kultur, Berücksichtigung von Groß- und Kleinschreibung und Sortierregeln, die für den Vergleich verwendet werden.</summary>
        <returns><see langword="true" />, wenn der Wert des <paramref name="a" />-Parameters dem Wert des <paramref name="b" />-Parameters entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `comparisonType` -Parameter gibt an, ob der Vergleich die aktuelle oder die invariante Kultur verwenden soll, die Groß-/Kleinschreibung der beiden zu vergleichenden Zeichen folgen berücksichtigt oder ignoriert oder ob Wort-oder ordinalsortier Regeln verwendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel werden vier Sätze von Wörtern mit jedem Member der <xref:System.StringComparison> -Enumeration verglichen.  Die Vergleiche verwenden die Konventionen der Kulturen Englisch (USA) und Sami (Upper Sweden). Beachten Sie, dass die Zeichen folgen "enzyklopäædia" und "Enzyklopädie" in der Kultur "en-US", aber nicht in der Kultur "Sami (Nordschweden)" gleichwertig betrachtet werden.  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert auf der Grundlage der angegebenen Formate den Wert von Objekten in Zeichenfolgen und fügt sie in eine andere Zeichenfolge ein.  
  
Wenn Sie die `String.Format`-Methode noch nicht kennen, lesen Sie den Abschnitt zur [String.Format-Methode](#Starting), um sich einen Überblick zu verschaffen.  
  
Eine allgemeine Dokumentation zur `String.Format`-Methode finden Sie im Abschnitt [Hinweise](#remarks-top).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 In diesem Abschnitt  
  
 [Beginnen Sie mit der String. Format-Methode](#Starting)   
 [Welche Methode rufe ich auf?](#FTaskList)   
 [Die Format-Methode kurz](#Format_Brief)   
 [Das Format Element](#FormatItem)   
 [Formatieren von Argumenten](#HowFormatted)   
 [Formatieren von Elementen mit demselben Index](#SameIndex)   
 [Formatierung und Kultur](#Format_Culture)   
 [Benutzerdefinierte Formatierungs Vorgänge](#Format_Custom)   
 [String. Format Q & A](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>Beginnen Sie mit der String. Format-Methode  
 Verwenden <xref:System.String.Format%2A?displayProperty=nameWithType> Sie, wenn Sie den Wert eines Objekts, einer Variablen oder eines Ausdrucks in eine andere Zeichenfolge einfügen müssen. Beispielsweise können Sie den Wert eines <xref:System.Decimal> Werts in eine Zeichenfolge einfügen, um Sie dem Benutzer als einzelne Zeichenfolge anzuzeigen:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 Und Sie können die Formatierung dieses Werts Steuern:  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Neben der Formatierung können Sie auch die Ausrichtung und den Abstand steuern.  
  
 ### <a name="inserting-a-string"></a>Einfügen einer Zeichenfolge  

 <xref:System.String.Format%2A?displayProperty=nameWithType>beginnt mit einer Format Zeichenfolge, gefolgt von einem oder mehreren-Objekten oder-Ausdrücken, die in Zeichen folgen konvertiert und an einer bestimmten Stelle in der Format Zeichenfolge eingefügt werden. Beispiel:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 Der `{0}` in der Format Zeichenfolge ist ein Format Element. `0`der Index des Objekts, dessen Zeichen folgen Wert an dieser Position eingefügt wird. (Indizes beginnen bei 0.) Wenn das einzufügende Objekt keine Zeichenfolge ist, wird `ToString` die zugehörige-Methode aufgerufen, um Sie in eine zu konvertieren, bevor Sie in die Ergebnis Zeichenfolge eingefügt wird.  
  
 Im folgenden finden Sie ein weiteres Beispiel, in dem zwei Format Elemente und zwei-Objekte in der Objektliste verwendet werden:  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 Sie können beliebig viele Format Elemente und beliebig viele Objekte in der Objektliste enthalten, solange der Index jedes Format Elements über ein entsprechendes Objekt in der Objektliste verfügt. Außerdem müssen Sie sich keine Gedanken darüber machen, welche Überlastung Sie aufrufen. der Compiler wählt den entsprechenden für Sie aus.  
  
 ### <a name="controlling-formatting"></a>Steuern der Formatierung  
 Sie können den Index in einem Format Element mit einer Format Zeichenfolge befolgen, um zu steuern, wie ein Objekt formatiert wird. Beispielsweise `{0:d}` wendet die Format Zeichenfolge "d" auf das erste Objekt in der Objektliste an. Im folgenden finden Sie ein Beispiel mit einem einzelnen-Objekt und zwei Format Elementen:  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Eine Reihe von Typen unterstützen Format Zeichenfolgen, einschließlich aller numerischen Typen ( [standardmäßige](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-numeric-format-strings.md) Format Zeichenfolgen), Datums-und Uhrzeitangaben ( [standardmäßige](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Format Zeichenfolgen) und Zeitintervallen (sowohl [Standard](~/docs/standard/base-types/standard-timespan-format-strings.md) [benutzerdefinierte](~/docs/standard/base-types/custom-timespan-format-strings.md) Format Zeichenfolgen), alle Enumerationstypen [Enumerationstypen](~/docs/standard/base-types/enumeration-format-strings.md)und [GUIDs](https://msdn.microsoft.com/library/97af8hh4.aspx). Sie können auch Unterstützung für Format Zeichenfolgen zu ihren eigenen Typen hinzufügen.  
  
 ### <a name="controlling-spacing"></a>Steuern des Abstands  
 Sie können die Breite der Zeichenfolge, die in die Ergebnis Zeichenfolge eingefügt wird `{0,12}`, mithilfe von Syntax definieren, die eine Zeichenfolge mit 12 Zeichen einfügt. In diesem Fall wird die Zeichen folgen Darstellung des ersten Objekts rechtsbündig im Feld mit 12 Zeichen ausgerichtet.  (Wenn die Zeichen folgen Darstellung des ersten Objekts mehr als 12 Zeichen lang ist, wird jedoch die bevorzugte Feldbreite ignoriert, und die gesamte Zeichenfolge wird in die Ergebnis Zeichenfolge eingefügt.)  
  
 Im folgenden Beispiel wird ein Zeichen aus 6 Zeichen definiert, das die Zeichenfolge "Year" und einige Jahr-Zeichen folgen enthält, sowie ein Feld mit 15 Zeichen, das die Zeichenfolge "Population" und einige auffüllungs Daten enthalten soll. Beachten Sie, dass die Zeichen rechtsbündig in dem Feld ausgerichtet sind.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs#33)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>Steuern der Ausrichtung  
 Standardmäßig werden Zeichen folgen rechtsbündig ausgerichtet, wenn Sie eine Feldbreite angeben. Wenn `{0,-12}` Zeichen folgen in einem Feld linksbündig ausgerichtet werden sollen, wird der Feldbreite ein negatives Vorzeichen vorangestellt, z. b., um ein mit 12 Zeichen ausgerichtetes Feld zu definieren.  
  
 Das folgende Beispiel ähnelt dem vorherigen, mit der Ausnahme, dass es sowohl Bezeichnungen als auch Daten linksbündig ausgerichtet ist.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType>verwendet die Funktion für die kombinierte Formatierung. Weitere Informationen finden Sie unter [Zusammengesetzte Formatierung](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Welche Methode rufe ich auf?  
  
|Beschreibung|Call|  
|--------|----------|  
|Formatiert ein oder mehrere-Objekte, indem die Konventionen der aktuellen Kultur verwendet werden.|Mit Ausnahme der über Ladungen, die einen `provider` -Parameter enthalten, <xref:System.String.Format%2A> enthalten die verbleibenden <xref:System.String> über Ladungen einen Parameter, gefolgt von einem oder mehreren Objekt Parametern. Aus diesem Grund müssen Sie nicht ermitteln, welche <xref:System.String.Format%2A> Überladung Sie aufrufen möchten. Der sprach Compiler wählt die entsprechende Überladung aus den über Ladungen aus, die nicht `provider` über einen Parameter verfügen, basierend auf der Argumentliste. Wenn die Argumentliste beispielsweise fünf Argumente enthält, ruft der Compiler die <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> -Methode auf.|  
|Formatieren eines oder mehrerer-Objekte mithilfe der Konventionen einer bestimmten Kultur.|Auf <xref:System.String.Format%2A> jede Überladung, die `provider` mit einem Parameter beginnt, <xref:System.String> folgt ein Parameter und ein oder mehrere Objekt Parameter. Aus diesem Grund müssen Sie nicht ermitteln, welche spezifische <xref:System.String.Format%2A> Überladung Sie aufrufen möchten. Der sprach Compiler wählt basierend auf der Argumentliste die entsprechende Überladung aus den `provider` über Ladungen aus, die über einen-Parameter verfügen. Wenn die Argumentliste beispielsweise fünf Argumente enthält, ruft der Compiler die <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> -Methode auf.|  
|Führen Sie einen benutzerdefinierten Formatierungs Vorgang <xref:System.ICustomFormatter> entweder mit einer <xref:System.IFormattable> -Implementierung oder einer-Implementierung aus.|Eine der vier über Ladungen mit einem `provider` -Parameter. Der Compiler wählt basierend auf der Argumentliste die entsprechende Überladung aus den `provider` über Ladungen aus, die über einen-Parameter verfügen.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Die Format-Methode kurz 

 Jede Überladung der <xref:System.String.Format%2A> -Methode verwendet die Funktion für die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um null-basierte indizierte Platzhalter ( *Format Elemente*) in eine kombinierte Format Zeichenfolge einzuschließen. Zur Laufzeit wird jedes Format Element durch die Zeichen folgen Darstellung des entsprechenden Arguments in einer Parameterliste ersetzt. Wenn der Wert des-Arguments ist `null`, wird das Format Element durch <xref:System.String.Empty?displayProperty=nameWithType>ersetzt. Beispielsweise enthält <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> der folgende Aufrufe der-Methode eine Format Zeichenfolge mit drei Format Elementen {0} {1},, und {2}sowie eine Argumentliste mit drei Elementen.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>Das Format Element  
 Ein Format Element weist folgende Syntax auf:  
  
```  
{index[,alignment][:formatString]}  
```  
 
 Eckige Klammern kennzeichnen optionale Elemente. Die öffnenden und schließenden geschweiften Klammern sind erforderlich. (Um eine Literale öffnende oder schließende geschweifte Klammer in der Format Zeichenfolge einzuschließen, lesen Sie den Abschnitt escapeklammern im Artikel zusammen [gesetzte Formatierung](~/docs/standard/base-types/composite-formatting.md) .) [](~/docs/standard/base-types/composite-formatting.md#escaping-braces)  
  
 Ein Format Element zum Formatieren eines Währungs Werts könnte z. b. folgendermaßen aussehen:  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 Ein Format Element verfügt über die folgenden Elemente:  
  
 *index*  
 Der null basierte Index des Arguments, dessen Zeichen folgen Darstellung an dieser Position in der Zeichenfolge eingefügt werden soll. Wenn dieses Argument ist `null`, wird an dieser Position in der Zeichenfolge eine leere Zeichenfolge eingefügt.  
  
 *alignment*  
 Dies ist optional. Eine ganze Zahl mit Vorzeichen, die die Gesamtlänge des Felds angibt, in das das Argument eingefügt wird, und ob es rechtsbündig (eine positive ganze Zahl) oder linksbündig (eine negative Ganzzahl) ist. Wenn Sie die *Ausrichtung*weglassen, wird die Zeichen folgen Darstellung des entsprechenden Arguments in ein Feld ohne führende oder nachfolgende Leerzeichen eingefügt.  
  
 Wenn der Wert der *Ausrichtung* kleiner als die Länge des einzufügenden Arguments ist, wird die *Ausrichtung* ignoriert, und die Länge der Zeichen folgen Darstellung des Arguments wird als Feldbreite verwendet.  
  
 *formatString*  
 Dies ist optional. Eine Zeichenfolge, die das Format der Ergebnis Zeichenfolge des entsprechenden Arguments angibt. Wenn Sie *Format Zeichenfolge*weglassen, wird die Parameter lose `ToString` -Methode des entsprechenden Arguments aufgerufen, um die Zeichen folgen Darstellung zu schaffen. Wenn Sie *Format Zeichenfolge*angeben, muss das Argument, auf das das Format <xref:System.IFormattable> Element verweist, die-Schnittstelle implementieren. Typen, die Format Zeichenfolgen unterstützen, sind:  
  
-   Alle ganzzahligen Typen und Gleit Komma Typen. (Siehe [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.)  
  
-   <xref:System.DateTime> und <xref:System.DateTimeOffset>. (Siehe Standard Format Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und benutzerdefinierte Format Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Alle Enumerationstypen. (Siehe [](~/docs/standard/base-types/enumeration-format-strings.md)Enumerationsformatzeichenfolgen.)  
  
-   <xref:System.TimeSpan>-Werte sind. (Siehe [TimeSpan-Standard Format](~/docs/standard/base-types/standard-timespan-format-strings.md) Zeichenfolgen und [Benutzerdefinierte TimeSpan-Format](~/docs/standard/base-types/custom-timespan-format-strings.md)Zeichenfolgen.)  
  
-   GUIDs. (Siehe die <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> -Methode.)  
  
 Beachten Sie jedoch, dass jeder benutzerdefinierte Typ <xref:System.IFormattable> die <xref:System.IFormattable> Implementierung eines vorhandenen Typs implementieren oder erweitern kann.  
  
 Im folgenden Beispiel wird das `alignment` - `formatString` Argument und das-Argument verwendet, um eine formatierte Ausgabe  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>Formatieren von Argumenten  
 Format Elemente werden sequenziell vom Anfang der Zeichenfolge verarbeitet. Jedes Format Element verfügt über einen Index, der einem Objekt in der Argumentliste der Methode entspricht. Die <xref:System.String.Format%2A> -Methode ruft das-Argument ab und leitet seine Zeichen folgen Darstellung wie folgt ab:  
  
-   Wenn das-Argument `null`ist, fügt <xref:System.String.Empty?displayProperty=nameWithType> die Methode in die Ergebnis Zeichenfolge ein. Sie müssen sich nicht mit der Behandlung <xref:System.NullReferenceException> von für NULL-Argumente befassen. 
  
-   <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Wenn Sie die-Überladung aufrufen und die <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> -Implementierung des `provider` -Objekts eine <xref:System.ICustomFormatter> nicht-NULL-Implementierung zurückgibt, <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> wird das-Argument an seine-Methode übermittelt. Wenn das Format Element ein Format *String* -Argument enthält, wird es als erstes Argument an die-Methode weitergegeben. Wenn die <xref:System.ICustomFormatter> Implementierung verfügbar ist und eine nicht-NULL-Zeichenfolge erzeugt, wird diese Zeichenfolge als Zeichen folgen Darstellung des Arguments zurückgegeben. andernfalls wird der nächste Schritt ausgeführt.  
  
-   Wenn das-Argument die <xref:System.IFormattable> -Schnittstelle <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementiert, wird die zugehörige-Implementierung aufgerufen.  
  
-   Die Parameter lose `ToString` -Methode des Arguments, die entweder überschreibt oder von einer Basisklassen Implementierung erbt, wird aufgerufen.  
  
 Ein Beispiel für das Abfangen von Aufrufen der <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> -Methode und das Überprüfen der Informationen, <xref:System.String.Format%2A> die die Methode an eine Formatierungs Methode für jedes Format Element in einer zusammen [gesetzten Format Zeichenfolge übergibt, finden Sie unter Beispiel: Ein Abfang Anbieter und ein Roman-Zahlen](#Format7_Example)Formatierer.  

 Weitere Informationen finden Sie im Abschnitt " [Verarbeitungsreihenfolge](~/docs/standard/base-types/composite-formatting.md##processing-order) " im Artikel zur zusammen [gesetzten Formatierung](~/docs/standard/base-types/composite-formatting.md) .  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Formatieren von Elementen mit demselben Index  
 Die <xref:System.String.Format%2A> -Methode löst <xref:System.FormatException> eine-Ausnahme aus, wenn der Index eines Index Elements größer oder gleich der Anzahl der Argumente in der Argumentliste ist. `format` Kann jedoch mehr Formatierungs Elemente enthalten, als Argumente vorhanden sind, solange mehrere Format Elemente denselben Index aufweisen. <xref:System.String.Format%28System.String%2CSystem.Object%29> Im folgenden Beispiel enthält die Argumentliste ein einzelnes Argument, die Format Zeichenfolge enthält jedoch zwei Format Elemente: eine zeigt den Dezimalwert einer Zahl an, und die andere zeigt den Hexadezimalwert an.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Formatierung und Kultur  
 Im Allgemeinen werden Objekte in der Argumentliste mithilfe der Konventionen der aktuellen Kultur, die von der <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> -Eigenschaft zurückgegeben wird, in ihre Zeichen folgen Darstellungen konvertiert. Sie können dieses Verhalten steuern, indem Sie eine der über Ladungen von <xref:System.String.Format%2A> aufrufen, die `provider` einen-Parameter enthält. Der `provider` -Parameter ist <xref:System.IFormatProvider> eine-Implementierung, die benutzerdefinierte und kulturspezifische Formatierungsinformationen bereitstellt, die zum moderieren des Formatierungs Vorgangs verwendet werden.  
  
 Die <xref:System.IFormatProvider> -Schnittstelle verfügt über einen <xref:System.IFormatProvider.GetFormat%2A>einzelnen Member,, der für die Rückgabe des Objekts zuständig ist, das Formatierungsinformationen bereitstellt. .Net verfügt über <xref:System.IFormatProvider> drei Implementierungen, die kulturspezifische Formatierung bereitstellen:  
  
-   <xref:System.Globalization.CultureInfo>. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> zugehörige-Methode gibt ein <xref:System.Globalization.NumberFormatInfo> kulturspezifisches Objekt zum Formatieren numerischer Werte und <xref:System.Globalization.DateTimeFormatInfo> ein kulturspezifisches Objekt zum Formatieren von Datums-und Uhrzeitwerten zurück.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, die für die kulturspezifische Formatierung von Datums-und Uhrzeitwerten verwendet wird. Seine <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> -Methode gibt sich selbst zurück.  
  
-   <xref:System.Globalization.NumberFormatInfo>, der für die kulturspezifische Formatierung numerischer Werte verwendet wird. Seine <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> -Eigenschaft gibt sich selbst zurück. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Benutzerdefinierte Formatierungs Vorgänge  
 Sie können auch die über Ladungen der <xref:System.String.Format%2A> -Methode aufrufen, die über einen `provider` Parameter vom Typ <xref:System.IFormatProvider> verfügen, um benutzerdefinierte Formatierungs Vorgänge auszuführen. Beispielsweise können Sie eine ganze Zahl als Identifikationsnummer oder als Telefonnummer formatieren. Um eine benutzerdefinierte Formatierung auszuführen `provider` , muss Ihr Argument sowohl <xref:System.IFormatProvider> die <xref:System.ICustomFormatter> -als auch die-Schnittstelle implementieren Wenn der <xref:System.String.Format%2A> -Methode eine <xref:System.ICustomFormatter> -Implementierung als `provider` Argument übermittelt wird <xref:System.String.Format%2A> , ruft die <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> -Methode ihre-Implementierung auf und <xref:System.ICustomFormatter>fordert ein Objekt vom Typ an. Anschließend wird die-Methode <xref:System.ICustomFormatter> des zurück <xref:System.ICustomFormatter.Format%2A> gegebenen-Objekts aufgerufen, um jedes Format Element in der an ihn weiter gegebenen Verbund Zeichenfolge zu formatieren  
  
 Weitere Informationen zum Bereitstellen von benutzerdefinierten Formatierungs [Lösungen finden Sie unter Gewusst wie: Definieren und Verwenden von benutzerdefinierten Zahlen](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) Format <xref:System.ICustomFormatter>Anbietern und. Ein Beispiel, das ganze Zahlen in formatierte benutzerdefinierte Zahlen konvertiert [, finden Sie unter Beispiel: Ein benutzerdefinierter Formatierungs Vorgang](#Format6_Example). Ein Beispiel, in dem nicht signierte Bytes in römische Zahlen konvertiert werden [, finden Sie unter Beispiel: Ein Abfang Anbieter und ein Roman-Zahlen](#Format7_Example)Formatierer.  
  
<a name="Format6_Example"></a>   
### <a name="example-a-custom-formatting-operation"></a>Beispiel: Ein benutzerdefinierter Formatierungs Vorgang  
 In diesem Beispiel wird ein Format Anbieter definiert, der einen ganzzahligen Wert als Kundenkonto Nummer in der Form x-xxxxx-xx formatiert.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>Beispiel: Ein Abfang Anbieter und ein Roman-formatiererformatierer  
 In diesem Beispiel wird ein benutzerdefinierter Format Anbieter definiert <xref:System.ICustomFormatter> , <xref:System.IFormatProvider> der die-und-Schnittstellen für zwei Dinge implementiert:  
  
-   Er zeigt die Parameter an, die <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> an seine Implementierung übertragen werden. Dadurch können wir sehen, welche Parameter die <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Methode an die Implementierung der benutzerdefinierten Formatierung für jedes Objekt übergibt, das Sie zu formatieren versucht. Dies kann hilfreich sein, wenn Sie Ihre Anwendung debuggen.  
  
-   Wenn das zu formatierende Objekt ein Bytewert ohne Vorzeichen ist, der mit der Standardformat Zeichenfolge "R" formatiert werden soll, formatiert das benutzerdefinierte Formatierungs Programm den numerischen Wert als römische Ziffer.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String. Format Q & A  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>Warum empfiehlt es sich, die Zeichen folgen Interpolationsmethode `String.Format` bei Aufrufen der-Methode zu verwenden?

Zeichen folgen Interpolationen:

- Flexibler. Sie kann in einer beliebigen Zeichenfolge verwendet werden, ohne dass eine Methode aufgerufen werden muss, die die kombinierte Formatierung unterstützt. Andernfalls müssen Sie die-Methode oder <xref:System.String.Format%2A> eine andere Methode aufzurufen, die die kombinierte Formatierung unter <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> stützt <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>, z. b. oder. 

- Besser lesbar. Da der Ausdruck, der in eine Zeichenfolge eingefügt werden soll, im interinterinterierten Ausdruck und nicht in einer Argumentliste angezeigt wird, sind interpoliert Zeichen folgen weitaus einfacher zu programmieren und zu lesen. Aufgrund der besseren Lesbarkeit können interinterpolierte Zeichen folgen nicht nur Aufrufe von Methoden für den zusammengesetzten Format ersetzen, Sie können jedoch auch in Zeichenfolgenverkettungs Vorgängen verwendet werden, um präziseren, klareren Code zu erzielen. 

Ein Vergleich der folgenden beiden Codebeispiele veranschaulicht die Überlegenheit von interpoliert-Zeichen folgen über die Zeichen folgen Verkettung und Aufrufe von Methoden für die kombinierte Formatierung. Durch die Verwendung mehrerer Zeichen folgen Verkettungs Vorgänge im folgenden Beispiel werden ausführlicher und schwer zu lesende Code erzeugt.

[!code-csharp[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs#QAInterpolated)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

Im Gegensatz dazu erzeugt die Verwendung von interpoliert Zeichen folgen im folgenden Beispiel viel klareren, präziseren Code als die Zeichen folgen-Verkettungs Anweisung und den <xref:System.String.Format%2A> aufrufungs Methode im vorherigen Beispiel.

[!code-csharp[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs#QAInterpolated2)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Wo finde ich eine Liste der vordefinierten Format Zeichenfolgen, die mit Format Elementen verwendet werden können?  
  
-   Informationen zu allen integralen und Gleit Komma Typen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Datums-und Uhrzeit Werte finden Sie unter Standard Format Zeichenfolgen für [Datum und](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Uhrzeit und benutzerdefinierte Format Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Enumerationswerte finden Sie [](~/docs/standard/base-types/enumeration-format-strings.md)unter Enumerationsformatzeichenfolgen.  
  
-   Werte finden Sie unter [TimeSpan-Standard Format](~/docs/standard/base-types/standard-timespan-format-strings.md) Zeichenfolgen und [Benutzerdefinierte TimeSpan-Format](~/docs/standard/base-types/custom-timespan-format-strings.md)Zeichenfolgen. <xref:System.TimeSpan>  
  
-   Informationen <xref:System.Guid> zu-Werten finden Sie im Abschnitt " <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> Hinweise" der-Referenzseite.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Gewusst wie die Ausrichtung der Ergebnis Zeichenfolgen steuern, die Format Elemente ersetzen?  
 Die allgemeine Syntax eines Format Elements lautet wie folgt:  
  
```  
{index[,alignment][: formatString]}  
```  
  
 Where *Alignment* ist eine Ganzzahl mit Vorzeichen, die die Feldbreite definiert. Wenn dieser Wert negativ ist, wird der Text im Feld linksbündig ausgerichtet. Wenn er positiv ist, wird der Text rechtsbündig ausgerichtet.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Gewusst wie die Anzahl der Ziffern nach dem Dezimaltrennzeichen Steuern?  
 Alle [standardmäßigen Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen außer "D" (die nur mit ganzen Zahlen verwendet werden), "G", "R" und "X" lassen einen Genauigkeits Bezeichner zu, der die Anzahl der Dezimalstellen in der Ergebnis Zeichenfolge definiert. Im folgenden Beispiel werden standardmäßige numerische Format Zeichenfolgen verwendet, um die Anzahl von Dezimalstellen in der Ergebnis Zeichenfolge zu steuern.  
  
 [!code-csharp[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Wenn Sie eine [benutzerdefinierte numerische Format](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolge verwenden, verwenden Sie den Format Bezeichner "0", um die Anzahl von Dezimalstellen in der Ergebnis Zeichenfolge zu steuern, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Gewusst wie die Anzahl der ganzzahligen Ziffern Steuern?  
 Standardmäßig werden bei Formatierungs Vorgängen nur ganzzahlige Ziffern ungleich Null angezeigt. Wenn Sie ganze Zahlen formatieren, können Sie einen Genauigkeits Bezeichner mit den standardmäßigen Format Zeichenfolgen "D" und "X" verwenden, um die Anzahl der Ziffern zu steuern.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 Sie können eine Ganzzahl oder eine Gleit Komma Zahl mit führenden Nullen auffüllen, um eine Ergebnis Zeichenfolge mit einer angegebenen Anzahl von ganzzahligen Ziffern zu entwickeln, indem Sie den [benutzerdefinierten numerischen Format](~/docs/standard/base-types/custom-numeric-format-strings.md)Bezeichner "0" verwenden, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>Wie viele Elemente kann ich in die Liste "Format" einschließen?  
 Es gibt keine praktische Beschränkung. Der zweite Parameter der <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> -Methode wird mit dem <xref:System.ParamArrayAttribute> -Attribut markiert, sodass Sie entweder eine durch Trennzeichen getrennte Liste oder ein Objekt Array als Format Liste einschließen können.  
  
<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Gewusst wie in die Ergebnis Zeichenfolge Literale geschweifte Klammern ("{" und "}") einschließen?  
 Beispielsweise verhindern Sie, dass der folgende Methodenaufrufe eine <xref:System.FormatException> -Ausnahme auslöst?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Eine einzelne öffnende oder schließende geschweifte Klammer wird immer als Anfang oder Ende eines Format Elements interpretiert. Damit er buchstäblich interpretiert wird, muss er mit Escapezeichen versehen werden. Sie können eine Klammer mit Escapezeichen versehen, indem Sie eine weitere geschweifter Klammer ("{{" und "}}" anstelle von "{" und "}") hinzufügen, wie im folgenden Methoden aufzurufen:  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 Selbst mit Escapezeichen versehene geschweifte Klammern können jedoch problemlos interpretiert werden Sie sollten geschweifte Klammern in die Format Liste einschließen und Format Elemente verwenden, um Sie in die Ergebnis Zeichenfolge einzufügen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Warum löst mein Rückruf der String. Format-Methode eine FormatException aus?  
 Die häufigste Ursache für die Ausnahme ist, dass der Index eines Format Elements keinem Objekt in der Format Liste entspricht. Normalerweise ist dies ein Hinweis darauf, dass Sie die Indizes von Format Elementen falsch nummeriert haben oder dass Sie vergessen haben, ein Objekt in die Format Liste einzufügen. Wenn Sie versuchen, eine Zeichenfolge mit Escapezeichen ohne Escapezeichen <xref:System.FormatException>einzufügen, wird auch eine ausgelöst. Gelegentlich ist die Ausnahme das Ergebnis eines Typo. ein typischer Fehler ist beispielsweise, "[" (die linke Klammer) anstelle von "{" (der linken geschweiften Klammer) zu täuschen.  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Wenn das Format (System. IFormatProvider, System. String, System. Object [])-Methode Parameter Arrays unterstützt, löst mein Code eine Ausnahme aus, wenn ich ein Array verwende?  
 Der folgende Code löst z. b. <xref:System.FormatException> eine-Ausnahme aus:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Dies ist ein Problem bei der Auflösung von compilerüberladungen. Da der Compiler ein Array von ganzen Zahlen nicht in ein Objekt Array konvertieren kann, wird das ganzzahlige Array als einzelnes Argument behandelt, sodass die <xref:System.String.Format%28System.String%2CSystem.Object%29> -Methode aufgerufen wird. Die-Ausnahme wird ausgelöst, weil vier Format Elemente vorhanden sind, aber nur ein einzelnes Element in der Format Liste.  
  
 Da weder Visual Basic noch C# ein ganzzahliges Array in ein Objekt Array konvertieren kann, müssen Sie die Konvertierung selbst ausführen, bevor <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> Sie die-Methode aufrufen. Im folgenden Beispiel wird eine-Implementierung bereitstellt.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

Zahlreiche Beispiele, in <xref:System.String.Format%2A> denen die-Methode aufgerufen wird, werden über den Abschnitt " [Hinweise](#remarks-top) " in diesem Artikel überschrieben.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

Sie können auch `String.Format` einen kompletten Satz von Beispielen herunterladen, die ein [.net Core 2,0-Projekt für C# ](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) und ein [.net Core 2,0-Projekt für Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip)aus dem [dotnet/Samples GitHub-Repository](https://github.com/dotnet/samples)enthalten.

Im folgenden finden Sie einige Beispiele, die im Artikel enthalten sind:

### <a name="create-a-format-string"></a>Erstellen einer Format Zeichenfolge

[Einfügen einer Zeichenfolge](#inserting-a-string)  
[Das Format Element](#the-format-item)  
[Formatieren von Elementen mit demselben Index](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>Formatierte Ausgabe formatieren

[Steuern der Formatierung](#controlling-formatting)  
[Steuern des Abstands](#controlling-spacing)  
[Steuern der Ausrichtung](#controlling-alignment)  
[Steuern der Anzahl von ganzzahligen Ziffern](#how-do-i-control-the-number-of-integral-digits)  
[Steuern der Anzahl der Ziffern nach dem Dezimaltrennzeichen](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[Einschließen von literalklammern in einer Ergebnis Zeichenfolge](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>Format Zeichenfolgen Kultur abhängig machen

[Kultur abhängige Formatierung](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>Anpassen des Formatierungs Vorgangs

[Ein benutzerdefinierter Formatierungs Vorgang](#example-a-custom-formatting-operation)  
[Ein Abfang Anbieter und ein Roman-formatiererformatierer](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das zu formatierende Objekt.</param>
        <summary>Ersetzt mindestens ein Formatelement in einer Zeichenfolge durch die Zeichenfolgendarstellung eines angegebenen Objekts.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der alle Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um den Wert eines Ausdrucks in seine Zeichen folgen Darstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>Beispiel: Formatieren eines einzelnen Arguments  
 
 Im folgenden Beispiel wird die <xref:System.String.Format%28System.String%2CSystem.Object%29> -Methode verwendet, um das Alter einer Person in der Mitte einer Zeichenfolge einzubetten.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Das Formatelement in <paramref name="format" /> ist ungültig.  
  
- oder - 
Der Index eines Formatelements ist nicht 0 (null).</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Ein Objektarray mit 0 (null) oder mehr zu formatierenden Objekten.</param>
        <summary>Ersetzt das Formatelement in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung eines entsprechenden Objekts in einem angegebenen Array.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung der entsprechenden Objekte in <paramref name="args" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um den Wert von vier oder mehr Ausdrücken in ihre Zeichen folgen Darstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten. Da der `args` -Parameter mit dem <xref:System.ParamArrayAttribute?displayProperty=nameWithType> -Attribut markiert ist, können Sie die-Objekte als <xref:System.Object> einzelne Argumente oder als Array an die Methode übergeben. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>Beispiel: Formatieren von mehr als drei Argumenten  
 
 In diesem Beispiel wird eine Zeichenfolge erstellt, die Daten für die hohe und niedrige Temperatur an einem bestimmten Datum enthält. Die kombinierte Format Zeichenfolge enthält fünf Format Elemente C# im Beispiel und sechs im Visual Basic Beispiel. Zwei der Format Elemente definieren die Breite der Zeichen folgen Darstellung Ihres entsprechenden Werts, und das erste Format Element enthält auch eine Standardformat Zeichenfolge für Datum und Uhrzeit.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 Sie können die zu formatierenden Objekte auch als Array und nicht als Argumentliste übergeben.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> oder <paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder - 
Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich der Länge des <paramref name="args" />-Arrays.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine [kombinierte Formatierungszeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung des angegebenen Objekts. Ein Parameter liefert kulturspezifische Formatierungsinformationen.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um den Wert eines Ausdrucks in seine Zeichen folgen Darstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten. Beim Durchführen der Konvertierung verwendet die-Methode Kultur abhängige Formatierung oder einen benutzerdefinierten Formatierer. Die-Methode `arg0` konvertiert in ihre Zeichen folgen Darstellung, indem Sie die **ToString (IFormatProvider)** -Methode aufruft, oder, wenn das entsprechende Format Element des Objekts eine Format Zeichenfolge durch Aufrufen seiner **ToString (String, IFormatProvider)** enthält. anzuwenden. Wenn diese Methoden nicht vorhanden sind, wird die **Parameter lose-** Methode des-Objekts aufgerufen.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder - 
Der Index eines Formatelements ist nicht 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Ein Objektarray mit 0 (null) oder mehr zu formatierenden Objekten.</param>
        <summary>Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellungen entsprechender Objekte in einem angegebenen Array. Ein Parameter liefert kulturspezifische Formatierungsinformationen.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung der entsprechenden Objekte in <paramref name="args" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um vier oder mehr Ausdrücke in ihre Zeichen folgen Darstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten. Beim Durchführen der Konvertierung verwendet die-Methode Kultur abhängige Formatierung oder einen benutzerdefinierten Formatierer. Die-Methode konvertiert <xref:System.Object> jedes Argument in seine Zeichen folgen Darstellung, indem die **ToString (IFormatProvider)** -Methode aufgerufen wird, oder, wenn das entsprechende Format Element des Objekts eine Format Zeichenfolge durch Aufrufen von **ToString (String, IFormatProvider)** -Methode. Wenn diese Methoden nicht vorhanden sind, wird die **Parameter lose-** Methode des-Objekts aufgerufen.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

<a name="culture-sensitive-formatting" /> 

### <a name="example-culture-sensitive-formatting"></a>Beispiel: Kultur abhängige Formatierung

 In diesem Beispiel wird <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> die-Methode verwendet, um die Zeichen folgen Darstellung einiger Datums-und Uhrzeitwerte und numerischer Werte mithilfe verschiedener Kulturen anzuzeigen.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> oder <paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder - 
Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich der Länge des <paramref name="args" />-Arrays.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von zwei angegebenen Objekten.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> und <paramref name="arg1" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um den Wert von zwei Ausdrücken in ihre Zeichen folgen Darstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>Beispiel: Formatieren von zwei Argumenten  
 
 In diesem Beispiel wird <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> die-Methode verwendet, um in einem generischen <xref:System.Collections.Generic.Dictionary%602> -Objekt gespeicherte Zeit-und Temperaturdaten anzuzeigen. Beachten Sie, dass die Format Zeichenfolge drei Format Elemente enthält, obwohl nur zwei zu formatierende Objekte vorhanden sind. Dies liegt daran, dass das erste Objekt in der Liste (ein Datums-und Uhrzeitwert) von zwei Format Elementen verwendet wird: Das erste Format Element zeigt die Uhrzeit an, während die zweite das Datum anzeigt.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder - 
Der Index eines Formatelements ist nicht 0 (null) oder 1.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von zwei angegebenen Objekten. Ein Parameter liefert kulturspezifische Formatierungsinformationen.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> und <paramref name="arg1" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um zwei Ausdrücke in ihre Zeichen folgen Darstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten. Beim Durchführen der Konvertierung verwendet die-Methode Kultur abhängige Formatierung oder einen benutzerdefinierten Formatierer. Die-Methode konvertiert <xref:System.Object> jedes Argument in seine Zeichen folgen Darstellung, indem die **ToString (IFormatProvider)** -Methode aufgerufen wird, oder, wenn das entsprechende Format Element des Objekts eine Format Zeichenfolge durch Aufrufen von **ToString (String, IFormatProvider)** -Methode. Wenn diese Methoden nicht vorhanden sind, wird die **Parameter lose-** Methode des-Objekts aufgerufen.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder - 
Der Index eines Formatelements ist nicht 0 (null) oder 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <param name="arg2">Das dritte zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von drei angegebenen Objekten.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" />, <paramref name="arg1" /> und <paramref name="arg2" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um den Wert von drei Ausdrücken in ihre Zeichen folgen Darstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>Beispiel: Formatieren von drei Argumenten  
 
 In diesem Beispiel wird <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> die-Methode verwendet, um eine Zeichenfolge zu erstellen, die das `And` Ergebnis einer booleschen Operation mit zwei ganzzahligen Werten veranschaulicht. Beachten Sie, dass die Format Zeichenfolge sechs Format Elemente enthält, die-Methode jedoch nur drei Elemente in der Parameterliste aufweist, da jedes Element auf zwei verschiedene Arten formatiert ist.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder - 
Der Index eines Formatelements ist kleiner als 0 (null) oder größer als 2.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <param name="arg2">Das dritte zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von drei angegebenen Objekten. Ein Parameter liefert kulturspezifische Formatierungsinformationen.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" />, <paramref name="arg1" /> und <paramref name="arg2" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um drei Ausdrücke in ihre Zeichen folgen Darstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten. Beim Durchführen der Konvertierung verwendet die-Methode Kultur abhängige Formatierung oder einen benutzerdefinierten Formatierer. Die-Methode konvertiert <xref:System.Object> jedes Argument in seine Zeichen folgen Darstellung, indem die **ToString (IFormatProvider)** -Methode aufgerufen wird, oder, wenn das entsprechende Format Element des Objekts eine Format Zeichenfolge durch Aufrufen von **ToString (String, IFormatProvider)** -Methode. Wenn diese Methoden nicht vorhanden sind, wird die **Parameter lose-** Methode des-Objekts aufgerufen.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder - 
Der Index eines Formatelements ist kleiner als 0 (null) oder größer als 2.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Objekt ab, das die einzelnen Zeichen dieser Zeichenfolge durchlaufen kann.</summary>
        <returns>Ein Enumeratorobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> Anstatt die <xref:System.String.GetEnumerator%2A> -Methode zum Abrufen eines <xref:System.CharEnumerator> -Objekts aufzurufenden, das Sie dann zum Auflisten einer Zeichenfolge verwenden, sollten Sie stattdessen das Iterations Konstrukt C#ihrer Sprache C++(in, in/CLR und in Visual Basic) verwenden. [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in C#, [for each](/cpp/dotnet/for-each-in) in C++/CLR und [for each](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) in Visual Basic).
  
 Diese Methode ermöglicht das Iterieren der einzelnen Zeichen in einer Zeichenfolge. Beispielsweise rufen die Visual Basic `For Each` - C# `foreach` und-Anweisungen diese Methode auf, <xref:System.CharEnumerator> um ein-Objekt zurückzugeben, das schreibgeschützten Zugriff auf die Zeichen in dieser Zeichen folgen Instanz bereitstellen kann.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Zeichen in mehreren Zeichen folgen durchlaufen und Informationen über ihre einzelnen Zeichen angezeigt. Es verwendet das Language Iterations Konstrukt anstelle eines Aufrufes der <xref:System.String.GetEnumerator%2A> -Methode.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Zeichenfolge zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten von <xref:System.String.GetHashCode%2A> hängt von der Implementierung ab, die sich von einer Version der Common Language Runtime in eine andere ändern kann. Ein Grund, warum dies passieren kann, ist die Verbesserung der <xref:System.String.GetHashCode%2A>Leistung von.  
  
> [!IMPORTANT]
>  Wenn zwei Zeichen folgen Objekte gleich sind, <xref:System.String.GetHashCode%2A> gibt die Methode identische Werte zurück. Es gibt jedoch keinen eindeutigen Hashcodewert für jeden eindeutigen Zeichen folgen Wert. Verschiedene Zeichen folgen können den gleichen Hashcode zurückgeben.  
>   
>  Der Hashcode selbst ist nicht garantiert stabil. Hashcodes für identische Zeichen folgen können in .net-Implementierungen, über .NET-Versionen und über .net-Plattformen (z. b. 32-Bit und 64-Bit) für eine einzelne Version von .net abweichen. In einigen Fällen können Sie sich sogar je nach Anwendungsdomäne unterscheiden. Dies bedeutet, dass zwei nachfolgende Ausführungen desselben Programms möglicherweise andere Hashcodes zurückgeben.  
>   
>  Daher sollten Hashcodes nie außerhalb der Anwendungsdomäne verwendet werden, in der Sie erstellt wurden. Sie sollten nie als Schlüsselfelder in einer Auflistung verwendet werden, und Sie sollten niemals persistent gespeichert werden.  
>   
>  Verwenden Sie zum Schluss nicht den Hashcode anstelle eines Werts, der von einer kryptografischen Hash Funktion zurückgegeben wird, wenn Sie einen kryptografisch starken Hash benötigen. Verwenden Sie für kryptografische Hashes eine Klasse, die von <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> der <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> -Klasse oder der-Klasse abgeleitet ist.  
>   
>  Weitere Informationen zu Hashcodes finden <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>Sie unter.  
  
 In Desktop-Apps können Sie das [ \<userandomizedstringhashalgorithm->-Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) verwenden, um eindeutige Hashcodes pro Anwendungsdomäne zu generieren. Dadurch kann die Anzahl von Kollisionen reduziert und die Gesamtleistung von Einfügungen und Such Vorgängen, die Hash Tabellen verwenden, verbessert werden. Im folgenden Beispiel wird gezeigt, wie das [ \<userandomizedstringhashalgorithm-> Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)verwendet wird. Es wird eine `DisplayString` Klasse definiert, die eine private Zeichen folgen `s`Konstante enthält, deren Wert "This is a String" ist. Außerdem enthält sie eine `ShowStringHashCode`-Methode, die den Zeichenfolgenwert und dessen Hashcode zusammen mit dem Namen der Anwendungsdomäne anzeigt, in der die Methode ausgeführt wird.
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 Wenn Sie das Beispiel ausführen, ohne eine Konfigurationsdatei anzugeben, wird die folgende Ausgabe angezeigt. Beachten Sie, dass die Hashcodes für die Zeichenfolge in den zwei Anwendungsdomänen identisch sind.  
  
```
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC
```  
  
 Wenn Sie jedoch die folgende Konfigurationsdatei im Verzeichnis des Beispiels hinzufügen und dann das Beispiel ausführen, unterscheiden sich die Hashcodes je nach Anwendungsdomäne.  
  
```xml
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>
```  
  
 Wenn die Konfigurationsdatei vorhanden ist, zeigt das Beispiel die folgende Ausgabe an:  
  
```  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D
String 'This is a string.' in domain 'NewDomain': 75CC8236
```  
  
> [!IMPORTANT]
>  Hashcodes werden verwendet, um Schlüssel gebundene Objekte effizient aus Hash Tabellen einzufügen und abzurufen. Mit Hashcodes werden Zeichen folgen jedoch nicht eindeutig identifiziert. Identische Zeichen folgen haben gleiche Hashcodes, aber die Common Language Runtime können auch den gleichen Hashcode anderen Zeichen folgen zuweisen. Außerdem können Hashcodes je nach Version von .net, nach Plattform innerhalb einer einzelnen Version und nach Anwendungsdomäne variieren. Aus diesem Grund sollten Sie Hash Code Werte weder serialisieren noch persistent speichern, auch wenn Sie nicht als Schlüssel in einer Hash Tabelle oder einem Wörterbuch verwendet werden.  
  
 Weitere Informationen zur Verwendung von Hashcodes und der `GetHashCode` -Methode finden <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>Sie unter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.GetHashCode%2A> -Methode mithilfe verschiedener Eingabe Zeichenfolgen veranschaulicht.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Der von <see cref="M:System.String.GetHashCode" /> zurückgegebene Wert ist plattformabhängig. Dies unterscheidet sich von der 32-Bit-Version und der 64-Bit-Version der .NET Framework. Sie kann sich auch zwischen den Versionen der .NET Framework und .net Core unterscheiden.</para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;Userandomizedstringhashalgorithm&gt; -Element</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Eine schreibgeschützte Zeichenspanne.</param>
        <summary>Gibt den Hashcode für die angegebene schreibgeschützte Zeichenspanne zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="comparisonType">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</param>
        <summary>Gibt den Hashcode für diese Zeichenfolge gemäß der festgelegten Regeln zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Eine schreibgeschützte Zeichenspanne.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</param>
        <summary>Gibt den Hashcode für die angegebene schreibgeschützte Zeichenspanne gemäß der festgelegten Regeln zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref readonly char GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.char GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; char ^ GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; char" Usage="string.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Char</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="netcore-3.0">
            <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Verweis auf das Element der Zeichenfolge zurück, das sich bei Index 0 befindet.</summary>
        <returns>Ein Zeichen, das den Verweis auf das Element der Zeichenfolge bei Index 0 darstellt.</returns>
        <remarks>
          <format type="text/markdown">
        

## Remarks

Die `GetPinnableReference` -Methode gibt ein Zeichen zurück, das zum Fixieren eines <xref:System.String> im Speicher verwendet werden kann. Es ist erforderlich, um die Verwendung von <xref:System.String> innerhalb einer fixed-Anweisung zu unterstützen.

             </format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die Zeichenfolge ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.TypeCode" /> für das <see cref="T:System.String" /> zurück.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.TypeCode> Enumerationskonstante für <xref:System.String> den-Typ angezeigt.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens eines angegebenen Unicode-Zeichens oder einer angegebenen Unicode-Zeichenfolge in dieser Instanz an. Die Methode gibt -1 zurück, wenn das Zeichen oder die Zeichenfolge in dieser Instanz nicht gefunden wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Ein zu suchendes Unicode-Zeichen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null.  
  
 Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind. Um eine Kultur abhängige Suche auszuführen, verwenden Sie die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (U + 00c6), als äquivalent zu jedem Vorkommen der Komponenten des Zeichens im richtige Reihenfolge, z. b. "AE" (u + 0041, u + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie mithilfe <xref:System.String> der <xref:System.String.IndexOf%2A> -Methode ein nach einem Zeichen durchsuchen können.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, andernfalls -1. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null.  
  
 Diese Methode führt unter Verwendung der aktuellen Kultur eine Wort Suche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch. Die Suche beginnt an der ersten Zeichenposition dieser Instanz und wird bis zur letzten Zeichenposition fortgesetzt.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` nur aus mindestens einem Ignorable-Zeichen besteht, gibt <xref:System.String.IndexOf%28System.String%29> die Methode immer 0 (null) zurück, um anzugeben, dass die Entsprechung am Anfang der aktuellen Instanz gefunden wird. Im folgenden Beispiel wird die <xref:System.String.IndexOf%28System.String%29> -Methode verwendet, um drei Teil Zeichenfolgen zu suchen (ein weicher Bindestrich (U + 00ad), ein weicher Bindestrich gefolgt von "n" und ein weicher Bindestrich, gefolgt von "m") in zwei Zeichen folgen. Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich. Wenn das Beispiel in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, in jedem Fall, da der weiche Bindestrich ein ignorierbares Zeichen ist, ist das Ergebnis das gleiche, als wäre der weiche Bindestrich nicht in `value`enthalten. Wenn nur nach einem Soft Bindestrich gesucht wird, gibt die Methode 0 (null) zurück, um anzugeben, dass eine Entsprechung am Anfang der Zeichenfolge gefunden wurde.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird nach "n" in "Animal" gesucht. Da Zeichen folgen Indizes bei Null und nicht bei einer beginnen <xref:System.String.IndexOf%28System.String%29> , gibt die Methode an, dass sich "n" an Position 1 befindet.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 Im folgenden Beispiel wird die <xref:System.String.IndexOf%2A> -Methode verwendet, um die Anfangsposition eines Tier namens in einem Satz zu bestimmen. Diese Position wird dann verwendet, um ein Adjektiv einzufügen, das das Tier in den Satz beschreibt.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen. Um den ersten Index einer Teil Zeichenfolge innerhalb einer Zeichen folgen Instanz mithilfe der Vergleichs Regeln der aktuellen Kultur zu ermitteln, müssen <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> Sie die-Methoden Überladung <see cref="F:System.StringComparison.CurrentCulture" /> mit dem `comparisonType` Wert für den-Parameter aufrufen.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein zu suchendes Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an. Die Suche beginnt an einer angegebenen Zeichenposition.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" /> ab dem Anfang der Zeichenfolge, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei 0. Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen. Wenn `startIndex` der Länge der Zeichen folgen Instanz gleicht, gibt die Methode-1 zurück.  
  
 Die Such Bereiche von `startIndex` bis zum Ende der Zeichenfolge.  
  
 Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind. Um eine Kultur abhängige Suche auszuführen, verwenden Sie die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (U + 00c6), als äquivalent zu jedem Vorkommen der Komponenten des Zeichens im richtige Reihenfolge, z. b. "AE" (u + 0041, u + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.IndexOf%2A> Methode.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge der Zeichenfolge.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Das zu suchende Zeichen.</param>
        <param name="comparisonType">Ein Enumerationswert, der die Regeln für die Suche festlegt.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an. Ein Parameter gibt den Typ der Suche für das angegebene Zeichen an.</summary>
        <returns>Der nullbasierte Index von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Die Index Nummerierung beginnt bei Null.  
  
Der `comparisonType` -Parameter ist <xref:System.StringComparison> ein-Enumerationsmember, der angibt, `value` ob bei der Suche nach dem-Argument die aktuelle oder invariante Kultur verwendet wird, ob die Groß-/Kleinschreibung beachtet wird oder ob Wort-oder Ordinalvergleichsregeln verwendet werden.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" /> vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei 0. Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen. Wenn `startIndex` der Länge der Zeichen folgen Instanz gleicht, gibt die Methode-1 zurück.  
  
 Diese Methode führt unter Verwendung der aktuellen Kultur eine Wort Suche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch. Die Suche beginnt an der `startIndex` Zeichenposition dieser Instanz und wird bis zur letzten Zeichenposition fortgesetzt.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` nur aus mindestens einem Ignorable-Zeichen besteht, gibt <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> die Methode immer `startIndex`zurück. Dies ist die Zeichenposition, an der die Suche beginnt. Im folgenden Beispiel wird die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> -Methode verwendet, um die Position eines Soft-Bindestrichs (U + 00ad), gefolgt von einem "m", in zwei Zeichen folgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, gibt die Methode in beiden Fällen den Index "m" in der Zeichenfolge zurück, da der weiche Bindestrich ein ignorierbares Zeichen ist. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird nach allen Vorkommen einer angegebenen Zeichenfolge in einer Ziel Zeichenfolge gesucht.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge dieser Zeichenfolge.</exception>
        <block subset="none" type="usage"><para>Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen. Um den ersten Index einer Teil Zeichenfolge zu ermitteln, die nach einer bestimmten Zeichenposition auftritt, indem Sie die Vergleichs Regeln der aktuellen Kultur <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> verwenden, müssen Sie die- <see cref="F:System.StringComparison.CurrentCulture" /> Methoden Überladung mit dem Wert für den `comparisonType` -Parameter aufrufen.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Ein Parameter gibt den Typ der Suche für die angegebene Zeichenfolge an.</summary>
        <returns>Die Indexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, andernfalls -1. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null.  
  
 Der `comparisonType` -Parameter gibt an, dass `value` mithilfe der aktuellen oder der invarianten Kultur nach dem-Parameter gesucht werden soll, wobei die Groß-/Kleinschreibung beachtet wird und die Suche ohne Beachtung der Groß-/Kleinschreibung verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei über Ladungen der <xref:System.String.IndexOf%2A> -Methode veranschaulicht, die das erste Vorkommen einer Zeichenfolge in einer anderen Zeichenfolge mithilfe verschiedener Werte <xref:System.StringComparison> der-Enumeration suchen.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> nur aus mindestens einem Ignorable-Zeichen besteht, gibt <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> die Methode immer 0 (null) zurück, um anzugeben, dass die Entsprechung am Anfang der aktuellen Instanz gefunden wird.  
  
Im folgenden Beispiel wird die <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> -Methode verwendet, um drei Teil Zeichenfolgen zu suchen (ein weicher Bindestrich (U + 00ad), ein weicher Bindestrich gefolgt von "n" und ein weicher Bindestrich, gefolgt von "m") in zwei Zeichen folgen. Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich. Wenn das Beispiel in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, da der weiche Bindestrich ein ignorierbares Zeichen ist, gibt eine Kultur abhängige Suche denselben Wert zurück, der zurückgegeben wird, wenn der weiche Bindestrich nicht in der Such Zeichenfolge enthalten wäre. Bei einer ordinalsuchsuche wird jedoch der weiche Bindestrich in einer Zeichenfolge gefunden, und es wird gemeldet, dass Sie in der zweiten Zeichenfolge nicht vorhanden ist.  
  
[! Code-csharp[System. String. IndexOf # 26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [! Code-vb[System. String. IndexOf # 26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein zu suchendes Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Zeichens in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" /> ab dem Anfang der Zeichenfolge, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche beginnt bei `startIndex` und wird zu `startIndex`  +  `count` -1 weitergeführt. Das Zeichen bei `startIndex`  + istnichtin derSucheenthalten`count` .  
  
 Die Index Nummerierung beginnt bei 0 (null). Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.  
  
 Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind. Um eine Kultur abhängige Suche auszuführen, verwenden Sie die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (U + 00c6), als äquivalent zu jedem Vorkommen der Komponenten des Zeichens im richtige Reihenfolge, z. b. "AE" (u + 0041, u + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.IndexOf%2A> Methode.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder - 
 <paramref name="startIndex" /> ist größer als die Länge dieser Zeichenfolge.  
  
- oder - 
 <paramref name="count" /> ist größer als die Länge dieser Zeichenfolge minus <paramref name="startIndex" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" /> vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei 0 (null). Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.  
  
 Diese Methode führt unter Verwendung der aktuellen Kultur eine Wort Suche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch. Die Suche beginnt bei `startIndex` und wird zu `startIndex`  +  `count` -1 weitergeführt. Das Zeichen bei `startIndex`  + istnichtin derSucheenthalten`count` .  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` nur aus mindestens einem Ignorable-Zeichen besteht, gibt <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> die Methode immer `startIndex`zurück. Dies ist die Zeichenposition, an der die Suche beginnt. Im folgenden Beispiel wird die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> -Methode verwendet, um die Position eines Soft Bindestrichs (U + 00ad), gefolgt von einem "m", beginnend mit den dritten bis sechsten Zeichen Positionen in zwei Zeichen folgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, wird in beiden Fällen, da der weiche Bindestrich ein ignorierbares Zeichen ist, die Methode den Index von "m" in der Zeichenfolge zurückgibt, wenn Sie einen Kultur abhängigen Vergleich durchführt. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index aller Vorkommen der Zeichenfolge "he" in einer Teil Zeichenfolge einer anderen Zeichenfolge gefunden. Beachten Sie, dass die Anzahl der zu durchsuchenden Zeichen für jede Such Iterations Dauer neu berechnet werden muss.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder - 
 <paramref name="startIndex" /> ist größer als die Länge dieser Zeichenfolge.  
  
- oder - 
 <paramref name="count" /> ist größer als die Länge dieser Zeichenfolge minus <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage"><para>Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen. Um die Vergleichs Regeln der aktuellen Kultur zu verwenden, um diesen Vorgang auszuführen, müssen <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> Sie die-Methoden Überladung <see cref="F:System.StringComparison.CurrentCulture" /> mit dem `comparisonType` Wert für den-Parameter aufrufen.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Parameter geben die Anfangssuchposition in der aktuellen Zeichenfolge und den Typ der Suche an, die für die angegebene Zeichenfolge verwendet werden soll.</summary>
        <returns>Die nullbasierte Indexposition des <paramref name="value" />-Parameters vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei 0. Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen. Wenn `startIndex` der Länge der Zeichen folgen Instanz gleicht, gibt die Methode-1 zurück.  
  
 Der `comparisonType` -Parameter gibt an, dass `value` mithilfe der aktuellen oder der invarianten Kultur nach dem-Parameter gesucht werden soll, wobei die Groß-/Kleinschreibung beachtet wird und die Suche ohne Beachtung der Groß-/Kleinschreibung verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei über Ladungen der <xref:System.String.IndexOf%2A> -Methode veranschaulicht, die das erste Vorkommen einer Zeichenfolge in einer anderen Zeichenfolge mithilfe verschiedener Werte <xref:System.StringComparison> der-Enumeration suchen.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge dieser Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> nur aus mindestens einem Ignorable-Zeichen besteht, gibt <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> die Methode immer <paramref name="startIndex" />zurück. Dies ist die Zeichenposition, an der die Suche beginnt.  
  
Im folgenden Beispiel wird die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> -Methode verwendet, um die Position eines Soft Bindestrichs (U + 00ad), gefolgt von einem "m", beginnend mit der dritten Zeichenposition in zwei Zeichen folgen zu suchen. Nur eine der Zeichen folgen enthält die erforderliche Teil Zeichenfolge. Wenn das Beispiel in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, wird in beiden Fällen, da der weiche Bindestrich ein ignorierbares Zeichen ist, die Methode den Index von "m" in der Zeichenfolge zurückgibt, wenn Sie einen Kultur abhängigen Vergleich durchführt. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt. Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.  
  
[! Code-csharp[System. String. IndexOf # 25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [! Code-vb[System. String. IndexOf # 25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Parameter geben die Anfangssuchposition in der aktuellen Zeichenfolge, die Anzahl der Zeichen in der aktuellen Zeichenfolge und den Typ der Suche für die angegebene Zeichenfolge an.</summary>
        <returns>Die nullbasierte Indexposition des <paramref name="value" />-Parameters vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei 0 (null). Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.  
  
 Die Suche beginnt bei `startIndex` und wird zu `startIndex`  +  `count` -1 weitergeführt. Das Zeichen bei `startIndex`  + istnichtin derSucheenthalten`count` .  
  
 Der `comparisonType` -Parameter gibt an, dass `value` mithilfe der aktuellen oder der invarianten Kultur nach dem-Parameter gesucht werden soll, wobei die Groß-/Kleinschreibung beachtet wird und die Suche ohne Beachtung der Groß-/Kleinschreibung verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei über Ladungen der <xref:System.String.IndexOf%2A> -Methode veranschaulicht, die das erste Vorkommen einer Zeichenfolge in einer anderen Zeichenfolge mithilfe verschiedener Werte <xref:System.StringComparison> der-Enumeration suchen.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder - 
 <paramref name="startIndex" /> ist größer als die Länge dieser Instanz.  
  
- oder - 
 <paramref name="count" /> ist größer als die Länge dieser Zeichenfolge minus <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> nur aus mindestens einem Ignorable-Zeichen besteht, gibt <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> die Methode immer <paramref name="startIndex" />zurück. Dies ist die Zeichenposition, an der die Suche beginnt.  
  
Im folgenden Beispiel wird die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> -Methode verwendet, um die Position eines Soft Bindestrichs (U + 00ad), gefolgt von einem "m", beginnend mit den dritten bis sechsten Zeichen Positionen in zwei Zeichen folgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, wird in beiden Fällen, da der weiche Bindestrich ein ignorierbares Zeichen ist, die Methode den Index von "m" in der Zeichenfolge zurückgibt, wenn Sie einen Kultur abhängigen Vergleich durchführt. Wenn ein Ordinalvergleich durchführt, wird die Teil Zeichenfolge jedoch nur in der ersten Zeichenfolge gefunden. Beachten Sie, dass bei der ersten Zeichenfolge, die den weichen Bindestrich, gefolgt von einem "m", die Methode nicht den Index des weichen Bindestrichs zurückgibt, sondern den Index des "m" zurückgibt, wenn ein Kultur abhängiger Vergleich durchgeführt wird. Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.  
  
[! Code-csharp[System. String. IndexOf # 24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [! Code-vb[System. String. IndexOf # 24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an. Die Methode gibt -1 zurück, wenn die Zeichen im Array nicht in dieser Instanz gefunden werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an.</summary>
        <returns>Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null.  
  
 Beim Suchen nach `anyOf` wird die Groß-/Kleinschreibung beachtet. Wenn `anyOf` ein leeres Array ist, findet die Methode am Anfang der Zeichenfolge eine Entsprechung (d. h. bei Index null).  
  
 Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind. Um eine Kultur abhängige Suche auszuführen, verwenden Sie die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (U + 00c6), als äquivalent zu jedem Vorkommen der Komponenten des Zeichens im richtige Reihenfolge, z. b. "AE" (u + 0041, u + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der erste Vokal in einer Zeichenfolge gesucht.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition.</summary>
        <returns>Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null. Der `startIndex` -Parameter kann zwischen 0 und eins liegen, die kleiner als die Länge der Zeichen folgen Instanz ist.  
  
 Die Such Bereiche von `startIndex` bis zum Ende der Zeichenfolge.  
  
 Beim Suchen nach `anyOf` wird die Groß-/Kleinschreibung beachtet.  
  
 Diese Methode führt eine Ordinalzahl (Kultur unabhängige Suche) aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn der zugehörige Unicode-Skalarwert identisch ist. Um eine Kultur abhängige Suche auszuführen, verwenden Sie die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (U + 00c6), als äquivalent zu jedem Vorkommen der Komponenten des Zeichens im richtige Reihenfolge, z. b. "AE" (u + 0041, u + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index des Vorkommens eines beliebigen Zeichens der Zeichenfolge "is" in einer Teil Zeichenfolge einer anderen Zeichenfolge gefunden.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder - 
 <paramref name="startIndex" /> ist größer als die Anzahl der Zeichen in dieser Instanz.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</summary>
        <returns>Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche beginnt bei `startIndex` und wird zu `startIndex`  +  `count` -1 weitergeführt. Das Zeichen bei `startIndex`  + istnichtin derSucheenthalten`count` .  
  
 Die Index Nummerierung beginnt bei Null. Der `startIndex` -Parameter kann zwischen 0 und eins liegen, die kleiner als die Länge der Zeichen folgen Instanz ist.  
  
 Beim Suchen nach `anyOf` wird die Groß-/Kleinschreibung beachtet.  
  
 Diese Methode führt eine Ordinalzahl (Kultur unabhängige Suche) aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn der zugehörige Unicode-Skalarwert identisch ist. Um eine Kultur abhängige Suche auszuführen, verwenden Sie die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (U + 00c6), als äquivalent zu jedem Vorkommen der Komponenten des Zeichens im richtige Reihenfolge, z. b. "AE" (u + 0041, u + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index des Vorkommens eines beliebigen Zeichens der Zeichenfolge "Aid" in einer Teil Zeichenfolge einer anderen Zeichenfolge gefunden.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder - 
 <paramref name="count" /> + <paramref name="startIndex" /> ist größer als die Anzahl der Zeichen in dieser Instanz.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Indexposition für das Einfügen.</param>
        <param name="value">Die einzufügende Zeichenfolge.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der eine angegebene Zeichenfolge an einer angegebenen Indexposition in dieser Instanz eingefügt wird.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz mit einem an der Position <paramref name="value" /> eingefügten <paramref name="startIndex" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `startIndex` gleich der Länge dieser Instanz ist, `value` wird am Ende dieser Instanz angefügt.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, `value` die in die aktuelle Instanz eingefügt wird.  
  
 Der Rückgabewert von `"abc".Insert(2, "XYZ")` lautet z. b. "abXYZc".  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Leerzeichen an der vierten Zeichenposition (das Zeichen am Index 3) einer Zeichenfolge eingefügt.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 Mit der folgenden Konsolenanwendung werden die Benutzer aufgefordert, mindestens einen Adjektive einzugeben, um zwei Tiere zu beschreiben. Anschließend wird die <xref:System.String.Insert%2A> -Methode aufgerufen, um den vom Benutzer eingegebenen Text in eine Zeichenfolge einzufügen.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist negativ oder größer als die Länge dieser Instanz.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">Eine im Internpool zu suchende Zeichenfolge.</param>
        <summary>Ruft den Verweis des Systems auf den angegebenen <see cref="T:System.String" /> ab.</summary>
        <returns>Der Verweis des Systems auf <paramref name="str" />, wenn dieser im Internpool vorhanden ist, andernfalls ein neuer Verweis auf eine Zeichenfolge mit dem Wert von <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Common Language Runtime die den Zeichen folgen Speicher beibehält, indem er eine Tabelle mit dem Namen Internpool verwaltet, die einen einzelnen Verweis auf jede eindeutige Literalzeichenfolge enthält, die im Programm Programm gesteuert deklariert oder erstellt wurde. Folglich ist eine Instanz einer Literalzeichenfolge mit einem bestimmten Wert nur einmal im System vorhanden.  
  
 Wenn Sie z. b. die gleiche Literalzeichenfolge mehreren Variablen zuweisen, ruft die Laufzeit denselben Verweis auf die Literalzeichenfolge aus dem Internpool ab und weist Sie jeder Variablen zu.  
  
 Die <xref:System.String.Intern%2A> -Methode verwendet den Internpool, um nach einer Zeichenfolge zu suchen, `str`die dem Wert von entspricht. Wenn eine solche Zeichenfolge vorhanden ist, wird der zugehörige Verweis im Internpool zurückgegeben. Wenn die Zeichenfolge nicht vorhanden ist, wird dem `str` Internalen Pool ein Verweis auf hinzugefügt. Anschließend wird dieser Verweis zurückgegeben.  
  
 Im folgenden Beispiel ist die Zeichenfolge S1 mit dem Wert "myTest" bereits interniert, weil es sich um ein Literalzeichen im Programm handelt. Die <xref:System.Text.StringBuilder?displayProperty=nameWithType> -Klasse generiert ein neues String-Objekt, das über denselben Wert wie S1 verfügt. Ein Verweis auf diese Zeichenfolge wird S2 zugewiesen. Die <xref:System.String.Intern%2A> -Methode sucht nach einer Zeichenfolge, die über den gleichen Wert wie S2 verfügt. Da eine solche Zeichenfolge vorhanden ist, gibt die Methode denselben Verweis zurück, der S1 zugewiesen wird. Dieser Verweis wird dann S3 zugewiesen. Verweise S1 und S2 vergleichen ungleich, da Sie auf unterschiedliche Objekte verweisen. Verweise S1 und S3 vergleichen gleich, da Sie auf dieselbe Zeichenfolge verweisen.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Vergleichen Sie diese Methode mit <xref:System.String.IsInterned%2A> der-Methode.  
  
## <a name="version-considerations"></a>Überlegungen zur Version  
 In wird das Verhalten <xref:System.String.Intern%2A> der-Methode in den .NET Framework 1,0 und 1,1 in Bezug auf das Internalisierung der leeren Zeichenfolge wieder hergestellt. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Im folgenden Beispiel wird der-Variablen `str1` ein Verweis auf <xref:System.String.Empty>zugewiesen, und der-Variablen `str2` wird der Verweis auf <xref:System.String.Empty> zugewiesen, der durch Aufrufen der <xref:System.String.Intern%2A> -Methode nach <xref:System.Text.StringBuilder>der-Methodezurückgegebenwird.Objekt, dessen Wert <xref:System.String.Empty> eine Zeichenfolge ist. Anschließend werden die in `str1` und `str2` enthaltenen Verweise auf Gleichheit verglichen.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]In, [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]und [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] sind`str2` und gleich. `str1` [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] In und[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]sind und`str2`nicht gleich. `str1`  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Wenn Sie versuchen, die Gesamtmenge des Arbeitsspeichers zu verringern, die von der Anwendung zugewiesen wird, sollten Sie Bedenken, dass das Trennen einer Zeichenfolge zwei unerwünschte Nebeneffekte hat. Zuerst wird der für Internpool vorhanden <xref:System.String> -Objekte zugeordnete Arbeitsspeicher wahrscheinlich erst freigegeben, wenn die Common Language Runtime (CLR) beendet wird. Der Grund hierfür ist, dass der CLR-Verweis auf das <xref:System.String> Internpool vorhanden-Objekt beibehalten werden kann, nachdem Ihre Anwendung oder sogar Ihre Anwendungsdomäne beendet wurde. Zweitens müssen Sie zuerst die Zeichenfolge erstellen, um eine Zeichenfolge zu interntigen. Der Arbeitsspeicher, der <xref:System.String> vom-Objekt verwendet wird, muss weiterhin zugeordnet werden, auch wenn der Arbeitsspeicher schließlich in eine Garbage Collection aufgenommen wird.  
  
 Der .NET Framework Version 2,0 führt den <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> Enumerationsmember ein. Der <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> Member markiert eine Assembly als keine Zeichen folgen Literale interning. Sie können mithilfe <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> des <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> -Attributs auf eine Assembly anwenden. Wenn Sie den [Ngen. exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) verwenden, um eine Assembly im Vorfeld der Laufzeit zu kompilieren, werden Zeichen folgen nicht über Module hinweg interniert.  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei Zeichen folgen verwendet, die dem-Wert entsprechen, um zu bestimmen, ob eine neu erstellte Zeichenfolge und eine intererte Zeichenfolge gleich sind.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="str">Die im Internpool zu suchende Zeichenfolge.</param>
        <summary>Ruft einen Verweis auf einen angegebenen <see cref="T:System.String" /> ab.</summary>
        <returns>Ein Verweis auf <paramref name="str" />, wenn sich dieser im Internpool der Common Language Runtime befindet; andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Common Language Runtime verwaltet automatisch eine Tabelle, die als Internpool bezeichnet wird und eine einzelne Instanz der einzelnen eindeutigen Literalzeichenfolgen-Konstanten, die in einem Programm deklariert sind, <xref:System.String> sowie jede eindeutige Instanz von, die Sie Programm gesteuert durch Aufrufen von hinzufügen. die <xref:System.String.Intern%2A> -Methode.  
  
 Der Internpool bietet einen Zeichen folgen Speicher. Wenn Sie mehrere Variablen eine Literalzeichenfolge-Konstante zuweisen, wird jede Variable so festgelegt, dass Sie auf dieselbe Konstante im Internpool verweist, anstatt <xref:System.String> auf verschiedene Instanzen von zu verweisen, die identische Werte aufweisen.  
  
 Diese Methode sucht `str` im Internpool. Wenn `str` bereits interniert wurde, wird ein Verweis auf diese Instanz zurückgegeben; `null` andernfalls wird zurückgegeben.  
  
 Vergleichen Sie diese Methode mit <xref:System.String.Intern%2A> der-Methode.  
  
 Diese Methode gibt keinen booleschen Wert zurück. Wenn Sie die-Methode aufzurufen, da Sie einen booleschen Wert wünschen, der angibt, ob eine bestimmte Zeichenfolge interniert ist, können Sie Code wie den folgenden verwenden.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  Ab der .NET Framework Version 2,0 können Sie die Verwendung des internspools überschreiben, wenn Sie den [Ngen. exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) verwenden, um eine Assembly im Cache für Native Images auf einem lokalen Computer zu installieren. Weitere Informationen finden Sie unter Überlegungen zur Leistung im Abschnitt "Hinweise <xref:System.String.Intern%2A> " für die-Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, dass Literalzeichenfolgen automatisch vom Compiler interniert werden.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob diese Zeichenfolge in einer bestimmten Unicode-Normalisierungsform vorliegt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob diese Zeichenfolge in der Unicode-Normalisierungsform C vorliegt.</summary>
        <returns><see langword="true" />, wenn diese Zeichenfolge in der Normalisierungsform C vorliegt; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Unicode-Zeichen verfügen über mehrere äquivalente binäre Darstellungen, die aus Mengen von Kombination aus und/oder zusammengesetzten Unicode-Zeichen bestehen Das vorhanden sein mehrerer Darstellungen für ein einzelnes Zeichen erschwert das suchen, sortieren, abgleichen und andere Vorgänge.  
  
 Der Unicode-Standard definiert einen Prozess namens Normalisierung, der eine binäre Darstellung zurückgibt, wenn eine der äquivalenten binären Darstellungen eines Zeichens angegeben wird. Die Normalisierung kann mit mehreren Algorithmen durchgeführt werden, die als normalisierungs Formulare bezeichnet werden, die unterschiedliche Regeln einhalten. .NET unterstützt derzeit die Normalisierungsformen C, D, KC und KD.  
  
 Eine Beschreibung der unterstützten Unicode-Normalisierungsformen <xref:System.Text.NormalizationForm?displayProperty=nameWithType>finden Sie unter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge erfolgreich in verschiedene Normalisierungsformen normalisiert wird.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</exception>
        <block subset="none" type="usage"><para>Die <see cref="Overload:System.String.IsNormalized" /> Methode gibt <see langword="false" /> zurück, sobald Sie das erste nicht normalisierte Zeichen in einer Zeichenfolge findet. Wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält, löst <see cref="Overload:System.String.Normalize" /> die Methode daher eine <see cref="T:System.ArgumentException" /> aus <see cref="Overload:System.String.IsNormalized" /> , <see langword="false" />obwohl zurückgibt.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Eine Unicode-Normalisierungsform.</param>
        <summary>Gibt an, ob diese Zeichenfolge in der angegebenen Unicode-Normalisierungsform vorliegt.</summary>
        <returns><see langword="true" />, wenn diese Zeichenfolge in der vom <paramref name="normalizationForm" />-Parameter angegebenen Normalisierungsform vorliegt; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Unicode-Zeichen verfügen über mehrere äquivalente binäre Darstellungen, die aus Mengen von Kombination aus und/oder zusammengesetzten Unicode-Zeichen bestehen Das vorhanden sein mehrerer Darstellungen für ein einzelnes Zeichen erschwert das suchen, sortieren, abgleichen und andere Vorgänge.  
  
 Der Unicode-Standard definiert einen Prozess namens Normalisierung, der eine binäre Darstellung zurückgibt, wenn eine der äquivalenten binären Darstellungen eines Zeichens angegeben wird. Die Normalisierung kann mit mehreren Algorithmen durchgeführt werden, die als normalisierungs Formulare bezeichnet werden, die unterschiedliche Regeln einhalten. .NET unterstützt derzeit die Normalisierungsformen C, D, KC und KD.  
  
 Eine Beschreibung der unterstützten Unicode-Normalisierungsformen <xref:System.Text.NormalizationForm?displayProperty=nameWithType>finden Sie unter.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.IsNormalized%2A> und <xref:System.String.Normalize%2A> Methoden.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</exception>
        <block subset="none" type="usage"><para>Die <see cref="Overload:System.String.IsNormalized" /> Methode gibt <see langword="false" /> zurück, sobald Sie das erste nicht normalisierte Zeichen in einer Zeichenfolge findet. Wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält, löst <see cref="Overload:System.String.Normalize" /> die Methode daher eine <see cref="T:System.ArgumentException" /> aus <see cref="Overload:System.String.IsNormalized" /> , <see langword="false" />obwohl zurückgibt.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Die zu testende Zeichenfolge.</param>
        <summary>Gibt an, ob die angegebene Zeichenfolge <see langword="null" /> oder eine leere Zeichenfolge ("") ist.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter <see langword="null" /> oder eine leere Zeichenfolge ("") ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A>ist eine Hilfsmethode, die es Ihnen ermöglicht, gleichzeitig <xref:System.String> zu `null` testen, ob ein <xref:System.String.Empty?displayProperty=nameWithType>oder sein Wert ist. Dies entspricht dem folgenden Code:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 Mit der <xref:System.String.IsNullOrWhiteSpace%2A> -Methode können Sie überprüfen, ob eine `null`Zeichenfolge ist, <xref:System.String.Empty?displayProperty=nameWithType>ob der Wert ist oder ob Sie nur aus Leerzeichen besteht.  
  
## <a name="what-is-a-null-string"></a>Was ist eine NULL-Zeichenfolge?

Eine Zeichenfolge `null` ist, wenn ihr kein Wert zugewiesen wurde (in C++ und Visual Basic) oder explizit ein Wert von `null`zugewiesen wurde. Obwohl das Feature für die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) eine NULL-Zeichenfolge ordnungsgemäß verarbeiten kann, wie im folgenden Beispiel gezeigt, wird versucht, einen aufzurufen, wenn seine Member eine <xref:System.NullReferenceException>auslösen.  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>Was ist eine leere Zeichenfolge?  

Eine Zeichenfolge ist leer, wenn Ihr explizit eine leere Zeichenfolge ("") <xref:System.String.Empty?displayProperty=nameWithType>oder explizit zugewiesen wird. Eine leere Zeichenfolge weist <xref:System.String.Length%2A> den Wert 0 auf.  Im folgenden Beispiel wird eine leere Zeichenfolge erstellt und der zugehörige Wert und seine Länge angezeigt.  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 Im folgenden Beispiel werden drei Zeichen folgen überprüft und bestimmt, ob jede Zeichenfolge über einen Wert verfügt, eine leere `null`Zeichenfolge ist, oder ist.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Die zu testende Zeichenfolge.</param>
        <summary>Gibt an, ob eine angegebene Zeichenfolge <see langword="null" /> ist, leer ist oder nur aus Leerzeichen besteht.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist oder wenn <paramref name="value" /> ausschließlich aus Leerzeichen besteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A>ist eine bequeme Methode, die dem folgenden Code ähnelt, mit dem Unterschied, dass Sie eine bessere Leistung bietet:  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Leerzeichen werden durch den Unicode-Standard definiert. Die <xref:System.String.IsNullOrWhiteSpace%2A> -Methode interpretiert jedes Zeichen, das den `true` Wert zurückgibt, wenn es als <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Leerzeichen an die-Methode übermittelt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Zeichen folgen Array erstellt und dann jedes Element des Arrays an die <xref:System.String.IsNullOrWhiteSpace%2A> -Methode weitergeleitet.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verkettet die Elemente eines angegebenen Arrays oder die Member einer Auflistung und verwendet das angegebene Trennzeichen zwischen jedem Element bzw. Member.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll.<paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</param>
        <param name="values">Eine Auflistung, die die zu verkettenden Zeichenfolgen enthält.</param>
        <summary>Verkettet die Member einer erstellten <see cref="T:System.Collections.Generic.IEnumerable`1" />-Auflistung vom Typ <see cref="T:System.String" /> und verwendet das angegebene Trennzeichen zwischen den einzelnen Membern.</summary>
        <returns>Eine Zeichenfolge, die aus den Membern von <paramref name="values" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge. Wenn <paramref name="values" /> keine Mitglieder hat, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `separator`den Wert<xref:System.String.Empty?displayProperty=nameWithType>hat, wird stattdessen eine leere Zeichenfolge () verwendet. `null` Wenn ein Member von `values` gleich `null`ist, wird stattdessen eine leere Zeichenfolge verwendet.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>ist eine Hilfsmethode, mit der Sie jedes Element in einer `IEnumerable(Of String)` Auflistung verketten können, ohne zuvor die Elemente in ein Zeichen folgen Array umzuwandeln. Dies ist besonders nützlich bei LINQ-Abfrage Ausdrücken (Language-Integrated Query). Im folgenden Beispiel wird ein `List(Of String)` -Objekt, das entweder die Groß-oder Kleinbuchstaben des Alphabets enthält, an einen Lambda-Ausdruck weitergeleitet, der Buchstaben auswählt, die gleich oder größer als ein bestimmter Buchstabe (im Beispiel "M") sind. Die `IEnumerable(Of String)` von der <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> -Methode zurückgegebene Auflistung wird an <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> die-Methode übermittelt, um das Ergebnis als eine einzelne Zeichenfolge anzuzeigen.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Sieb des Eratosthenes-Algorithmus zum Berechnen der Primzahlen, die kleiner oder gleich 100 sind, verwendet. Das Ergebnis wird einem <xref:System.Collections.Generic.List%601> -Objekt vom Typ <xref:System.String>zugewiesen, das dann an die <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> -Methode weitergeleitet wird.  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</param>
        <param name="values">Ein Array, das die zu verkettenden Elemente enthält.</param>
        <summary>Verkettet die Elemente eines Objektarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</summary>
        <returns>Eine Zeichenfolge, die aus den Membern von <paramref name="values" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge. Wenn <paramref name="values" /> eine leeres Array ist, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `separator` `values` ist `null` oder wenn ein Element von einem anderen Element als das erste `null`Element ist, wird stattdessen<xref:System.String.Empty?displayProperty=nameWithType>eine leere Zeichenfolge () verwendet. Weitere Informationen finden Sie im Abschnitt Hinweise für Aufrufer `values` , `null`wenn das erste Element von ist.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>ist eine bequeme Methode, mit der Sie jedes Element in einem Objekt Array verketten können, ohne seine Elemente explizit in Zeichen folgen zu wandeln. Die Zeichen folgen Darstellung der einzelnen Objekte im Array wird durch Aufrufen der- `ToString` Methode dieses Objekts abgeleitet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Sieb des Eratosthenes-Algorithmus zum Berechnen der Primzahlen, die kleiner oder gleich 100 sind, verwendet. Das Ergebnis wird einem ganzzahligen Array zugewiesen, das dann an die <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> -Methode weitergeleitet wird.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Wenn das erste Element von <paramref name="values" /> ist <see langword="null" />, verkettet die <see cref="M:System.String.Join(System.String,System.Object[])" /> Methode nicht die Elemente in <paramref name="values" /> , sondern gibt stattdessen zurück <see cref="F:System.String.Empty" />. Es sind eine Reihe von Problem Umgehungen für dieses Problem verfügbar. Am einfachsten ist es, dem ersten Element <see cref="F:System.String.Empty" /> des Arrays den Wert zuzuweisen, wie im folgenden Beispiel gezeigt.  
  
[! Code-csharp[System. String. Join # 6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! Code-vb[System. String. Join # 6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="value" /> mehr als ein Element enthält.</param>
        <param name="value">Ein Array, das die zu verkettenden Elemente enthält.</param>
        <summary>Verkettet alle Elemente eines Zeichenfolgenarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</summary>
        <returns>Eine Zeichenfolge, die aus den Membern von <paramref name="value" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge. Wenn <paramref name="value" /> eine leeres Array ist, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `separator` z. b. "," ist und die Elemente `value` von "Apple", "Orange", "Grape" und "Birnen" sind, `Join(separator, value)` wird "Apple, Orange, Grape, Birne" zurückgegeben.  
  
 Wenn `separator`den Wert<xref:System.String.Empty?displayProperty=nameWithType>hat, wird stattdessen eine leere Zeichenfolge () verwendet. `null` Wenn ein Element in `value` ist `null`, wird stattdessen eine leere Zeichenfolge verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Join%2A> Methode.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="value" /> mehr als ein Element enthält.</param>
        <param name="value">Ein Array, das die zu verkettenden Elemente enthält.</param>
        <param name="startIndex">Das erste zu verwendende Element aus <paramref name="value" />.</param>
        <param name="count">Die Anzahl der zu verwendenden Elemente aus <paramref name="value" />.</param>
        <summary>Verkettet die angegebenen Elemente eines Zeichenfolgenarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</summary>
        <returns>Eine Zeichenfolge, die aus den Zeichenfolgen in <paramref name="value" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge.  
  
- oder - 
 <see cref="F:System.String.Empty" />, wenn <paramref name="count" /> 0 (null) ist, <paramref name="value" /> keine Elemente enthält oder <paramref name="separator" /> und alle Elemente von <paramref name="value" /> <see cref="F:System.String.Empty" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `separator` z. b. "," ist und die Elemente `value` von "Apple", "Orange", "Grape" und "Birnen" sind, `Join(separator, value, 1, 2)` wird "Orange, Traube" zurückgegeben.  
  
 Wenn `separator`den Wert<xref:System.String.Empty?displayProperty=nameWithType>hat, wird stattdessen eine leere Zeichenfolge () verwendet. `null` Wenn ein Element in `value` ist `null`, wird stattdessen eine leere Zeichenfolge verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei-Elemente aus einem Array mit den Namen von Früchten verkettet.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
- oder - 
 <paramref name="startIndex" /> plus <paramref name="count" /> ist größer als die Anzahl von Elementen in <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Nicht genügend Arbeitsspeicher.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Member von <paramref name="values" />.</typeparam>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll.<paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</param>
        <param name="values">Eine Auflistung, die die zu verkettenden Objekte enthält.</param>
        <summary>Verkettet die Member einer Auflistung und verwendet das angegebene Trennzeichen zwischen den einzelnen Membern.</summary>
        <returns>Eine Zeichenfolge, die aus den Membern von <paramref name="values" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge. Wenn <paramref name="values" /> keine Mitglieder hat, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `separator`den Wert<xref:System.String.Empty?displayProperty=nameWithType>hat, wird stattdessen eine leere Zeichenfolge () verwendet. `null` Wenn ein Member von `values` gleich `null`ist, wird stattdessen eine leere Zeichenfolge verwendet.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>ist eine bequeme Methode, mit der Sie jedes <xref:System.Collections.Generic.IEnumerable%601> Element einer Auflistung verketten können, ohne Sie zuvor in Zeichen folgen zu wandeln. Die Zeichen folgen Darstellung der einzelnen Objekte in <xref:System.Collections.Generic.IEnumerable%601> der Auflistung wird durch Aufrufen der- `ToString` Methode dieses Objekts abgeleitet.  
  
 Diese Methode ist besonders nützlich, wenn LINQ-Abfrage Ausdrücke (Language-Integrated Query) eingesetzt werden. Der folgende Code definiert z. b. eine einfache `Animal` Klasse, die den Namen eines Tieres und die Reihenfolge enthält, zu der er gehört. Anschließend wird ein <xref:System.Collections.Generic.List%601> -Objekt definiert, das eine Reihe `Animal` von-Objekten enthält. Die <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> -Erweiterungsmethode wird aufgerufen, um `Animal` die Objekte `Order` zu extrahieren, deren-Eigenschaft "Rodent" entspricht. Das Ergebnis wird an die <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> -Methode übermittelt.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Sieb des Eratosthenes-Algorithmus zum Berechnen der Primzahlen, die kleiner oder gleich 100 sind, verwendet. Das Ergebnis wird einem <xref:System.Collections.Generic.List%601> -Objekt vom Typ Integer zugewiesen, das dann an die <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> -Methode weitergeleitet wird.  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens oder einer angegebenen Unicode-Zeichenfolge in dieser Instanz an. Die Methode gibt -1 zurück, wenn das Zeichen oder die Zeichenfolge in dieser Instanz nicht gefunden wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Das zu suchende Unicode-Zeichen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens in dieser Instanz an.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null. Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte <xref:System.String.Length%2A> den Wert-1.  
  
 Diese Methode beginnt mit der Suche an der letzten Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis `value` entweder gefunden wird oder die erste Zeichenposition überprüft wurde. Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.  
  
 Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind. Um eine Kultur abhängige Suche auszuführen, verwenden Sie die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (U + 00c6), als äquivalent zu jedem Vorkommen der Komponenten des Zeichens im richtige Reihenfolge, z. b. "AE" (u + 0041, u + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine `ExtractFilename` -Methode definiert, <xref:System.String.LastIndexOf%28System.Char%29> die die-Methode verwendet, um das letzte Verzeichnis Trennzeichen in einer Zeichenfolge zu suchen und den Dateinamen der Zeichenfolge zu extrahieren. Wenn die Datei vorhanden ist, gibt die Methode den Dateinamen ohne ihren Pfad zurück.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, andernfalls -1. Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, ist der Rückgabewert die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null. Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte <xref:System.String.Length%2A> den Wert-1.  
  
 Die Suche beginnt an der letzten Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder `value` gefunden wird oder die erste Zeichenposition überprüft wurde.  
  
 Diese Methode führt unter Verwendung der aktuellen Kultur eine Wort Suche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` nur aus mindestens einem Ignorable-Zeichen besteht, gibt <xref:System.String.LastIndexOf%28System.String%29> die Methode immer <xref:System.String.Length%2A?displayProperty=nameWithType> -1 zurück, das die letzte Indexposition in der aktuellen Instanz darstellt. Im folgenden Beispiel wird die <xref:System.String.LastIndexOf%28System.String%29> -Methode verwendet, um drei Teil Zeichenfolgen zu suchen (ein weicher Bindestrich (U + 00ad), ein weicher Bindestrich gefolgt von "n" und ein weicher Bindestrich, gefolgt von "m") in zwei Zeichen folgen. Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich. Wenn das Beispiel in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, in jedem Fall, da der weiche Bindestrich ein ignorierbares Zeichen ist, ist das Ergebnis das gleiche, als wäre der weiche Bindestrich nicht in `value`enthalten. Bei der Suche nach einem Soft Bindestrich gibt die Methode 6 und 5 zurück. Diese Werte entsprechen dem Index des letzten Zeichens in den beiden Zeichen folgen.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 Im folgenden Beispiel werden öffnende und schließende HTML-Tags aus einer Zeichenfolge entfernt, wenn die Tags beginnen und die Zeichenfolge beenden. Wenn eine Zeichenfolge mit einem schließenden Klammer Zeichen (">") endet, verwendet das <xref:System.String.LastIndexOf%2A> Beispiel die-Methode, um den Anfang des Endtags zu suchen.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen. Um den letzten Index einer Teil Zeichenfolge innerhalb einer Zeichen folgen Instanz mithilfe der Vergleichs Regeln der aktuellen Kultur zu ermitteln, müssen <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> Sie die-Methoden Überladung <see cref="F:System.StringComparison.CurrentCulture" /> mit dem <paramref name="comparisonType" /> Wert für den-Parameter aufrufen.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Das zu suchende Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, oder -1, wenn es nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null. Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 (null) und <xref:System.String.Length%2A> das letzte bei-1. diese Methode beginnt `startIndex` mit der Suche an der Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang der aktuellen Instanz, bis eine der beiden `value` wurde gefunden, oder die erste Zeichenposition wurde überprüft. Wenn `startIndex` z. b. <xref:System.String.Length%2A> -1 ist, durchsucht die-Methode alle Zeichen vom letzten Zeichen in der Zeichenfolge bis zum Anfang. Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.  
  
 Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind. Um eine Kultur abhängige Suche auszuführen, verwenden Sie die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (U + 00c6), als äquivalent zu jedem Vorkommen der Komponenten des Zeichens im richtige Reihenfolge, z. b. "AE" (u + 0041, u + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index aller Vorkommen eines Zeichens in einer Zeichenfolge gesucht. dabei wird vom Ende der Zeichenfolge bis zum Anfang der Zeichenfolge gearbeitet.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer oder gleich der Länge dieser Instanz.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</summary>
        <returns>Die nullbasierte Anfangsindexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null. Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte <xref:System.String.Length%2A> den Wert-1.  
  
 Die Suche beginnt an der `startIndex` Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder `value` gefunden wird oder die erste Zeichenposition überprüft wurde. Wenn `startIndex` z. b. <xref:System.String.Length%2A> -1 ist, durchsucht die-Methode alle Zeichen vom letzten Zeichen in der Zeichenfolge bis zum Anfang.  
  
 Diese Methode führt unter Verwendung der aktuellen Kultur eine Wort Suche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` nur aus mindestens einem Ignorable-Zeichen besteht, gibt <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> die Methode immer `startIndex`zurück. Dies ist die Zeichenposition, an der die Suche beginnt. Im folgenden Beispiel wird die <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> -Methode verwendet, um eine Teil Zeichenfolge zu suchen, die einen Soft Bindestrich (U + 00ad) enthält, und der dem abschließenden "m" in einer Zeichenfolge vorangestellt ist. Wenn das Beispiel in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, weil der weiche Bindestrich in der Such Zeichenfolge ignoriert wird, wird die-Methode aufgerufen, um eine Teil Zeichenfolge zu suchen, die aus dem Soft-Bindestrich und "m" besteht, die Position des "m" in der Zeichenfolge zurückgegeben, während Sie aufgerufen wird, um eine substrin zu suchen. g, der aus dem weichen Bindestrich und "n" besteht, gibt die Position des "n" zurück. Wenn die Such Zeichenfolge nur den weichen Bindestrich enthält, gibt die Methode den Index des "m" zurück, das den Wert `startIndex`von darstellt.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index aller Vorkommen einer Zeichenfolge in der Ziel Zeichenfolge gesucht, wobei vom Ende der Ziel Zeichenfolge bis zum Anfang der Ziel Zeichenfolge gearbeitet wird.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge der aktuellen Instanz.  
  
- oder - 
Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als -1 oder größer als 0 (null).</exception>
        <block subset="none" type="usage"><para>Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen. Um den Index einer Teil Zeichenfolge zu suchen, die einer bestimmten Zeichenposition vorangestellt ist, indem Sie die Vergleichs Regeln der aktuellen <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> Kultur verwenden, rufen Sie die <see cref="F:System.StringComparison.CurrentCulture" /> -Methoden <paramref name="comparisonType" /> Überladung mit dem Wert für den-Parameter auf.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des letzten Vorkommens einer angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Ein Parameter gibt den Typ der Suche für die angegebene Zeichenfolge an.</summary>
        <returns>Die nullbasierte Indexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, andernfalls -1. Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, ist der Rückgabewert die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null. Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte <xref:System.String.Length%2A> den Wert-1.  
  
 Der `comparisonType` -Parameter gibt an, dass `value` mithilfe der aktuellen oder der invarianten Kultur nach dem-Parameter gesucht werden soll, wobei die Groß-/Kleinschreibung beachtet wird und die Suche ohne Beachtung der Groß-/Kleinschreibung verwendet wird.  
  
 Die Suche beginnt an der letzten Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder `value` gefunden wird oder die erste Zeichenposition überprüft wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei über Ladungen der <xref:System.String.LastIndexOf%2A> -Methode veranschaulicht, die das letzte Vorkommen einer Zeichenfolge in einer anderen Zeichenfolge mithilfe verschiedener Werte <xref:System.StringComparison> der-Enumeration suchen.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="options" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> nur aus mindestens einem Ignorable-Zeichen besteht, gibt <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> die Methode immer <see cref="P:System.String.Length" /> -1 zurück, das die letzte Indexposition in der aktuellen Instanz darstellt.  
  
Im folgenden Beispiel wird die <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> -Methode verwendet, um drei Teil Zeichenfolgen zu suchen (ein weicher Bindestrich (U + 00ad), ein weicher Bindestrich gefolgt von "n" und ein weicher Bindestrich, gefolgt von "m") in zwei Zeichen folgen. Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich. Wenn das Beispiel in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, da der weiche Bindestrich ein ignorierbares Zeichen ist, gibt eine Kultur abhängige Suche denselben Wert zurück, der zurückgegeben wird, wenn der weiche Bindestrich nicht in der Such Zeichenfolge enthalten wäre. Bei einer ordinalsuchsuche wird jedoch der weiche Bindestrich in einer Zeichenfolge gefunden, und es wird gemeldet, dass Sie in der zweiten Zeichenfolge nicht vorhanden ist.  
  
[! Code-csharp[System. String. LastIndexOf # 26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [! Code-vb[System. String. LastIndexOf # 26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Das zu suchende Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens des angegebenen Unicode-Zeichens in einer Teilzeichenfolge dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, oder -1, wenn es nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null. Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte <xref:System.String.Length%2A> den Wert-1.  
  
 Diese Methode beginnt mit der Suche `startIndex` an der Zeichenposition und geht rückwärts zum Anfang dieser Instanz, bis `value` entweder gefunden wird `count` oder Zeichen Positionen überprüft wurden. Wenn `startIndex` z. b. <xref:System.String.Length%2A> -1 ist, durchsucht die `count` -Methode rückwärts Zeichen aus dem letzten Zeichen in der Zeichenfolge. Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.  
  
 Diese Methode führt eine Ordinalzahl (Kultur unabhängige Suche) aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn der zugehörige Unicode-Skalarwert identisch ist. Um eine Kultur abhängige Suche auszuführen, verwenden Sie die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (U + 00c6), als äquivalent zu jedem Vorkommen der Komponenten des Zeichens im richtige Reihenfolge, z. b. "AE" (u + 0041, u + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index aller Vorkommen eines Zeichens in einer Teil Zeichenfolge gefunden. dabei wird vom Ende der Teil Zeichenfolge bis zum Anfang der Teil Zeichenfolge gearbeitet.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer oder gleich der Länge dieser Instanz.  
  
- oder - 
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> - <paramref name="count" /> + 1 ist kleiner als 0 (null).</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</summary>
        <returns>Die nullbasierte Anfangsindexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null. Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte <xref:System.String.Length%2A> den Wert-1.  
  
 Die Suche beginnt an der `startIndex` Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder `value` gefunden wird oder `count` Zeichen Positionen überprüft wurden. Wenn `startIndex` z. b. <xref:System.String.Length%2A> -1 ist, durchsucht die `count` -Methode rückwärts Zeichen aus dem letzten Zeichen in der Zeichenfolge.  
  
 Diese Methode führt unter Verwendung der aktuellen Kultur eine Wort Suche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` nur aus mindestens einem Ignorable-Zeichen besteht, gibt <xref:System.String.LastIndexOf%2A> die Methode immer `startIndex`zurück. Dies ist die Zeichenposition, an der die Suche beginnt. Im folgenden Beispiel wird die <xref:System.String.LastIndexOf%2A> -Methode verwendet, um die Position eines weichen Bindestrichs (U + 00ad) in den zwei Zeichen zu finden, die dem abschließenden "m" der beiden Zeichen folgen vorangestellt sind. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, wird in beiden Fällen, da der weiche Bindestrich ein ignorierbares Zeichen ist, die Methode den Index von "m" in der Zeichenfolge zurückgibt, wenn Sie einen Kultur abhängigen Vergleich durchführt. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index aller Vorkommen einer Zeichenfolge in der Teil Zeichenfolge gesucht, wobei vom Ende der Teil Zeichenfolge bis zum Anfang der Teil Zeichenfolge gearbeitet wird.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist ein negativer Wert.  
  
- oder - 
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder - 
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist größer als die Länge dieser Instanz.  
  
- oder - 
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> - <paramref name="count" />+ 1 gibt eine Position an, die nicht innerhalb dieser Instanz liegt.  
  
- oder - 
Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="start" /> ist kleiner als -1 oder größer als 0 (null).  
  
- oder - 
Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="count" /> ist größer als 1.</exception>
        <block subset="none" type="usage"><para>Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen. Um diesen Vorgang mithilfe der Vergleichs Regeln der aktuellen Kultur auszuführen, müssen Sie die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> -Methoden Überladung mit dem <see cref="F:System.StringComparison.CurrentCulture" /> Wert für <paramref name="comparisonType" /> den-Parameter aufrufen.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des letzten Vorkommens einer angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt. Ein Parameter gibt den Typ des bei der Suche nach der angegebenen Zeichenfolge auszuführenden Vergleichs an.</summary>
        <returns>Die nullbasierte Anfangsindexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null. Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte <xref:System.String.Length%2A> den Wert-1.  
  
 Die Suche beginnt an der `startIndex` Zeichenposition und wird rückwärts verlaufen, `value` bis entweder gefunden wird oder die erste Zeichenposition untersucht wurde. Wenn `startIndex` z. b. <xref:System.String.Length%2A> -1 ist, durchsucht die-Methode alle Zeichen vom letzten Zeichen in der Zeichenfolge bis zum Anfang.  
  
 Der `comparisonType` -Parameter gibt an, dass `value` mithilfe der aktuellen oder der invarianten Kultur nach dem-Parameter gesucht werden soll, wobei die Groß-/Kleinschreibung beachtet wird und die Suche ohne Beachtung der Groß-/Kleinschreibung verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei über Ladungen der <xref:System.String.LastIndexOf%2A> -Methode veranschaulicht, die das letzte Vorkommen einer Zeichenfolge in einer anderen Zeichenfolge mithilfe verschiedener Werte <xref:System.StringComparison> der-Enumeration suchen.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge der aktuellen Instanz.  
  
- oder - 
Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als -1 oder größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> nur aus mindestens einem Ignorable-Zeichen besteht, gibt <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> die Methode immer <paramref name="startIndex" />zurück. Dies ist die Zeichenposition, an der die Suche beginnt.  
  
Im folgenden Beispiel wird die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> -Methode verwendet, um die Position eines Soft Bindestrichs (U + 00ad), gefolgt von einem "m", zu suchen, beginnend mit dem abschließenden "m" in zwei Zeichen folgen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, wird in beiden Fällen, da der weiche Bindestrich ein ignorierbares Zeichen ist, die Methode den Index von "m" in der Zeichenfolge zurückgibt, wenn Sie einen Kultur abhängigen Vergleich durchführt. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt. Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.  
  
[! Code-csharp[System. String. LastIndexOf # 25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [! Code-vb[System. String. LastIndexOf # 25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge. Ein Parameter gibt den Typ des bei der Suche nach der angegebenen Zeichenfolge auszuführenden Vergleichs an.</summary>
        <returns>Die nullbasierte Anfangsindexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null. Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte <xref:System.String.Length%2A> den Wert-1.  
  
 Die Suche beginnt an der `startIndex` Zeichenposition und wird rückwärts verlaufen, `value` bis entweder gefunden `count` wird oder Zeichen Positionen überprüft wurden. Wenn `startIndex` z. b. <xref:System.String.Length%2A> -1 ist, durchsucht die `count` -Methode rückwärts Zeichen aus dem letzten Zeichen in der Zeichenfolge.  
  
 Der `comparisonType` -Parameter gibt an, dass `value` mithilfe der aktuellen oder der invarianten Kultur nach dem-Parameter gesucht werden soll, wobei die Groß-/Kleinschreibung beachtet wird und die Suche ohne Beachtung der Groß-/Kleinschreibung verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei über Ladungen der <xref:System.String.LastIndexOf%2A> -Methode veranschaulicht, die das letzte Vorkommen einer Zeichenfolge in einer anderen Zeichenfolge mithilfe verschiedener Werte <xref:System.StringComparison> der-Enumeration suchen.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist ein negativer Wert.  
  
- oder - 
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder - 
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist größer als die Länge dieser Instanz.  
  
- oder - 
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> + 1 - <paramref name="count" /> gibt eine Position an, die nicht innerhalb dieser Instanz liegt.  
  
- oder - 
Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="start" /> ist kleiner als -1 oder größer als 0 (null).  
  
- oder - 
Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="count" /> ist größer als 1.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> nur aus mindestens einem Ignorable-Zeichen besteht, gibt <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> die Methode immer <paramref name="startIndex" />zurück. Dies ist die Zeichenposition, an der die Suche beginnt.  
  
Im folgenden Beispiel wird die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> -Methode verwendet, um die Position eines Soft-Bindestrichs (U + 00ad), gefolgt von einem "m", als die erste Zeichenposition vor dem abschließenden "m" in zwei Zeichen folgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel in [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, wird in beiden Fällen, da der weiche Bindestrich ein ignorierbares Zeichen ist, die Methode den Index von "m" in der Zeichenfolge zurückgibt, wenn Sie einen Kultur abhängigen Vergleich durchführt. Wenn ein Ordinalvergleich durchführt, wird die Teil Zeichenfolge jedoch nur in der ersten Zeichenfolge gefunden. Beachten Sie, dass bei der ersten Zeichenfolge, die den weichen Bindestrich, gefolgt von einem "m", die Methode nicht den Index des weichen Bindestrichs zurückgibt, sondern den Index des "m" zurückgibt, wenn ein Kultur abhängiger Vergleich durchgeführt wird. Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.  
  
[! Code-csharp[System. String. LastIndexOf # 24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [! Code-vb[System. String. LastIndexOf # 24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an. Die Methode gibt -1 zurück, wenn die Zeichen im Array nicht in dieser Instanz gefunden werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an.</summary>
        <returns>Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null.  
  
 Diese Methode beginnt mit der Suche an der letzten Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder ein Zeichen `anyOf` in gefunden wird oder die erste Zeichenposition überprüft wurde. Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.  
  
 Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind. Um eine Kultur abhängige Suche auszuführen, verwenden Sie die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (U + 00c6), als äquivalent zu jedem Vorkommen der Komponenten des Zeichens im richtige Reihenfolge, z. b. "AE" (u + 0041, u + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index des letzten Vorkommens eines beliebigen Zeichens in der Zeichenfolge "is" in einer anderen Zeichenfolge gefunden.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</summary>
        <returns>Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde, oder wenn die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null.  
  
 Diese Methode beginnt mit der Suche `startIndex` an der Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder ein Zeichen `anyOf` in gefunden wird oder die erste Zeichenposition überprüft wurde. Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.  
  
 Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind. Um eine Kultur abhängige Suche auszuführen, verwenden Sie die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (U + 00c6), als äquivalent zu jedem Vorkommen der Komponenten des Zeichens im richtige Reihenfolge, z. b. "AE" (u + 0041, u + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index des letzten Vorkommens eines beliebigen Zeichens in der Zeichenfolge "is" in einer Teil Zeichenfolge einer anderen Zeichenfolge gefunden.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> gibt eine Position an, die nicht innerhalb dieser Instanz liegt.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</summary>
        <returns>Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde, oder wenn die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Nummerierung beginnt bei Null.  
  
 Diese Methode beginnt mit der Suche `startIndex` an der Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder ein Zeichen `anyOf` in gefunden wird `count` oder Zeichen Positionen überprüft wurden. Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.  
  
 Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind. Um eine Kultur abhängige Suche auszuführen, verwenden Sie die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (U + 00c6), als äquivalent zu jedem Vorkommen der Komponenten des Zeichens im richtige Reihenfolge, z. b. "AE" (u + 0041, u + 0045), abhängig von der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index des letzten Vorkommens eines beliebigen Zeichens in der Zeichenfolge "Aid" in einer Teil Zeichenfolge einer anderen Zeichenfolge gesucht.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder - 
Die aktuelle Instanz ist nicht gleich <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> minus <paramref name="count" /> + 1 ist weniger als 0 (null).</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Zeichen im aktuellen <see cref="T:System.String" />-Objekt ab.</summary>
        <value>Die Anzahl der Zeichen in der aktuellen Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Length%2A> -Eigenschaft gibt die <xref:System.Char> Anzahl der-Objekte in dieser Instanz zurück, nicht die Anzahl der Unicode-Zeichen. Der Grund hierfür ist, dass ein Unicode-Zeichen durch mehr als eins <xref:System.Char>dargestellt werden kann. Verwenden Sie <xref:System.Globalization.StringInfo?displayProperty=nameWithType> die-Klasse, um mit jedem Unicode-Zeichen <xref:System.Char>anstelle von jedem zu arbeiten.  
  
 In einigen Sprachen, wie z. b C++. C und, gibt ein NULL-Zeichen das Ende einer Zeichenfolge an. In .net kann ein NULL-Zeichen in eine Zeichenfolge eingebettet werden. Wenn eine Zeichenfolge ein oder mehrere NULL Zeichen enthält, sind Sie in der Länge der gesamten Zeichenfolge enthalten. In der folgenden Zeichenfolge werden z. b. die Teil Zeichenfolgen "ABC" und "Def" durch ein NULL-Zeichen voneinander getrennt. Die <xref:System.String.Length%2A> -Eigenschaft gibt 7 zurück, was darauf hinweist, dass Sie die sechs alphabetischen Zeichen sowie das NULL-Zeichen enthält.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Length%2A> -Eigenschaft veranschaulicht.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine neue Zeichenfolge zurück, deren binäre Darstellung in einer bestimmten Unicode-Normalisierungsform vorliegt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine neue Zeichenfolge zurück, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der Unicode-Normalisierungsform C vorliegt.</summary>
        <returns>Eine neue normalisierte Zeichenfolge, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der Normalisierungsform C vorliegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Unicode-Zeichen verfügen über mehrere äquivalente binäre Darstellungen, die aus Mengen von Kombination aus und/oder zusammengesetzten Unicode-Zeichen bestehen Beispielsweise kann jeder der folgenden Code Punkte den Buchstaben "ắ" darstellen:  
  
-   U + 1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Das vorhanden sein mehrerer Darstellungen für ein einzelnes Zeichen erschwert das suchen, sortieren, abgleichen und andere Vorgänge.  
  
 Der Unicode-Standard definiert einen Prozess namens Normalisierung, der eine binäre Darstellung zurückgibt, wenn eine der äquivalenten binären Darstellungen eines Zeichens angegeben wird. Die Normalisierung kann mit mehreren Algorithmen durchgeführt werden, die als normalisierungs Formulare bezeichnet werden, die unterschiedliche Regeln einhalten. .NET unterstützt die vier Normalisierungsformen (C, D, KC und KD), die durch den Unicode-Standard definiert werden. Wenn zwei Zeichen folgen in derselben normalisierungs Form dargestellt werden, können Sie mithilfe eines Ordinalvergleichs verglichen werden.  
  
 Gehen Sie folgendermaßen vor, um zwei Zeichen folgen zu normalisieren und zu vergleichen:  
  
1.  Abrufen der Zeichen folgen, die von einer Eingabe Quelle, z. b. einer Datei oder einem Benutzereingabe Gerät, verglichen werden sollen.  
  
2.  Ruft die <xref:System.String.Normalize> -Methode auf, um die Zeichen folgen in die normalisierungs Form C zu normalisieren.  
  
3.  Um zwei Zeichen folgen zu vergleichen, müssen Sie eine Methode, die einen ordinalen Zeichen folgen <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> Vergleich unterstützt, wie z. b <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> . die <xref:System.StringComparison> -Methode, und einen Wert von <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> oder als Argument angeben. Um ein Array von normalisierten Zeichen folgen zu sortieren, `comparer` übergeben Sie <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> einen <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> Wert von oder an eine <xref:System.Array.Sort%2A?displayProperty=nameWithType>entsprechende Überladung von.  
  
4.  Geben Sie die Zeichen folgen in der sortierten Ausgabe basierend auf der im vorherigen Schritt angegebenen Reihenfolge aus.  
  
 Eine Beschreibung der unterstützten Unicode-Normalisierungsformen <xref:System.Text.NormalizationForm?displayProperty=nameWithType>finden Sie unter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in jede von vier normalisierungs Formularen normalisiert, bestätigt, dass die Zeichenfolge in die angegebene normalisierungs Form normalisiert wurde, und listet dann die Code Punkte in der normalisierten Zeichenfolge auf.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</exception>
        <block subset="none" type="usage"><para>Die <see cref="Overload:System.String.IsNormalized" /> Methode gibt <see langword="false" /> zurück, sobald Sie das erste nicht normalisierte Zeichen in einer Zeichenfolge findet. Wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält, löst <see cref="Overload:System.String.Normalize" /> die Methode daher eine <see cref="T:System.ArgumentException" /> aus <see cref="Overload:System.String.IsNormalized" /> , <see langword="false" />obwohl zurückgibt.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Eine Unicode-Normalisierungsform.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der angegebenen Unicode-Normalisierungsform vorliegt.</summary>
        <returns>Eine neue Zeichenfolge, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der im <paramref name="normalizationForm" />-Parameter angegebenen Normalisierungsform vorliegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Unicode-Zeichen verfügen über mehrere äquivalente binäre Darstellungen, die aus Mengen von Kombination aus und/oder zusammengesetzten Unicode-Zeichen bestehen Das vorhanden sein mehrerer Darstellungen für ein einzelnes Zeichen erschwert das suchen, sortieren, abgleichen und andere Vorgänge.  
  
 Der Unicode-Standard definiert einen Prozess namens Normalisierung, der eine binäre Darstellung zurückgibt, wenn eine der äquivalenten binären Darstellungen eines Zeichens angegeben wird. Die Normalisierung kann mit mehreren Algorithmen durchgeführt werden, die als normalisierungs Formulare bezeichnet werden, die unterschiedliche Regeln einhalten. .NET unterstützt die vier Normalisierungsformen (C, D, KC und KD), die durch den Unicode-Standard definiert werden. Wenn zwei Zeichen folgen in derselben normalisierungs Form dargestellt werden, können Sie mithilfe eines Ordinalvergleichs verglichen werden.  
  
 Gehen Sie folgendermaßen vor, um zwei Zeichen folgen zu normalisieren und zu vergleichen:  
  
1.  Abrufen der Zeichen folgen, die von einer Eingabe Quelle, z. b. einer Datei oder einem Benutzereingabe Gerät, verglichen werden sollen.  
  
2.  Ruft die <xref:System.String.Normalize%28System.Text.NormalizationForm%29> -Methode auf, um die Zeichen folgen auf eine angegebene normalisierungs Form zu normalisieren.  
  
3.  Um zwei Zeichen folgen zu vergleichen, müssen Sie eine Methode, die einen ordinalen Zeichen folgen <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> Vergleich unterstützt, wie z. b <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> . die <xref:System.StringComparison> -Methode, und einen Wert von <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> oder als Argument angeben. Um ein Array von normalisierten Zeichen folgen zu sortieren, `comparer` übergeben Sie <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> einen <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> Wert von oder an eine <xref:System.Array.Sort%2A?displayProperty=nameWithType>entsprechende Überladung von.  
  
4.  Geben Sie die Zeichen folgen in der sortierten Ausgabe basierend auf der im vorherigen Schritt angegebenen Reihenfolge aus.  
  
 Eine Beschreibung der unterstützten Unicode-Normalisierungsformen <xref:System.Text.NormalizationForm?displayProperty=nameWithType>finden Sie unter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge in jede von vier normalisierungs Formularen normalisiert, bestätigt, dass die Zeichenfolge in die angegebene normalisierungs Form normalisiert wurde, und listet dann die Code Punkte in der normalisierten Zeichenfolge auf.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</exception>
        <block subset="none" type="usage"><para>Die <see cref="Overload:System.String.IsNormalized" /> Methode gibt <see langword="false" /> zurück, sobald Sie das erste nicht normalisierte Zeichen in einer Zeichenfolge findet. Wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält, kann <see cref="Overload:System.String.Normalize" /> die Methode daher eine <see cref="T:System.ArgumentException" /> auslösen <see cref="Overload:System.String.IsNormalized" /> , <see langword="false" />obwohl zurückgibt.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="b">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene Zeichenfolgen denselben Wert haben.</summary>
        <returns><see langword="true" />, wenn <paramref name="a" /> und <paramref name="b" /> denselben Wert haben, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.op_Equality%2A> -Methode definiert den Vorgang des Gleichheits Operators für <xref:System.String> die-Klasse. Dadurch wird Code wie im Beispiel Abschnitt angezeigt. Der-Operator ruft wiederum die statische <xref:System.String.Equals%28System.String%2CSystem.String%29> -Methode auf, die einen Ordinalvergleich (Groß-/Kleinschreibung und Kultur unabhängige) ausführt.  
  
> [!NOTE]
>  Der Visual Basic-Compiler löst den Gleichheits Operator nicht als Aufrufe der <xref:System.String.op_Equality%2A> -Methode auf. Stattdessen umschließt der Gleichheits Operator einen Rückruf für <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> die-Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Gleichheits Operator veranschaulicht.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="b">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene Zeichenfolgen verschiedene Werte haben.</summary>
        <returns><see langword="true" />, wenn der Wert von <paramref name="a" /> vom Wert von <paramref name="b" /> verschieden ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.op_Inequality%2A> -Methode definiert den Vorgang des Ungleichheits Operators für <xref:System.String> die-Klasse.   Sie ermöglicht Code wie im Abschnitt "Beispiele".  
  
 Der <xref:System.String.op_Inequality%2A> -Operator ruft wiederum die statische <xref:System.String.Equals%28System.String%2CSystem.String%29> -Methode auf, die einen Ordinalvergleich (Groß-/Kleinschreibung und Kultur unabhängige) ausführt.  
  
> [!NOTE]
>  Der Visual Basic-Compiler löst den Ungleichheits Operator nicht als Aufrufe der <xref:System.String.op_Inequality%2A> -Methode auf. Stattdessen umschließt der Ungleichheits Operator einen Rückruf für <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> die-Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Ungleichheits Operator veranschaulicht.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine neue Zeichenfolge mit einer angegebenen Länge zurück, in der der Anfang der aktuellen Zeichenfolge mit Leerzeichen oder einem angegebenen Unicode-Zeichen aufgefüllt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, bei der die Zeichen in dieser Instanz rechtsbündig ausgerichtet werden, indem die linke Seite mit Leerzeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit Leerzeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird. Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück. Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Unicode-Leerzeichen ist als hexadezimal 0x0020 definiert.  
  
 Die <xref:System.String.PadLeft%28System.Int32%29> -Methode füllt den Anfang der zurückgegebenen Zeichenfolge auf. Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen der Rechte Teil der Zeichenfolge aufgefüllt wird.  
  
> [!NOTE]
>  Wenn die-Methode die aktuelle-Instanz mit Leerzeichen füllt, ändert diese Methode nicht den Wert der aktuellen Instanz. <xref:System.String.PadLeft%2A> Stattdessen wird eine neue Zeichenfolge zurückgegeben, die mit einem führenden Leerzeichen aufgefüllt wird, sodass die `totalWidth` Gesamtlänge Zeichen beträgt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.PadLeft%2A> Methode.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> ist kleiner als Null.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</param>
        <param name="paddingChar">Ein Unicode-Füllzeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, bei der die Zeichen in dieser Instanz rechtsbündig ausgerichtet werden, indem die linke Seite mit einem angegebenen Unicode-Zeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit <paramref name="paddingChar" />-Zeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird. Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück. Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> -Methode füllt den Anfang der zurückgegebenen Zeichenfolge auf. Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen der Rechte Teil der Zeichenfolge aufgefüllt wird.  
  
> [!NOTE]
>  Wenn die-Methode die aktuelle-Instanz mit Leerzeichen füllt, ändert diese Methode nicht den Wert der aktuellen Instanz. <xref:System.String.PadLeft%2A> Stattdessen wird eine neue Zeichenfolge zurückgegeben, die mit führenden `paddingChar` Zeichen aufgefüllt wird, sodass die Gesamt `totalWidth` Länge Zeichen beträgt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.PadLeft%2A> Methode.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> ist kleiner als Null.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine neue Zeichenfolge mit einer angegebenen Länge zurück, in der das Ende der aktuellen Zeichenfolge mit Leerzeichen oder einem angegebenen Unicode-Zeichen aufgefüllt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, deren Zeichen linksbündig ausgerichtet werden, indem die rechte Seite mit Leerzeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit Leerzeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird. Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück. Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Unicode-Leerzeichen ist als hexadezimal 0x0020 definiert.  
  
 Die <xref:System.String.PadRight%28System.Int32%29> -Methode füllt das Ende der zurückgegebenen Zeichenfolge auf. Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen der linke Teil der Zeichenfolge aufgefüllt wird.  
  
> [!NOTE]
>  Wenn die-Methode die aktuelle-Instanz mit Leerzeichen füllt, ändert diese Methode nicht den Wert der aktuellen Instanz. <xref:System.String.PadRight%2A> Stattdessen wird eine neue Zeichenfolge zurückgegeben, die mit nachfolgenden Leerzeichen aufgefüllt wird, sodass die `totalWidth` Gesamtlänge Zeichen beträgt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.PadRight%2A> Methode.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> ist kleiner als Null.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</param>
        <param name="paddingChar">Ein Unicode-Füllzeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, deren Zeichen linksbündig ausgerichtet werden, indem die rechte Seite mit einem angegebenen Unicode-Zeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit <paramref name="paddingChar" />-Zeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird. Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück. Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> -Methode füllt das Ende der zurückgegebenen Zeichenfolge auf. Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen der linke Teil der Zeichenfolge aufgefüllt wird.  
  
> [!NOTE]
>  Wenn die-Methode die aktuelle-Instanz mit Leerzeichen füllt, ändert diese Methode nicht den Wert der aktuellen Instanz. <xref:System.String.PadRight%2A> Stattdessen wird eine neue Zeichenfolge zurückgegeben, die mit nachfolg `paddingChar` enden Zeichen aufgefüllt wird, sodass die `totalWidth` Gesamtlänge Zeichen beträgt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.PadRight%2A> Methode.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> ist kleiner als Null.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine neue Zeichenfolge zurück, in der eine angegebene Anzahl von Zeichen aus der aktuellen Zeichenfolge gelöscht wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Position, ab der Zeichen gelöscht werden sollen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der alle Zeichen in der aktuellen Instanz, beginnend an einer angegebenen Position und sich über die letzte Position fortsetzend, gelöscht wurden.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Zeichenfolge ohne die entfernten Zeichen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]In sind Zeichen folgen Null basiert. Der Wert des `startIndex` -Parameters kann zwischen null und eins liegen, der kleiner als die Länge der Zeichen folgen Instanz ist.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen `startIndex` von der Position bis zum Ende der ursprünglichen Zeichenfolge entfernt wurden.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Remove%2A> Methode. Der nächste Fall entfernt den gesamten Text, beginnend ab dem angegebenen Index bis zum Ende der Zeichenfolge. Im letzten Fall werden drei Zeichen entfernt, beginnend beim angegebenen Index.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> gibt eine Position an, die sich nicht innerhalb der Zeichenfolge befindet.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Position, ab der Zeichen gelöscht werden sollen.</param>
        <param name="count">Die Anzahl der zu löschenden Zeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der eine bestimmte Anzahl von Zeichen in er aktuellen Instanz, beginnend an einer angegebenen Position, gelöscht wurden.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz ohne die entfernten Zeichen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]In sind Zeichen folgen Null basiert. Der Wert des `startIndex` -Parameters kann zwischen null und eins liegen, der kleiner als die Länge der Zeichen folgen Instanz ist.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der die durch den `count` -Parameter angegebene Anzahl von Zeichen entfernt wurde. Die Zeichen werden an der durch `startIndex`angegebenen Position entfernt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie den Vornamen aus einem kompletten Namen entfernen können.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Entweder <paramref name="startIndex" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
- oder - 
 <paramref name="startIndex" /> plus <paramref name="count" /> bezeichnen eine Position außerhalb dieser Instanz.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen von einem angegebenen Unicode-Zeichen oder <see cref="T:System.String" /> in der aktuellen Zeichenfolge durch ein anderes angegebenes Unicode-Zeichen oder einen anderen <see cref="T:System.String" /> ersetzt werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Das zu ersetzende Unicode-Zeichen.</param>
        <param name="newChar">Das Unicode-Zeichen, das jedes Vorkommen von <paramref name="oldChar" /> ersetzen soll.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen eines angegebenen Unicode-Zeichens in dieser Instanz durch ein anderes angegebenes Unicode-Zeichen ersetzt wurden.</summary>
        <returns>Eine Zeichenfolge, die dieser Instanz entspricht, außer dass alle Instanzen von <paramref name="oldChar" /> durch <paramref name="newChar" /> ersetzt werden. Wenn <paramref name="oldChar" /> nicht in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt eine zu `oldChar`suchende Ordinalsuche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle `oldChar` Vorkommen von durch `newChar`ersetzt werden.  
  
 Da diese Methode die geänderte Zeichenfolge zurückgibt, können Sie aufeinander folgende Aufrufe der <xref:System.String.Replace%2A> -Methode verketten, um mehrere Ersetzungen in der ursprünglichen Zeichenfolge auszuführen. Methodenaufrufe werden von links nach rechts ausgeführt. Dies wird im folgenden Beispiel veranschaulicht.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine durch Kommas getrennte Liste erstellt, indem die Leerzeichen zwischen einer Reihe von Zahlen durch Kommas ersetzt werden.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Die zu ersetzende Zeichenfolge.</param>
        <param name="newValue">Die Zeichenfolge, die jedes Vorkommen von <paramref name="oldValue" /> ersetzen soll.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen einer angegebenen Zeichenfolge in der aktuellen Instanz durch eine andere angegebene Zeichenfolge ersetzt wurden.</summary>
        <returns>Eine Zeichenfolge, die der aktuellen Zeichenfolge entspricht, außer dass alle Instanzen von <paramref name="oldValue" /> durch <paramref name="newValue" /> ersetzt werden. Wenn <paramref name="oldValue" /> nicht in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `newValue`den Wert `oldValue` hat, werden alle Vorkommen von entfernt. `null`  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle `oldValue` Vorkommen von durch `newValue`ersetzt werden.  
  
 Diese Methode führt eine zu `oldValue`suchende Ordinalsuche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch.  
  
 Da diese Methode die geänderte Zeichenfolge zurückgibt, können Sie aufeinander folgende Aufrufe der <xref:System.String.Replace%2A> -Methode verketten, um mehrere Ersetzungen in der ursprünglichen Zeichenfolge auszuführen. Methodenaufrufe werden von links nach rechts ausgeführt. Dies wird im folgenden Beispiel veranschaulicht.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie die <xref:System.String.Replace%2A> -Methode verwenden können, um einen Rechtschreibfehler zu korrigieren.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> ist die leere Zeichenfolge ("").</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein Zeichenfolgenarray zurück, das die Teilzeichenfolgen dieser Instanz enthält, die durch Elemente eines angegebenen Zeichenfolgen- oder Unicode-Zeichenarrays getrennt sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A>wird verwendet, um eine Zeichenfolge mit Trennzeichen in Teil Zeichenfolgen zu zerlegen. Sie können entweder ein Zeichen Array verwenden, um NULL, ein oder mehrere Trennzeichen (die <xref:System.String.Split%28System.Char%5B%5D%29> -Methode) anzugeben, oder Sie können ein Zeichen Array verwenden, um NULL, eine Zeichenfolge oder mehrere Trennzeichen als Zeichen folgen anzugeben. Über Ladungen der <xref:System.String.Split%2A> -Methode ermöglichen es Ihnen, die Anzahl der von der-Methode (der <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> -Methode) zurückgegebenen Teil Zeichenfolgen einzuschränken, um zu bestimmen, ob leere Zeichen folgen <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> in <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> die zurückgegebenen Teil Zeichenfolgen (die-und-Methoden) eingeschlossen werden (die-Methode und <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> die <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> -Methode).  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>Alternativen zu String. Split

 Die <xref:System.String.Split%2A> -Methode ist nicht immer die beste Möglichkeit, eine Zeichenfolge mit Trennzeichen in Teil Zeichenfolgen zu unterteilen. Wenn Sie nicht alle Teil Zeichenfolgen einer durch Trennzeichen getrennten Zeichenfolge extrahieren möchten oder wenn Sie eine Zeichenfolge auf Grundlage eines Musters anstelle eines Satzes von Trennzeichen analysieren möchten, sollten Sie die folgenden Alternativen in Erwägung ziehen.  
  
### <a name="regular-expressions"></a>Reguläre Ausdrücke  
 Wenn die Zeichen folgen einem festen Muster entsprechen, können Sie einen regulären Ausdruck verwenden, um ihre Elemente zu extrahieren und zu verarbeiten. Wenn Zeichen folgen z. b. die Form "*Number* *Operand* *Number*" haben, können Sie einen [regulären Ausdruck](~/docs/standard/base-types/regular-expressions.md) verwenden, um die Elemente der Zeichenfolge zu extrahieren und zu verarbeiten. Im Folgenden ein Beispiel:  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Das Muster `(\d+)\s+([-+*/])\s+(\d+)` für reguläre Ausdrücke wird wie folgt definiert:  
  
|Muster|Beschreibung|  
|-------------|-----------------|  
|`(\d+)`|Entsprechung für mindestens eine Dezimalstelle finden. Dies ist die erste Erfassungsgruppe.|  
|`\s+`|Entspricht einem oder mehreren Leerzeichen.|  
|`([-+*/])`|Entsprechung für ein arithmetisches Operator Zeichen (+,-, * oder/). Dies ist die zweite Erfassungsgruppe.|  
|`\s+`|Entspricht einem oder mehreren Leerzeichen.|  
|`(\d+)`|Entsprechung für mindestens eine Dezimalstelle finden. Dies ist die dritte Erfassungsgruppe.|  
  
 Sie können auch einen regulären Ausdruck verwenden, um Teil Zeichenfolgen auf der Grundlage eines Musters anstelle eines festen Zeichensatzes aus einer Zeichenfolge zu extrahieren. Dies ist ein häufiges Szenario, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Mindestens eines der Trennzeichen dient nicht immer als Trennzeichen in der <xref:System.String> -Instanz.  
  
-   Die Sequenz und die Anzahl der Trennzeichen sind variabel oder unbekannt.  
  
 Beispielsweise kann die <xref:System.String.Split%2A> -Methode nicht zum Aufteilen der folgenden Zeichenfolge verwendet werden, da die `\n` Anzahl von C#(in `vbCrLf` ) oder (in Visual Basic)-Zeichen variabel ist und nicht immer als Trennzeichen fungieren.  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 Ein regulärer Ausdruck kann diese Zeichenfolge leicht aufteilen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Das Muster `\[([^\[\]]+)\]` für reguläre Ausdrücke wird wie folgt definiert:  
  
|Muster|Beschreibung|  
|-------------|-----------------|  
|`\[`|Entspricht einer öffnenden Klammer.|  
|`([^\[\]]+)`|Entsprechung für ein beliebiges Zeichen, das keine öffnende oder schließende eckige Klammer ist, einmal oder mehrmals. Dies ist die erste Erfassungsgruppe.|  
|`\]`|Entsprechung für eine schließende Klammer.|  
  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> -Methode ist nahezu identisch <xref:System.String.Split%2A?displayProperty=nameWithType>mit, mit der Ausnahme, dass Sie eine Zeichenfolge auf Grundlage eines Musters für reguläre Ausdrücke anstelle eines festen Zeichensatzes aufteilt. Im folgenden Beispiel wird beispielsweise die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> -Methode verwendet, um eine Zeichenfolge zu teilen, die Teil Zeichenfolgen enthält, die durch verschiedene Kombinationen von Bindestrichen und anderen Zeichen getrennt sind.  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Das Muster `\s-\s?[+*]?\s?-\s` für reguläre Ausdrücke wird wie folgt definiert:  
  
|Muster|Beschreibung|  
|-------------|-----------------|  
|`\s-`|Entspricht einem Leerzeichen, gefolgt von einem Bindestrich.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen.|  
|`[+*]?`|Entsprechung für NULL oder ein Vorkommen des Zeichens "+" oder "*".|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen.|  
|`-\s`|Entspricht einem Bindestrich, gefolgt von einem Leerzeichen.|  
  
### <a name="search-methods-and-the-substring-method"></a>Suchmethoden und die Substring-Methode  
 Wenn Sie nicht an allen Teil Zeichenfolgen in einer Zeichenfolge interessiert sind, empfiehlt es sich, mit einer der Methoden für den Zeichen folgen Vergleich zu arbeiten, die den Index zurückgibt, bei dem die Überprüfung beginnt. Sie können dann die <xref:System.String.Substring%2A> -Methode zum Extrahieren der gewünschten Teil Zeichenfolge aufzurufen. Die Methoden für den Zeichen folgen Vergleich umfassen Folgendes:  
  
-   <xref:System.String.IndexOf%2A>Gibt den NULL basierten Index des ersten Vorkommens eines Zeichens oder einer Zeichenfolge in einer Zeichen folgen Instanz zurück.  
  
-   <xref:System.String.IndexOfAny%2A>, der den NULL basierten Index in der aktuellen Zeichen folgen Instanz des ersten Vorkommens eines beliebigen Zeichens in einem Zeichen Array zurückgibt.  
  
-   <xref:System.String.LastIndexOf%2A>Gibt den NULL basierten Index des letzten Vorkommens eines Zeichens oder einer Zeichenfolge in einer Zeichen folgen Instanz zurück.  
  
-   <xref:System.String.LastIndexOfAny%2A>, die einen NULL basierten Index in der aktuellen Zeichen folgen Instanz des letzten Vorkommens eines beliebigen Zeichens in einem Zeichen Array zurückgibt.  
  
 Im folgenden Beispiel wird die <xref:System.String.IndexOf%2A> -Methode verwendet, um die Zeiträume in einer Zeichenfolge zu suchen. Anschließend wird die <xref:System.String.Substring%2A> -Methode verwendet, um vollständige Sätze zurückzugeben.  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in Teilzeichenfolgen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen von dieser Instanz enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Zeichenfolge durch einen bekannten Zeichensatz getrennt ist, können Sie die <xref:System.String.Split%28System.Char%5B%5D%29> -Methode verwenden, um Sie in Teil Zeichenfolgen zu trennen.   
  
### <a name="return-value-details"></a>Rückgabewert Details  
 Trennzeichen sind nicht in den Elementen des zurückgegebenen Arrays enthalten. Wenn das Trennzeichen Array z. b. das Zeichen "-" enthält und der Wert der aktuellen Zeichen folgen Instanz "AA-BB-CC" ist, gibt die Methode ein Array zurück, das drei Elemente enthält: "AA", "BB" und "CC".  
  
 Wenn diese Instanz keines der Zeichen in `separator`enthält, besteht das zurückgegebene Array aus einem einzelnen Element, das diese Instanz enthält.  
  
 Jedes Element von `separator` definiert ein separates Trennzeichen. Wenn zwei Trennzeichen nebeneinander liegen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält <xref:System.String.Empty>das entsprechende Element im zurückgegebenen Array. Hier einige Beispiele:  
  
|Zeichen folgen Wert|Trennzeichen|Zurück gegebenes Array|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|New Char [] {', ', ' '} (C#)<br /><br /> Char () = {"," c "," c} "(Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|new Char[] {'.'} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|Bananen|new Char[] {'.'} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|{"Banana"}|  
|"Darb\nsmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|New Char [] {} (C#)<br /><br /> Char () = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nsmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
### <a name="the-separator-array"></a>Das Trennzeichen Array  
 Jedes Element des Trenn Zeichens definiert ein separates Trennzeichen, das aus einem einzelnen Zeichen besteht. Wenn das `separator` -Argument `null` ist oder keine Zeichen enthält, behandelt die Methode Leerzeichen als Trennzeichen. Leerzeichen werden durch den Unicode-Standard definiert. Sie geben `true` zurück, wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> -Methode übermittelt werden.  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>String. Split (Char []) und compilerüberladungs Auflösung  
 Obwohl der einzige Parameter für diese Überladung <xref:System.String.Split%2A?displayProperty=nameWithType> von ein Zeichen Array ist, können Sie ihn mit einem einzelnen Zeichen aufrufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Da der `separator` -Parameter mit dem <xref:System.ParamArrayAttribute> -Attribut versehen ist, interpretieren Compiler ein einzelnes Zeichen als ein Zeichen Array mit einem einzelnen Element. Dies ist nicht der Fall für andere <xref:System.String.Split%2A?displayProperty=nameWithType> über Ladungen, die einen `separator` -Parameter enthalten. Sie müssen diese Überladungen explizit als `separator` -Argument übergeben.  
  
### <a name="comparison-details"></a>Vergleichs Details  
 Die <xref:System.String.Split%28System.Char%5B%5D%29> -Methode extrahiert die Teil Zeichenfolgen in dieser Zeichenfolge, die durch ein oder mehrere der Zeichen `separator` im Array getrennt sind, und gibt diese Teil Zeichenfolgen als Elemente eines Arrays zurück.  
  
 Die <xref:System.String.Split%28System.Char%5B%5D%29> -Methode sucht nach Trennzeichen, indem Sie Vergleiche mithilfe von ordinalsortierungs Regeln für die Groß-und Kleinschreibung durchführt Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Sie unter der-Enumeration.  
  
### <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> -Methoden weisen Speicher für das zurückgegebene Array Objekt <xref:System.String> und ein-Objekt für jedes Array Element zu. Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung der Speicher Belegung in der Anwendung wichtig ist, <xref:System.String.IndexOf%2A> sollten <xref:System.String.IndexOfAny%2A> Sie die-Methode oder die-Methode verwenden. Sie haben auch die Möglichkeit, die <xref:System.String.Compare%2A> -Methode zu verwenden, um eine Teil Zeichenfolge innerhalb einer Zeichenfolge zu suchen.  
  
 Verwenden Sie die-Methode oder <xref:System.String.IndexOf%2A> <xref:System.String.IndexOfAny%2A> die-Methode, um eine Zeichenfolge mit einem Trennzeichen zu teilen. Um eine Zeichenfolge in eine Trenn Zeichenfolge aufzuteilen <xref:System.String.IndexOf%2A> , <xref:System.String.IndexOfAny%2A> verwenden Sie die-oder-Methode, um das erste Zeichen der Trenn Zeichenfolge zu suchen. Verwenden Sie dann <xref:System.String.Compare%2A> die-Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen gleich den verbleibenden Zeichen der Trenn Zeichenfolge sind.  
  
 Wenn außerdem die gleichen Zeichen folgen zum Aufteilen von Zeichen folgen in mehreren <xref:System.String.Split%2A> Methoden aufrufen verwendet werden, sollten Sie in Erwägung gezogen werden, ein einzelnes Array zu erstellen und in jedem Methodenaufruf darauf zu verweisen. Dadurch wird der zusätzliche mehr Aufwand für die einzelnen Methodenaufrufe erheblich reduziert.  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einzelne Wörter aus einem Textblock extrahiert werden, indem Leerzeichen und Satzzeichen als Trennzeichen behandelt werden. Das Zeichen Array, das an `separator` den-Parameter <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> der-Methode übergeben wird, besteht aus einem Leerzeichen und einem Tabstopp Zeichen sowie einigen allgemeinen Interpunktions Symbolen.  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> <paramref name="separator" /> <see cref="M:System.String.Split(System.Char[])" /> In und früheren Versionen verwendet die-Methode einen leicht abweichenden Satz von Zeichen, um die Zeichenfolge zu unterteilen, wenn die-Methode ein ist oder keine Zeichen enthält. [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] kürzen Sie die Zeichenfolge. Beginnend mit dem .NET Framework 4 verwenden beide Methoden einen identischen Satz von Unicode-Leerzeichen.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="count">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in eine maximale Anzahl von Teilzeichenfolgen. Sie geben außerdem die maximale Anzahl der zurückzugebenden Teilzeichenfolgen an.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Instanz enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trennzeichen sind nicht in den Elementen des zurückgegebenen Arrays enthalten.  
  
 Wenn diese Instanz keines der Zeichen in `separator`enthält, besteht das zurückgegebene Array aus einem einzelnen Element, das diese Instanz enthält. Wenn `count` 0 (null) ist, wird ein leeres Array zurückgegeben.  
  
 Wenn der `separator` -Parameter `null` ist oder keine Zeichen enthält, wird davon ausgegangen, dass Leerzeichen als Trennzeichen verwendet werden. Leerzeichen werden durch den Unicode-Standard definiert und geben zurück `true` , wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> -Methode übermittelt werden.  
  
 Jedes Element von `separator` definiert ein separates Trennzeichen. Wenn zwei Trennzeichen nebeneinander liegen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält <xref:System.String.Empty>das entsprechende Array Element.  
  
 Wenn in dieser Instanz mehr `count` als Teil Zeichenfolgen vorhanden sind, `count` werden die ersten minus 1 Teil Zeichenfolgen `count` in den ersten minus 1 Elementen des Rückgabewerts zurückgegeben, und die restlichen Zeichen in dieser Instanz werden in der letzten zurückgegeben. -Element des Rückgabewerts.  
  
 Wenn `count` größer als die Anzahl der Teil Zeichenfolgen ist, werden die verfügbaren Teil Zeichenfolgen zurückgegeben, und es wird keine Ausnahme ausgelöst.  
  
 In der folgenden Tabelle finden Sie Beispiele.  
  
|Zeichen folgen Wert|Trennzeichen|Anzahl|Zurück gegebenes Array|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|New Char [] {', ', ' '} (C#)<br /><br /> Char () = {"," c "," c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|new Char[] {'.'} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|Bananen|new Char[] {'.'} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nsmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|New Char [] {} (C#)<br /><br /> Char () = {} (Visual Basic)|1|{"Darb\nsmarba"} (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|  
|"Darb\nsmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|New Char [] NULL (C#)<br /><br /> Char () = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nsmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|New Char [] NULL (C#)<br /><br /> Char () = Nothing|100|{"Darb", "Smarba"}|  
  
### <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> -Methoden weisen Speicher für das zurückgegebene Array Objekt <xref:System.String> und ein-Objekt für jedes Array Element zu. Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung der Speicher Belegung in der Anwendung wichtig ist, <xref:System.String.IndexOf%2A> sollten <xref:System.String.IndexOfAny%2A> Sie die-Methode oder <xref:System.String.Compare%2A> die-Methode und optional die-Methode verwenden, um eine Teil Zeichenfolge innerhalb einer Zeichenfolge zu suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen aufteilen, verwenden Sie <xref:System.String.IndexOf%2A> die <xref:System.String.IndexOfAny%2A> -Methode oder die-Methode, um ein Trennzeichen in der Zeichenfolge zu suchen. Wenn Sie eine Zeichenfolge in eine Trenn Zeichenfolge aufteilen, <xref:System.String.IndexOf%2A> verwenden <xref:System.String.IndexOfAny%2A> Sie die-oder-Methode, um das erste Zeichen der Trenn Zeichenfolge zu suchen. Verwenden Sie dann <xref:System.String.Compare%2A> die-Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen gleich den verbleibenden Zeichen der Trenn Zeichenfolge sind.  
  
 Wenn außerdem die gleichen Zeichen folgen zum Aufteilen von Zeichen folgen in mehreren <xref:System.String.Split%2A> Methoden aufrufen verwendet werden, sollten Sie in Erwägung gezogen werden, ein einzelnes Array zu erstellen und in jedem Methodenaufruf darauf zu verweisen. Dadurch wird der zusätzliche mehr Aufwand für die einzelnen Methodenaufrufe erheblich reduziert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht `count` , wie die Anzahl der von <xref:System.String.Split%2A>zurückgegebenen Zeichen folgen beeinflusst.  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist ein negativer Wert.</exception>
        <block subset="none" type="usage"><para><see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> <paramref name="separator" /> <see cref="M:System.String.Split(System.Char[])" /> In und früheren Versionen verwendet die-Methode einen leicht abweichenden Satz von Zeichen, um die Zeichenfolge zu unterteilen, wenn die-Methode ein ist oder keine Zeichen enthält. [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] kürzen Sie die Zeichenfolge. Beginnend mit dem .NET Framework 4 verwenden beide Methoden einen identischen Satz von Unicode-Leerzeichen.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in Teilzeichenfolgen. Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Rückgabewert Details  
 Trennzeichen (die Zeichen im `separator` Array) sind nicht in den Elementen des zurückgegebenen Arrays enthalten. Wenn das `separator` Array z. b. das Zeichen "-" enthält und der Wert der aktuellen Zeichen folgen Instanz "AA-BB-CC" ist, gibt die Methode ein Array zurück, das drei Elemente enthält: "AA", "BB" und "CC".  
  
 Wenn diese Instanz keines der Zeichen in `separator`enthält, besteht das zurückgegebene Array aus einem einzelnen Element, das diese Instanz enthält.  
  
 Wenn der `options` <xref:System.StringSplitOptions.RemoveEmptyEntries> -Parameter und die Länge dieser Instanz 0 (null) ist, gibt die Methode ein leeres Array zurück.  
  
 Jedes Element von `separator` definiert ein separates Trennzeichen, das aus einem einzelnen Zeichen besteht. Wenn das `options` -Argument <xref:System.StringSplitOptions.None>ist und zwei Trennzeichen nebeneinander liegen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält <xref:System.String.Empty?displayProperty=nameWithType>das entsprechende Array Element. Wenn `separator` z. b. zwei Elemente enthält: "-" und\_"", ist der Wert der Zeichen folgen Instanz "\_-AA\_ `options` -", und der Wert des-Arguments <xref:System.StringSplitOptions.None>ist, die Methode gibt ein Zeichen folgen Array mit zurück. die folgenden fünf Elemente:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>stellt die leere Zeichenfolge dar, die dem Zeichen "-" bei Index 0 vorangestellt ist.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, die die leere Zeichenfolge zwischen dem Zeichen "-" bei Index 0 und dem Zeichen "_" bei Index 1 darstellt.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, die die leere Zeichenfolge darstellt, die auf das Zeichen "_" bei Index 4 folgt.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, die die leere Zeichenfolge darstellt, die auf das Zeichen "-" am Index 5 folgt.  
  
### <a name="the-separator-array"></a>Das Trennzeichen Array  
 Wenn der `separator` -Parameter `null` ist oder keine Zeichen enthält, wird davon ausgegangen, dass Leerzeichen als Trennzeichen verwendet werden. Leerzeichen werden durch den Unicode-Standard definiert und geben zurück `true` , wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> -Methode übermittelt werden.  
  
 Wenn der `separator` Parameter im Aufrufen dieser Methoden Überladung ist `null`, misslingt die compilerüberladungs Auflösung. Um die aufgerufene Methode eindeutig zu identifizieren, muss der Code den Typ `null`der angeben. Im folgenden Beispiel werden mehrere Möglichkeiten zum eindeutigen Identifizieren dieser Überladung veranschaulicht.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>Vergleichs Details  
 Die <xref:System.String.Split%2A> -Methode extrahiert die Teil Zeichenfolgen in dieser Zeichenfolge, die durch ein oder mehrere der Zeichen `separator` des-Parameters getrennt sind, und gibt diese Teil Zeichenfolgen als Elemente eines Arrays zurück.  
  
 Die <xref:System.String.Split%2A> -Methode sucht nach Trennzeichen, indem Sie Vergleiche mithilfe von ordinalsortierungs Regeln für die Groß-und Kleinschreibung durchführt Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Sie unter der-Enumeration.  
  
### <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> -Methoden weisen Speicher für das zurückgegebene Array Objekt <xref:System.String> und ein-Objekt für jedes Array Element zu. Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung der Speicher Belegung in der Anwendung wichtig ist, <xref:System.String.IndexOf%2A> sollten <xref:System.String.IndexOfAny%2A> Sie die-Methode oder <xref:System.String.Compare%2A> die-Methode und optional die-Methode verwenden, um eine Teil Zeichenfolge innerhalb einer Zeichenfolge zu suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen aufteilen, verwenden Sie <xref:System.String.IndexOf%2A> die <xref:System.String.IndexOfAny%2A> -Methode oder die-Methode, um ein Trennzeichen in der Zeichenfolge zu suchen. Wenn Sie eine Zeichenfolge in eine Trenn Zeichenfolge aufteilen, <xref:System.String.IndexOf%2A> verwenden <xref:System.String.IndexOfAny%2A> Sie die-oder-Methode, um das erste Zeichen der Trenn Zeichenfolge zu suchen. Verwenden Sie dann <xref:System.String.Compare%2A> die-Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen gleich den verbleibenden Zeichen der Trenn Zeichenfolge sind.  
  
 Wenn außerdem die gleichen Zeichen folgen zum Aufteilen von Zeichen folgen in mehreren <xref:System.String.Split%2A> Methoden aufrufen verwendet werden, sollten Sie in Erwägung gezogen werden, ein einzelnes Array zu erstellen und in jedem Methodenaufruf darauf zu verweisen. Dadurch wird der zusätzliche mehr Aufwand für die einzelnen Methodenaufrufe erheblich reduziert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.StringSplitOptions> -Enumeration verwendet, um von der <xref:System.String.Split%2A> -Methode generierte Teil Zeichenfolgen einzuschließen oder auszuschließen.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> entspricht keinem der <see cref="T:System.StringSplitOptions" />-Werte.</exception>
        <block subset="none" type="usage"><para><see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> <paramref name="separator" /> <see cref="M:System.String.Split(System.Char[])" /> In und früheren Versionen verwendet die-Methode einen leicht abweichenden Satz von Zeichen, um die Zeichenfolge zu unterteilen, wenn die-Methode ein ist oder keine Zeichen enthält. [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] kürzen Sie die Zeichenfolge. Beginnend mit dem .NET Framework 4 verwenden beide Methoden einen identischen Satz von Unicode-Leerzeichen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Array mit Zeichenfolgen, die die Teilzeichenfolgen in dieser Zeichenfolge trennen, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichenfolgen in einem Array in Teilzeichenfolgen. Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichenfolgen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Zeichenfolge durch einen bekannten Zeichen folgen Satz getrennt ist, können Sie die <xref:System.String.Split%2A> -Methode verwenden, um Sie in Teil Zeichenfolgen zu trennen.  
  
### <a name="return-value-details"></a>Rückgabewert Details  
 Trennzeichen-Zeichen folgen sind nicht in den Elementen des zurückgegebenen Arrays enthalten. Wenn das `separator` Array z. b. die Zeichenfolge "--" enthält und der Wert der aktuellen Zeichen folgen Instanz "AA--BB-CC" ist, gibt die Methode ein Array zurück, das drei Elemente enthält: "AA", "BB" und "CC".  
  
 Wenn diese Instanz keine Zeichen folgen in `separator`enthält, besteht das zurückgegebene Array aus einem einzelnen Element, das diese Instanz enthält.  
  
 Wenn der `options` <xref:System.StringSplitOptions.RemoveEmptyEntries> -Parameter und die Länge dieser Instanz 0 (null) ist, gibt die Methode ein leeres Array zurück.  
  
 Jedes Element von `separator` definiert ein separates Trennzeichen, das aus einem oder mehreren Zeichen besteht. Wenn das `options` -Argument <xref:System.StringSplitOptions.None>ist und zwei Trennzeichen nebeneinander liegen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält <xref:System.String.Empty?displayProperty=nameWithType>das entsprechende Array Element. Wenn `separator` z. b. zwei Elemente enthält: "-" und\_"", ist der Wert der Zeichen folgen Instanz "\_-AA\_ `options` -", und der Wert des-Arguments <xref:System.StringSplitOptions.None>ist, die Methode gibt ein Sting-Array mit die folgenden fünf Elemente:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>stellt die leere Zeichenfolge dar, die der "-"-Teil Zeichenfolge bei Index 0 vorangestellt ist.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, die die leere Zeichenfolge zwischen der "-"-Teil Zeichenfolge bei Index 0 und der Teil Zeichenfolge "_" bei Index 1 darstellt.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>stellt die leere Zeichenfolge dar, die auf die Teil Zeichenfolge "_" bei Index 4 folgt.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>stellt die leere Zeichenfolge dar, die auf die Teil Zeichenfolge "-" bei Index 5 folgt.  
  
### <a name="the-separator-array"></a>Das Trennzeichen Array  
 Wenn eines der Elemente in `separator` aus mehreren Zeichen besteht, gilt die gesamte Teil Zeichenfolge als Trennzeichen. Wenn eines der Elemente in `separator` z. b. "10" ist, wird versucht, die Zeichenfolge "This10is10a10string" aufzuteilen. Gibt das folgende Array von vier Elementen zurück: {"This", "is", "a", "String". }.  
  
 Wenn der `separator` -Parameter `null` ist oder keine Zeichen enthält, wird davon ausgegangen, dass Leerzeichen als Trennzeichen verwendet werden. Leerzeichen werden durch den Unicode-Standard definiert und geben zurück `true` , wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> -Methode übermittelt werden.  
  
 Wenn der `separator` Parameter im Aufrufen dieser Methoden Überladung ist `null`, misslingt die compilerüberladungs Auflösung. Um die aufgerufene Methode eindeutig zu identifizieren, muss der Code den Typ `null`der angeben. Im folgenden Beispiel werden mehrere Möglichkeiten zum eindeutigen Identifizieren dieser Überladung veranschaulicht.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>Vergleichs Details  
 Die <xref:System.String.Split%2A> -Methode extrahiert die Teil Zeichenfolgen in dieser Zeichenfolge, die durch mindestens eine Zeichenfolge `separator` im-Parameter getrennt sind, und gibt diese Teil Zeichenfolgen als Elemente eines Arrays zurück.  
  
 Die <xref:System.String.Split%2A> -Methode sucht nach Trennzeichen, indem Sie Vergleiche mithilfe von ordinalsortierungs Regeln für die Groß-und Kleinschreibung durchführt Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Sie unter der-Enumeration.  
  
 Die <xref:System.String.Split%2A> -Methode ignoriert alle Elemente `separator` von, deren `null` Wert oder die leere Zeichenfolge ("") ist.  
  
 Um mehrdeutige Ergebnisse zu vermeiden, `separator` wenn Zeichen folgen in gemeinsame <xref:System.String.Split%2A> Zeichen aufweisen, wird der Vorgang vom Anfang bis zum Ende des Werts der-Instanz fortgesetzt und entspricht dem `separator` ersten Element in, das gleich einem Trennzeichen im lichen. Die Reihenfolge, in der Teil Zeichenfolgen in der-Instanz gefunden werden, hat Vorrang `separator`vor der Reihenfolge der Elemente in.  
  
 Stellen Sie sich z. b. eine Instanz vor, deren Wert "abcdef" ist. Wenn das erste Element in `separator` "EF" und das zweite Element "bcde" war, wäre das Ergebnis des Split-Vorgangs ein Zeichen folgen Array, das zwei Elemente enthält: "a" und "f". Dies liegt daran, dass die Teil Zeichenfolge in der-Instanz, "bcde", gefunden wird `separator` und mit einem Element in übereinstimmt, bevor die Teil Zeichenfolge "f" gefunden wird.  
  
 Wenn jedoch das erste Element von `separator` "BCD" und das zweite Element "BC" war, wäre das Ergebnis des Split-Vorgangs ein Zeichen folgen Array, das zwei Elemente enthält: "a" und "EF". Dies liegt daran, dass "BCD" das erste Trennzeichen in `separator` ist, das mit einem Trennzeichen in der-Instanz übereinstimmt. Wenn die Reihenfolge der Trennzeichen umgekehrt wurde, sodass das erste Element "BC" und das zweite Element "BCD" war, wäre das Ergebnis ein Zeichen folgen Array, das zwei Elemente enthält: "a" und "Def".  
  
### <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> -Methoden weisen Speicher für das zurückgegebene Array Objekt <xref:System.String> und ein-Objekt für jedes Array Element zu. Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung der Speicher Belegung in der Anwendung wichtig ist, <xref:System.String.IndexOf%2A> sollten <xref:System.String.IndexOfAny%2A> Sie die-Methode oder <xref:System.String.Compare%2A> die-Methode und optional die-Methode verwenden, um eine Teil Zeichenfolge innerhalb einer Zeichenfolge zu suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen aufteilen, verwenden Sie <xref:System.String.IndexOf%2A> die <xref:System.String.IndexOfAny%2A> -Methode oder die-Methode, um ein Trennzeichen in der Zeichenfolge zu suchen. Wenn Sie eine Zeichenfolge in eine Trenn Zeichenfolge aufteilen, <xref:System.String.IndexOf%2A> verwenden <xref:System.String.IndexOfAny%2A> Sie die-oder-Methode, um das erste Zeichen der Trenn Zeichenfolge zu suchen. Verwenden Sie dann <xref:System.String.Compare%2A> die-Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen gleich den verbleibenden Zeichen der Trenn Zeichenfolge sind.  
  
 Wenn außerdem die gleichen Zeichen folgen zum Aufteilen von Zeichen folgen in mehreren <xref:System.String.Split%2A> Methoden aufrufen verwendet werden, sollten Sie in Erwägung gezogen werden, ein einzelnes Array zu erstellen und in jedem Methodenaufruf darauf zu verweisen. Dadurch wird der zusätzliche mehr Aufwand für die einzelnen Methodenaufrufe erheblich reduziert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Unterschied in den Arrays veranschaulicht, die durch Aufrufen <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> der-Methode `options` einer Zeichenfolge <xref:System.StringSplitOptions.None?displayProperty=nameWithType> zurück <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>gegeben werden, deren-Parameter gleich und ist.  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 Im folgenden Beispiel wird ein Array von Trennzeichen definiert, das Interpunktions-und Leerzeichen enthält. Wenn Sie dieses Array zusammen mit einem Wert <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> von an <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> die-Methode übergeben, wird ein Array zurückgegeben, das aus den einzelnen Wörtern aus der Zeichenfolge besteht.  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Beachten Sie, dass die-Methode aufgerufen `options` wird und das <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>-Argument auf festgelegt ist. Dadurch wird verhindert, dass das zurück <xref:System.String.Empty?displayProperty=nameWithType> gegebene Array Werte einschließt, die leere Teil Zeichenfolgen-Übereinstimmungen zwischen Interpunktions Zeichen und Leerzeichen darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> entspricht keinem der <see cref="T:System.StringSplitOptions" />-Werte.</exception>
        <block subset="none" type="usage"><para><see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> <paramref name="separator" /> <see cref="M:System.String.Split(System.Char[])" /> In und früheren Versionen verwendet die-Methode einen leicht abweichenden Satz von Zeichen, um die Zeichenfolge zu unterteilen, wenn die-Methode ein ist oder keine Zeichen enthält. [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] kürzen Sie die Zeichenfolge. Beginnend mit dem .NET Framework 4 verwenden beide Methoden einen identischen Satz von Unicode-Leerzeichen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="count">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in eine maximale Anzahl von Teilzeichenfolgen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trennzeichen sind nicht in den Elementen des zurückgegebenen Arrays enthalten.  
  
 Wenn diese Instanz keines der Zeichen in `separator`enthält oder der `count` -Parameter 1 ist, besteht das zurückgegebene Array aus einem einzelnen-Element, das diese Instanz enthält. Wenn der `separator` -Parameter `null` ist oder keine Zeichen enthält, wird davon ausgegangen, dass Leerzeichen als Trennzeichen verwendet werden. Leerzeichen werden durch den Unicode-Standard definiert und geben zurück `true` , wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> -Methode übermittelt werden. Wenn der Parameter im `separator` Aufrufen dieser Methoden Überladung ist `null`, misslingt die compilerüberladungs Auflösung. Um die aufgerufene Methode eindeutig zu identifizieren, muss der Code den Typ der NULL angeben. Im folgenden Beispiel werden mehrere Möglichkeiten zum eindeutigen Identifizieren dieser Überladung veranschaulicht.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Wenn der `count` -Parameter 0 (null) `options` ist, <xref:System.StringSplitOptions.RemoveEmptyEntries> oder wenn der-Parameter ist und die Länge dieser Instanz 0 (null) ist, wird ein leeres Array zurückgegeben.  
  
 Jedes Element von `separator` definiert ein separates Trennzeichen. Wenn der `options` -Parameter <xref:System.StringSplitOptions.None>ist und zwei Trennzeichen nebeneinander liegen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält <xref:System.String.Empty>das entsprechende Array Element.  
  
 Wenn in dieser Instanz mehr `count` als Teil Zeichenfolgen vorhanden sind, `count` werden die ersten minus 1 Teil Zeichenfolgen `count` in den ersten minus 1 Elementen des Rückgabewerts zurückgegeben, und die restlichen Zeichen in dieser Instanz werden in der letzten zurückgegeben. -Element des Rückgabewerts.  
  
 Wenn `count` größer als die Anzahl der Teil Zeichenfolgen ist, werden die verfügbaren Teil Zeichenfolgen zurückgegeben, und es wird keine Ausnahme ausgelöst.  
  
### <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> -Methoden weisen Speicher für das zurückgegebene Array Objekt <xref:System.String> und ein-Objekt für jedes Array Element zu. Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung der Speicher Belegung in der Anwendung wichtig ist, <xref:System.String.IndexOf%2A> sollten <xref:System.String.IndexOfAny%2A> Sie die-Methode oder <xref:System.String.Compare%2A> die-Methode und optional die-Methode verwenden, um eine Teil Zeichenfolge innerhalb einer Zeichenfolge zu suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen aufteilen, verwenden Sie <xref:System.String.IndexOf%2A> die <xref:System.String.IndexOfAny%2A> -Methode oder die-Methode, um ein Trennzeichen in der Zeichenfolge zu suchen. Wenn Sie eine Zeichenfolge in eine Trenn Zeichenfolge aufteilen, <xref:System.String.IndexOf%2A> verwenden <xref:System.String.IndexOfAny%2A> Sie die-oder-Methode, um das erste Zeichen der Trenn Zeichenfolge zu suchen. Verwenden Sie dann <xref:System.String.Compare%2A> die-Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen gleich den verbleibenden Zeichen der Trenn Zeichenfolge sind.  
  
 Wenn außerdem die gleichen Zeichen folgen zum Aufteilen von Zeichen folgen in mehreren <xref:System.String.Split%2A> Methoden aufrufen verwendet werden, sollten Sie in Erwägung gezogen werden, ein einzelnes Array zu erstellen und in jedem Methodenaufruf darauf zu verweisen. Dadurch wird der zusätzliche mehr Aufwand für die einzelnen Methodenaufrufe erheblich reduziert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.StringSplitOptions> -Enumeration verwendet, um von der <xref:System.String.Split%2A> -Methode generierte Teil Zeichenfolgen einzuschließen oder auszuschließen.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> entspricht keinem der <see cref="T:System.StringSplitOptions" />-Werte.</exception>
        <block subset="none" type="usage"><para><see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> <paramref name="separator" /> <see cref="M:System.String.Split(System.Char[])" /> In und früheren Versionen verwendet die-Methode einen leicht abweichenden Satz von Zeichen, um die Zeichenfolge zu unterteilen, wenn die-Methode ein ist oder keine Zeichen enthält. [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] kürzen Sie die Zeichenfolge. Beginnend mit dem .NET Framework 4 verwenden beide Methoden einen identischen Satz von Unicode-Leerzeichen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Array mit Zeichenfolgen, die die Teilzeichenfolgen in dieser Zeichenfolge trennen, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="count">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichenfolgen in einem Array in eine maximale Anzahl von Teilzeichenfolgen. Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichenfolgen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Rückgabewert Details  
 Trennzeichen-Zeichen folgen sind nicht in den Elementen des zurückgegebenen Arrays enthalten.  
  
 Wenn diese Instanz keine Zeichen folgen in `separator`enthält oder der `count` -Parameter 1 ist, besteht das zurückgegebene Array aus einem einzelnen-Element, das diese Instanz enthält. Wenn der `separator` -Parameter `null` ist oder keine Zeichen enthält, wird davon ausgegangen, dass Leerzeichen als Trennzeichen verwendet werden. Leerzeichen werden durch den Unicode-Standard definiert und geben zurück `true` , wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> -Methode übermittelt werden. Wenn der Parameter im `separator` Aufrufen dieser Methoden Überladung ist `null`, misslingt die compilerüberladungs Auflösung. Um die aufgerufene Methode eindeutig zu identifizieren, muss der Code den Typ `null`der angeben. Im folgenden Beispiel werden mehrere Möglichkeiten zum eindeutigen Identifizieren dieser Überladung veranschaulicht.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Wenn der `count` -Parameter 0 (null) `options` ist, <xref:System.StringSplitOptions.RemoveEmptyEntries> oder wenn der-Parameter ist und die Länge dieser Instanz 0 (null) ist, wird ein leeres Array zurückgegeben.  
  
 Jedes Element von `separator` definiert ein separates Trennzeichen, das aus einem oder mehreren Zeichen besteht. Wenn der `options` -Parameter <xref:System.StringSplitOptions.None>ist und zwei Trennzeichen nebeneinander liegen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält <xref:System.String.Empty>das entsprechende Array Element.  
  
 Wenn in dieser Instanz mehr `count` als Teil Zeichenfolgen vorhanden sind, `count` werden die ersten minus 1 Teil Zeichenfolgen `count` in den ersten minus 1 Elementen des Rückgabewerts zurückgegeben, und die restlichen Zeichen in dieser Instanz werden in der letzten zurückgegeben. -Element des Rückgabewerts.  
  
 Wenn `count` größer als die Anzahl der Teil Zeichenfolgen ist, werden die verfügbaren Teil Zeichenfolgen zurückgegeben, und es wird keine Ausnahme ausgelöst.  
  
### <a name="the-separator-array"></a>Das Trennzeichen Array  
 Wenn eines der Elemente in `separator` aus mehreren Zeichen besteht, gilt die gesamte Teil Zeichenfolge als Trennzeichen. Wenn eines der Elemente in `separator` z. b. "10" ist, wird versucht, die Zeichenfolge "This10is10a10string" aufzuteilen. gibt dieses Array mit vier Elementen zurück: {"This", "is", "a", "String". }.  
  
### <a name="comparison-details"></a>Vergleichs Details  
 Die <xref:System.String.Split%2A> -Methode extrahiert die Teil Zeichenfolgen in dieser Zeichenfolge, die durch mindestens eine Zeichenfolge `separator` im-Parameter getrennt sind, und gibt diese Teil Zeichenfolgen als Elemente eines Arrays zurück.  
  
 Die <xref:System.String.Split%2A> -Methode sucht nach Trennzeichen, indem Sie Vergleiche mithilfe von ordinalsortierungs Regeln für die Groß-und Kleinschreibung durchführt Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Sie unter der-Enumeration.  
  
 Die <xref:System.String.Split%2A> -Methode ignoriert alle Elemente `separator` von, deren `null` Wert oder die leere Zeichenfolge ("") ist.  
  
 Um mehrdeutige Ergebnisse zu vermeiden, `separator` wenn Zeichen folgen in gemeinsame <xref:System.String.Split%2A> Zeichen aufweisen, fährt die Methode vom Anfang bis zum Ende des Werts der-Instanz fort und entspricht dem ersten `separator` Element in, das gleich einem Trennzeichen im lichen. Die Reihenfolge, in der Teil Zeichenfolgen in der-Instanz gefunden werden, hat Vorrang `separator`vor der Reihenfolge der Elemente in.  
  
 Stellen Sie sich z. b. eine Instanz vor, deren Wert "abcdef" ist. Wenn das erste Element in `separator` "EF" und das zweite Element "bcde" war, wäre das Ergebnis des Split-Vorgangs "a" und "f". Dies liegt daran, dass die Teil Zeichenfolge in der-Instanz, "bcde", gefunden wird `separator` und mit einem Element in übereinstimmt, bevor die Teil Zeichenfolge "f" gefunden wird.  
  
 Wenn jedoch das erste Element von `separator` "BCD" und das zweite Element "BC" war, wäre das Ergebnis des Split-Vorgangs "a" und "EF". Dies liegt daran, dass "BCD" das erste Trennzeichen in `separator` ist, das mit einem Trennzeichen in der-Instanz übereinstimmt. Wenn die Reihenfolge der Trennzeichen umgekehrt wurde, sodass das erste Element "BC" und das zweite Element "BCD" war, wäre das Ergebnis "a" und "Def".  
  
### <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> -Methoden weisen Speicher für das zurückgegebene Array Objekt <xref:System.String> und ein-Objekt für jedes Array Element zu. Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung der Speicher Belegung in der Anwendung wichtig ist, <xref:System.String.IndexOf%2A> sollten <xref:System.String.IndexOfAny%2A> Sie die-Methode oder <xref:System.String.Compare%2A> die-Methode und optional die-Methode verwenden, um eine Teil Zeichenfolge innerhalb einer Zeichenfolge zu suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen aufteilen, verwenden Sie <xref:System.String.IndexOf%2A> die <xref:System.String.IndexOfAny%2A> -Methode oder die-Methode, um ein Trennzeichen in der Zeichenfolge zu suchen. Wenn Sie eine Zeichenfolge in eine Trenn Zeichenfolge aufteilen, <xref:System.String.IndexOf%2A> verwenden <xref:System.String.IndexOfAny%2A> Sie die-oder-Methode, um das erste Zeichen der Trenn Zeichenfolge zu suchen. Verwenden Sie dann <xref:System.String.Compare%2A> die-Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen gleich den verbleibenden Zeichen der Trenn Zeichenfolge sind.  
  
 Wenn außerdem die gleichen Zeichen folgen zum Aufteilen von Zeichen folgen in mehreren <xref:System.String.Split%2A> Methoden aufrufen verwendet werden, sollten Sie in Erwägung gezogen werden, ein einzelnes Array zu erstellen und in jedem Methodenaufruf darauf zu verweisen. Dadurch wird der zusätzliche mehr Aufwand für die einzelnen Methodenaufrufe erheblich reduziert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.StringSplitOptions> -Enumeration verwendet, um von der <xref:System.String.Split%2A> -Methode generierte Teil Zeichenfolgen einzuschließen oder auszuschließen.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> entspricht keinem der <see cref="T:System.StringSplitOptions" />-Werte.</exception>
        <block subset="none" type="usage"><para><see cref="M:System.String.Trim(System.Char[])" /> <see langword="null" /> <paramref name="separator" /> <see cref="M:System.String.Split(System.Char[])" /> In und früheren Versionen verwendet die-Methode einen leicht abweichenden Satz von Zeichen, um die Zeichenfolge zu unterteilen, wenn die-Methode ein ist oder keine Zeichen enthält. [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] kürzen Sie die Zeichenfolge. Beginnend mit dem .NET Framework 4 verwenden beide Methoden einen identischen Satz von Unicode-Leerzeichen.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz mit einer angegebenen Zeichenfolge übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu vergleichende Zeichenfolge.</param>
        <summary>Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns><see langword="true" />, wenn <paramref name="value" /> mit dem Anfang dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht `value` mit der Teil Zeichenfolge am Anfang dieser Instanz, die dieselbe Länge wie `value`hat, und gibt eine Angabe darüber zurück, ob Sie gleich sind. Muss gleich sein, `value` muss eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) sein, muss ein Verweis auf dieselbe Instanz sein oder mit dem Anfang dieser Instanz übereinstimmen.  
  
 Diese Methode führt einen Vergleich mit der aktuellen Kultur durch (Unterscheidung nach Groß-/Kleinschreibung und Kultur sensitiv).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine `StripStartTags` -Methode definiert, <xref:System.String.StartsWith%28System.String%29> die die-Methode verwendet, um HTML-Start Tags vom Anfang einer Zeichenfolge zu entfernen. Beachten Sie, `StripStartTags` dass die-Methode rekursiv aufgerufen wird, um sicherzustellen, dass mehrere HTML-Starttags am Zeilen Anfang entfernt werden. In diesem Beispiel werden keine in eine Zeichenfolge eingebetteten HTML-Tags entfernt.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen. Um zu ermitteln, ob eine Zeichenfolge mit einer bestimmten Teil Zeichenfolge beginnt, indem Sie die Regeln <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> <see cref="F:System.StringComparison.CurrentCulture" /> für den Zeichen folgen Vergleich der aktuellen Kultur verwenden, müssen <paramref name="comparisonType" /> Sie die-Methoden Überladung mit dem Wert für den Parameter aufrufen</para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Die zu vergleichende Zeichenfolge.</param>
        <param name="comparisonType">Einer der Enumerationswerte, die bestimmen, wie diese Zeichenfolge und <paramref name="value" /> verglichen werden.</param>
        <summary>Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Vergleichsoption mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns><see langword="true" />, wenn diese Instanz mit <paramref name="value" /> beginnt; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.StartsWith%2A> -Methode vergleicht `value` den-Parameter mit der Teil Zeichenfolge am Anfang dieser Zeichenfolge und gibt einen Wert zurück, der angibt, ob Sie gleich sind. Muss gleich sein, `value` muss ein Verweis auf dieselbe Zeichenfolge sein, muss eine leere Zeichenfolge ("") sein oder mit dem Anfang dieser Zeichenfolge übereinstimmen. Der Typ des Vergleichs, der von <xref:System.String.StartsWith%2A> der-Methode ausgeführt wird, hängt `comparisonType` vom Wert des-Parameters ab. Beim Vergleich können die Konventionen der aktuellen Kultur (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> und <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) oder der invarianten Kultur (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> und <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>) verwendet werden, oder Sie können aus einem Zeichen-zu-Zeichen-Vergleich von Code Punkten bestehen<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> (oder <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). Beim Vergleich kann auch die Groß-/Kleinschreibung beachtet werden <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>(<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, oder), oder es kann die groß <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>-/Kleinschreibung ignoriert werden (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>,).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Suche nach der Zeichenfolge "The" am Anfang einer längeren Zeichenfolge durchzuführen, die mit dem Wort "The" beginnt. Wie die Ausgabe des Beispiels zeigt, kann ein Aufrufvorgang <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> der-Methode, die einen Kultur unabhängigen Vergleich durchführt, aber die Groß-/Kleinschreibung beachtet, nicht mit der Zeichenfolge übereinstimmen  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge mit einer bestimmten Teil Zeichenfolge beginnt. Ein zweidimensionales Zeichen folgen Array wird initialisiert. Das erste Element in der zweiten Dimension enthält eine Zeichenfolge, und das zweite Element enthält die Zeichenfolge, nach der am Anfang der ersten Zeichenfolge gesucht werden soll. Die Ergebnisse sind von der Auswahl der Kultur betroffen, unabhängig davon, ob die Groß-/Kleinschreibung ignoriert wird und ob ein Ordinalvergleich durchgeführt wird. Beachten Sie Folgendes: Wenn die Zeichen folgen Instanz eine LIGATURE enthält, Stimmen Kultur abhängige Vergleiche mit den aufeinander folgenden Zeichen erfolgreich ab.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Die zu vergleichende Zeichenfolge.</param>
        <param name="ignoreCase"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <param name="culture">Kulturinformationen, die bestimmen, wie diese Instanz und <paramref name="value" /> verglichen werden. Wenn <paramref name="culture" /> <see langword="null" /> ist, wird die aktuelle Kultur verwendet.</param>
        <summary>Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Kultur mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter mit dem Anfang dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht den `value` -Parameter mit der Teil Zeichenfolge am Anfang dieser Zeichenfolge, die dieselbe Länge `value`wie hat, und gibt einen Wert zurück, der angibt, ob Sie gleich sind. Muss gleich sein, `value` muss eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) sein, muss ein Verweis auf dieselbe Instanz sein oder mit dem Anfang dieser Instanz übereinstimmen.  
  
 Diese Methode führt einen Vergleich mit der angegebenen Groß-und Kleinschreibung durch.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge am Anfang einer anderen Zeichenfolge auftritt. Die <xref:System.String.StartsWith%2A> -Methode wird mehrmals unter Berücksichtigung der Groß-/Kleinschreibung, Unterscheidung nach Groß-/Kleinschreibung und verschiedener Kulturen aufgerufen, die die Ergebnisse der Suche beeinflussen.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine Teilzeichenfolge dieser Instanz ab.  
  
 Dieser Member wird überladen. Klicken Sie auf einen Namen in der Überladungsliste, um vollständige Informationen zu diesem Member sowie zu Syntax, Nutzung und Beispielen zu erhalten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Index) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Index startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : Index -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</param>
        <summary>Ruft eine Teilzeichenfolge dieser Instanz ab. Die untergeordnete Zeichenfolge beginnt in einer angegebenen Zeichenposition und wird an das Ende der Zeichenfolge fortgesetzt.</summary>
        <returns>Eine Zeichenfolge, die der Teilzeichenfolge ab <paramref name="startIndex" /> in dieser Instanz entspricht, oder <see cref="F:System.String.Empty" />, wenn <paramref name="startIndex" /> gleich der Länge dieser Instanz ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Substring%28System.Int32%29> -Methode wird aufgerufen, um eine Teil Zeichenfolge aus einer Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und am Ende der Zeichenfolge endet. Die Anfangs Zeichenposition ist ein NULL basiertes; Anders ausgedrückt: das erste Zeichen in der Zeichenfolge hat den Index 0 (nicht Index 1). Um eine Teil Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und vor dem Ende der Zeichenfolge <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> endet, wird die-Methode aufgerufen.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, die an `startIndex` der Position in der aktuellen Zeichenfolge beginnt.  
  
 Um eine Teil Zeichenfolge zu extrahieren, die mit einem bestimmten Zeichen oder einer Zeichenfolge beginnt, <xref:System.String.IndexOf%2A> können <xref:System.String.IndexOf%2A> Sie eine Methode wie oder `startIndex`abrufen, um den Wert von zu erhalten. Das zweite Beispiel veranschaulicht dies: Es extrahiert einen Schlüsselwert, der eine Zeichenposition nach dem Zeichen "=" beginnt.  
  
 Wenn `startIndex` gleich 0 (null) ist, gibt die Methode die ursprüngliche Zeichenfolge unverändert zurück.  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Abrufen einer Teil Zeichenfolge aus einer Zeichenfolge.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 Im folgenden Beispiel wird die <xref:System.String.Substring%2A> -Methode verwendet, um Schlüssel-Wert-Paare, die durch ein Gleichheitszeichen ("=") getrennt sind, zu trennen.  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Die <xref:System.String.IndexOf%2A> -Methode wird verwendet, um die Position des Gleichheitszeichens in der Zeichenfolge zu erhalten. Der- <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> Methodenaufrufe extrahiert den Schlüsselnamen, der mit dem ersten Zeichen in der Zeichenfolge beginnt und die Anzahl der Zeichen erweitert, die durch den Aufrufder <xref:System.String.IndexOf%2A> -Methode zurückgegeben werden. Der- <xref:System.String.Substring%28System.Int32%29> Methodenaufrufe extrahiert dann den Wert, der dem Schlüssel zugewiesen ist. Er beginnt an einer Zeichenposition hinter dem Gleichheitszeichen und erstreckt sich bis zum Ende der Zeichenfolge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Range range);" />
      <MemberSignature Language="F#" Value="member this.Substring : Range -&gt; string" Usage="string.Substring range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</param>
        <param name="length">Die Anzahl der Zeichen in der Teilzeichenfolge.</param>
        <summary>Ruft eine Teilzeichenfolge dieser Instanz ab. Die Teilzeichenfolge beginnt an einer angegebenen Zeichenposition und hat eine angegebene Länge.</summary>
        <returns>Eine Zeichenfolge, die der Teilzeichenfolge mit der Länge <paramref name="length" /> ab <paramref name="startIndex" /> in dieser Instanz entspricht, oder <see cref="F:System.String.Empty" />, wenn <paramref name="startIndex" /> gleich der Länge dieser Instanz und <paramref name="length" /> 0 (null) ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> -Methode wird aufgerufen, um eine Teil Zeichenfolge aus einer Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und vor dem Ende der Zeichenfolge endet. Die Anfangs Zeichenposition ist ein NULL basiertes; Anders ausgedrückt: das erste Zeichen in der Zeichenfolge hat den Index 0 (nicht Index 1). Um eine Teil Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und am Ende der Zeichenfolge fort <xref:System.String.Substring%28System.Int32%29> gesetzt wird, wird die-Methode aufgerufen.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge mit `length` Zeichen zurückgegeben, die ab der `startIndex` Position in der aktuellen Zeichenfolge beginnen.  
  
 Der `length` -Parameter stellt die Gesamtzahl der Zeichen dar, die aus der aktuellen Zeichen folgen Instanz extrahiert werden. Dies schließt das beim Index `startIndex`gefundene Startzeichen ein.  Mit anderen Worten: die <xref:System.String.Substring%2A> Methode versucht, Zeichen aus dem Index `startIndex` in Index `startIndex`  +  `length` -1 zu extrahieren.  
  
 Um eine Teil Zeichenfolge zu extrahieren, die mit einem bestimmten Zeichen oder einer Zeichenfolge beginnt, <xref:System.String.IndexOf%2A> können <xref:System.String.LastIndexOf%2A> Sie eine Methode wie oder `startIndex`abrufen, um den Wert von zu erhalten.  
  
 Wenn die Teil Zeichenfolge `startIndex` von auf eine angegebene Zeichen Sequenz erweitert wird, können Sie eine Methode <xref:System.String.IndexOf%2A> wie <xref:System.String.LastIndexOf%2A> oder abrufen, um den Index des Endzeichens oder der Zeichenfolge zu erhalten.  Anschließend können Sie diesen Wert wie folgt in eine Indexposition in der Zeichenfolge konvertieren:  
  
-   Wenn Sie nach einem einzelnen Zeichen gesucht haben, das das Ende der Teil Zeichenfolge markieren soll, `length` entspricht <xref:System.String.IndexOf%2A> `endIndex` `endIndex`  -  `startIndex` der-Parameter dem Wert + 1, wobei der Rückgabewert <xref:System.String.IndexOf%2A> von oder ist. anzuwenden. Im folgenden Beispiel wird ein fortlaufender Block von "b"-Zeichen aus einer Zeichenfolge extrahiert.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Wenn Sie mehrere Zeichen durchsucht haben, die das Ende der Teil Zeichenfolge markieren, entspricht `length` `startIndex` `endIndex`  -   +  `endMatchLength`der-Parameter dem `endIndex` , wobei der Rückgabewert von ist.<xref:System.String.IndexOf%2A> oder `endMatchLength` -Methode, und die Länge der Zeichenfolge, die das Ende der Teil Zeichenfolge markiert. <xref:System.String.IndexOf%2A> Im folgenden Beispiel wird ein Textblock extrahiert, der ein XML `<definition>` -Element enthält.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Wenn das Zeichen oder die Zeichenfolge nicht am Ende der Teil Zeichenfolge enthalten ist, `length` entspricht <xref:System.String.IndexOf%2A> `endIndex` `endIndex`  -  `startIndex`der-Parameter, wobei der Rückgabewert von oder <xref:System.String.IndexOf%2A> ist. anzuwenden.  
  
 Wenn `startIndex` gleich 0 (null) ist und der Länge der aktuellen Zeichenfolge entspricht, gibt die Methode die ursprüngliche Zeichenfolge unverändert zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein einfacher Aufrufder <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> -Methode veranschaulicht, die zwei Zeichen aus einer Zeichenfolge extrahiert, beginnend bei der sechsten Zeichenposition (d. h. bei Index fünf).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 Im folgenden Beispiel wird die <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> -Methode in den folgenden drei Fällen verwendet, um Teil Zeichenfolgen in einer Zeichenfolge zu isolieren. In zwei Fällen werden die Teil Zeichenfolgen in Vergleichen verwendet, und im dritten Fall wird eine Ausnahme ausgelöst, weil ungültige Parameter angegeben werden.  
  
-   Es extrahiert das einzelne Zeichen und die dritte Position in der Zeichenfolge (bei Index 2) und vergleicht es mit einem "c". Dieser Vergleich gibt `true`zurück.  
  
-   Sie extrahiert NULL Zeichen beginnend an der vierten Position in der Zeichenfolge (bei Index 3) und übergibt sie an <xref:System.String.IsNullOrEmpty%2A> die-Methode. Dies gibt true zurück, da der Rückruf <xref:System.String.Substring%2A> der Methode <xref:System.String.Empty?displayProperty=nameWithType>zurückgibt.  
  
-   Es wird versucht, ein Zeichen zu extrahieren, beginnend an der vierten Position in der Zeichenfolge. Da an dieser Position kein Zeichen vorhanden ist, löst der Methodenaufrufe eine <xref:System.ArgumentOutOfRangeException> Ausnahme aus.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 Im folgenden Beispiel wird die <xref:System.String.Substring%2A> -Methode verwendet, um Schlüssel-Wert-Paare, die durch ein Gleichheitszeichen ("=") getrennt sind, zu trennen.  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Die <xref:System.String.IndexOf%2A> -Methode wird verwendet, um die Position des Gleichheitszeichens in der Zeichenfolge zu erhalten. Der- <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> Methodenaufrufe extrahiert den Schlüsselnamen, der mit dem ersten Zeichen in der Zeichenfolge beginnt und die Anzahl der Zeichen erweitert, die durch den Aufrufder <xref:System.String.IndexOf%2A> -Methode zurückgegeben werden. Der- <xref:System.String.Substring%28System.Int32%29> Methodenaufrufe extrahiert dann den Wert, der dem Schlüssel zugewiesen ist. Er beginnt an einer Zeichenposition hinter dem Gleichheitszeichen und erstreckt sich bis zum Ende der Zeichenfolge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> plus <paramref name="length" /> gibt eine Position außerhalb dieser Instanz an.  
  
- oder - 
 <paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der das aktuelle <see cref="T:System.String" />-Objekt durchläuft.</summary>
        <returns>Ein stark typisierter Enumerator, der zum Durchlaufen des aktuellen <see cref="T:System.String" />-Objekts verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Sie kann nur verwendet werden, wenn <xref:System.String> die-Instanz in ein <xref:System.Collections.Generic.IEnumerable%601> Schnittstellen Objekt umgewandelt wird. Weitere Informationen finden Sie unter der Methode <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der das aktuelle <see cref="T:System.String" />-Objekt durchläuft.</summary>
        <returns>Ein Enumerator, mit dem die Elemente in der aktuellen Zeichenfolge durchlaufen werden können.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.Collections.IEnumerable>-Schnittstelle umgewandelt wird. Weitere Informationen finden Sie unter der Methode <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" />, wenn der Wert der aktuellen Zeichenfolge <see cref="F:System.Boolean.TrueString" /> ist. <see langword="false" />, wenn der Wert der aktuellen Zeichenfolge <see cref="F:System.Boolean.FalseString" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert der aktuellen Zeichenfolge ist weder <see cref="F:System.Boolean.TrueString" /> noch <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.Byte.MaxValue" /> oder kleiner als <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Das Zeichen am Index 0 im aktuellen <see cref="T:System.String" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.Int16.MaxValue" /> oder kleiner als <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.SByte.MaxValue" /> oder kleiner als <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zurückgegebenen Objekts.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ChangeType%2A> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht in den vom <paramref name="type" />-Parameter angegebenen Typ konvertiert werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.UInt16.MaxValue" /> oder kleiner als <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.UInt32.MaxValue" /> oder kleiner als <see cref="F:System.UInt32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert die Zeichen dieser Instanz in ein Array von Unicode-Zeichen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Zeichen dieser Instanz in ein Array von Unicode-Zeichen.</summary>
        <returns>Ein Array von Unicode-Zeichen, dessen Elemente die einzelnen Zeichen dieser Instanz darstellen. Wenn diese Instanz eine leere Zeichenfolge ist, ist das zurückgegebene Array leer und hat die Länge 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert jedes Zeichen (d. h. <xref:System.Char> jedes Objekt) in einer Zeichenfolge in ein Zeichen Array. Das erste kopierte Zeichen weist den Index NULL des zurückgegebenen Zeichen Arrays auf. das letzte kopierte Zeichen befindet sich <xref:System.Array.Length%2A?displayProperty=nameWithType> am Index-1.  
  
 Um eine Zeichenfolge aus den Zeichen in einem Zeichen Array zu erstellen, <xref:System.String.%23ctor%28System.Char%5B%5D%29> rufen Sie den-Konstruktor auf.  
  
 Zum Erstellen eines Bytearrays, das die codierten Zeichen in einer Zeichenfolge enthält, instanziieren Sie das <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> entsprechende <xref:System.Text.Encoding> -Objekt, und rufen Sie dessen-Methode auf Einige der in .NET verfügbaren Standard Codierungen umfassen Folgendes:  
  
|Codierung|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Weitere Informationen finden Sie unter [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.ToCharArray%2A> -Methode aufgerufen, um die Zeichen in einer Zeichenfolge in ein Zeichen Array zu extrahieren. Anschließend werden die Original Zeichenfolge und die Elemente im Array angezeigt.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 Im folgenden Beispiel wird eine Zeichenfolge definiert, die die Zeichen enthält, die in einer durch Trennzeichen getrennten Zeichenfolge als Trennzeichen fungieren. Anschließend wird die <xref:System.String.ToCharArray%2A> -Methode aufgerufen, um ein Zeichen Array zu erstellen, das an <xref:System.String.Split%28System.Char%5B%5D%29> die-Methode weitergegeben werden kann, um die Zeichenfolge in die einzelnen Teil Zeichenfolgen zu trennen.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</param>
        <param name="length">Die Länge einer Teilzeichenfolge innerhalb dieser Instanz.</param>
        <summary>Kopiert die Zeichen einer angegebenen Teilzeichenfolge dieser Instanz in ein Array von Unicode-Zeichen.</summary>
        <returns>Ein Array von Unicode-Zeichen, dessen Elemente die <paramref name="length" />-Zeichen dieser Instanz ab Zeichenposition <paramref name="startIndex" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert die Zeichen in einem Teil einer Zeichenfolge in ein Zeichen Array. Um eine Zeichenfolge aus einem Zeichenbereich in einem Zeichen Array zu erstellen, rufen <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Sie den-Konstruktor auf.  
  
 Der `startIndex` -Parameter ist NULL basiert. Das heißt, der Index des ersten Zeichens in der Zeichen folgen Instanz ist 0 (null).  
  
 Wenn `length` 0 (null) ist, ist das zurückgegebene Array leer und hat die Länge 0 (null). Wenn diese Instanz oder `null` eine leere Zeichenfolge ("") ist, ist das zurückgegebene Array leer und hat eine Länge von 0 (null).  
  
 Um ein Bytearray zu erstellen, das die codierten Zeichen in einem Teil einer Zeichenfolge enthält, instanziieren Sie das <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> entsprechende <xref:System.Text.Encoding> -Objekt, und rufen Sie dessen-Methode auf. Zu den in .NET verfügbaren Standard Codierungen gehören:  
  
|Codierung|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Weitere Informationen finden Sie unter [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Teil Zeichenfolge innerhalb einer Zeichenfolge in ein Zeichen Array konvertiert. Anschließend werden die Elemente des Arrays aufgelistet und angezeigt.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="startIndex" /> plus <paramref name="length" /> ist größer als die Länge dieser Instanz.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</summary>
        <returns>Eine Zeichenfolge aus Kleinbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode berücksichtigt die Regeln der Groß-und Kleinschreibung der aktuellen Kultur.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert werden.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Der Schreibvorgang, der sich aus dem <xref:System.String.ToLower> Aufrufen der-Methode ergibt, übernimmt die Groß-/Kleinschreibungskonventionen der aktuellen Kultur. Verwenden <xref:System.String.ToLowerInvariant%2A> Sie die-Methode oder <xref:System.String.ToUpperInvariant%2A> die-Methode, wenn Sie die Groß-oder Kleinbuchstaben Version eines Betriebssystem Bezeichners benötigen, z. b. einen Dateinamen, Named Pipe oder einen Registrierungsschlüssel. Dies erzeugt dasselbe Ergebnis in jeder Kultur (im Gegensatz zur <xref:System.String.ToLower> -Methode) und führt zu einer effizienteren Leistung.  
  
   
  
## Examples  
 Im folgenden Beispiel werden mehrere gemischte Case-Zeichen folgen in Kleinbuchstaben konvertiert.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, Methoden zum Schreiben von Zeichen folgen nicht aufzurufen, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen. Um ein Zeichen in Kleinbuchstaben zu konvertieren, indem Sie die Groß-/Kleinschreibungskonventionen der aktuellen Kultur verwenden, müssen Sie <paramref name="culture" /> die <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> -Methoden Überladung mit dem <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> Wert für den Parameter aufrufen</para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</param>
        <summary>Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück, wobei die Regeln der Groß- und Kleinschreibung der angegebenen Kultur verwendet werden.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Kleinbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Regeln für die Groß-und Kleinschreibung `culture` der durch den-Parameter angegebenen Kultur bestimmen, wie der Fall der Zeichenfolge geändert wird.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert werden.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Wenn Sie der <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> -Methode ein <xref:System.Globalization.CultureInfo> anderes-Objekt <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>als übergeben, werden bei der Groß-/Kleinschreibung kulturspezifische Regeln berücksichtigt. Wenn Sie die Kleinbuchstaben-oder Großbuchstaben Version eines Betriebssystem Bezeichners benötigen, z. b. einen Dateinamen, Named Pipe oder einen Registrierungsschlüssel <xref:System.String.ToLowerInvariant%2A> , <xref:System.String.ToUpperInvariant%2A> verwenden Sie die-Methode oder die-Methode. Dies führt in jeder Kultur zu demselben Ergebnis und führt zu einer effizienteren Leistung.  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei Zeichen folgen von Großbuchstaben in Kleinbuchstaben konvertiert, indem die Kulturen English-USA und Turkish-Türkei verwendet werden. Anschließend werden die Zeichen folgen in Kleinbuchstaben verglichen. Die Zeichen folgen in Großbuchstaben sind beinahe identisch, mit der Ausnahme, dass für jedes Vorkommen des Unicode-lateinischen Großbuchstaben i in einer Zeichenfolge die andere Zeichenfolge den lateinischen Großbuchstaben i mit einem vorangehenden Punkt enthält.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine in Kleinbuchstaben konvertierte Kopie dieses <see cref="T:System.String" /> -Objekts zurück, wobei die Regeln der Groß- und Kleinschreibung der invarianten Kultur verwendet werden.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Kleinbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die invariante Kultur stellt eine Kultur dar, die Kultur unabhängig ist. Sie ist mit der englischen Sprache verknüpft, jedoch nicht mit einem bestimmten Land oder einer bestimmten Region. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 Wenn die Anwendung von der Groß-und Kleinschreibung einer Zeichenfolge abhängig ist, die von der aktuellen Kultur nicht betroffen ist, <xref:System.String.ToLowerInvariant%2A> verwenden Sie die-Methode. Die <xref:System.String.ToLowerInvariant%2A> -Methode `ToLower(CultureInfo.InvariantCulture)`entspricht. Die-Methode wird empfohlen, wenn eine Auflistung von Zeichen folgen in einer vorhersagbaren Reihenfolge in einem Benutzeroberflächen Steuerelement angezeigt werden muss.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert werden.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Verwenden <xref:System.String.ToLowerInvariant%2A> Sie die-Methode oder <xref:System.String.ToUpperInvariant%2A> die-Methode, wenn Sie die Groß-oder Kleinbuchstaben Version eines Betriebssystem Bezeichners benötigen, z. b. einen Dateinamen, Named Pipe oder einen Registrierungsschlüssel.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Zeichen folgen Array definiert, das ein einzelnes Wort in einer Reihe von Sprachen enthält. Die <xref:System.String.ToLowerInvariant%2A> -Methode wird verwendet, um die Elemente eines parallelen Arrays mit der Unterscheidung nach Groß-/Kleinschreibung der einzelnen Word-Elemente aufzufüllen. Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> -Methode wird verwendet, um das Array mit Berücksichtigung der Groß-/Kleinschreibung basierend auf der Reihenfolge der Elemente im Array für Kleinbuchstaben zu sortieren, um sicherzustellen, dass Elemente unabhängig von der Sprache in derselben Reihenfolge  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in einen <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt diese Instanz von <see cref="T:System.String" /> zurück. Es wird keine wirkliche Konvertierung durchgeführt.</summary>
        <returns>Die aktuelle Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da diese Methode die aktuelle Zeichenfolge einfach unverändert zurückgibt, ist es nicht erforderlich, Sie direkt aufzurufen. Sie wird in der Regel implizit in einem zusammengesetzten Formatierungs Vorgang aufgerufen, wie im Beispiel gezeigt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.ToString%2A> -Methode veranschaulicht. Beachten Sie, dass im Beispiel nicht explizit die <xref:System.String.ToString%2A> -Methode aufgerufen wird. Stattdessen wird die-Methode implizit von der Funktion für die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) aufgerufen.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">(Reserviert) Ein Objekt, das kulturabhängige Formatierungsinformationen bereitstellt.</param>
        <summary>Gibt diese Instanz von <see cref="T:System.String" /> zurück. Es wird keine wirkliche Konvertierung durchgeführt.</summary>
        <returns>Die aktuelle Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider`ist reserviert und ist zurzeit nicht an diesem Vorgang beteiligt.  
  
 Da diese Methode die aktuelle Zeichenfolge einfach unverändert zurückgibt, ist es nicht erforderlich, Sie direkt aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die Regeln der Groß-/Kleinschreibung der aktuellen Kultur, um jedes Zeichen in der aktuellen-Instanz in den entsprechenden Großbuchstaben zu konvertieren. Wenn ein Zeichen nicht über eine Entsprechung in Großbuchstaben verfügt, ist es in der zurückgegebenen Zeichenfolge unverändert enthalten.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert werden.  
  
 Die <xref:System.String.ToUpper%2A> -Methode wird häufig verwendet, um eine Zeichenfolge in Großbuchstaben zu konvertieren, sodass Sie bei einem Vergleich ohne Beachtung der Groß-/Kleinschreibung verwendet werden kann. Eine bessere Methode, Vergleiche ohne Berücksichtigung der Groß-/Kleinschreibung durchzuführen, besteht darin, <xref:System.StringComparison> eine Zeichen folgen Vergleichsmethode mit <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> einem-Parameter aufzurufen, dessen Wert Sie für einen Kultur abhängigen, Groß-/Kleinschreibung unterschieden.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Der Schreibvorgang, der sich aus dem <xref:System.String.ToUpper> Aufrufen der-Methode ergibt, übernimmt die Groß-/Kleinschreibungskonventionen der aktuellen Kultur. Wenn Sie die Kleinbuchstaben-oder Großbuchstaben Version eines Betriebssystem Bezeichners benötigen, z. b. einen Dateinamen, Named Pipe oder einen Registrierungsschlüssel <xref:System.String.ToLowerInvariant%2A> , <xref:System.String.ToUpperInvariant%2A> verwenden Sie die-Methode oder die-Methode. Dies erzeugt dasselbe Ergebnis in jeder Kultur (im Gegensatz zur <xref:System.String.ToUpper> -Methode) und führt zu einer effizienteren Leistung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.ToUpper%2A> -Methode aufgerufen, um eine Reihe von Zeichen folgen mit einer Zeichenfolge zu konvertieren, die jedes Zeichen in den grundlegenden lateinischen, lateinischen und lateinischen Zeichensätzen und lateinischen Zeichensätzen enthalten. Anschließend wird jede Zeichenfolge angezeigt, deren Großbuchstabe von Ihrem Kleinbuchstaben abweicht.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, Methoden zum Schreiben von Zeichen folgen nicht aufzurufen, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen. Um eine Zeichenfolge mithilfe der groß-/Kleinschreibungskonventionen der aktuellen Kultur in groß <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> Buchstaben zu konvertieren, müssen Sie <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> die- <paramref name="culture" /> Methoden Überladung mit dem Wert für den-Parameter aufrufen.</para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</param>
        <summary>Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück, wobei die Regeln der Groß- und Kleinschreibung der angegebenen Kultur verwendet werden.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Regeln für die Groß-und Kleinschreibung `culture` der durch den-Parameter angegebenen Kultur bestimmen, wie die Groß-und Kleinschreibung einer Zeichenfolge geändert  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert werden.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Wenn Sie der <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> -Methode ein <xref:System.Globalization.CultureInfo> anderes-Objekt <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>als übergeben, werden bei der Groß-/Kleinschreibung kulturspezifische Regeln berücksichtigt. Wenn Sie die Kleinbuchstaben-oder Großbuchstaben Version eines Betriebssystem Bezeichners benötigen, z. b. einen Dateinamen, Named Pipe oder einen Registrierungsschlüssel <xref:System.String.ToLowerInvariant%2A> , <xref:System.String.ToUpperInvariant%2A> verwenden Sie die-Methode oder die-Methode. Dies führt in jeder Kultur zu demselben Ergebnis und führt zu einer effizienteren Leistung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge aus Kleinbuchstaben mithilfe der Kulturen Englisch-USA und Türkisch-Türkei in zwei Zeichen folgen von Großbuchstaben konvertiert. Anschließend werden die Zeichen folgen in Großbuchstaben verglichen. Die Zeichen folgen in Großbuchstaben sind beinahe identisch, mit der Ausnahme, dass für jedes Vorkommen des Unicode-lateinischen Großbuchstaben i in einer Zeichenfolge die andere Zeichenfolge den lateinischen Großbuchstaben i mit einem vorangehenden Punkt enthält.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine in Großbuchstaben konvertierte Kopie dieses <see cref="T:System.String" /> -Objekts zurück, wobei die Regeln der Groß- und Kleinschreibung der invarianten Kultur verwendet werden.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die invariante Kultur stellt eine Kultur dar, die Kultur unabhängig ist. Sie ist mit der englischen Sprache verknüpft, jedoch nicht mit einem bestimmten Land oder einer bestimmten Region. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 Wenn die Anwendung von der Groß-und Kleinschreibung einer Zeichenfolge abhängig ist, die von der aktuellen Kultur nicht betroffen ist, <xref:System.String.ToUpperInvariant%2A> verwenden Sie die-Methode. Die <xref:System.String.ToUpperInvariant%2A> -Methode `ToUpper(CultureInfo.InvariantCulture)`entspricht. Die-Methode wird empfohlen, wenn eine Auflistung von Zeichen folgen in einer vorhersagbaren Reihenfolge in einem Benutzeroberflächen Steuerelement angezeigt werden muss.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert werden.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Verwenden <xref:System.String.ToLowerInvariant%2A> Sie die-Methode oder <xref:System.String.ToUpperInvariant%2A> die-Methode, wenn Sie die Groß-oder Kleinbuchstaben Version eines Betriebssystem Bezeichners benötigen, z. b. einen Dateinamen, Named Pipe oder einen Registrierungsschlüssel.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Zeichen folgen Array definiert, das ein einzelnes Wort in einer Reihe von Sprachen enthält. Die <xref:System.String.ToUpperInvariant%2A> -Methode wird verwendet, um die Elemente eines parallelen Arrays mit der Unterscheidung nach Groß-/Kleinschreibung der einzelnen Word-Elemente aufzufüllen. Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> -Methode wird verwendet, um das Array mit Berücksichtigung der Groß-/Kleinschreibung basierend auf der Reihenfolge der Elemente im Array für Großbuchstaben zu sortieren, um sicherzustellen, dass Elemente unabhängig von der Sprache in derselben Reihenfolge  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine neue Zeichenfolge zurück, in der alle führenden und nachgestellten Vorkommen eines Satzes von angegebenen Zeichen aus dem aktuellen <see cref="T:System.String" />-Objekt entfernt wurden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle führenden und nachgestellten Leerraumzeichen aus dem aktuellen <see cref="T:System.String" />-Objekt.</summary>
        <returns>Die resultierende Zeichenfolge nach dem Entfernen alle Leerraumzeichen am Anfang und Ende der aktuellen Zeichenfolge. Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Trim%2A> -Methode entfernt alle führenden und nachfolgenden Leerzeichen aus der aktuellen Zeichenfolge. Jeder führende und nachfolgende Trim-Vorgang wird beendet, wenn ein nicht-Leerzeichen auftritt. Wenn die aktuelle Zeichenfolge z. b. "abc xyz" ist <xref:System.String.Trim%2A> , gibt die Methode "abc xyz" zurück. Verwenden Sie [reguläre .net-Ausdrücke](~/docs/standard/base-types/regular-expressions.md), um Leerzeichen zwischen Wörtern in einer Zeichenfolge zu entfernen.  
  
> [!NOTE]
>  Wenn die <xref:System.String.Trim%2A> -Methode alle Zeichen aus der aktuellen Instanz entfernt, ändert diese Methode nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle führenden und nachfolgenden Leerzeichen, die in der aktuellen Instanz gefunden werden, entfernt werden.  
  
 Wenn die aktuelle Zeichenfolge <xref:System.String.Empty> oder alle Zeichen in der aktuellen Instanz aus Leerzeichen bestehen, gibt die Methode zurück. <xref:System.String.Empty>  
  
 Leerzeichen werden durch den Unicode-Standard definiert. Die <xref:System.String.Trim> -Methode entfernt alle führenden und nachfolgenden Zeichen, die einen Rückgabe `true` Wert von ergeben, wenn Sie <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> an die-Methode übermittelt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Trim?displayProperty=nameWithType> -Methode verwendet, um alle zusätzlichen Leerzeichen aus Zeichen folgen zu entfernen, die vom Benutzer eingegeben wurden, bevor Sie verkettet werden.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>In [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen wird eine interne Liste von leer Raum Zeichen beibehalten, die von dieser Methode fest sind. Beginnend mit [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]stellt die-Methode alle Unicode-Leerzeichen (d. h. Zeichen, die einen <see langword="true" /> Rückgabewert ergeben, wenn Sie an die <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> -Methode übermittelt werden). Aufgrund dieser Änderung entfernt <see cref="M:System.String.Trim" /> die-Methode in der-und der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] früheren-Version zwei Zeichen, den Leerraum (u + 200B) und den NULL-Wert ohne Umbruch Zeichen (u + FEFF) <see cref="M:System.String.Trim" /> , [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]dass die-Methode in und höheren Versionen nicht entfernen. Außerdem werden mit der <see cref="M:System.String.Trim" /> [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] -Methode in und früheren Versionen nicht drei Unicode-leer Raum Zeichen beschnitten: Mongolischer vowel-Trennzeichen (u + 180E), schmaler, nicht Umbruch Bereich (u + 202F) und mittlerer mathematischer Raum (u + 205f).</para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Ein Array mit den zu entfernenden Unicode-Zeichen oder <see langword="null" />.</param>
        <summary>Entfernt alle führenden und nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem aktuellen <see cref="T:System.String" />-Objekt.</summary>
        <returns>Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars" />-Parameter übergebenen Zeichen am Anfang und Ende der aktuellen Zeichenfolge entfernt wurden. Wenn <paramref name="trimChars" /> <see langword="null" /> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt. Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Trim%2A> -Methode entfernt alle führenden und nachfolgenden Zeichen aus der aktuellen Zeichenfolge, `trimChars` die im-Parameter enthalten sind. Jeder führende und nachfolgende Trim-Vorgang wird beendet, wenn ein Zeichen `trimChars` , das nicht in ist, gefunden wird. Wenn die aktuelle Zeichenfolge z. b. "123abc456xyz789" `trimChars` ist und die Ziffern von "1" bis "9" enthält <xref:System.String.Trim%2A> , gibt die Methode "abc456xyz" zurück.  
  
> [!NOTE]
>  Wenn die <xref:System.String.Trim%2A> -Methode alle Zeichen aus der aktuellen Instanz entfernt, ändert diese Methode nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle in `trimChars` der aktuellen Instanz gefundenen führenden und nachfolgenden Zeichen entfernt werden.  
  
 Wenn die aktuelle Zeichenfolge <xref:System.String.Empty> ist oder alle Zeichen in der aktuellen Instanz aus Zeichen `trimChars` im Array bestehen, gibt die Methode zurück <xref:System.String.Empty>.  
  
 Wenn `trimChars` oder `null` ein leeres Array ist, entfernt diese Methode alle führenden oder nachfolgenden Zeichen, die dazu führen, `true` dass die Methode zurückgibt, <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Wenn Sie an die-Methode übermittelt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> -Methode verwendet, um Leerzeichen, Sternchen (*) und Apostroph (') aus einer Zeichenfolge zu entfernen.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>In [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen wird eine interne Liste von leer Raum Zeichen verwaltet, die von dieser Methode nur <paramref name="trimChars" /> dann <see langword="null" /> untersucht werden, wenn ist, oder ein leeres Array. [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]Beginnend mit <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> , wenn <paramref name="trimChars" /> oder ein <see langword="null" /> leeres Array ist, schneidet die-Methode alle Unicode-Leerzeichen ab (d. h. Zeichen, die einen <see langword="true" /> Rückgabewert ergeben, wenn Sie an die-Methode übermittelt werden). Aufgrund dieser Änderung entfernt <see cref="M:System.String.Trim" /> die-Methode in der-und der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] früheren-Version zwei Zeichen, den Leerraum (u + 200B) und den NULL-Wert ohne Umbruch Zeichen (u + FEFF) <see cref="M:System.String.Trim" /> , [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]dass die-Methode in und höheren Versionen nicht entfernen. Außerdem werden mit der <see cref="M:System.String.Trim" /> [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] -Methode in und früheren Versionen nicht drei Unicode-leer Raum Zeichen beschnitten: Mongolischer vowel-Trennzeichen (u + 180E), schmaler, nicht Umbruch Bereich (u + 202F) und mittlerer mathematischer Raum (u + 205f).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Ein Array mit den zu entfernenden Unicode-Zeichen oder <see langword="null" />.</param>
        <summary>Entfernt alle nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem aktuellen <see cref="T:System.String" />-Objekt.</summary>
        <returns>Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars" />-Parameter übergebenen Zeichen am Ende der aktuellen Zeichenfolge entfernt wurden. Wenn <paramref name="trimChars" /> <see langword="null" /> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt. Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.TrimEnd%2A> -Methode entfernt alle nachfolgenden Zeichen, die `trimChars` im-Parameter enthalten sind, aus der aktuellen Zeichenfolge. Der Trim-Vorgang wird beendet, wenn das erste Zeichen, `trimChars` das sich nicht in befindet, am Ende der Zeichenfolge gefunden wird. Wenn die aktuelle Zeichenfolge z. b. "123abc456xyz789" `trimChars` ist und die Ziffern von "1" bis "9" enthält <xref:System.String.TrimEnd%2A> , gibt die Methode "123abc456xyz" zurück.  
  
> [!NOTE]
>  Wenn die <xref:System.String.TrimEnd%2A> -Methode alle Zeichen aus der aktuellen Instanz entfernt, ändert diese Methode nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle nachfolgenden `trimChars` Zeichen, die in gefunden werden, aus der aktuellen Zeichenfolge entfernt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie die <xref:System.String.TrimEnd%28System.Char%5B%5D%29> -Methode verwenden können, um Leerzeichen oder Satzzeichen am Ende einer Zeichenfolge zu kürzen.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>In [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen wird eine interne Liste von leer Raum Zeichen verwaltet, die von dieser Methode nur <paramref name="trimChars" /> dann <see langword="null" /> untersucht werden, wenn ist, oder ein leeres Array. [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]Beginnend mit <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> , wenn <paramref name="trimChars" /> oder ein <see langword="null" /> leeres Array ist, schneidet die-Methode alle Unicode-Leerzeichen ab (d. h. Zeichen, die einen <see langword="true" /> Rückgabewert ergeben, wenn Sie an die-Methode übermittelt werden). Aufgrund dieser Änderung entfernt <see cref="M:System.String.Trim" /> die-Methode in der-und der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] früheren-Version zwei Zeichen, den Leerraum (u + 200B) und den NULL-Wert ohne Umbruch Zeichen (u + FEFF) <see cref="M:System.String.Trim" /> , [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] dass die-Methode in und höheren Versionen nicht entfernen. Außerdem werden mit der <see cref="M:System.String.Trim" /> [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] -Methode in und früheren Versionen nicht drei Unicode-leer Raum Zeichen beschnitten: Mongolischer vowel-Trennzeichen (u + 180E), schmaler, nicht Umbruch Bereich (u + 202F) und mittlerer mathematischer Raum (u + 205f).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Ein Array mit den zu entfernenden Unicode-Zeichen oder <see langword="null" />.</param>
        <summary>Entfernt alle nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem aktuellen <see cref="T:System.String" />-Objekt.</summary>
        <returns>Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars" />-Parameter übergebenen Zeichen am Anfang der aktuellen Zeichenfolge entfernt wurden. Wenn <paramref name="trimChars" /> <see langword="null" /> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.TrimStart%2A> -Methode entfernt alle führenden Zeichen aus der aktuellen Zeichenfolge, die `trimChars` im-Parameter enthalten sind. Der Trim-Vorgang wird beendet, wenn ein Zeichen, `trimChars` das nicht in ist, gefunden wird. Wenn die aktuelle Zeichenfolge z. b. "123abc456xyz789" `trimChars` ist und die Ziffern von "1" bis "9" enthält <xref:System.String.TrimStart%2A> , gibt die Methode "abc456xyz789" zurück.  
  
> [!NOTE]
>  Wenn die <xref:System.String.TrimStart%2A> -Methode alle Zeichen aus der aktuellen Instanz entfernt, ändert diese Methode nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle in der aktuellen Instanz gefundenen führenden Leerzeichen entfernt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die grundlegenden Funktionen <xref:System.String.TrimStart%2A> der-Methode veranschaulicht:

 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

 Im folgenden Beispiel wird die <xref:System.String.TrimStart%2A> -Methode verwendet, um Leerzeichen und Kommentarzeichen aus Zeilen des Quellcodes zu kürzen. Die `StripComments` <xref:System.String.TrimStart%2A> -Methode umschließt einen-Vorgang und übergibt ihm ein Zeichen Array mit einem Leerzeichen und dem Kommentarzeichen, das ein Apostroph (') in Visual Basic und ein Schrägstrich (/ C#) in ist. Die <xref:System.String.TrimStart%2A> -Methode wird auch aufgerufen, um führende Leerzeichen zu entfernen, wenn ausgewertet wird, ob eine Zeichenfolge ein Kommentar ist.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 Im folgenden Beispiel wird ein Aufruf der `StripComments`-Methode veranschaulicht.  
  
 [!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
 [!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>In [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen wird eine interne Liste von leer Raum Zeichen verwaltet, die von dieser Methode nur <paramref name="trimChars" /> dann <see langword="null" /> untersucht werden, wenn ist, oder ein leeres Array. [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]Beginnend mit <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> , wenn <paramref name="trimChars" /> oder ein <see langword="null" /> leeres Array ist, schneidet die-Methode alle Unicode-Leerzeichen ab (d. h. Zeichen, die einen <see langword="true" /> Rückgabewert ergeben, wenn Sie an die-Methode übermittelt werden). Aufgrund dieser Änderung entfernt <see cref="M:System.String.Trim" /> die-Methode in der-und der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] früheren-Version zwei Zeichen, den Leerraum (u + 200B) und den NULL-Wert ohne Umbruch Zeichen (u + FEFF) <see cref="M:System.String.Trim" /> , [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] dass die-Methode in und höheren Versionen nicht entfernen. Außerdem werden mit der <see cref="M:System.String.Trim" /> [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] -Methode in und früheren Versionen nicht drei Unicode-leer Raum Zeichen beschnitten: Mongolischer vowel-Trennzeichen (u + 180E), schmaler, nicht Umbruch Bereich (u + 202F) und mittlerer mathematischer Raum (u + 205f).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>