<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="String.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">037e736f-f76f-422a-bcb7-5d2d599f851d401fd31105c0672ff290b44bd02a359e72436589.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">401fd31105c0672ff290b44bd02a359e72436589</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6fc53860cd2661bb7bde6e4b2858fcda4ec4c889</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/10/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Represents text as a sequence of UTF-16 code units.</source>
          <target state="translated">Stellt Text als Sequenz von UTF-16-Codeeinheiten dar.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string is a sequential collection of characters that is used to represent text.</source>
          <target state="translated">Eine Zeichenfolge ist eine sequenzielle Auflistung von Zeichen, die zum Darstellen von Text verwendet wird.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A <ph id="ph1">&lt;xref:System.String&gt;</ph> object is a sequential collection of <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> objects that represent a string; a <ph id="ph3">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> object corresponds to a UTF-16 code unit.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt ist eine sequenzielle Auflistung von <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> Objekte, die darstellen, eine Zeichenfolge; ein <ph id="ph3">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> -Objekt entspricht einer Codeeinheit UTF-16.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The value of the <ph id="ph1">&lt;xref:System.String&gt;</ph> object is the content of the sequential collection of <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> objects, and that value is immutable (that is, it is read-only).</source>
          <target state="translated">Der Wert, der die <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt befindet sich der Inhalt der sequenziellen Auflistung von <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> Objekte und Wert unveränderlich ist (d. h., sie ist schreibgeschützt).</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about the immutability of strings, see the <bpt id="p1">[</bpt>Immutability and the StringBuilder class<ept id="p1">](#Immutability)</ept> section later in this topic.</source>
          <target state="translated">Weitere Informationen über die Unveränderlichkeit von Zeichenfolgen, finden Sie unter der <bpt id="p1">[</bpt>Unveränderlichkeit und der StringBuilder-Klasse<ept id="p1">](#Immutability)</ept> weiter unten in diesem Thema.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The maximum size of a <ph id="ph1">&lt;xref:System.String&gt;</ph> object in memory is 2GB, or about 1 billion characters.</source>
          <target state="translated">Die maximale Größe einer <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt im Arbeitsspeicher ist 2 GB oder ungefähr 1 Milliarde Zeichen.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this section:</source>
          <target state="translated">In diesem Abschnitt</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Instantiating a String object<ept id="p1">](#Instantiation)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Instanziieren ein String-Objekt<ept id="p1">](#Instantiation)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Char objects and Unicode characters<ept id="p1">](#Characters)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Char-Objekte und Unicode-Zeichen<ept id="p1">](#Characters)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Strings and The Unicode Standard<ept id="p1">](#Unicode)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Zeichenfolgen und Unicode-Standard<ept id="p1">](#Unicode)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Strings and embedded null characters<ept id="p1">](#EmbeddedNulls)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Zeichenfolgen und eingebettete Null-Zeichen<ept id="p1">](#EmbeddedNulls)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Strings and indexes<ept id="p1">](#Indexes)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Zeichenfolgen und Indizes<ept id="p1">](#Indexes)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Null strings and empty strings<ept id="p1">](#Nulls)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>NULL-Zeichenfolgen und leere Zeichenfolgen<ept id="p1">](#Nulls)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Immutability and the StringBuilder class<ept id="p1">](#Immutability)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Unveränderlichkeit und der StringBuilder-Klasse<ept id="p1">](#Immutability)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Ordinal vs. culture-sensitive operations<ept id="p1">](#CultureSensitive)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Ordnungszahl im Vergleich zu kulturabhängige Operationen<ept id="p1">](#CultureSensitive)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Normalisierung<ept id="p1">](#Normalization)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Zeichenfolgenoperationen nach Kategorie<ept id="p1">](#ByCategory)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Instantiating a String object</source>
          <target state="translated">Instanziieren ein String-Objekt</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.String&gt;</ph> object in the following ways:</source>
          <target state="translated">Instanziieren Sie ein <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt auf folgende Weise:</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By assigning a string literal to a <ph id="ph1">&lt;xref:System.String&gt;</ph> variable.</source>
          <target state="translated">Durch Zuweisen eines Zeichenfolgenliterals zu einer <ph id="ph1">&lt;xref:System.String&gt;</ph> Variable.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the most commonly used method for creating a string.</source>
          <target state="translated">Dies ist die am häufigsten verwendete Methode zum Erstellen einer Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses assignment to create several strings.</source>
          <target state="translated">Im folgenden Beispiel wird die Zuordnung zum Erstellen von mehreren Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that in C#, because the backslash (<ph id="ph1">\\</ph>) is an escape character, literal backslashes in a string must be escaped or the entire string must be <ph id="ph2">@-quoted</ph>.</source>
          <target state="translated">Beachten Sie, dass in C# geschrieben, da der umgekehrte Schrägstrich (<ph id="ph1">\\</ph>) ist ein Escapezeichen, literal umgekehrte Schrägstriche in einer Zeichenfolge müssen mit Escapezeichen versehen werden, oder die gesamte Zeichenfolge muss <ph id="ph2">@-quoted</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By calling a <ph id="ph1">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">Durch Aufrufen einer <ph id="ph1">&lt;xref:System.String&gt;</ph> Klassenkonstruktor.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example instantiates strings by calling several class constructors.</source>
          <target state="translated">Im folgende Beispiel werden Zeichenfolgen durch Aufrufen von mehreren Klassenkonstruktoren instanziiert.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters.</source>
          <target state="translated">Beachten Sie, dass einige der Konstruktoren Zeiger auf Zeichen oder mit Vorzeichen Bytearrays als Parameter enthalten.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Visual Basic does not support calls to these constructors.</source>
          <target state="translated">Visual Basic unterstützt keine Aufrufe dieser Konstruktoren.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For detailed information about <ph id="ph1">&lt;xref:System.String&gt;</ph> constructors, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Ausführliche Informationen zu <ph id="ph1">&lt;xref:System.String&gt;</ph> Konstruktoren finden Sie unter der <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> Konstruktor Zusammenfassung.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By using the string concatenation operator (+ in C# and &amp; or + in Visual Basic) to create a single string from any combination of <ph id="ph1">&lt;xref:System.String&gt;</ph> instances and string literals.</source>
          <target state="translated">Mithilfe des Operators für zeichenfolgenverkettung (+ in C# geschrieben und &amp; oder + in Visual Basic) So erstellen Sie eine einzelne Zeichenfolge aus einer beliebigen Kombination <ph id="ph1">&lt;xref:System.String&gt;</ph> Instanzen und Zeichenfolgenliterale.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the use of the string concatenation operator.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung der der Operator für zeichenfolgenverkettung.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By retrieving a property or calling a method that returns a string.</source>
          <target state="translated">Abrufen einer Eigenschaft oder eine Methode aufrufen, die eine Zeichenfolge zurückgibt.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the methods of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class to extract a substring from a larger string.</source>
          <target state="translated">Das folgende Beispiel verwendet die Methoden der <ph id="ph1">&lt;xref:System.String&gt;</ph> Klasse, um eine Unterzeichenfolge aus einer größeren Zeichenfolge zu extrahieren.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By calling a formatting method to convert a value or object to its string representation.</source>
          <target state="translated">Durch Aufrufen einer Formatierungsmethode um einen Wert oder ein Objekt in seine Zeichenfolgendarstellung zu konvertieren.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the                <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature to embed the string representation of two objects into a string.</source>
          <target state="translated">Im folgenden Beispiel wird die <bpt id="p1">[</bpt>kombinierte Formatierung<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> Funktion, um die Zeichenfolgendarstellung von zwei Objekten in eine Zeichenfolge einzubetten.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Char objects and Unicode characters</source>
          <target state="translated">Char-Objekte und Unicode-Zeichen</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character.</source>
          <target state="translated">Jedes Zeichen in einer Zeichenfolge wird durch einen skalaren Unicodewert, auch als einen Unicode-Codepunkt oder den Ordinalwert des Unicode-Zeichens (numerisch) definiert.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
          <target state="translated">Jeden Codepunkt mithilfe von UTF-16-Codierung codiert ist, und der numerische Wert der einzelnen Elemente der Codierung wird dargestellt, indem ein <ph id="ph1">&lt;xref:System.Char&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that, because a <ph id="ph1">&lt;xref:System.String&gt;</ph> instance consists of a sequential collection of UTF-16 code units, it is possible to create a <ph id="ph2">&lt;xref:System.String&gt;</ph> object that is not a well-formed Unicode string.</source>
          <target state="translated">Beachten Sie Folgendes: Da ein <ph id="ph1">&lt;xref:System.String&gt;</ph> -Instanz besteht aus einer sequenziellen Auflistung von UTF-16-Codeeinheiten, es ist möglich, erstellen Sie eine <ph id="ph2">&lt;xref:System.String&gt;</ph> -Objekt, das keine Unicode-Zeichenfolge wohlgeformt ist.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate.</source>
          <target state="translated">Beispielsweise ist es möglich, eine Zeichenfolge zu erstellen, die ein niedriges Ersatzzeichen ohne entsprechenden hohes Ersatzzeichen ist.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Although some methods, such as the methods of encoding and decoding objects in the <ph id="ph1">&lt;xref:System.Text&gt;</ph> namespace, may performs checks to ensure that strings are well-formed, <ph id="ph2">&lt;xref:System.String&gt;</ph> class members don't ensure that a string is well-formed.</source>
          <target state="translated">Obwohl einige Methoden, z. B. die Methoden der Codierung und Decodierung von Objekten in der <ph id="ph1">&lt;xref:System.Text&gt;</ph> Namespace, möglicherweise führt Überprüfungen, um sicherzustellen, dass Zeichenfolgen wohlgeformt sind <ph id="ph2">&lt;xref:System.String&gt;</ph> Klassenmember ist nicht sichergestellt, dass eine Zeichenfolge wohlgeformt ist.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A single <ph id="ph1">&lt;xref:System.Char&gt;</ph> object usually represents a single code point; that is, the numeric value of the <ph id="ph2">&lt;xref:System.Char&gt;</ph> equals the code point.</source>
          <target state="translated">Ein einzelnes <ph id="ph1">&lt;xref:System.Char&gt;</ph> Objekt stellt normalerweise eine einzelne Codepunkt, d. h. den numerischen Wert der <ph id="ph2">&lt;xref:System.Char&gt;</ph> Codepunkt entspricht.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the code point for the character "a" is U+0061.</source>
          <target state="translated">Z. B. den Codepunkt für das Zeichen "a" ist U + 0061 ist.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, a code point might require more than one encoded element (more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph> object).</source>
          <target state="translated">Allerdings erfordert ein Codepunkt möglicherweise mehr als eine codiertes Element (mehr als ein <ph id="ph1">&lt;xref:System.Char&gt;</ph> Objekt).</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The Unicode standard defines two types of characters that correspond to multiple <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.</source>
          <target state="translated">Die Unicode-Standard definiert zwei Typen von Zeichen, die entsprechen mit mehreren <ph id="ph1">&lt;xref:System.Char&gt;</ph> Objekte: Graphemes und ergänzende Unicode-Codepunkten, die die zusätzlichen Ebenen von Unicode-Zeichen entsprechen.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A grapheme is represented by a base character followed by one or more combining characters.</source>
          <target state="translated">Eine zwischen graphemgruppen wird durch ein Basiszeichen gefolgt von mindestens Kombinationszeichen dargestellt.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the character ä is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object whose code point is U+0061 followed by a <ph id="ph2">&lt;xref:System.Char&gt;</ph> object whose code point is U+0308.</source>
          <target state="translated">Das Zeichen "ä" wird beispielsweise dargestellt, durch ein <ph id="ph1">&lt;xref:System.Char&gt;</ph> Objekt, dessen Codepunkt U + 0061 ist, gefolgt von einem <ph id="ph2">&lt;xref:System.Char&gt;</ph> Objekt, dessen Codepunkt U + 0308.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This character can also be defined by a single <ph id="ph1">&lt;xref:System.Char&gt;</ph> object that has a code point of U+00E4.</source>
          <target state="translated">Diese Zeichen kann auch über einen einzelnen definiert <ph id="ph1">&lt;xref:System.Char&gt;</ph> Objekt, das einen Codepunkt U + 00E4 verfügt.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not.</source>
          <target state="translated">Wie im folgenden Beispiel wird gezeigt, gibt ein kulturabhängiger Vergleich, Gleichheit, dass diese zwei Darstellungen gleich sind, obwohl Sie ein Ordinalvergleich durch normaler nicht der Fall ist.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, if the two strings are normalized, an ordinal comparison also indicates that they are equal.</source>
          <target state="translated">Wenn die beiden Zeichenfolgen normalisiert werden, gibt hingegen ein ordinalen Vergleich auch, dass sie gleich sind.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(For more information on normalizing strings, see the <bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept> section.)</source>
          <target state="translated">(Weitere Informationen zum Normalisieren von Zeichenfolgen finden Sie unter der <bpt id="p1">[</bpt>Normalisierung<ept id="p1">](#Normalization)</ept> Abschnitt.)</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A Unicode supplementary code point (a surrogate pair) is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object whose code point is a high surrogate followed by a <ph id="ph2">&lt;xref:System.Char&gt;</ph> object whose code point is a low surrogate.</source>
          <target state="translated">Eine Unicode ergänzende Codepunkt (ein Ersatzzeichenpaar) wird durch eine <ph id="ph1">&lt;xref:System.Char&gt;</ph> -Objekt, dessen Codepunkt ein hohes Ersatzzeichen ist, gefolgt von einer <ph id="ph2">&lt;xref:System.Char&gt;</ph> -Objekt, dessen Codepunkt ein niedriges Ersatzzeichen ist.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The code units of high surrogates range from U+D800 to U+DBFF.</source>
          <target state="translated">Die Codeeinheiten der hohe Ersatzzeichen zwischen U + D800 und U + DBFF liegt.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The code units of low surrogates range from U+DC00 to U+DFFF.</source>
          <target state="translated">Die Codeeinheiten der niedrige Ersatzzeichen liegen zwischen U + DC00 und U + DFFF.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes.</source>
          <target state="translated">Ersatzzeichenpaare werden verwendet, um Zeichen in die 16 ergänzenden Unicode-Ebenen darstellen.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example creates a surrogate character and passes it to the <ph id="ph1">&lt;xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> method to determine whether it is a surrogate pair.</source>
          <target state="translated">Das folgende Beispiel erstellt ein Ersatzzeichen und übergibt es an die <ph id="ph1">&lt;xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> Methode, um zu bestimmen, ob es sich um ein Ersatzzeichenpaar ist.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Strings and The Unicode Standard</source>
          <target state="translated">Zeichenfolgen und Unicode-Standard</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Characters in a string are represented by UTF-16 encoded code units, which correspond to <ph id="ph1">&lt;xref:System.Char&gt;</ph> values.</source>
          <target state="translated">Zeichen in einer Zeichenfolge von UTF-16-codierte Codeeinheiten, die entsprechen dargestellt sind <ph id="ph1">&lt;xref:System.Char&gt;</ph> Werte.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each character in a string has an associated Unicode character category, which is represented in the .NET Framework by the <ph id="ph1">&lt;xref:System.Globalization.UnicodeCategory&gt;</ph> enumeration.</source>
          <target state="translated">Jedes Zeichen in einer Zeichenfolge verfügt über eine Kategorie zugeordneten Unicode-Zeichen, die in .NET Framework durch dargestellt wird die <ph id="ph1">&lt;xref:System.Globalization.UnicodeCategory&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The category of a character or a surrogate pair can be determined by calling the <ph id="ph1">&lt;xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die Kategorie eines Zeichens oder ein Ersatzzeichenpaar kann bestimmt werden, durch Aufrufen der <ph id="ph1">&lt;xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET maintains its own table of characters and their corresponding categories, which ensures that a specific version of a .NET implementation running on different platforms returns identical character category information.</source>
          <target state="translated">.NET behält eine eigene Tabelle von Zeichen und ihrer entsprechenden Kategorien, der sicherstellt, dass eine bestimmte Version einer .NET-Implementierung, die auf anderen Plattformen ausgeführt Kategorieinformationen identische Zeichen zurückgibt.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following table lists .NET versions and the versions of the Unicode Standard on which their character categories are based.</source>
          <target state="translated">Die folgende Tabelle enthält .NET und -Versionen im Unicode-Standard, auf denen ihre Zeichenkategorien basieren.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework version</source>
          <target state="translated">.NET Framework-Version</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Version of the Unicode Standard</source>
          <target state="translated">Version des Unicode-Standards</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 4.0.0<ept id="p1">](https://www.unicode.org/versions/Unicode4.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 4.0.0 im Unicode-Standard<ept id="p1">](https://www.unicode.org/versions/Unicode4.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework 2.0</source>
          <target state="translated">.NET Framework 2.0</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 5.0.0 im Unicode-Standard<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 5.0.0 im Unicode-Standard<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 5.0.0 im Unicode-Standard<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 6.3.0 im Unicode-Standard<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 6.3.0 im Unicode-Standard<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 6.3.0 im Unicode-Standard<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 6.3.0 im Unicode-Standard<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 6.3.0 im Unicode-Standard<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 8.0.0<ept id="p1">](https://www.unicode.org/versions/Unicode8.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 8.0.0 im Unicode-Standard<ept id="p1">](https://www.unicode.org/versions/Unicode8.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Core (all versions)</source>
          <target state="translated">.NET Core (alle Versionen)</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 8.0.0<ept id="p1">](https://www.unicode.org/versions/Unicode8.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 8.0.0 im Unicode-Standard<ept id="p1">](https://www.unicode.org/versions/Unicode8.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, the .NET Framework supports string comparison and sorting based on the Unicode standard.</source>
          <target state="translated">Darüber hinaus unterstützt .NET Framework Zeichenfolgenvergleich und Sortierung basierend auf den Unicode-Standard.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In versions of the .NET Framework through the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the .NET Framework maintains its own table of string data.</source>
          <target state="translated">In Versionen von .NET Framework über die <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, .NET Framework verwaltet eine eigenen Tabelle von Zeichenfolgendaten.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is also true of versions of the .NET Framework starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on Windows 7.</source>
          <target state="translated">Dies gilt auch, beginnend mit .NET Framework-Versionen der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> auf Windows 7 ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> auf Windows 8 und höheren Versionen von Windows-Betriebssystem ausgeführt wird, die die Common Language Runtime-Delegaten Zeichenfolge Vergleichs- und Sortiervorgänge für das Betriebssystem.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following table lists the versions of the .NET Framework and the versions of the Unicode Standard on which character comparison and sorting are based.</source>
          <target state="translated">Die folgende Tabelle enthält die Versionen von .NET Framework und die Versionen im Unicode-Standard, auf welches Zeichen Vergleich und Sortierung basieren.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework version</source>
          <target state="translated">.NET Framework-Version</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Version of the Unicode Standard</source>
          <target state="translated">Version des Unicode-Standards</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 4.0.0<ept id="p1">](https://www.unicode.org/versions/Unicode4.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 4.0.0 im Unicode-Standard<ept id="p1">](https://www.unicode.org/versions/Unicode4.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework 2.0</source>
          <target state="translated">.NET Framework 2.0</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 5.0.0 im Unicode-Standard<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 5.0.0 im Unicode-Standard<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 5.0.0 im Unicode-Standard<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later on Windows 7</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> und höher unter Windows 7</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 5.0.0 im Unicode-Standard<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later on Windows 8 and later Windows operating systems</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> und höher unter Windows 8 und höheren Windows-Betriebssysteme</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Version 6.3.0 im Unicode-Standard<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In .NET Core, sorting and comparison operations are based on <bpt id="p1">[</bpt>Version 8.0.0 of the Unicode Standard<ept id="p1">](https://www.unicode.org/versions/Unicode8.0.0/)</ept>.</source>
          <target state="translated">In .NET Core, basieren die Sortier- und Vergleichsregeln Vorgänge auf <bpt id="p1">[</bpt>Version 8.0.0 im Unicode-Standard<ept id="p1">](https://www.unicode.org/versions/Unicode8.0.0/)</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Strings and embedded null characters</source>
          <target state="translated">Zeichenfolgen und eingebettete Null-Zeichen</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the .NET Framework, a <ph id="ph1">&lt;xref:System.String&gt;</ph> object can include embedded null characters, which count as a part of the string's length.</source>
          <target state="translated">In .NET Framework eine <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt kann eingebettete Null-Zeichen, die Anzahl der im Rahmen der Länge der Zeichenfolge enthalten.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, in some languages such as C and C++, a null character indicates the end of a string;it is not considered a part of the string and is not counted as part of the string's length.</source>
          <target state="translated">Jedoch in einigen Sprachen wie C# und C++, ein Null-Zeichen gibt das Ende einer Zeichenfolge, die nicht als einen Teil der Zeichenfolge und wird als Teil der Länge der Zeichenfolge nicht gezählt.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to <ph id="ph1">&lt;xref:System.String&gt;</ph> objects:</source>
          <target state="translated">Dies bedeutet, dass die folgenden allgemeinen Annahmen, die C- und C++-Programmierer oder Bibliotheken, die in C oder C++ geschriebene über Zeichenfolgen, die möglicherweise nicht unbedingt gültig, wenn Sie zugewiesen sind <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekte:</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The value returned by the <ph id="ph1">`strlen`</ph> or <ph id="ph2">`wcslen`</ph> functions does not necessarily equal <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der zurückgegebene Wert den <ph id="ph1">`strlen`</ph> oder <ph id="ph2">`wcslen`</ph> Funktionen entspricht nicht unbedingt <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The string created by the <ph id="ph1">`strcpy_s`</ph> or <ph id="ph2">`wcscpy_s`</ph> functions is not necessarily identical to the string created by the <ph id="ph3">&lt;xref:System.String.Copy%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die Zeichenfolge, die erstellt, indem die <ph id="ph1">`strcpy_s`</ph> oder <ph id="ph2">`wcscpy_s`</ph> Funktionen ist nicht unbedingt identisch mit der Zeichenfolge erstellt, indem die <ph id="ph3">&lt;xref:System.String.Copy%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You should ensure that native C and C++ code that instantiates <ph id="ph1">&lt;xref:System.String&gt;</ph> objects, and code that is passed <ph id="ph2">&lt;xref:System.String&gt;</ph> objects through platform invoke, don't assume that an embedded null character marks the end of the string.</source>
          <target state="translated">Sie sollten sicherstellen, dass diese systemeigene C- und C++-Code, der instanziiert <ph id="ph1">&lt;xref:System.String&gt;</ph> Benutzerobjekten und Code, der übergeben wird <ph id="ph2">&lt;xref:System.String&gt;</ph> Objekte über Platform aufrufen, nicht davon ausgehen, dass ein eingebettetes Null-Zeichen das Ende der Zeichenfolge markiert.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched.</source>
          <target state="translated">Eingebettete Null-Zeichen in einer Zeichenfolge werden ebenfalls anders behandelt werden, wenn eine Zeichenfolge sortiert (oder verglichen) und eine Zeichenfolge durchsucht wird.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture.</source>
          <target state="translated">NULL-Zeichen werden ignoriert, wenn kulturabhängige Vergleiche zwischen zwei Zeichenfolgen, einschließlich vergleichen, die mit der invarianten Kultur ausgeführt.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>They are considered only for ordinal or case-insensitive ordinal comparisons.</source>
          <target state="translated">Diese sind nur für die Ordinalvergleiche von ordinal oder Groß-/Kleinschreibung berücksichtigt.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, embedded null characters are always considered when searching a string with methods such as <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.StartsWith%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.IndexOf%2A&gt;</ph>.</source>
          <target state="translated">Andererseits, eingebettete Null-Zeichen werden immer berücksichtigt, wenn eine Zeichenfolge mit Methoden wie z. B. Suche <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.StartsWith%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.String.IndexOf%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Strings and indexes</source>
          <target state="translated">Zeichenfolgen und Indizes</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An index is the position of a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object (not a Unicode character) in a <ph id="ph2">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Ein Index ist die Position des eine <ph id="ph1">&lt;xref:System.Char&gt;</ph> Objekt (nicht in ein Unicode-Zeichen) in einem <ph id="ph2">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero.</source>
          <target state="translated">Ein Index ist eine nullbasierte, nicht negative Zahl, die von der ersten Position in der Zeichenfolge beginnt, der Indexposition 0 (null) ist.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A number of search methods, such as <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, return the index of a character or substring in the string instance.</source>
          <target state="translated">Eine Reihe von Methoden wie z. B. <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, zurückgeben den Index eines Zeichens oder einer Teilzeichenfolge in der Zeichenfolgeninstanz.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property lets you access individual <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects by their index position in the string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> Eigenschaft ermöglicht den Zugriff auf einzelne <ph id="ph2">&lt;xref:System.Char&gt;</ph> Objekte durch ihre Indexposition in der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects in a string by using code such as the following.</source>
          <target state="translated">Da die <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> Eigenschaft ist die Standardeigenschaft (in Visual Basic) oder Indexer (in c#), können Sie die einzelnen zugreifen <ph id="ph2">&lt;xref:System.Char&gt;</ph> Objekte in einer Zeichenfolge durch folgenden Code verwenden.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This code looks for white space or punctuation characters in a string to determine how many words the string contains.</source>
          <target state="translated">Dieser Code sucht nach Leerzeichen oder Satzzeichen in eine Zeichenfolge, um zu bestimmen, wie viele Wörter die Zeichenfolge enthält.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the <ph id="ph1">&lt;xref:System.String&gt;</ph> class implements the <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface, you can also iterate through the <ph id="ph3">&lt;xref:System.Char&gt;</ph> objects in a string by using a <ph id="ph4">`foreach`</ph> construct, as the following example shows.</source>
          <target state="translated">Da die <ph id="ph1">&lt;xref:System.String&gt;</ph> -Klasse implementiert die <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> -Schnittstelle, Sie können auch durchlaufen die <ph id="ph3">&lt;xref:System.Char&gt;</ph> Objekte in einer Zeichenfolge mit einer <ph id="ph4">`foreach`</ph> Konstrukt, wie im folgenden Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
          <target state="translated">Aufeinander folgende Indexwerte entspricht möglicherweise nicht aufeinander folgenden Unicode-Zeichen, da ein Zeichen möglicherweise Unicode codiert als mehr als ein <ph id="ph1">&lt;xref:System.Char&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs.</source>
          <target state="translated">Insbesondere kann eine Zeichenfolge mehreren Zeichen Einheiten von Text enthalten, die durch ein Basiszeichen gefolgt durch eine oder mehrere Kombinationszeichen oder von Ersatzzeichenpaaren gebildet werden.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To work with Unicode characters instead of <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects, use the <ph id="ph2">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> classes.</source>
          <target state="translated">Arbeiten mit Unicode-Zeichen anstelle von <ph id="ph1">&lt;xref:System.Char&gt;</ph> verwenden Sie die Objekte, die <ph id="ph2">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> und <ph id="ph3">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> Klassen.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the difference between code that works with <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects and code that works with Unicode characters.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht den Unterschied zwischen Code, mit der Funktionsweise <ph id="ph1">&lt;xref:System.Char&gt;</ph> Benutzerobjekten und Code, die mit Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It compares the number of characters or text elements in each word of a sentence.</source>
          <target state="translated">Die Anzahl der Zeichen oder Textelemente in der jedes Wort im Satz verglichen.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The string includes two sequences of a base character followed by a combining character.</source>
          <target state="translated">Die Zeichenfolge enthält zwei Sequenzen von eines Basiszeichens gefolgt von einer Kombination von Zeichen.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This example works with text elements by using the <ph id="ph1">&lt;xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> class to enumerate all the text elements in a string.</source>
          <target state="translated">Dieses Beispiel funktioniert mit Textelemente mithilfe der <ph id="ph1">&lt;xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType&gt;</ph> Methode und die <ph id="ph2">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> Klasse, um die Textelemente einer Zeichenfolge aufgelistet.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also retrieve an array that contains the starting index of each text element by calling the <ph id="ph1">&lt;xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Sie können auch ein Array, das durch Aufrufen der Startindex des jedes Textelement enthält Abrufen der <ph id="ph1">&lt;xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about working with units of text rather than individual <ph id="ph1">&lt;xref:System.Char&gt;</ph> values, see the <ph id="ph2">&lt;xref:System.Globalization.StringInfo&gt;</ph> class.</source>
          <target state="translated">Weitere Informationen zum Arbeiten mit Einheiten eher Text als einzelne <ph id="ph1">&lt;xref:System.Char&gt;</ph> -Werte finden Sie in der <ph id="ph2">&lt;xref:System.Globalization.StringInfo&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Null strings and empty strings</source>
          <target state="translated">NULL-Zeichenfolgen und leere Zeichenfolgen</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string that has been declared but has not been assigned a value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Eine Zeichenfolge, die deklariert wurde, jedoch wurde kein Wert zugewiesen ist <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Attempting to call methods on that string throws a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen von Methoden für diese Zeichenfolge löst eine <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A null string is different from an empty string, which is a string whose value is "" or <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Eine null-Zeichenfolge unterscheidet sich von einer leeren Zeichenfolge, d. h. eine Zeichenfolge, deren Wert "" oder <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In some cases, passing either a null string or an empty string as an argument in a method call throws an exception.</source>
          <target state="translated">In einigen Fällen löst eine Ausnahme aus, wenn Sie eine null-Zeichenfolge oder eine leere Zeichenfolge als Argument in einem Methodenaufruf übergeben.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, passing a null string to the <ph id="ph1">&lt;xref:System.Int32.Parse%2A?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>, and passing an empty string throws a <ph id="ph3">&lt;xref:System.FormatException&gt;</ph>.</source>
          <target state="translated">Z. B. eine null-Zeichenfolge zu übergeben der <ph id="ph1">&lt;xref:System.Int32.Parse%2A?displayProperty=nameWithType&gt;</ph> -Methode löst eine <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>, und übergeben einer leeren Zeichenfolge löst eine <ph id="ph3">&lt;xref:System.FormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In other cases, a method argument can be either a null string or an empty string.</source>
          <target state="translated">In anderen Fällen kann ein Methodenargument eine null-Zeichenfolge oder eine leere Zeichenfolge sein.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if you are providing an <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.</source>
          <target state="translated">Wenn Sie bereit sind z. B. eine <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> Implementierung für eine Klasse, eine null-Zeichenfolge und eine leere Zeichenfolge mit der allgemeine Formatbezeichner ("G") entsprechen soll.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes the following two convenience methods that enable you to test whether a string is <ph id="ph2">`null`</ph> or empty:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String&gt;</ph> Klasse enthält die folgenden zwei Hilfsmethoden, mit denen Sie überprüfen, ob eine Zeichenfolge ist <ph id="ph2">`null`</ph> oder leer:</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph>, which indicates whether a string is either <ph id="ph2">`null`</ph> or is equal to  <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph>, der angibt, ob eine Zeichenfolge entweder ist <ph id="ph2">`null`</ph> oder gleich <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This method eliminates the need to use code such as the following:</source>
          <target state="translated">Diese Methode entfällt die Notwendigkeit, den folgenden Code verwenden:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph>, which indicates whether a string is <ph id="ph2">`null`</ph>, equals <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, or consists exclusively of white-space characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph>, der angibt, ob eine Zeichenfolge ist <ph id="ph2">`null`</ph>, gleich <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, oder ausschließlich aus Leerzeichen besteht.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This method eliminates the need to use code such as the following:</source>
          <target state="translated">Diese Methode entfällt die Notwendigkeit, den folgenden Code verwenden:</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method in the <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> implementation of a custom <ph id="ph3">`Temperature`</ph> class.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> Methode in der <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> Implementierung eines benutzerdefinierten <ph id="ph3">`Temperature`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The method supports the "G", "C", "F", and "K" format strings.</source>
          <target state="translated">Die Methode unterstützt die Formatzeichenfolgen "G", "C", "F" und "K".</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If an empty format string or a format string whose value is <ph id="ph1">`null`</ph> is passed to the method, its value is changed to the "G" format string.</source>
          <target state="translated">Wenn eine leere Zeichenfolge oder ein Format, dessen Wert eine Zeichenfolge ist <ph id="ph1">`null`</ph> übergeben wird an die Methode wird der Wert in der Formatzeichenfolge "G" geändert.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Immutability and the StringBuilder class</source>
          <target state="translated">Unveränderlichkeit und der StringBuilder-Klasse</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A <ph id="ph1">&lt;xref:System.String&gt;</ph> object is called immutable (read-only), because its value cannot be modified after it has been created.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt heißt unveränderlich (schreibgeschützt), da der Wert kann nicht geändert werden, nachdem es erstellt wurde.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that appear to modify a <ph id="ph1">&lt;xref:System.String&gt;</ph> object actually return a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object that contains the modification.</source>
          <target state="translated">Methoden, die angezeigt werden, so ändern Sie eine <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt zurückgeben tatsächlich ein neues <ph id="ph2">&lt;xref:System.String&gt;</ph> -Objekt, das die Änderung enthält.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty.</source>
          <target state="translated">Da Zeichenfolgen unveränderlich sind, so lange Zeichenfolge-manipulationsroutinen, die ausführen hinzugefügten oder gelöschten, was angezeigt wird, sein, dass eine einzelne Zeichenfolge erhebliche Leistungseinbußen genauen kann wiederholt.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F.</source>
          <target state="translated">Der folgende Code verwendet beispielsweise einen Zufallszahlengenerator So erstellen Sie eine Zeichenfolge mit 1000 Zeichen im Bereich 0 x 0001, 0x052F an.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Although the code appears to use string concatenation to append a new character to the existing string named <ph id="ph1">`str`</ph>, it actually creates a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each concatenation operation.</source>
          <target state="translated">Obwohl der Code zum Verketten von Zeichenfolgen zu verwenden wird, um ein neues Zeichen in die vorhandene Zeichenfolge mit dem Namen Anfügen <ph id="ph1">`str`</ph>, tatsächlich wird ein neuer <ph id="ph2">&lt;xref:System.String&gt;</ph> Objekt für jeden Verkettungsvorgang.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> class instead of the <ph id="ph2">&lt;xref:System.String&gt;</ph> class for operations that make multiple changes to the value of a string.</source>
          <target state="translated">Können Sie die <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> -Klasse statt der <ph id="ph2">&lt;xref:System.String&gt;</ph> Klasse für Vorgänge, die mehrere Änderungen an den Wert einer Zeichenfolge vornehmen.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Unlike instances of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class, <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string.</source>
          <target state="translated">Im Gegensatz zu Instanzen der <ph id="ph1">&lt;xref:System.String&gt;</ph> Klasse <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> Objekte sind änderbar; beim Verketten, Anfügen oder Teilzeichenfolgen aus einer Zeichenfolge zu löschen, werden die Vorgänge auf einer einzelnen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When you have finished modifying the value of a <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object, you can call its <ph id="ph2">&lt;xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType&gt;</ph> method to convert it to a string.</source>
          <target state="translated">Nach Abschluss des Ändern des Werts einer <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> -Objekts können Sie erreichen die <ph id="ph2">&lt;xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType&gt;</ph> Methode in eine Zeichenfolge zu konvertieren.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example replaces the <ph id="ph1">&lt;xref:System.String&gt;</ph> used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> object.</source>
          <target state="translated">Im folgende Beispiel ersetzt die <ph id="ph1">&lt;xref:System.String&gt;</ph> zum Verketten von 1000 zufälligen Zeichen im Bereich 0 x 0001 bis 0x052F mit im vorherigen Beispiel verwendet eine <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinal vs. culture-sensitive operations</source>
          <target state="translated">Ordnungszahl im Vergleich zu kulturabhängige Operationen</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Members of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class perform either ordinal or culture-sensitive (linguistic) operations on a <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">Mitglieder der <ph id="ph1">&lt;xref:System.String&gt;</ph> Klasse ordinal oder kulturabhängige (linguistische) Vorgänge ausführen, auf eine <ph id="ph2">&lt;xref:System.String&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal operation acts on the numeric value of each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
          <target state="translated">Ein ordinal Vorgang ausgeführt wird, nach dem numerischen Wert der einzelnen <ph id="ph1">&lt;xref:System.Char&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive operation acts on the value of the <ph id="ph1">&lt;xref:System.String&gt;</ph> object, and takes culture-specific casing, sorting, formatting, and parsing rules into account.</source>
          <target state="translated">Eine kulturabhängige Operation wird der Wert von der <ph id="ph1">&lt;xref:System.String&gt;</ph> -Objekt, und nimmt kulturspezifische Groß-/Kleinschreibung, Sortierung Formatierung und Analyse Regeln berücksichtigt.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture.</source>
          <target state="translated">Kulturabhängige Operationen im Kontext einer explizit deklarierten Kultur oder die implizite aktuelle Kultur ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The two kinds of operations can produce very different results when they are performed on the same string.</source>
          <target state="translated">Die zwei Arten von Vorgängen können sehr unterschiedliche Ergebnisse erzeugen, wenn sie auf die gleiche Zeichenfolge ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework also supports culture-insensitive linguistic string operations by using the invariant culture (<ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>), which is loosely based on the culture settings of the English language independent of region.</source>
          <target state="translated">.NET Framework unterstützt auch kulturunabhängige linguistische Zeichenfolgenoperationen mit der invarianten Kultur (<ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>), die lose basiert auf den kultureinstellungen des der englischen Sprache, die unabhängig von der Region.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Unlike other <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of the .NET Framework.</source>
          <target state="translated">Im Gegensatz zu anderen <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> Einstellungen, die von der invarianten Kultur ist sichergestellt, dass auf einem einzelnen Computer, von System zu System und in .NET Framework-Versionen konsistent bleiben.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.</source>
          <target state="translated">Die invariante Kultur kann als eine Art schwarzes Kästchen, die Stabilität von Zeichenfolgenvergleichen wird sichergestellt, dass Sicht- und Reihenfolge in allen Kulturen gleich.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison.</source>
          <target state="translated">Wenn Ihre Anwendung eine sicherheitsentscheidung zu einer symbolischen Bezeichner, z. B. einen Dateinamen stellt oder Pipes benannte oder zu persistente Daten, z. B. die textbasierten Daten in eine XML-Datei, sollten der Vorgang einen ordinalen Vergleich anstelle einer kulturabhängigen Vergleich verwenden.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.</source>
          <target state="translated">Grund hierfür ist ein kulturabhängiger Vergleich aktiviert ist, je nach Kultur unterschiedliche Ergebnisse führen kann hingegen ein ordinalen Vergleich ausschließlich auf den binären Wert der verglichenen Zeichen abhängig ist.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Most methods that perform string operations include an overload that has a parameter of type <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation.</source>
          <target state="translated">Die meisten Methoden zum Ausführen von Zeichenfolgenoperationen enthalten eine Überladung, die einen vom Typ Parameter <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>, können Sie angeben, ob die Methode einen ordinalen oder kulturabhängigen Vorgang ausführt.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In general, you should call this overload to make the intent of your method call clear.</source>
          <target state="translated">Im Allgemeinen sollten Sie diese Überladung, um den Zweck der Methode Methodenaufrufs eindeutig anzugeben aufrufen.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For best practices and guidance for using ordinal and culture-sensitive operations on strings, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Best Practices und Anleitungen für die Verwendung von Ordnungszahlen und kulturabhängige Operations mit Zeichenfolgen finden Sie unter <bpt id="p1">[</bpt>bewährte Methoden für die Verwendung von Zeichenfolgen<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Operations for <bpt id="p1">[</bpt>casing<ept id="p1">](#casing)</ept>, <bpt id="p2">[</bpt>parsing and formatting<ept id="p2">](#parsing)</ept>, <bpt id="p3">[</bpt>comparison and sorting<ept id="p3">](#comparison)</ept>, and <bpt id="p4">[</bpt>testing for equality<ept id="p4">](#equality)</ept> can be either ordinal or culture-sensitive.</source>
          <target state="translated">Vorgänge für <bpt id="p1">[</bpt>Schreibweise<ept id="p1">](#casing)</ept>, <bpt id="p2">[</bpt>analysieren und formatieren<ept id="p2">](#parsing)</ept>, <bpt id="p3">[</bpt>Vergleich und Sortierung<ept id="p3">](#comparison)</ept>, und <bpt id="p4">[</bpt>Testen auf Gleichheit<ept id="p4">](#equality)</ept> kann ordinal oder kulturabhängig sein.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following sections discuss each category of operation.</source>
          <target state="translated">Den folgenden Abschnitten werden die einzelnen Kategorien des Vorgangs.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You should always call a method overload that makes the intent of your method call clear.</source>
          <target state="translated">Sie sollten immer eine methodenüberladung aufrufen, die den Zweck der Methode Methodenaufrufs eindeutig macht.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, instead of calling the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method with a value of <ph id="ph3">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> for the <ph id="ph4">`comparisonType`</ph> argument.</source>
          <target state="translated">Z. B. statt der <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> Methode einen kulturabhängiger Vergleich von zwei Zeichenfolgen durchgeführt wird, wird mit den Konventionen der aktuellen Kultur, rufen Sie die <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> Methode mit einem Wert von <ph id="ph3">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> für die <ph id="ph4">`comparisonType`</ph> Argument.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Casing</source>
          <target state="translated">Schreibweise</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase.</source>
          <target state="translated">Regeln Groß-und Kleinschreibung bestimmen, wie die Groß-/Kleinschreibung von einem Unicode-Zeichen ändern. z. B. von Klein-in Großbuchstaben konvertiert wurden.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Often, a casing operation is performed before a string comparison.</source>
          <target state="translated">Häufig wird ein Schreibweise Vorgang vor einem Zeichenfolgenvergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a string might be converted to uppercase so that it can be compared with another uppercase string.</source>
          <target state="translated">Beispielsweise kann eine Zeichenfolge in Großbuchstaben konvertiert werden, damit es mit einer anderen Zeichenfolge in Großbuchstaben verglichen werden kann.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can convert the characters in a string to lowercase by calling the <ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method, and you can convert them to uppercase by calling the <ph id="ph3">&lt;xref:System.String.ToUpper%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Sie können die Zeichen in einer Zeichenfolge durch den Aufruf in Kleinbuchstaben konvertieren die <ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> Methode, und Sie können diese durch Aufrufen von Großbuchstaben konvertieren die <ph id="ph3">&lt;xref:System.String.ToUpper%2A&gt;</ph> oder <ph id="ph4">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, you can use the <ph id="ph1">&lt;xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType&gt;</ph> method to convert a string to title case.</source>
          <target state="translated">Darüber hinaus können Sie die <ph id="ph1">&lt;xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType&gt;</ph> Methode zum Konvertieren einer Zeichenfolge in titelschreibung.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture.</source>
          <target state="translated">Schreibweise Vorgänge können auf den Regeln der aktuellen Kultur, einer angegebenen Kultur oder der invarianten Kultur basieren.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture.</source>
          <target state="translated">Da schreibungszuordnungen abhängig von der verwendeten Kultur variieren können, kann das Ergebnis der Schreibweise Vorgänge basierend auf der Kultur variieren.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The actual differences in casing are of three kinds:</source>
          <target state="translated">Die tatsächliche Unterschiede in Groß-/Kleinschreibung gibt drei Arten:</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131).</source>
          <target state="translated">Unterschiede in der Groß-/Kleinschreibung Zuordnung von LATIN CAPITAL LETTER I (U + 0049), kleine Buchstaben LATEINISCH I (U + 0069), LATIN CAPITAL LETTER I mit Punkt oben (U + 0130) und LATIN kleine Buchstaben ohne Punkte I (U + 0131).</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE.</source>
          <target state="translated">Das tr-TR (Türkisch (Türkei)) und az-Latn-AZ (Aserbaidschan, Lateinisch) Kulturen im tr, az und az-Latn neutralen Kulturen die kleinbuchstabenentsprechung von LATIN CAPITAL LETTER I ist LATIN kleine Buchstaben ohne Punkte I und der entsprechende Großbuchstabe LATIN kleine Buchstaben I LATIN CAPITAL LETTER I mit Punkt oben ist.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.</source>
          <target state="translated">In anderen Kulturen einschließlich der invarianten Kultur, kleine Buchstaben LATEINISCH I und LATIN CAPITAL LETTER ich und Großbuchstaben, Kleinbuchstaben Entsprechungen sind.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie ein Zeichenfolgenvergleich entwickelt um zu verhindern, dass bei der normalen Dateisystemzugriffs fehlschlagen können, wenn es auf einem Vergleich kulturabhängig Groß-/Kleinschreibung beruht.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(The casing conventions of the invariant culture should have been used.)</source>
          <target state="translated">(Die Groß-/ Kleinschreibungskonventionen der invarianten Kultur sollte verwendet werden.)</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Differences in case mappings between the invariant culture and all other cultures.</source>
          <target state="translated">Unterschiede in der Groß-/Kleinschreibung Zuordnungen zwischen der invarianten Kultur und alle anderen Kulturen.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character.</source>
          <target state="translated">In diesen Fällen gibt die Regeln der Groß-und Kleinschreibung der invarianten Kultur verwenden, so ändern Sie ein Zeichen in Groß-oder Kleinbuchstaben desselben Zeichens zurück.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For all other cultures, it returns a different character.</source>
          <target state="translated">Für alle anderen Kulturen wird ein anderes Zeichen zurückgegeben.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Some of the affected characters are listed in the following table.</source>
          <target state="translated">Einige der betroffenen Zeichen sind in der folgenden Tabelle aufgeführt.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Character</source>
          <target state="translated">Zeichen</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If changed to</source>
          <target state="translated">Wenn in geändert</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Returns</source>
          <target state="translated">Rückgabe</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>MICRON SIGN (U+00B5)</source>
          <target state="translated">NM-ZEICHEN (U + 00B5)</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">Großbuchstaben</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>GREEK CAPITAL LETTER MU (U+-39C)</source>
          <target state="translated">GRIECHISCH GROSSBUCHSTABE MU (U +-39C)</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</source>
          <target state="translated">LATIN CAPITAL LETTER ICH PUNKT OBEN (U + 0130)</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Lowercase</source>
          <target state="translated">Kleinbuchstaben</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER I (U+0069)</source>
          <target state="translated">KLEINE LATEINISCHE BUCHSTABEN I (U + 0069)</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER DOTLESS I (U+0131)</source>
          <target state="translated">LATEINISCHE KLEINBUCHSTABEN OHNE PUNKTE ICH (U + 0131)</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">Großbuchstaben</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER I (U+0049)</source>
          <target state="translated">LATIN CAPITAL LETTER ICH (U + 0049)</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER LONG S (U+017F)</source>
          <target state="translated">KLEINES LATEINISCHES LANGE S (U + 017F.)</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">Großbuchstaben</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER S (U+0053)</source>
          <target state="translated">LATIN CAPITAL LETTER S (U + 0053)</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)</source>
          <target state="translated">LATIN CAPITAL LETTER D MIT KLEINEN BUCHSTABEN Z MIT HÁČEK (U + 01C 5)</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Lowercase</source>
          <target state="translated">Kleinbuchstaben</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER DZ WITH CARON (U+01C6)</source>
          <target state="translated">KLEINES LATEINISCHES DZ MIT HÁČEK (U + 01C 6)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>COMBINING GREEK YPOGEGRAMMENI (U+0345)</source>
          <target state="translated">KOMBINIEREN VON YPOGRAMMENI (U + 0345)</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">Großbuchstaben</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>GREEK CAPITAL LETTER IOTA (U+0399)</source>
          <target state="translated">GRIECHISCH GROSSBUCHSTABE IOTA (U + 0399)</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Differences in case mappings of two-letter mixed-case pairs in the ASCII character range.</source>
          <target state="translated">Unterschiede in der Groß-/Kleinschreibung Zuordnungen von zwei Buchstaben bestehende gemischter Groß-/Kleinschreibung-Paaren im ASCII-Zeichenbereich.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair.</source>
          <target state="translated">In den meisten Kulturen entspricht ein zweistelliger gemischter Groß-/Kleinschreibung-Paar an das entsprechende Paar aus zwei Buchstaben bestehende Groß- oder Kleinbuchstaben.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:</source>
          <target state="translated">Dies gilt nicht für die folgenden zwei Buchstaben bestehende-Paare in der folgenden Kulturen, da in jedem Fall an einen Digraph verglichen werden:</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture.</source>
          <target state="translated">"lJ" und "nJ" in die Kultur hr-HR (Kroatisch (Kroatien)).</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.</source>
          <target state="translated">"cH" in der Cs-CZ (Tschechisch (Tschechische Republik)) und Kulturen sk-SK (Slowakisch (Slowakei)).</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"aA" in the da-DK (Danish (Denmark)) culture.</source>
          <target state="translated">"aA" in der Kultur da-DK (Dänisch (Dänemark)).</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture.</source>
          <target state="translated">"cS", "dZ", "dZS", "nY", "sZ", "tY" und "zS" in der Kultur Hu-HU (Ungarisch (Ungarn)).</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.</source>
          <target state="translated">"cH" und "lL" in der Kultur es-ES_tradnl (Spanisch (Spanien, Traditionelle Sortierung)).</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture.</source>
          <target state="translated">"cH", "gI", "kH", "nG", "nH", "pH", "qU", "tH" und "tR" in der Kultur des vi-VN (Vietnamesisch (Vietnam)).</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.</source>
          <target state="translated">Es ist jedoch ungewöhnlich, die eine Situation, in der ein kulturabhängiger Vergleich dieser Paare Probleme erstellt, auftreten, da diese Paare feste Zeichenfolgen oder Bezeichner nicht üblich sind.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht einige der Unterschiede in Regeln Groß-und Kleinschreibung zwischen Kulturen beim Konvertieren von Zeichenfolgen in Großbuchstaben.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parsing and formatting</source>
          <target state="translated">Analysieren und formatieren</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting and parsing are inverse operations.</source>
          <target state="translated">Formatierung und Analyse sind umgekehrte Vorgänge.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time.</source>
          <target state="translated">Formatierungsregeln bestimmen, wie einen Wert, z. B. ein Datum und Uhrzeit oder einer Zahl in die Zeichenfolgendarstellung konvertieren während Analyseregeln bestimmen, wie eine Zeichenfolgendarstellung auf einen Wert wie ein Datum und eine Uhrzeit konvertiert.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Both formatting and parsing rules are dependent on cultural conventions.</source>
          <target state="translated">Kulturelle Konventionen hängen sowohl Formatierung und Analyse für Regeln.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Mehrdeutigkeit, die auftreten kann, wenn eine kulturspezifische Datumszeichenfolge zu interpretieren.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.</source>
          <target state="translated">Ohne zu wissen, die Konventionen der Kultur, die verwendet wurde, um eine Datumszeichenfolge zu erzeugen, ist es nicht möglich, zu wissen, ob 03/01/2011, 3/1/2011 und 01/03/2011 3. Januar 2011 oder am 1. März 2011 darstellen.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.</source>
          <target state="translated">Auf ähnliche Weise wie im folgenden Beispiel wird gezeigt, kann eine einzelne Zeichenfolge verschiedene Datumsangaben abhängig von der Kultur erzeugen, deren Konventionen in der Analysevorgang verwendet werden.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String comparison and sorting</source>
          <target state="translated">Zeichenfolgenvergleich und-Sortierung</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Conventions for comparing and sorting strings vary from culture to culture.</source>
          <target state="translated">Konventionen für den Vergleich und Sortierung von Zeichenfolgen variieren Kulturen.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the sort order may be based on phonetics or on the visual representation of characters.</source>
          <target state="translated">Beispielsweise kann die Sortierreihenfolge für Phonetics oder für die visuelle Darstellung der Zeichen basieren.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In East Asian languages, characters are sorted by the stroke and radical of ideographs.</source>
          <target state="translated">In ostasiatischen Sprachen werden Zeichen anhand der Anzahl der Striche und der Radikale der Ideogramme sortiert.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Sorting also depends on the order languages and cultures use for the alphabet.</source>
          <target state="translated">Die Sortierung hängt außerdem von der Reihenfolge ab, die das Alphabet der jeweiligen Sprache bzw. Kultur aufweist.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the Danish language has an "Æ" character that it sorts after "Z" in the alphabet.</source>
          <target state="translated">Im Dänischen gibt es beispielsweise das Zeichen "Æ", das im Alphabet nach dem Zeichen "Z" einsortiert ist.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture.</source>
          <target state="translated">Darüber hinaus Vergleiche können Groß- und Kleinschreibung beachtet werden, und in einigen Fällen Regeln Groß-und Kleinschreibung unterscheiden sich auch von Kultur.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.</source>
          <target state="translated">Ordinalvergleich verwendet andererseits, die Unicode-Codepunkten der einzelnen Zeichen in eine Zeichenfolge, die beim Vergleichen und Sortieren von Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other.</source>
          <target state="translated">Sortierregeln, die bestimmen, dass die alphabetische Reihenfolge von Unicode-Zeichen und wie zwei Zeichenfolgen miteinander vergleichen.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> method compares two strings based on the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> Methode vergleicht zwei Zeichenfolgen, die auf der Grundlage der <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the parameter value is <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>, the method performs an ordinal comparison.</source>
          <target state="translated">Wenn der Parameterwert ist <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, die Methode führt einen linguistischen Vergleich, der die Konventionen der aktuellen Kultur; verwendet, wenn der Parameterwert ist <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>, die Methode führt einen Ordinalvergleich.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".</source>
          <target state="translated">Folglich, wie im folgenden Beispiel gezeigt, wenn die aktuelle Kultur "USA" Englisch, der erste Aufruf der <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> (mithilfe von kulturabhängigen Vergleich) Methode betrachtet "a" kleiner als "A", aber der zweite Aufruf von derselben Methode (mit Ordinalvergleich) betrachtet "a" größer als "A".</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework supports word, string, and ordinal sort rules:</source>
          <target state="translated">.NET Framework unterstützt Word, String und Ordinalsortierung:</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them.</source>
          <target state="translated">Bei einer Wortsortierung wird ein kulturabhängiger Vergleich von Zeichenfolgen durchgeführt, bei dem bestimmten nicht alphanumerischen Unicode-Zeichen u. U. bestimmte Gewichtungen zugeordnet sind.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list.</source>
          <target state="translated">Beispielsweise ggf. wird der Bindestrich (-) eine sehr geringe Gewichtung zugeordnet, sodass "Coop" und "Co-op" in einer sortierten Liste nebeneinander angezeigt werden.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For a list of the <ph id="ph1">&lt;xref:System.String&gt;</ph> methods that compare two strings using word sort rules, see the <bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept> section.</source>
          <target state="translated">Eine Liste der <ph id="ph1">&lt;xref:System.String&gt;</ph> Methoden, die zwei Zeichenfolgen mithilfe von Word-Sortierregeln, Vergleichen finden Sie unter der <bpt id="p1">[</bpt>Zeichenfolgenoperationen nach Kategorie<ept id="p1">](#ByCategory)</ept> Abschnitt.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string sort also performs a culture-sensitive comparison.</source>
          <target state="translated">Eine Sortierung Zeichenfolge führt auch einen kulturabhängigen Vergleich.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters.</source>
          <target state="translated">Es ähnelt der eine Sortierung Wort identisch, es keine spezielle Fälle gibt und alle nicht alphanumerische Symbole, vor den alphanumerischen Unicode-Zeichen stammen.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Two strings can be compared using string sort rules by calling the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType&gt;</ph> method overloads that have an <ph id="ph2">`options`</ph> parameter that is supplied a value of <ph id="ph3">&lt;xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Zwei Zeichenfolgen können verglichen werden, mithilfe von Zeichenfolgensortierregeln durch Aufrufen der <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType&gt;</ph> methodenüberladungen, die über eine <ph id="ph2">`options`</ph> Parameter bereitgestellte Wert <ph id="ph3">&lt;xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that this is the only method that the .NET Framework provides to compare two strings using string sort rules.</source>
          <target state="translated">Beachten Sie, dass dies die einzige Methode, die .NET Framework zum Vergleichen von zwei Zeichenfolgen mithilfe von Zeichenfolgensortierregeln bereitstellt.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal sort compares strings based on the numeric value of each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object in the string.</source>
          <target state="translated">Eine Ordinalsortierung vergleicht Zeichenfolgen anhand des numerischen Werts jedes <ph id="ph1">&lt;xref:System.Char&gt;</ph>-Objekts in der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points.</source>
          <target state="translated">Ein ordinalen Vergleich ist automatisch die Groß-/Kleinschreibung beachtet, da die Groß- und Kleinbuchstaben Versionen eines Zeichens unterschiedliche Codepunkte aufweisen.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, if case is not important, you can specify an ordinal comparison that ignores case.</source>
          <target state="translated">Wenn die Anfrage nicht wichtig ist, können Sie einen ordinalen Vergleich angeben, der Groß-und Kleinschreibung berücksichtigt.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result.</source>
          <target state="translated">Dies entspricht dem Konvertieren der Zeichenfolge in Großbuchstaben unter Verwendung der invarianten Kultur und anschließend einen Ordinalvergleich ausführen, auf dem Ergebnis.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For a list of the <ph id="ph1">&lt;xref:System.String&gt;</ph> methods that compare two strings using ordinal sort rules, see the <bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept> section.</source>
          <target state="translated">Eine Liste der <ph id="ph1">&lt;xref:System.String&gt;</ph> Methoden, die zwei Zeichenfolgen mithilfe von ordinalen Sortierregeln Vergleichen finden Sie unter der <bpt id="p1">[</bpt>Zeichenfolgenoperationen nach Kategorie<ept id="p1">](#ByCategory)</ept> Abschnitt.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object, including the invariant culture that is specified by the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Ein kulturabhängiger Vergleich ist ein Vergleich, der explizit oder implizit verwendet eine <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> -Objekts, einschließlich der invarianten Kultur, die von angegeben wird die <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The implicit culture is the current culture, which is specified by the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Die implizite Kultur ist die aktuelle Kultur, der durch angegeben ist die <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <ph id="ph1">&lt;xref:System.Char.IsLetter%2A?displayProperty=nameWithType&gt;</ph> property returns <ph id="ph2">`true`</ph>) across cultures.</source>
          <target state="translated">Es gibt erhebliche Variation in der Sortierreihenfolge der alphabetischen Zeichen (d. h. Zeichen, für die die <ph id="ph1">&lt;xref:System.Char.IsLetter%2A?displayProperty=nameWithType&gt;</ph> -Eigenschaft gibt <ph id="ph2">`true`</ph>) zwischen Kulturen.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object to a string comparison method such as <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph>.</source>
          <target state="translated">Sie können angeben, dass einen kulturabhängiger Vergleich, der die Konventionen einer bestimmten Kultur durch Angabe verwendet eine <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> -Objekt an eine Methode zum Zeichenfolgenvergleich wie <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, or any member of the <ph id="ph3">&lt;xref:System.Globalization.CompareOptions&gt;</ph> enumeration other than <ph id="ph4">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph5">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> to an appropriate overload of the <ph id="ph6">&lt;xref:System.String.Compare%2A&gt;</ph> method.</source>
          <target state="translated">Sie können angeben, dass einen kulturabhängiger Vergleich, der durch Angabe der Konventionen der aktuellen Kultur verwendet <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, oder ein Member des der <ph id="ph3">&lt;xref:System.Globalization.CompareOptions&gt;</ph> Enumeration außer <ph id="ph4">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> oder <ph id="ph5">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> an eine entsprechende Überladung der der <ph id="ph6">&lt;xref:System.String.Compare%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not.</source>
          <target state="translated">Ein kulturabhängiger Vergleich eignet sich in der Regel für die Sortierung hingegen ein ordinalen Vergleich nicht ist.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.</source>
          <target state="translated">Ein ordinalen Vergleich eignet sich im Allgemeinen zu bestimmen, ob zwei Zeichenfolgen gleich sind (d. h. für die Bestimmung der Identität) dagegen ein kulturabhängigen Vergleich nicht ist.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the difference between culture-sensitive and ordinal comparison.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht den Unterschied zwischen ordinalen Vergleich kulturabhängig.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The example evaluates three strings, "Apple", "Æble", and "AEble", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method is called).</source>
          <target state="translated">Im Beispiel ergibt drei Zeichenfolgen, "Apple", "Æble" und "AEble" ordinalen Vergleich mit den Konventionen der Kulturen da-DK "und" En-US (von denen jede die Standardkultur ist, zum Zeitpunkt der <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> -Methode aufgerufen wird).</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the Danish language treats the character "Æ" as an individual letter and sorts it after "Z" in the alphabet, the string "Æble" is greater than "Apple".</source>
          <target state="translated">Da die dänische Sprache das Zeichen "Æ" als ein einzelner Buchstabe behandelt und sortiert es im Alphabet nach "Z", ist die Zeichenfolge "Æble" größer als "Apple".</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, "Æble" is not considered equivalent to "AEble", so "Æble" is also greater than "AEble".</source>
          <target state="translated">"Æble" ist jedoch nicht äquivalent zu "AEble", interpretiert, damit "Æble" auch "AEble" größer ist.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The en-US culture doesn't include the letter"Æ" but treats it as equivalent to "AE", which explains why  "Æble" is less than "Apple" but equal to "AEble".</source>
          <target state="translated">Der Kultur En-US interpretiert als äquivalent zu "AE", die erläutern, warum "Æble" kleiner als "Apple", aber "AEble" gleich ist jedoch nicht der Buchstabe "Æ" enthalten.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinal comparison, on the other hand, considers "Apple" to be less than "Æble", and "Æble" to be greater than "AEble".</source>
          <target state="translated">Ordinalvergleich durch, hält andererseits, "Apple" niedriger sein als "Æble" und "Æble" größer als "AEble" sein.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Use the following general guidelines to choose an appropriate sorting or string comparison method:</source>
          <target state="translated">Verwenden Sie die folgenden allgemeinen Richtlinien, um eine entsprechende Sortierung oder Zeichenfolge Vergleichsmethode auszuwählen:</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture.</source>
          <target state="translated">Wenn Sie basierend auf der Kultur des Benutzers die Zeichenfolgen, die sortiert werden soll, sollten basierend auf den Konventionen der aktuellen Kultur sortiert werden.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the user's culture changes, the order of sorted strings will also change accordingly.</source>
          <target state="translated">Wenn die Kultur des Benutzers geändert wird, wird die Reihenfolge der sortierten Zeichenfolgen auch entsprechend geändert.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a thesaurus application should always sort words based on the user's culture.</source>
          <target state="translated">Eine Thesaurus-Anwendung sollte beispielsweise immer Wörter, die basierend auf der Kultur des Benutzers sortieren.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents that culture to a comparison method.</source>
          <target state="translated">Gegebenenfalls die Zeichenfolgen, die sortiert werden basierend auf den Konventionen einer bestimmten Kultur bestellen Sie diese durch Angabe einer <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> -Objekt, das die Kultur für eine Vergleichsmethode darstellt.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.</source>
          <target state="translated">Beispielsweise sollen in eine Anwendung, Studenten eine bestimmte Sprache zu unterrichten, Zeichenfolgen, um sortiert zu werden basierend auf den Konventionen einer Kulturen, die diese Sprache spricht.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison.</source>
          <target state="translated">Wenn Sie die Reihenfolge von Zeichenfolgen zwischen Kulturen unverändert bleiben soll, sollten Sie in beliebiger Reihenfolge basierend auf den Konventionen der invarianten Kultur oder verwenden einen Ordinalvergleich durch.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.</source>
          <target state="translated">Beispielsweise würde eine Ordinalsortierung verwenden, um die Namen der Dateien, Prozesse, Mutexe zu organisieren oder named Pipes.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Einen Vergleich, der eine sicherheitsentscheidung (z. B., ob ein Benutzernamen gültig ist) umfasst, sollten Sie immer einen Ordinalzahlen Test auf Gleichheit ausführen, durch Aufruf einer Überladung von der <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET Framework.</source>
          <target state="translated">Der kulturabhängige Sortierung und Groß-/Kleinschreibung in Zeichenfolgenvergleich verwendete Regeln hängen von der Version von .NET Framework.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the .NET Framework <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on the <ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph> operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard.</source>
          <target state="translated">In .NET Framework <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> unter der <ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph> Betriebssystem, Sortierung, Groß-/Kleinschreibung, Normalisierung und Unicode-Zeicheninformationen entspricht dem Standard Unicode 6.0.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On other operating systems, it conforms to the Unicode 5.0 standard.</source>
          <target state="translated">Auf anderen Betriebssystemen entspricht die Unicode 5.0-Standard es.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about word, string, and ordinal sort rules, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> topic.</source>
          <target state="translated">Weitere Informationen zum Word Zeichenfolge und Ordinalsortierung finden Sie unter der <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> Thema.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For additional recommendations on when to use each rule, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Weitere Empfehlungen dazu, wann jeder Regel verwenden, finden Sie unter <bpt id="p1">[</bpt>bewährte Methoden für die Verwendung von Zeichenfolgen<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinarily, you don't call string comparison methods such as <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> directly to determine the sort order of strings.</source>
          <target state="translated">In der Regel, Sie rufen Sie nicht Zeichenfolge Vergleichsmethoden, z. B. <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> direkt auf die Sortierreihenfolge von Zeichenfolgen zu bestimmen.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Instead, comparison methods are called by sorting methods such as <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Stattdessen werden die Methoden zum Zeichenfolgenvergleich Methoden wie z. B. beim Sortieren aufgerufen <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use.</source>
          <target state="translated">Im folgenden Beispiel wird vier verschiedene Sortieroperationen (Word-Sortierung verwenden, die aktuelle Kultur, Word-Sortierung mit der invarianten Kultur Ordinalsortierung und Zeichenfolge Sortieren mit der invarianten Kultur) ohne expliziten Aufruf einer Methode zum Zeichenfolgenvergleich, obwohl sie den Typ des Vergleichs mit angeben.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that each type of sort produces a unique ordering of strings in its array.</source>
          <target state="translated">Beachten Sie, dass jede Art von Sortierreihenfolge erzeugt eine eindeutige Sortierung von Zeichenfolgen im Array.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Internally, the.NET Framework uses sort keys to support culturallysensitive string comparison.</source>
          <target state="translated">.NET Framework verwendet intern Sortierschlüssel Culturallysensitive Zeichenfolgenvergleich zu unterstützen.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic.</source>
          <target state="translated">Jedem Zeichen in einer Zeichenfolge sind mehrere Sortiergewichtungskategorien zugeordnet, darunter nach Skript, alphabetischer Folge, Groß-/Kleinschreibung und diakritischer Gewichtung.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A sort key, represented by the <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> class, provides a repository of these weights for a particular string.</source>
          <target state="translated">Ein Sortierschlüssel, dargestellt durch die <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> Klasse, ein Repository mit diesen Gewichtungen für eine bestimmte Zeichenfolge enthält.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses.</source>
          <target state="translated">Wenn eine große Anzahl von suchen oder Sortiervorgänge auf den gleichen Satz von Zeichenfolgen in Ihre app ausgeführt wird, können Sie die Leistung verbessern, indem generieren und zu speichern Sortierschlüssel für alle Zeichenfolgen, die verwendet werden.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When a sort or comparison operation is required, you use the sort keys instead of the strings.</source>
          <target state="translated">Wenn eine Sortierung oder ein Vergleich erforderlich ist, verwenden Sie den Sortierschlüssel anstelle von Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> class.</source>
          <target state="translated">Weitere Informationen finden Sie in den Ausführungen zur <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you don't specify a string comparison convention, sorting methods such as <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> perform a culture-sensitive, case-sensitive sort on strings.</source>
          <target state="translated">Wenn Sie eine Konvention, die Zeichenfolge Vergleich angeben, Sortieren Sie Methoden wie z. B. <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> führen Sie eine Sortierung kulturabhängig, Groß-/Kleinschreibung für Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates how changing the current culture affects the order of sorted strings in an array.</source>
          <target state="translated">Im folgende Beispiel wird veranschaulicht, wie die Reihenfolge der sortierten Zeichenfolgen in einem Array ändern die aktuelle Kultur auf auswirkt.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It creates an array of three strings.</source>
          <target state="translated">Erstellt ein Array von drei Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>First, it sets the <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> property to en-US and calls the <ph id="ph2">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Zuerst wird die <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph>-Eigenschaft auf "en-US" festgelegt, und die <ph id="ph2">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph>-Methode wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The resulting sort order is based on sorting conventions for the English (United States) culture.</source>
          <target state="translated">Die sich daraus ergebende Sortierreihenfolge basiert auf den Sortierkonventionen für die Kultur Englisch (USA).</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Next, the example sets the <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> property to da-DK and calls the <ph id="ph2">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> method again.</source>
          <target state="translated">Als Nächstes wird die <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph>-Eigenschaft auf "da-DK" festgelegt und die <ph id="ph2">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>-Methode erneut aufgerufen.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).</source>
          <target state="translated">Die sich daraus ergebende Sortierreihenfolge unterscheidet sich von den Ergebnissen für "en-US", da die Sortierkonventionen für "Dänisch (Dänemark)" verwendet werden.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your primary purpose in comparing strings is to determine whether they are equal, you should call the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Wenn der primäre Zweck in Vergleichen von Zeichenfolgen ist, um zu bestimmen, ob sie gleich sind, rufen Sie die <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Typically, you should use <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> to perform an ordinal comparison.</source>
          <target state="translated">Sie sollten in der Regel verwenden <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> einen Ordinalvergleich ausführen.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> method is intended primarily to sort strings.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> -Methode dient in erster Linie zum Sortieren von Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String search methods, such as <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, also can perform culture-sensitive or ordinal string comparisons.</source>
          <target state="translated">Zeichenfolgensuchmethoden, z. B. <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, auch können kulturabhängig oder Ordnungszahl Zeichenfolgenvergleiche ausführen.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Unterschiede zwischen der Ordinalzahl und kulturabhängige Vergleiche mit der <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "œ".</source>
          <target state="translated">Eine kulturabhängige Suche, in der die aktuelle Kultur Englisch (Vereinigte Staaten) ist, betrachtet die Teilzeichenfolge "Oe" entsprechend der Ligatur "œ".</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> and finds a match at the beginning of the string.</source>
          <target state="translated">Da Sie ein bedingten Bindestrich (U + 00AD) eine Breite von NULL-Zeichen ist, behandelt die Suche den bedingten Bindestrich als Entsprechung zu <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> und findet eine Übereinstimmung am Anfang der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal search, on the other hand, does not find a match in either case.</source>
          <target state="translated">Eine Ordinalsuche ist in beiden Fällen andererseits, keine Übereinstimmung gefunden.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Searching Strings</source>
          <target state="translated">Suchen von Zeichenfolgen</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String search methods, such as <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.</source>
          <target state="translated">Zeichenfolgensuchmethoden, z. B. <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, auch ausführen, kulturabhängig oder Ordnungszahl Zeichenfolgenvergleiche zu bestimmen, ob ein Zeichen oder eine Teilzeichenfolge in einer angegebenen Zeichenfolge gefunden wird.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The search methods in the <ph id="ph1">&lt;xref:System.String&gt;</ph> class that search for an individual character, such as the <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method, or one of a set of characters,   such as the <ph id="ph3">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, all perform an ordinal search.</source>
          <target state="translated">Die Suche Methoden in der <ph id="ph1">&lt;xref:System.String&gt;</ph> -Klasse, die für ein einzelnes Zeichen wie z. B. Suchen der <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode oder zu einem Satz von Zeichen, wie z. B. die <ph id="ph3">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> -Methode, eine Ordinalsuche Portverweise.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To perform a culture-sensitive search for a character, you must call a <ph id="ph1">&lt;xref:System.Globalization.CompareInfo&gt;</ph> method such as <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Um eine kulturabhängige Suche nach einem Zeichen auszuführen, rufen Sie eine <ph id="ph1">&lt;xref:System.Globalization.CompareInfo&gt;</ph> Methode z. B. <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> oder <ph id="ph3">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different.</source>
          <target state="translated">Beachten Sie, dass die Ergebnisse der Suche nach einem Zeichen mit einem ordinalen und kulturabhängige Vergleich sehr unterschiedlich sein können.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a search for a precomposed Unicode character such as the ligature "Æ" (U+00C6) might match any occurrence of its components in the correct sequence, such as "AE" (U+041U+0045), depending on the culture.</source>
          <target state="translated">Beispielsweise könnte eine Suche für ein zusammengesetztes Unicode-Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) entspricht jedem Vorkommen der Komponenten in der richtigen Reihenfolge, z. B. "AE" (U + 041U + 0045), abhängig von der Kultur.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the difference between the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> methods when searching for an individual character.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht den Unterschied zwischen der <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> Methoden bei der Suche nach einem einzelnen Zeichen.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The ligature "æ" (U+00E6) is found in the string "aerial" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.</source>
          <target state="translated">Die Ligatur "Æ" (U + 00E6) wird in der Zeichenfolge "Luftbild" bei Verwendung der Konventionen der Kultur En-US, jedoch nicht, wenn die Konventionen der Kultur da-DK verwendet oder wenn Sie einen Ordinalvergleich ausführen gefunden.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, <ph id="ph1">&lt;xref:System.String&gt;</ph> class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>.</source>
          <target state="translated">Andererseits, <ph id="ph1">&lt;xref:System.String&gt;</ph> -Klassenmethoden, die Suche nach einer Zeichenfolge statt eines Zeichens eine kulturabhängige Suche ausführen, wenn Suchoptionen durch einen Parameter vom Typ nicht explizit angegeben werden <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sole exception is <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, which performs an ordinal search.</source>
          <target state="translated">Die einzige Ausnahme ist <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, die eine Ordinalsuche durchführt.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Testing for equality</source>
          <target state="translated">Testen auf Gleichheit</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Use the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> method to determine the relationship of two strings in the sort order.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> Methode, um die Beziehung der beiden Zeichenfolgen in der Sortierreihenfolge festzulegen.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Typically, this is a culture-sensitive operation.</source>
          <target state="translated">Dies ist normalerweise eine kulturabhängige Operation.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In contrast, call the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> method to test for equality.</source>
          <target state="translated">Im Gegensatz dazu rufen Sie die <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> Methode auf Gleichheit.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.</source>
          <target state="translated">Da der Test auf Gleichheit Benutzereingaben mit einigen bekannten Zeichenfolge, z. B. einen gültigen Benutzernamen, ein Kennwort oder einen Dateisystempfad, in der Regel verglichen wird er in der Regel eine Ordinalzahl Vorgang.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It is possible to test for equality by calling the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> method and determining whether the return value is zero.</source>
          <target state="translated">Es ist möglich, die Gleichheit zu prüfende durch Aufrufen der <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> -Methode und bestimmen, ob der Rückgabewert 0 (null) ist.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, this practice is not recommended.</source>
          <target state="translated">Dieses Vorgehen wird jedoch nicht empfohlen.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To determine whether two strings are equal, you should call one of the overloads of the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Um zu bestimmen, ob zwei Zeichenfolgen gleich sind, sollten Sie eine der Überladungen der Aufrufen der <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The preferred overload to call is either the instance <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> method or the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, because both methods include a <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=nameWithType&gt;</ph> parameter that explicitly specifies the type of comparison.</source>
          <target state="translated">Die bevorzugte Überladung aufrufen, ist entweder die Instanz <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> -Methode oder die statische <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> -Methode, da beide Methoden enthalten eine <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=nameWithType&gt;</ph> Parameter, der den Typ des Vergleichs explizit angibt.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Gefahr der Ausführung eines kulturabhängigen Vergleichs, Gleichheit, wenn eine Ordinalzahl einer sollte stattdessen verwendet werden.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://".</source>
          <target state="translated">In diesem Fall ist der Zweck des Codes zu Dateisystemzugriff von URLs zu verhindern, die mit "FILE://" oder "file://" beginnt, durch Ausführen des Anfangs einer URL mit der Zeichenfolge "FILE://" Groß-und Kleinschreibung unterschieden.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "İ" instead of "I".</source>
          <target state="translated">Jedoch wenn ein kulturabhängiger Vergleich unter Verwendung der Kultur Türkisch (Türkei) in einer URL, die mit "file://" beginnt, ausgeführt wird, fehlschlägt, der Vergleich Gleichheit, weil der türkischen Sprache entsprechende Großbuchstabe den Kleinbuchstaben "i" "İ" anstelle von "I" ist.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>As a result, file system access is inadvertently permitted.</source>
          <target state="translated">Daher wird Dateisystemzugriff versehentlich zulässig.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.</source>
          <target state="translated">Andererseits, ein ordinalen Vergleich durchgeführt wird, wird der Vergleich Gleichheit ist erfolgreich, und Dateisystemzugriff verweigert wird.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalization</source>
          <target state="translated">Normalisierung</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Some Unicode characters have multiple representations.</source>
          <target state="translated">Mehrere Darstellungen müssen einige Unicodezeichen.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, any of the following code points can represent the letter "ắ":</source>
          <target state="translated">Beispielsweise kann eine der folgenden Codepunkte den Buchstaben "ắ" darstellen:</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>U+1EAF</source>
          <target state="translated">U + 1EAF</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>U+0103 U+0301</source>
          <target state="translated">U + 0103 U + 0301</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>U+0061 U+0306 U+0301</source>
          <target state="translated">U + 0061 U + 0306 U + 0301</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Multiple representations for a single character complicate searching, sorting, matching, and other string operations.</source>
          <target state="translated">Mehrere Darstellungen für ein einzelnes Zeichen erschweren suchen, sortieren, Abgleich und andere Zeichenfolgenoperationen.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations.</source>
          <target state="translated">Im Unicode-standard definiert eine sogenannte Normalisierung, die eine binäre Darstellung eines Unicode-Zeichens für jede der entsprechende binäre Darstellung zurückgibt.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalization can use several algorithms, called normalization forms, that follow different rules.</source>
          <target state="translated">Normalisierung können mehrere Algorithmen, so genannte Normalisierung Formulare, die verschiedenen Regeln entsprechen.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework supports Unicode normalization forms C, D, KC, and KD.</source>
          <target state="translated">.NET Framework unterstützt Unicode-Normalisierung Forms C, D, KC und KD.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.</source>
          <target state="translated">Wenn Sie Zeichenfolgen in der gleichen Normalisierungsform normalisiert wurden, können sie mithilfe von ordinalen Vergleich verglichen werden.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects in each string.</source>
          <target state="translated">Ein ordinalen Vergleich ist ein binärer Vergleich von der Unicode-Skalarwert des entsprechenden <ph id="ph1">&lt;xref:System.Char&gt;</ph> Objekte in jeder Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes a number of methods that can perform an ordinal comparison, including the following:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String&gt;</ph> Klasse enthält eine Reihe von Methoden, die einen Ordinalvergleich durch, u. a. folgende ausführen können:</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Any overload of the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Equals%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph>,  <ph id="ph4">&lt;xref:System.String.EndsWith%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOf%2A&gt;</ph>, and <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> methods that includes a <ph id="ph7">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
          <target state="translated">Überladung von der <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Equals%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.String.EndsWith%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOf%2A&gt;</ph>, und <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> Methoden, die umfasst eine <ph id="ph7">&lt;xref:System.StringComparison&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The method performs an ordinal comparison if you supply a value of <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase&gt;</ph> for this parameter.</source>
          <target state="translated">Die Methode führt einen ordinalen Vergleich aus, wenn Sie angeben, dass der Wert <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase&gt;</ph> für diesen Parameter.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> method.</source>
          <target state="translated">Die Überladungen der <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that use ordinal comparison by default, such as <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Replace%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.Split%2A&gt;</ph>.</source>
          <target state="translated">Methoden, mit denen Ordinalvergleich standardmäßig, wie z. B. <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Replace%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.String.Split%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that search for a <ph id="ph1">&lt;xref:System.Char&gt;</ph> value or for the elements in a <ph id="ph2">&lt;xref:System.Char&gt;</ph> array in a string instance.</source>
          <target state="translated">Methoden, die für die Suche eine <ph id="ph1">&lt;xref:System.Char&gt;</ph> Wert oder für die Elemente in einem <ph id="ph2">&lt;xref:System.Char&gt;</ph> Array in eine Zeichenfolgeninstanz.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Such methods include <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>.</source>
          <target state="translated">Solche Methoden umfassen <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> und <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can determine whether a string is normalized to normalization form C by calling the <ph id="ph1">&lt;xref:System.String.IsNormalized?displayProperty=nameWithType&gt;</ph> method, or you can call the <ph id="ph2">&lt;xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> method to determine whether a string is normalized to a specified normalization form.</source>
          <target state="translated">Sie können bestimmen, ob eine Zeichenfolge in der Normalisierungsform C, durch Aufrufen normalisiert wird der <ph id="ph1">&lt;xref:System.String.IsNormalized?displayProperty=nameWithType&gt;</ph> -Methode, oder Sie rufen die <ph id="ph2">&lt;xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> Methode, um zu bestimmen, ob eine Zeichenfolge in einer angegebenen Normalisierungsform normalisiert wird.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also call the <ph id="ph1">&lt;xref:System.String.Normalize?displayProperty=nameWithType&gt;</ph> method to convert a string to normalization form C, or you can call the <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> method to convert a string to a specified normalization form.</source>
          <target state="translated">Sie können auch aufrufen, die <ph id="ph1">&lt;xref:System.String.Normalize?displayProperty=nameWithType&gt;</ph> Methode zum Konvertieren einer Zeichenfolge in der Normalisierungsform C, oder Sie können Aufrufen der <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> Methode zum Konvertieren einer Zeichenfolge in einer angegebenen Normalisierungsform.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For step-by-step information about normalizing and comparing strings, see the <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> methods.</source>
          <target state="translated">Ausführliche Informationen zu normalisieren, und Vergleichen von Zeichenfolgen finden Sie die <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> und <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following simple example illustrates string normalization.</source>
          <target state="translated">Das folgende einfache Beispiel veranschaulicht die Normalisierung von Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It defines the letter "ố" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings.</source>
          <target state="translated">Er definiert den Buchstaben "ố" auf drei verschiedene Arten in drei verschiedenen Zeichenfolgen und einen ordinalen Vergleich Gleichheit verwendet, um zu bestimmen, dass jede Zeichenfolge von den anderen beiden Zeichenfolgen unterscheidet.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form.</source>
          <target state="translated">Er jede Zeichenfolge wird dann an den Formularen unterstützten Normalisierung konvertiert, und führt erneut einen ordinalen Vergleich einer Zeichenfolge in einer angegebenen Normalisierungsform.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In each case, the second test for equality shows that the strings are equal.</source>
          <target state="translated">In jedem Fall zeigt der zweite Test auf Gleichheit an, dass die Zeichenfolgen gleich sind.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about normalization and normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>, as well as <bpt id="p1">[</bpt>Unicode Standard Annex #15: Unicode Normalization Forms<ept id="p1">](https://unicode.org/reports/tr15/)</ept> and the <bpt id="p2">[</bpt>Normalization FAQ<ept id="p2">](https://www.unicode.org/faq/normalization.html)</ept> on the unicode.org website.</source>
          <target state="translated">Weitere Informationen zur Normalisierung und Normalisierung Forms finden Sie unter <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>, als auch <bpt id="p1">[</bpt>Unicode Standard Annex #15: Unicode-Normalisierung Forms<ept id="p1">](https://unicode.org/reports/tr15/)</ept> und <bpt id="p2">[</bpt>Normalisierung – häufig gestellte Fragen<ept id="p2">](https://www.unicode.org/faq/normalization.html)</ept> auf die Unicode.org-Website.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String operations by category</source>
          <target state="translated">Zeichenfolgenoperationen nach Kategorie</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String&gt;</ph> Klasse enthält Elemente für das Vergleichen von Zeichenfolgen, Testen von Zeichenfolgen auf Gleichheit, Suchen von Zeichen oder Teilzeichenfolgen in einer Zeichenfolge, die Änderung einer Zeichenfolge, die Teilzeichenfolgen in einer Zeichenfolge, die Kombination von Zeichenfolgen, Formatieren von Werten, Kopieren einer Zeichenfolge und Normalisieren einer Zeichenfolge zu extrahieren.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Comparing strings</source>
          <target state="translated">Vergleichen von Zeichenfolgen</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can compare strings to determine their relative position in the sort order by using the following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods:</source>
          <target state="translated">Sie können Zeichenfolgen vergleichen, um ihre relative Position in der Sortierreihenfolge bestimmen mithilfe der Folgendes <ph id="ph1">&lt;xref:System.String&gt;</ph> Methoden:</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> returns an integer that indicates the relationship of one string to a second string in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> Gibt eine ganze Zahl, die die Beziehung aus einer Zeichenfolge in eine zweite Zeichenfolge in der Sortierreihenfolge angibt.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> Gibt eine ganze Zahl, die die Beziehung von einer Zeichenfolge mit einer zweiten Zeichenfolge basierend auf einem Vergleich ihrer Codepunkte angibt.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> returns an integer that indicates the relationship of the current string instance to a second string in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> Gibt eine ganze Zahl, die die Beziehung von der aktuellen Zeichenfolgeninstanz in eine zweite Zeichenfolge in der Sortierreihenfolge angibt.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method provides the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> and <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> implementations for the <ph id="ph4">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> Methode stellt der <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> und <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> Implementierungen für die <ph id="ph4">&lt;xref:System.String&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Testing strings for equality</source>
          <target state="translated">Testen von Zeichenfolgen auf Gleichheit</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method to determine whether two strings are equal.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> Methode, um zu bestimmen, ob zwei Zeichenfolgen gleich sind.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The instance <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> and the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored.</source>
          <target state="translated">Die Instanz <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> und der statischen <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> Überladungen können Sie angeben, ob der Vergleich kulturabhängig oder Ordinalzahl ist, und gibt an, ob Fall berücksichtigt oder ignoriert wird.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.</source>
          <target state="translated">Die meisten Tests Gleichheit Ordinalvergleiche darstellen, und Vergleiche auf Gleichheit, die bestimmen, den Zugriff auf eine Systemressource (z. B. ein Dateisystemobjekt) sollten immer ordinal sein.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Finding characters in a string</source>
          <target state="translated">Suchen von Zeichen in einer Zeichenfolge</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes two kinds of search methods:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String&gt;</ph> Klasse enthält zwei Arten von Suchmethoden:</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that return a <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> value to indicate whether a particular substring is present in a string instance.</source>
          <target state="translated">Methoden, mit denen eine <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> Wert, um anzugeben, ob eine bestimmte Teilzeichenfolge in einer Zeichenfolgeninstanz vorhanden ist.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>These include the <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph> methods.</source>
          <target state="translated">Dazu gehören die <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that indicate the starting position of a substring in a string instance.</source>
          <target state="translated">Methoden, die die Anfangsposition einer Teilzeichenfolge in einer Zeichenfolgeninstanz angeben.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>These include the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph> methods.</source>
          <target state="translated">Dazu gehören die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions.</source>
          <target state="translated">Wenn Sie für eine bestimmte Teilzeichenfolge, anstatt ein bestimmtes Muster eine Zeichenfolge suchen möchten, sollten Sie reguläre Ausdrücke verwenden.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
          <target state="translated">Weitere Informationen hierzu finden Sie unter <bpt id="p1">[</bpt>Reguläre Ausdrücke von .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Modifying a string</source>
          <target state="translated">Ändern einer Zeichenfolge</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes the following methods that appear to modify the value of a string:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String&gt;</ph> Klasse enthält die folgenden Methoden, die zum Ändern des Werts einer Zeichenfolge angezeigt werden:</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> inserts a string into the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> Fügt eine Zeichenfolge in der aktuellen <ph id="ph2">&lt;xref:System.String&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> inserts one or more occurrences of a specified character at the beginning of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> Fügt eine oder mehrere Vorkommen eines angegebenen Zeichens am Anfang einer Zeichenfolge ein.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> inserts one or more occurrences of a specified character at the end of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> Fügt eine oder mehrere Vorkommen eines angegebenen Zeichens am Ende einer Zeichenfolge ein.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> deletes a substring from the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> Löscht eine Teilzeichenfolge aus dem aktuellen <ph id="ph2">&lt;xref:System.String&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> replaces a substring with another substring in the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> ersetzt eine Teilzeichenfolge durch eine andere Teilzeichenfolge in der aktuellen <ph id="ph2">&lt;xref:System.String&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> convert all the characters in a string to lowercase.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> konvertiert alle Zeichen in einer Zeichenfolge in Kleinbuchstaben.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> convert all the characters in a string to uppercase.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> konvertiert alle Zeichen in einer Zeichenfolge in Großbuchstaben konvertiert wurden.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> removes all occurrences of a character from the beginning and end of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> Entfernt alle Vorkommen von einem Zeichen am Anfang und Ende einer Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> removes all occurrences of a character from the end of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> Entfernt alle Vorkommen eines Zeichens vom Ende einer Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> removes all occurrences of a character from the beginning of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> Entfernt alle Vorkommen eines Zeichens vom Anfang einer Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All string modification methods return a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">Alle Zeichenfolgenmethoden Änderung eine neue zurückgeben <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>They don't modify the value of the current instance.</source>
          <target state="translated">Ändern sie nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Extracting substrings from a string</source>
          <target state="translated">Extrahieren von Teilzeichenfolgen aus einer Zeichenfolge</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method separates a single string into multiple strings.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> Methode trennt eine einzelne Zeichenfolge in mehrere Zeichenfolgen zu trennen.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.</source>
          <target state="translated">Überladungen der Methode ermöglichen Ihnen die Angabe mehrerer Trennzeichen, um die maximale Anzahl von Teilzeichenfolgen zu bestimmen, von dem die Methode extrahiert, und um zu bestimmen, ob leere Zeichenfolgen (die auftreten, wenn es sich bei Trennzeichen nebeneinander angeordnet sind) für die zurückgegebenen Zeichenfolgen enthalten sind.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Combining strings</source>
          <target state="translated">Kombinieren von Zeichenfolgen</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods can be used for string concatenation:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.String&gt;</ph> Methoden für das Verketten von Zeichenfolgen verwendet werden können:</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> combines one or more substrings into a single string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> werden ein oder mehrere Teilzeichenfolgen in einer einzelnen Zeichenfolge kombiniert.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> concatenates one or more substrings into a single element and adds a separator between each substring.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> verkettet eine oder mehrere Teilzeichenfolgen in ein einzelnes Element und fügt ein Trennzeichen zwischen den Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting values</source>
          <target state="translated">Formatieren von Werten</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> Methode verwendet die Funktion für kombinierte Formatierung, um einen oder mehrere Platzhalter in einer Zeichenfolge durch die Zeichenfolgendarstellung für einige Objekte oder Werte zu ersetzen.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method is often used to do the following:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> Methode wird häufig verwendet, um die folgenden Aktionen ausführen:</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of a numeric value in a string.</source>
          <target state="translated">So betten Sie die Darstellung eines numerischen Werts in einer Zeichenfolge ein.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of a date and time value in a string.</source>
          <target state="translated">Die Zeichenfolgendarstellung eines Werts für Datum und Uhrzeit in eine Zeichenfolge eingebettet werden sollen.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of an enumeration value in a string.</source>
          <target state="translated">Die angegebene Zeichenfolgendarstellung eines Enumerationswerts in eine Zeichenfolge eingebettet werden sollen.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of some object that supports the <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interface in a string.</source>
          <target state="translated">So betten Sie die Zeichenfolgendarstellung eines Objekts ein, die unterstützt die <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> Schnittstelle in einer Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To right-justify or left-justify a substring in a field within a larger string.</source>
          <target state="translated">Rechtsbündig oder eine Teilzeichenfolge in einem Feld innerhalb einer größeren Zeichenfolge linksbündig.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For detailed information about formatting operations and examples, see the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload summary.</source>
          <target state="translated">Ausführliche Informationen zum Formatieren von Operationen und Beispiele finden Sie unter der <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> Zusammenfassung überladen.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Copying a string</source>
          <target state="translated">Kopieren einer Zeichenfolge</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can call the following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods to make a copy of a string:</source>
          <target state="translated">Sie können die folgenden Aufrufen <ph id="ph1">&lt;xref:System.String&gt;</ph> Methoden, um eine Kopie einer Zeichenfolge zu erstellen:</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> returns a reference to an existing <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> Gibt einen Verweis auf ein vorhandenes <ph id="ph2">&lt;xref:System.String&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> creates a copy of an existing string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> erstellt eine Kopie einer vorhandenen Zeichenfolge an.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> copies a portion of a string to a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> Kopiert einen Teil einer Zeichenfolge in ein Zeichenarray.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalizing a string</source>
          <target state="translated">Eine Zeichenfolge normalisieren</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In Unicode, a single character can have multiple code points.</source>
          <target state="translated">Im Unicode-Format kann ein einzelnes Zeichen mehrere Codepunkte haben.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalization converts these equivalent characters into the same binary representation.</source>
          <target state="translated">Normalisierung konvertiert diese äquivalenten Zeichen in der gleichen binäre Darstellung.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Normalize%2A?displayProperty=nameWithType&gt;</ph> method performs the normalization, and the <ph id="ph2">&lt;xref:System.String.IsNormalized%2A?displayProperty=nameWithType&gt;</ph> method determines whether a string is normalized.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Normalize%2A?displayProperty=nameWithType&gt;</ph> -Methode führt die Normalisierung und die <ph id="ph2">&lt;xref:System.String.IsNormalized%2A?displayProperty=nameWithType&gt;</ph> Methode bestimmt, ob eine Zeichenfolge normalisiert wird.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information and an example, see the <bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept> section earlier in this topic.</source>
          <target state="translated">Weitere Informationen und ein Beispiel finden Sie unter der <bpt id="p1">[</bpt>Normalisierung<ept id="p1">](#Normalization)</ept> weiter oben in diesem Thema.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This type is thread safe.</source>
          <target state="translated">Dieser Typ ist threadsicher.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this section:</source>
          <target state="translated">In diesem Abschnitt</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Overloaded constructor syntax<ept id="p1">](#Syntax)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Überladener Konstruktorsyntax<ept id="p1">](#Syntax)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Parameters<ept id="p1">](#Params)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Parameter<ept id="p1">](#Params)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Exceptions<ept id="p1">](#Exceptions)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Ausnahmen<ept id="p1">](#Exceptions)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#Tasks)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Welche Methode werden aufgerufen?<ept id="p1">](#Tasks)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Creating strings<ept id="p1">](#Creating_Strings)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Erstellen von Zeichenfolgen<ept id="p1">](#Creating_Strings)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Handling repetitive strings<ept id="p1">](#Repetitive)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Behandlung von Zeichenfolgen<ept id="p1">](#Repetitive)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Examples of instantiating strings:</source>
          <target state="translated">Beispiele für Zeichenfolgen instanziieren:</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using string assignment<ept id="p1">](#Ctor1_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Mit der Zeichenfolge Zuweisung<ept id="p1">](#Ctor1_Example)</ept></target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a character array<ept id="p1">](#Ctor2_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Verwenden ein Array von Zeichen<ept id="p1">](#Ctor2_Example)</ept></target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a portion of a character array and repeating a single character<ept id="p1">](#Ctor3_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Verwenden einen Teil eines Arrays von Zeichen, und wiederholen ein einzelnes Zeichen<ept id="p1">](#Ctor3_Example)</ept></target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a pointer to a character array<ept id="p1">](#Ctor4_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Mithilfe eines Zeigers auf ein Array von Zeichen<ept id="p1">](#Ctor4_Example)</ept></target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using  a pointer and a range of an array<ept id="p1">](#Ctor5_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Verwenden einen Zeiger und einen Bereich eines Arrays<ept id="p1">](#Ctor5_Example)</ept></target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a pointer to a signed byte array<ept id="p1">](#Ctor6_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Mithilfe eines Zeigers auf ein Bytearray mit Vorzeichen<ept id="p1">](#Ctor6_Example)</ept></target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Version information<ept id="p1">](#Versions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Versionsinformationen<ept id="p1">](#Versions)</ept></target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Overloaded constructor syntax</source>
          <target state="translated">Überladener Konstruktorsyntax</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String constructors fall into two categories: those without pointer parameters, and those with pointer parameters.</source>
          <target state="translated">Konstruktoren Zeichenfolgen in zwei Kategorien unterteilen: ohne Zeigerparametern, und die mit Zeigerparametern.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructors that use pointers are not CLS-compliant.</source>
          <target state="translated">Die Konstruktoren, die Zeiger verwenden, sind nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, Visual Basic does not support the use of pointers, and C# requires code that uses pointers to run in an unsafe context.</source>
          <target state="translated">Darüber hinaus Visual Basic unterstützt nicht die Verwendung von Zeigern und C#-Code, der Zeiger verwendet wird, um in einem unsicheren Kontext ausgeführt werden muss.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>unsafe<ept id="p1">](~/docs/csharp/language-reference/keywords/unsafe.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>unsafe<ept id="p1">](~/docs/csharp/language-reference/keywords/unsafe.md)</ept>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For additional guidance on choosing an overload, see <bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#Tasks)</ept></source>
          <target state="translated">Weitere Anleitungen zum Auswählen einer Überladung finden Sie unter <bpt id="p1">[</bpt>welche Methode aufrufen?<ept id="p1">](#Tasks)</ept></target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Initializes the new instance to the value indicated by an array of Unicode characters.</source>
          <target state="translated">Initialisiert die neue Instanz mit dem durch ein Array von Unicode-Zeichen angegebenen Wert.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This constructor copies Unicode characters(<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor2_Example)</ept>).</source>
          <target state="translated">Dieser Konstruktor kopiert Unicode-Zeichen (<bpt id="p1">[</bpt>Beispiel<ept id="p1">](#Ctor2_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Initializes the new instance to the value indicated by an array of Unicode characters, a starting character position within that array, and a length (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>).</source>
          <target state="translated">Initialisiert die neue Instanz mit dem Wert durch ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge angegeben (<bpt id="p1">[</bpt>Beispiel<ept id="p1">](#Ctor3_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Initializes the new instance to the value indicated by a specified Unicode character repeated a specified number of times (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>).</source>
          <target state="translated">Initialisiert die neue Instanz mit dem Wert von einem angegebenen Unicode-Zeichen angegeben wiederholt eine festgelegte Anzahl von Malen (<bpt id="p1">[</bpt>Beispiel<ept id="p1">](#Ctor3_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of Unicode characters that is terminated by a null character (U+0000 or '\0').</source>
          <target state="translated"><bpt id="p1">**</bpt>(Nicht CLS-kompatibel) <ept id="p1">**</ept> Initialisiert die neue Instanz mit dem Wert durch einen Zeiger auf ein Array von Unicode-Zeichen, die durch ein Null-Zeichen beendet wird (U + 0000 oder '\0').</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor4_Example)</ept>).</source>
          <target state="translated">(<bpt id="p1">[</bpt>Beispiel<ept id="p1">](#Ctor4_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Berechtigung: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of Unicode characters, a starting character position within that array, and a length.</source>
          <target state="translated"><bpt id="p1">**</bpt>(Nicht CLS-kompatibel) <ept id="p1">**</ept> Initialisiert die neue Instanz mit dem Wert durch einen Zeiger auf ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge angegeben.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor copies the Unicode characters from <ph id="ph1">`value`</ph> starting at index <ph id="ph2">`startIndex`</ph> and ending at index <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph> – 1 (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor5_Example)</ept>).</source>
          <target state="translated">Der Konstruktor übernimmt die Unicode-Zeichen aus <ph id="ph1">`value`</ph> ab Index <ph id="ph2">`startIndex`</ph> und endet am Index <ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph> – 1 (<bpt id="p1">[</bpt>Beispiel<ept id="p1">](#Ctor5_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Berechtigung: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers.</source>
          <target state="translated"><bpt id="p1">**</bpt>(Nicht CLS-kompatibel) <ept id="p1">**</ept> Der neue Instanz mit den durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen angegebenen Wert initialisiert.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Das Array wird davon ausgegangen, dass zur Darstellung einer Zeichenfolge mit der aktuellen Codepage des Systems codiert (d. h. die festgelegte Codierung <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor processes characters from <ph id="ph1">`value`</ph> starting from the location specified by the pointer until a null character (0x00) is reached (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor6_Example)</ept>).</source>
          <target state="translated">Der Konstruktor verarbeitet Zeichen aus <ph id="ph1">`value`</ph> ab der Position des Zeigers angegeben wird, bis ein Null-Zeichen (0 x 00) erreicht ist (<bpt id="p1">[</bpt>Beispiel<ept id="p1">](#Ctor6_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Berechtigung: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</source>
          <target state="translated"><bpt id="p1">**</bpt>(Nicht CLS-kompatibel) <ept id="p1">**</ept> Initialisiert die neue Instanz mit dem Wert, der durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays und eine Länge angegeben.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Das Array wird davon ausgegangen, dass zur Darstellung einer Zeichenfolge mit der aktuellen Codepage des Systems codiert (d. h. die festgelegte Codierung <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor processes characters from value starting at <ph id="ph1">`startIndex`</ph> and ending at <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1 (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor6_Example)</ept>).</source>
          <target state="translated">Der Konstruktor verarbeitet Zeichen aus dem Wert beginnenden <ph id="ph1">`startIndex`</ph> und endet bei <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1 (<bpt id="p1">[</bpt>Beispiel<ept id="p1">](#Ctor6_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Berechtigung: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>(Nicht CLS-kompatibel) <ept id="p1">**</ept> Initialisiert die neue Instanz mit dem Wert, der durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays, eine Länge angegeben und ein <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Berechtigung: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parameters</source>
          <target state="translated">Parameter</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here is a complete list of parameters used by <ph id="ph1">&lt;xref:System.String&gt;</ph> constructors that don't include a pointer parameter.</source>
          <target state="translated">Hier ist eine vollständige Liste der von verwendeten Parameter <ph id="ph1">&lt;xref:System.String&gt;</ph> Konstruktoren, die einen Zeigerparameter enthalten.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For the parameters used by each overload, see the overload syntax above.</source>
          <target state="translated">Die Parameter, die durch jede Überladung verwendet wird finden Sie in der obigen Syntax für Überladung.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parameter</source>
          <target state="translated">Parameter</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Type</source>
          <target state="translated">Typ</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Char&gt;</ph>[]</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Char&gt;</ph>[]</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An array of Unicode characters.</source>
          <target state="translated">Ein Array von Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A Unicode character.</source>
          <target state="translated">Ein Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The starting position in <ph id="ph1">`value`</ph> of the first character in the new string.</source>
          <target state="translated">Die Anfangsposition im <ph id="ph1">`value`</ph> des ersten Zeichens in der neuen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: 0</source>
          <target state="translated">Standardwert: 0</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The number of characters in <ph id="ph1">`value`</ph> to include in the new string.</source>
          <target state="translated">Die Anzahl der Zeichen in <ph id="ph1">`value`</ph> in der neuen Zeichenfolge eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Standardwert: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The number of times the character <ph id="ph1">`c`</ph> is repeated in the new string.</source>
          <target state="translated">Die Häufigkeit, mit des Zeichens <ph id="ph1">`c`</ph> wird in der neuen Zeichenfolge wiederholt.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`count`</ph> is zero, the value of the new object is <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`count`</ph> NULL ist, wird der Wert des neuen Objekts <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here is a complete list of parameters used by <ph id="ph1">&lt;xref:System.String&gt;</ph> constructors that include a pointer parameter.</source>
          <target state="translated">Hier ist eine vollständige Liste der von verwendeten Parameter <ph id="ph1">&lt;xref:System.String&gt;</ph> Konstruktoren, die einen Zeigerparameter enthalten.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For the parameters used by each overload, see the overload syntax above.</source>
          <target state="translated">Die Parameter, die durch jede Überladung verwendet wird finden Sie in der obigen Syntax für Überladung.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parameter</source>
          <target state="translated">Parameter</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Type</source>
          <target state="translated">Typ</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A pointer to a null-terminated array of Unicode characters or an array of 8-bit signed integers.</source>
          <target state="translated">Ein Zeiger auf ein mit Null endendes Array von Unicode-Zeichen oder ein Array von 8-Bit-Ganzzahlen mit Vorzeichen.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph> or an empty array, the value of the new string is <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`value`</ph> ist <ph id="ph2">`null`</ph> oder ein leeres Array, der Wert der neuen Zeichenfolge <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The index of the array element that defines the first character in the new string.</source>
          <target state="translated">Der Index des Arrayelements, der das erste Zeichen in der neuen Zeichenfolge definiert.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: 0</source>
          <target state="translated">Standardwert: 0</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The number of array elements to use to create the new string.</source>
          <target state="translated">Die Anzahl von Arrayelementen zu verwenden, um die neue Zeichenfolge zu erstellen.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If length is zero, the constructor creates a string whose value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn die Länge 0 (null) ist, wird der Konstruktor erstellt eine Zeichenfolge, deren Wert <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Standardwert: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An object that specifies how the <ph id="ph1">`value`</ph> array is encoded.</source>
          <target state="translated">Ein Objekt, der angibt, wie die <ph id="ph1">`value`</ph> Array codiert ist.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>, or the system's current ANSI code page</source>
          <target state="translated">Standardwert: <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>, oder die aktuelle ANSI-Codepage des Systems</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Exceptions</source>
          <target state="translated">Ausnahmen</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's a list of exceptions thrown by constructors that don't include pointer parameters.</source>
          <target state="translated">Hier ist eine Liste der Ausnahmen von Konstruktoren, die keine Zeigerparametern enthalten.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Exception</source>
          <target state="translated">Ausnahme</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Condition</source>
          <target state="translated">Bedingung</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Thrown by</source>
          <target state="translated">Ausgelöst von</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ist <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`startIndex`</ph>,<ph id="ph2">`length`</ph>, or <ph id="ph3">`count`</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph>,<ph id="ph2">`length`</ph>, oder <ph id="ph3">`count`</ph> ist kleiner als 0 (null).</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sum of <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> is greater than the number of elements in <ph id="ph3">`value`</ph>.</source>
          <target state="translated">Die Summe von <ph id="ph1">`startIndex`</ph> und <ph id="ph2">`length`</ph> ist größer als die Anzahl der Elemente von <ph id="ph3">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`count`</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">`count`</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's a list of exceptions thrown by constructors that include pointer parameters.</source>
          <target state="translated">Hier ist eine Liste der Ausnahmen von Konstruktoren, die Zeigerparameter enthalten.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Exception</source>
          <target state="translated">Ausnahme</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Condition</source>
          <target state="translated">Bedingung</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Thrown by</source>
          <target state="translated">Ausgelöst von</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> specifies an array that contains an invalid Unicode character.</source>
          <target state="translated"><ph id="ph1">`value`</ph> Gibt ein Array, das ein ungültiges Unicode-Zeichen enthält.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> or <ph id="ph2">`value`</ph><ph id="ph3"> + </ph><ph id="ph4">`startIndex`</ph> specifies an address that is less than 64K.</source>
          <target state="translated"><ph id="ph1">`value`</ph> oder <ph id="ph2">`value`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`startIndex`</ph> gibt eine Adresse, die weniger als 64 KB ist.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A new <ph id="ph1">&lt;xref:System.String&gt;</ph> instance could not be initialized from the <ph id="ph2">`value`</ph> byte array because <ph id="ph3">`value`</ph> does not use the default code page encoding.</source>
          <target state="translated">Ein neues <ph id="ph1">&lt;xref:System.String&gt;</ph> Instanz konnte nicht initialisiert werden, aus der <ph id="ph2">`value`</ph> Bytearray, da <ph id="ph3">`value`</ph> nicht der Standardeinstellung codepagecodierung verwendet.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All constructors with pointers.</source>
          <target state="translated">Alle Konstruktoren mit Zeigern.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> is null.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ist NULL.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The current process does not have read access to all the addressed characters.</source>
          <target state="translated">Der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`startIndex`</ph> or <ph id="ph2">`length`</ph> is less than zero, <ph id="ph3">`value`</ph><ph id="ph4"> + </ph><ph id="ph5">`startIndex`</ph> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> oder <ph id="ph2">`length`</ph> ist kleiner als 0 (null), <ph id="ph3">`value`</ph><ph id="ph4"> + </ph><ph id="ph5">`startIndex`</ph> verursacht einen Zeigerüberlauf oder der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The length of the new string is too large to allocate.</source>
          <target state="translated">Die Länge der neuen Zeichenfolge ist zu groß zum zuordnen.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All constructors with pointers.</source>
          <target state="translated">Alle Konstruktoren mit Zeigern.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph>, or <ph id="ph2">`value`</ph><ph id="ph3"> + </ph><ph id="ph4">`startIndex`</ph><ph id="ph5"> + </ph><ph id="ph6">`length`</ph> – 1, specifies an invalid address.</source>
          <target state="translated"><ph id="ph1">`value`</ph>, oder <ph id="ph2">`value`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`startIndex`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`length`</ph> – 1, gibt eine ungültige Adresse an.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Which method do I call?</source>
          <target state="translated">Welche Methode werden aufgerufen?</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Call or use</source>
          <target state="translated">Aufruf oder verwenden</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string.</source>
          <target state="translated">Erstellen Sie eine Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Assignment from a string literal or an existing string (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor1_Example)</ept>)</source>
          <target state="translated">Zuweisung von einem Zeichenfolgenliteral oder eine vorhandene Zeichenfolge (<bpt id="p1">[</bpt>Beispiel<ept id="p1">](#Ctor1_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from an entire character array.</source>
          <target state="translated">Erstellen Sie eine Zeichenfolge aus einer gesamten Zeichenarray.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor2_Example)</ept>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> (<bpt id="p1">[</bpt>Beispiel<ept id="p1">](#Ctor2_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Createa string from a portion of a character array.</source>
          <target state="translated">Erstellt einen Zeichenfolge aus einem Teil eines Arrays von Zeichen.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>Beispiel<ept id="p1">](#Ctor3_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string that repeats the same character multiple times.</source>
          <target state="translated">Erstellen Sie eine Zeichenfolge, die das gleiche Zeichen mehrmals wiederholt.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>Beispiel<ept id="p1">](#Ctor3_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from a pointer to a Unicode or wide character array.</source>
          <target state="translated">Erstellen Sie eine Zeichenfolge von einem Zeiger auf eine Unicode- oder ein Array mit Breitzeichen.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from a portion of a Unicode or wide character array by using its pointer.</source>
          <target state="translated">Erstellen Sie eine Zeichenfolge aus einem Abschnitt eine Unicode-oder Breitzeichen Array mithilfe der Zeiger.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from a C++ <ph id="ph1">`char`</ph> array.</source>
          <target state="translated">Erstellen Sie eine Zeichenfolge aus einer C++ <ph id="ph1">`char`</ph> Array.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph>, <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph>, <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph></target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from ASCII characters.</source>
          <target state="translated">Erstellen Sie eine Zeichenfolge aus ASCII-Zeichen.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Creating strings</source>
          <target state="translated">Erstellen von Zeichenfolgen</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The most commonly used technique for creating strings programmatically is simple assignment, as illustrated in <bpt id="p1">[</bpt>this example<ept id="p1">](#Ctor1_Example)</ept>.</source>
          <target state="translated">Die am häufigsten verwendeten Verfahren zur Erstellung von Zeichenfolgen programmgesteuert einfache Zuweisung, wie im veranschaulicht <bpt id="p1">[</bpt>in diesem Beispiel<ept id="p1">](#Ctor1_Example)</ept>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class also includes four types of constructor overloads that let you create strings from the following values:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String&gt;</ph> Klasse enthält auch vier Typen von Konstruktorüberladungen, mit denen Sie die Zeichenfolgen aus folgenden Werten zu erstellen:</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a character array (an array of UTF-16-encoded characters).</source>
          <target state="translated">Aus einem Zeichenarray von (ein Array von UTF-16-codierte Zeichen).</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from the characters in the entire array or a portion of it.</source>
          <target state="translated">Sie können ein neues erstellen <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt aus der Zeichen in das gesamte Array oder einem Teil davon.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> constructor copies all the characters in the array to the new string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> Konstruktor kopiert alle Zeichen im Array, an der neuen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor copies the characters from index <ph id="ph2">`startIndex`</ph> to index <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph> – 1 to the new string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Konstruktor kopiert die Zeichen aus dem Index <ph id="ph2">`startIndex`</ph> Index <ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph> – 1, um die neue Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`length`</ph> is zero, the value of the new string is <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`length`</ph> NULL ist, wird der Wert der neuen Zeichenfolge <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your code repeatedly instantiates strings that have the same value, you can improve application performance by using an alternate means of creating strings.</source>
          <target state="translated">Wenn Code wiederholt Zeichenfolgen, die den gleichen Wert haben instanziiert, können Sie die Leistung der Anwendung verbessern, ein alternativen Verfahren zum Erstellen von Zeichenfolgen mit.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Handling repetitive strings<ept id="p1">](#Repetitive)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Behandlung von Zeichenfolgen von<ept id="p1">](#Repetitive)</ept>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a single character that is duplicated zero, one, or more times, by using the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Von einem einzelnen Zeichen, doppelte 0 (null), in einer oder mehrere Male, indem die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`count`</ph> is zero, the value of the new string is <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`count`</ph> NULL ist, wird der Wert der neuen Zeichenfolge <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a pointer to a null-terminated character array, by using the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> or <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Von einem Zeiger auf ein Zeichenarray mit Null endende, durch die Verwendung der <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Either the entire array or a specified range can be used to initialize the string.</source>
          <target state="translated">Das gesamte Array oder einem angegebenen Bereich kann verwendet werden, um die Zeichenfolge zu initialisieren.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor copies a sequence of Unicode characters starting from the specified pointer or from the specified pointer plus <ph id="ph1">`startIndex`</ph> and continuing to the end of the array or for <ph id="ph2">`length`</ph> characters.</source>
          <target state="translated">Der Konstruktor übernimmt eine Sequenz von Unicode-Zeichen ab, aus dem angegebenen Zeiger oder des angegebenen Zeigers plus <ph id="ph1">`startIndex`</ph> und fortgesetzt, bis zum Ende des Arrays oder für <ph id="ph2">`length`</ph> Zeichen.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`value`</ph> is a null pointer or <ph id="ph2">`length`</ph> is zero, the constructor creates a string whose value is <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`value`</ph> ist ein null-Zeiger oder <ph id="ph2">`length`</ph> NULL ist, wird der Konstruktor erstellt eine Zeichenfolge, deren Wert <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the copy operation proceeds to the end of the array and the array is not null-terminated, the constructor behavior is system-dependent.</source>
          <target state="translated">Wenn der Kopiervorgang wird, bis zum Ende des Arrays fortgesetzt, und das Array ist nicht für die Null-terminierte, ist das Verhalten des Konstruktors systemabhängig.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Such a condition might cause an access violation.</source>
          <target state="translated">Diese Situation kann eine zugriffsverletzung verursachen.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the array contains any embedded null characters (U+0000 or '\0') and the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is called, the string instance contains <ph id="ph2">`length`</ph> characters including any embedded nulls.</source>
          <target state="translated">Wenn das Array eingebetteten Null-Zeichen enthält (U + 0000 oder '\0') und die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Überladung aufgerufen wird, enthält die Zeichenfolgeninstanz <ph id="ph2">`length`</ph> Zeichen einschließlich eines beliebigen eingebettete NULL-Werte.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel zeigt, was geschieht, wenn ein Zeiger auf ein Array mit 10 Elementen, die zwei Null-Zeichen enthält, übergeben, wird die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</source>
          <target state="translated">Da die Adresse der Anfang des Arrays ist und alle Elemente im Array der Zeichenfolge hinzugefügt werden, wird der Konstruktor eine Zeichenfolge mit zehn Zeichen, z. B. zwei eingebetteten NULL-Werte instanziiert.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, if the same array is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> constructor, the result is a four-character string that does not include the first null character.</source>
          <target state="translated">Andererseits, wenn im selben Array übergeben wird, um die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> Konstruktor, der das Ergebnis ist eine vier-Zeichenfolge, die keine erste Null-Zeichen enthalten.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The array must contain Unicode characters.</source>
          <target state="translated">Das Array muss es sich um Unicode-Zeichen enthalten.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In C++, this means that the character array must be defined either as the managed <ph id="ph1">&lt;xref:System.Char&gt;</ph>[] type or the unmanaged<ph id="ph2">`wchar_t`</ph>[] type.</source>
          <target state="translated">In C++ ist dies bedeutet, dass das Zeichenarray muss entweder als die verwaltete definiert <ph id="ph1">&lt;xref:System.Char&gt;</ph>[]-Typ oder die nicht verwaltete<ph id="ph2">`wchar_t`</ph>[]-Typ.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> overload is called and the array is not null-terminated, or if the <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is called and <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph>-1 includes a range that it outside the memory allocated for the sequence of characters, the behavior of the constructor is system-dependent, and an access violation may occur.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> Überladung wird aufgerufen, und das Array ist nicht für die Null-terminiert ist, oder wenn die <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Überladung wird aufgerufen und <ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph>-1 umfasst einen Bereich, der es außerhalb des Arbeitsspeichers für die Sequenz von Zeichen, d. h. zugewiesen das Verhalten des Konstruktors systemabhängig, und eine zugriffsverletzung auftreten.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, on the Intel Itanium processor, calls to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor may throw a <ph id="ph2">&lt;xref:System.DataMisalignedException&gt;</ph> exception.</source>
          <target state="translated">Darüber hinaus in der Intel Itanium-Prozessor aufruft, um die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Konstruktor Auslösen einer <ph id="ph2">&lt;xref:System.DataMisalignedException&gt;</ph> Ausnahme.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If this occurs, call the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> instead.</source>
          <target state="translated">In diesem Fall rufen die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> stattdessen.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a pointer to a signed byte array.</source>
          <target state="translated">Von einem Zeiger auf ein Bytearray mit Vorzeichen.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Either the entire array or a specified range can be used to initialize the string.</source>
          <target state="translated">Das gesamte Array oder einem angegebenen Bereich kann verwendet werden, um die Zeichenfolge zu initialisieren.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sequence of bytes can be interpreted by using the default code page encoding, or an encoding can be specified in the constructor call.</source>
          <target state="translated">Die Abfolge von Bytes interpretiert werden kann, mithilfe der Standardcodepage, die Codierung, oder eine Codierung, die im Konstruktoraufruf angegeben werden kann.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the constructor tries to instantiate a string from an entire array that is not null-terminated, or if the range of the array from <ph id="ph1">`value`</ph><ph id="ph2"> + </ph><ph id="ph3">`startIndex`</ph> to <ph id="ph4">`value`</ph><ph id="ph5"> + </ph><ph id="ph6">`startIndex`</ph><ph id="ph7"> + </ph><ph id="ph8">`length`</ph> -1 is outside of the memory allocated for the array, the behavior of this constructor is system-dependent, and an access violation may occur.</source>
          <target state="translated">Wenn der Konstruktor versucht, eine Zeichenfolge aus einem gesamten Array zu instanziieren, das keine Null-terminiert ist, oder wenn der Bereich des Arrays von <ph id="ph1">`value`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`startIndex`</ph> auf <ph id="ph4">`value`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`startIndex`</ph> <ph id="ph7"> + </ph> <ph id="ph8">`length`</ph> -1 befindet sich außerhalb des Arbeitsspeichers für das Array zugeordnet und das Verhalten dieses Konstruktors ist systemabhängig eine zugriffsverletzung auftreten.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The three constructors that include a signed byte array as a parameter are designed primarily to convert a C++ <ph id="ph1">`char`</ph> array to a string, as shown in this example:</source>
          <target state="translated">Die drei Konstruktoren, die einen Bytewert mit Vorzeichen Array als Parameter enthalten dienen in erster Linie zum Konvertieren einer C++ <ph id="ph1">`char`</ph> array in eine Zeichenfolge, wie im folgenden Beispiel gezeigt:</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the array contains any null characters ('\0') or bytes whose value is 0 and the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is called, the string instance contains <ph id="ph2">`length`</ph> characters including any embedded nulls.</source>
          <target state="translated">Wenn das Array enthält Null-Zeichen ('\0') oder die Bytes, dessen Wert 0 ist, und der <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Überladung aufgerufen wird, enthält die Zeichenfolgeninstanz <ph id="ph2">`length`</ph> Zeichen einschließlich eines beliebigen eingebettete NULL-Werte.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel zeigt, was geschieht, wenn ein Zeiger auf ein Array mit 10 Elementen, die zwei Null-Zeichen enthält, übergeben, wird die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</source>
          <target state="translated">Da die Adresse der Anfang des Arrays ist und alle Elemente im Array der Zeichenfolge hinzugefügt werden, wird der Konstruktor eine Zeichenfolge mit zehn Zeichen, z. B. zwei eingebetteten NULL-Werte instanziiert.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, if the same array is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> constructor, the result is a four-character string that does not include the first null character.</source>
          <target state="translated">Andererseits, wenn im selben Array übergeben wird, um die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> Konstruktor, der das Ergebnis ist eine vier-Zeichenfolge, die keine erste Null-Zeichen enthalten.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> and <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructors interpret <ph id="ph3">`value`</ph> by using the default ANSI code page, calling these constructors with identical byte arrays may create strings that have different values on different systems.</source>
          <target state="translated">Da die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> und <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Konstruktoren interpretieren <ph id="ph3">`value`</ph> mithilfe der voreingestellten ANSI-Codepage Aufrufen dieser Konstruktoren mit identischer Bytearrays Zeichenfolgen verschiedene Werte für das entsprechende System erstellen kann.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Handling repetitive strings</source>
          <target state="translated">Behandlung von Zeichenfolgen</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Apps that parse or decode streams of text often use the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor or the <ph id="ph2">&lt;xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to convert sequences of characters into a string.</source>
          <target state="translated">Apps, die analysiert oder häufig Decodieren von Streams von Text, verwenden die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Konstruktor oder die <ph id="ph2">&lt;xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> Methode, um Sequenzen von Zeichen in eine Zeichenfolge zu konvertieren.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Repeatedly creating new strings with the same value instead of creating and reusing one string wastes memory.</source>
          <target state="translated">Wiederholt Erstellen neuer Zeichenfolgen mit demselben Wert anstatt zu erstellen und Wiederverwenden von einer Zeichenfolge wird Arbeitsspeicher vergeudet.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you are likely to create the same string value repeatedly by calling the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor, even if you don't know in advance what those identical string values may be, you can use a lookup table instead.</source>
          <target state="translated">Wenn Sie wahrscheinlich den gleichen Zeichenfolgenwert wiederholt zu erstellen, indem die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Konstruktor, auch wenn Sie nicht in kennen zu gelangen, was identisch Zeichenfolgenwerte sein können, können Sie stattdessen eine Nachschlagetabelle verwenden.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, suppose you read and parse a stream of characters from a file that contains XML tags and attributes.</source>
          <target state="translated">Nehmen wir beispielsweise an, Sie lesen und Analysieren einen Datenstrom von Zeichen aus einer Datei, die XML-Tags und Attribute enthält.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When you parse the stream, you repeatedly encounter certain tokens (that is, sequences of characters that have a symbolic meaning).</source>
          <target state="translated">Wenn Sie den Stream analysieren, treten wiederholt bestimmte Token (d. h. Sequenzen von Zeichen, die eine symbolische Bedeutung haben).</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Tokens equivalent to the strings "0", "1", "true", and "false" are likely to occur frequently in an XML stream.</source>
          <target state="translated">Token, die Zeichenfolgen "0", "1", "true" und "false" werden wahrscheinlich in einem XML-Stream häufig auftreten.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Instead of converting each token into a new string, you can create a <ph id="ph1">&lt;xref:System.Xml.NameTable?displayProperty=nameWithType&gt;</ph> object to hold commonly occurring strings.</source>
          <target state="translated">Statt jedes Token in einer neuen Zeichenfolge konvertieren, können Sie erstellen eine <ph id="ph1">&lt;xref:System.Xml.NameTable?displayProperty=nameWithType&gt;</ph> Objekt, das häufig auftretende Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.Xml.NameTable&gt;</ph> object improves performance, because it retrieves stored strings without allocating temporary memory.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Xml.NameTable&gt;</ph> Objekt verbessert die Leistung, da es gespeicherte Zeichenfolgen abruft, ohne temporären Speicher zu belegen.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When you encounter a token, use the <ph id="ph1">&lt;xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to retrieve the token from the table.</source>
          <target state="translated">Wenn Sie ein Token auftritt, verwenden Sie die <ph id="ph1">&lt;xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> Methode, um das Token aus der Tabelle abzurufen.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the token exists, the method returns the corresponding string.</source>
          <target state="translated">Wenn das Token vorhanden ist, gibt die Methode die entsprechende Zeichenfolge zurück.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the token does not exist, use the <ph id="ph1">&lt;xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to insert the token into the table and to get the corresponding string.</source>
          <target state="translated">Wenn das Token nicht vorhanden ist, verwenden Sie die <ph id="ph1">&lt;xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> Methode, um das Token in die Tabelle einzufügen und die entsprechende Zeichenfolge abgerufen.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 1: Using string assignment</source>
          <target state="translated">Beispiel 1: Verwenden von zeichenkettenzuweisung</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example creates a new string by assigning it a string literal.</source>
          <target state="translated">Das folgende Beispiel erstellt eine neue Zeichenfolge durch ein Zeichenfolgenliteral zuweisen.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It creates a second string by assigning the value of the first string to it.</source>
          <target state="translated">Es erstellt eine zweite Zeichenfolge, durch den Wert der ersten Zeichenfolge zuweisen.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>These are the two most common ways to instantiate a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">Dies sind die beiden am häufigsten verwendeten Arten, instanziieren Sie ein neues <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 2: Using a character array</source>
          <target state="translated">Beispiel 2: Verwenden ein Array von Zeichen</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from a character array.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt aus einem Zeichenarray von.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 3: Using a portion of a character array and repeating a single character</source>
          <target state="translated">Beispiel 3: Verwenden einen Teil eines Arrays von Zeichen, und wiederholen ein einzelnes Zeichen</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from a portion of a character array, and how to create a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object that contains multiple occurrences of a single character.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt aus einen Teil ein Zeichenarray und zum Erstellen eines neuen <ph id="ph2">&lt;xref:System.String&gt;</ph> -Objekt, das mehrere Vorkommen eines einzelnen Zeichens enthält.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 4: Using a pointer to a character array</source>
          <target state="translated">Beispiel 4: Mithilfe eines Zeigers auf ein Array von Zeichen</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from a pointer to an array of characters.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt von einem Zeiger auf ein Array von Zeichen.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The C# example must be compiled by using the <ph id="ph1">`/unsafe`</ph> compiler switch.</source>
          <target state="translated">Das C#-Beispiel muss kompiliert werden, mithilfe der <ph id="ph1">`/unsafe`</ph> Compilerschalter.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 5: Instantiating a string from a pointer and a range of an array</source>
          <target state="translated">Beispiel 5: Instanziieren eine Zeichenfolge mit einem Zeiger und einen Bereich eines Arrays</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example examines the elements of a character array for either a period or an exclamation point.</source>
          <target state="translated">Im folgende Beispiel werden die Elemente eines Arrays von Zeichen für einen Punkt oder ein Ausrufezeichen untersucht.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If one is found, it instantiates a string from the characters in the array that precede the punctuation symbol.</source>
          <target state="translated">Wenn eine gefunden wird, instanziiert es eine Zeichenfolge aus der Zeichen im Array, die das interpunktionssymbol vorausgehen.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If not, it instantiates a string with the entire contents of the array.</source>
          <target state="translated">Wenn dies nicht der Fall ist, es wird eine Zeichenfolge mit den gesamten Inhalt des Arrays instanziiert.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The C# example must be compiled using the <ph id="ph1">`/unsafe`</ph> compiler switch.</source>
          <target state="translated">Das C#-Beispiel muss kompiliert werden, mithilfe der <ph id="ph1">`/unsafe`</ph> Compilerschalter.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 6: Instantiating a string from a pointer to a signed byte array</source>
          <target state="translated">Beispiel 6: Instanziieren einer Zeichenfolge von einem Zeiger auf ein Bytearray mit Vorzeichen</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how you can create an instance of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class with the <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> constructor.</source>
          <target state="translated">Im folgende Beispiel wird veranschaulicht, wie Sie eine Instanz von erstellen können die <ph id="ph1">&lt;xref:System.String&gt;</ph> -Klasse mit der <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Version information</source>
          <target state="translated">Versionsinformationen</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework</source>
          <target state="translated">.NET Framework</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</source>
          <target state="translated">Alle Überladungen werden unterstützt: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework Client Profile</source>
          <target state="translated">.NET Framework Client Profile</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads are supported in: 4, 3.5 SP1</source>
          <target state="translated">Alle Überladungen werden unterstützt: 4, 3.5 SP1</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Portable Class Library</source>
          <target state="translated">Portable Klassenbibliothek</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads without an <ph id="ph1">&lt;xref:System.SByte&gt;</ph><ph id="ph2">`*`</ph> parameter are supported</source>
          <target state="translated">Alle Überladungen ohne eine <ph id="ph1">&lt;xref:System.SByte&gt;</ph> <ph id="ph2">`*`</ph> Parameter werden unterstützt.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET for Windows Store apps</source>
          <target state="translated">.NET für Windows Store-Apps</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads without an <ph id="ph1">&lt;xref:System.SByte&gt;</ph><ph id="ph2">`*`</ph> parameter are supported in: Windows 8</source>
          <target state="translated">Alle Überladungen ohne eine <ph id="ph1">&lt;xref:System.SByte&gt;</ph> <ph id="ph2">`*`</ph> Parameter werden unterstützt: Windows 8</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source>A pointer to a null-terminated array of Unicode characters.</source>
          <target state="translated">Ein Zeiger auf ein mit Null endendes Array von Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of Unicode characters.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von Unicode-Zeichen bestimmt wird.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Beispiele und Informationen über diese und andere umfassende Verwendung <ph id="ph1">`String`</ph> Konstruktorüberladungen, finden Sie unter der <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> Konstruktor Zusammenfassung.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source>The current process does not have read access to all the addressed characters.</source>
          <target state="translated">Der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifies an array that contains an invalid Unicode character, or <ph id="ph2">&lt;paramref name="value" /&gt;</ph> specifies an address less than 64000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> gibt ein Array an, das ein ungültiges Unicode-Zeichen enthält, oder <ph id="ph2">&lt;paramref name="value" /&gt;</ph> gibt eine Adresse kleiner als 64000 an.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[])">
          <source>An array of Unicode characters.</source>
          <target state="translated">Ein Array von Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by an array of Unicode characters.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Klasse mit dem durch ein Array von Unicode-Zeichen angegebenen Wert.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char[])">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Beispiele und Informationen über diese und andere umfassende Verwendung <ph id="ph1">`String`</ph> Konstruktorüberladungen, finden Sie unter der <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> Konstruktor Zusammenfassung.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>A pointer to a null-terminated array of 8-bit signed integers.</source>
          <target state="translated">Ein Zeiger auf ein mit NULL endendes Array von 8-Bit-Ganzzahlen mit Vorzeichen.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>The integers are interpreted using the current system code page encoding (that is, the encoding specified by <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph>).</source>
          <target state="translated">Die Ganzzahlen werden mit der aktuellen Systemcodeseiten-Codierung interpretiert (d.h. der durch <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph> angegebenen Codierung).</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a pointer to an array of 8-bit signed integers.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Klasse mit dem durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen angegebenen Wert.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Beispiele und Informationen über diese und andere umfassende Verwendung <ph id="ph1">`String`</ph> Konstruktorüberladungen, finden Sie unter der <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> Konstruktor Zusammenfassung.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> could not be initialized using <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, assuming <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is encoded in ANSI.</source>
          <target state="translated">Eine neue Instanz von <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> konnte nicht mit <ph id="ph2">&lt;paramref name="value" /&gt;</ph> initialisiert werden, wobei angenommen wurde, dass <ph id="ph3">&lt;paramref name="value" /&gt;</ph> in ANSI codiert ist.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>The length of the new string to initialize, which is determined by the null termination character of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, is too large to allocate.</source>
          <target state="translated">Die Länge der neuen zu initialisierenden Zeichenfolge, die durch das NULL-Abschlusszeichen von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> bestimmt wird, ist zu groß für die Zuordnung.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifies an invalid address.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> gibt eine ungültige Adresse an.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>A Unicode character.</source>
          <target state="translated">Ein Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>The number of times <bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept> occurs.</source>
          <target state="translated">Die Anzahl des Vorkommens von <bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified Unicode character repeated a specified number of times.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Klasse mit dem Wert, der durch ein angegebenes so oft wie angegeben wiederholtes Unicode-Zeichen bestimmt wird.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Beispiele und Informationen über diese und andere umfassende Verwendung <ph id="ph1">`String`</ph> Konstruktorüberladungen, finden Sie unter der <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> Konstruktor Zusammenfassung.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>A pointer to an array of Unicode characters.</source>
          <target state="translated">Ein Zeiger auf ein Array von Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Anfangsposition in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Die Anzahl der aus <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> zu verwendenden Zeichen.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von Unicode-Zeichen, durch die Position des ersten Zeichens innerhalb dieses Arrays und durch eine Länge bestimmt wird.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Beispiele und Informationen über diese und andere umfassende Verwendung <ph id="ph1">`String`</ph> Konstruktorüberladungen, finden Sie unter der <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> Konstruktor Zusammenfassung.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero, <ph id="ph3">&lt;paramref name="value" /&gt;</ph><ph id="ph4"> + </ph><ph id="ph5">&lt;paramref name="startIndex" /&gt;</ph> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ist kleiner als 0 (null), <ph id="ph3">&lt;paramref name="value" /&gt;</ph><ph id="ph4"> + </ph><ph id="ph5">&lt;paramref name="startIndex" /&gt;</ph> verursacht einen Zeigerüberlauf oder der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifies an array that contains an invalid Unicode character, or <ph id="ph2">&lt;paramref name="value" /&gt;</ph><ph id="ph3"> + </ph><ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> specifies an address less than 64000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> gibt ein Array an, das ein ungültiges Unicode-Zeichen enthält, oder <ph id="ph2">&lt;paramref name="value" /&gt;</ph><ph id="ph3"> + </ph><ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> gibt eine Adresse kleiner als 64000 an.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>An array of Unicode characters.</source>
          <target state="translated">Ein Array von Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Anfangsposition in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Die Anzahl der aus <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> zu verwendenden Zeichen.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Klasse mit dem Wert, der durch ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge bestimmt wird.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Beispiele und Informationen über diese und andere umfassende Verwendung <ph id="ph1">`String`</ph> Konstruktorüberladungen, finden Sie unter der <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> Konstruktor Zusammenfassung.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>The sum of <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Die Summe von <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ist größer als die Anzahl der Elemente von <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>A pointer to an array of 8-bit signed integers.</source>
          <target state="translated">Ein Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The integers are interpreted using the current system code page encoding (that is, the encoding specified by <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph>).</source>
          <target state="translated">Die Ganzzahlen werden mit der aktuellen Systemcodeseiten-Codierung interpretiert (d.h. der durch <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph> angegebenen Codierung).</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Anfangsposition in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Die Anzahl der aus <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> zu verwendenden Zeichen.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays und die Länge angegeben wird.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Beispiele und Informationen über diese und andere umfassende Verwendung <ph id="ph1">`String`</ph> Konstruktorüberladungen, finden Sie unter der <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> Konstruktor Zusammenfassung.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is too large for the current platform; that is, the address calculation overflowed.</source>
          <target state="translated">Die durch <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> angegebene Adresse ist für die aktuelle Plattform zu groß, d.h., bei der Berechnung der Adresse ist ein Überlauf aufgetreten.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The length of the new string to initialize is too large to allocate.</source>
          <target state="translated">Die Länge der zu initialisierenden neuen Zeichenfolge ist zu groß und kann daher nicht zugeordnet werden.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is less than 64K.</source>
          <target state="translated">Die durch <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> angegebene Adresse ist kleiner als 64K.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> could not be initialized using <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, assuming <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is encoded in ANSI.</source>
          <target state="translated">Eine neue Instanz von <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> konnte nicht mit <ph id="ph2">&lt;paramref name="value" /&gt;</ph> initialisiert werden, wobei angenommen wurde, dass <ph id="ph3">&lt;paramref name="value" /&gt;</ph> in ANSI codiert ist.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="length" /&gt;</ph> collectively specify an invalid address.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> und <ph id="ph3">&lt;paramref name="length" /&gt;</ph> geben zusammen eine ungültige Adresse an.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>A pointer to an array of 8-bit signed integers.</source>
          <target state="translated">Ein Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Anfangsposition in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Die Anzahl der aus <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> zu verwendenden Zeichen.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>An object that specifies how the array referenced by <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> is encoded.</source>
          <target state="translated">Ein Objekt, das angibt, wie das Array codiert ist, auf das <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> verweist.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>enc<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, ANSI encoding is assumed.</source>
          <target state="translated">Wenn <bpt id="p1">&lt;c&gt;</bpt>enc<ept id="p1">&lt;/c&gt;</ept> gleich <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist, wird von ANSI-Codierung ausgegangen.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays, eine Länge und ein <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>-Objekt angegeben wird.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Beispiele und Informationen über diese und andere umfassende Verwendung <ph id="ph1">`String`</ph> Konstruktorüberladungen, finden Sie unter der <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> Konstruktor Zusammenfassung.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is too large for the current platform; that is, the address calculation overflowed.</source>
          <target state="translated">Die durch <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> angegebene Adresse ist für die aktuelle Plattform zu groß, d.h., bei der Berechnung der Adresse ist ein Überlauf aufgetreten.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The length of the new string to initialize is too large to allocate.</source>
          <target state="translated">Die Länge der zu initialisierenden neuen Zeichenfolge ist zu groß und kann daher nicht zugeordnet werden.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is less than 64K.</source>
          <target state="translated">Die durch <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> angegebene Adresse ist kleiner als 64K.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> could not be initialized using <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, assuming <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is encoded as specified by <ph id="ph4">&lt;paramref name="enc" /&gt;</ph>.</source>
          <target state="translated">Eine neue Instanz von <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> konnte nicht mit <ph id="ph2">&lt;paramref name="value" /&gt;</ph> initialisiert werden, wenn angenommen wird, dass <ph id="ph3">&lt;paramref name="value" /&gt;</ph> entsprechend <ph id="ph4">&lt;paramref name="enc" /&gt;</ph> codiert ist.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="length" /&gt;</ph> collectively specify an invalid address.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> und <ph id="ph3">&lt;paramref name="length" /&gt;</ph> geben zusammen eine ungültige Adresse an.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="P:System.String.Chars(System.Int32)">
          <source>A position in the current string.</source>
          <target state="translated">Eine Position in der aktuellen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="P:System.String.Chars(System.Int32)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Char" /&gt;</ph> object at a specified position in the current <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Ruft das <ph id="ph1">&lt;see cref="T:System.Char" /&gt;</ph>-Objekt an einer angegebenen Zeichenposition innerhalb des aktuellen <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>-Objekts ab.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>The object at position <ph id="ph1">&lt;paramref name="index" /&gt;</ph>.</source>
          <target state="translated">Das Objekt an der <ph id="ph1">&lt;paramref name="index" /&gt;</ph>-Position.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>The <ph id="ph1">`index`</ph> parameter is zero-based.</source>
          <target state="translated">Die <ph id="ph1">`index`</ph> Parameter ist nullbasiert.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>This property returns the <ph id="ph1">&lt;xref:System.Char&gt;</ph> object at the position specified by the <ph id="ph2">`index`</ph> parameter.</source>
          <target state="translated">Diese Eigenschaft gibt die <ph id="ph1">&lt;xref:System.Char&gt;</ph> Objekt an der Position, die gemäß der <ph id="ph2">`index`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>However, a Unicode character might be represented by more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</source>
          <target state="translated">Allerdings kann ein Unicode-Zeichen dargestellt werden, von mehreren <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> class to work with Unicode characters instead of <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> -Klasse zum Arbeiten mit Unicode-Zeichen anstelle von <ph id="ph2">&lt;xref:System.Char&gt;</ph> Objekte.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>For more information, see the "Char Objects and Unicode Characters" section in the <ph id="ph1">&lt;xref:System.String&gt;</ph> class overview.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt "Char-Objekte und Unicode-Zeichen" in der <ph id="ph1">&lt;xref:System.String&gt;</ph> -Klassenübersicht.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>In C#, the <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property is an indexer.</source>
          <target state="translated">In c# ist die <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> Eigenschaft ist für einen Indexer.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>In Visual Basic, it is the default property of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated">In Visual Basic ist es die Standardeigenschaft eines der <ph id="ph1">&lt;xref:System.String&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>Each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object in the string can be accessed by using code such as the following.</source>
          <target state="translated">Jede <ph id="ph1">&lt;xref:System.Char&gt;</ph> Objekt in der Zeichenfolge kann zugegriffen werden, indem Sie Code wie den folgenden.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>The following example demonstrates how you can use this indexer in a routine to validate a string.</source>
          <target state="translated">Im folgende Beispiel wird veranschaulicht, wie Sie mit diesem Indexer in einer Routine verwenden können, um eine Zeichenfolge zu überprüfen.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="P:System.String.Chars(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than or equal to the length of this object or less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist größer oder gleich der Länge dieses Objekts oder kleiner als 0 (null).</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.String.Clone">
          <source>Returns a reference to this instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Gibt einen Verweis auf diese Instanz von <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.String.Clone">
          <source>This instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Diese Instanz von <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Clone">
          <source>The return value is not an independent copy of this instance; it is simply another view of the same data.</source>
          <target state="translated">Der Rückgabewert ist eine unabhängige Kopie dieser Instanz; Es ist einfach eine andere Ansicht der gleichen Daten.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Clone">
          <source>Use the <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.CopyTo%2A&gt;</ph> method to create a separate <ph id="ph3">&lt;xref:System.String&gt;</ph> object with the same value as this instance.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.CopyTo%2A&gt;</ph> Methode zum Erstellen eines separaten <ph id="ph3">&lt;xref:System.String&gt;</ph> Objekt mit demselben Wert wie diese Instanz.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Clone">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> method simply returns the existing string instance, there is little reason to call it directly.</source>
          <target state="translated">Da die <ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> -Methode einfach die vorhandene Zeichenfolgeninstanz zurückgibt, ist es ratsam, um sie direkt aufrufen.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Vergleicht zwei angegebene <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads of the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method return a 32-bit signed integer indicating the lexical relationship between the two comparands.</source>
          <target state="translated">Alle Überladungen der Methode <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> geben eine 32-Bit-Ganzzahl mit Vorzeichen zurück, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Value</source>
          <target state="translated">Wert</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Condition</source>
          <target state="translated">Bedingung</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Less than zero</source>
          <target state="translated">Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The first substring precedes the second substring in the sort order.</source>
          <target state="translated">Die erste Teilzeichenfolge steht die zweite Teilzeichenfolge in der Sortierreihenfolge vor.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Zero</source>
          <target state="translated">Zero</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The substrings occur in the same position in the sort order, or <ph id="ph1">`length`</ph> is zero.</source>
          <target state="translated">Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <ph id="ph1">`length`</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Greater than zero</source>
          <target state="translated">Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The first substring follows the second substring in the sort order.</source>
          <target state="translated">Die erste Teilzeichenfolge folgt die zweite Teilzeichenfolge in der Sortierreihenfolge an.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Whenever possible, you should call an overload of the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method that includes a <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
          <target state="translated">Wann immer möglich, sollten Sie eine Überladung der Aufrufen der <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> Methode, enthält eine <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>The first string to compare.</source>
          <target state="translated">Die erste zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>The second string to compare.</source>
          <target state="translated">Die zweite zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Vergleicht zwei angegebene <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> steht in der Sortierreihenfolge vor <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> tritt in der Sortierreihenfolge an der gleichen Position wie <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> auf.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> steht in der Sortierreihenfolge hinter <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Der Vergleich wird mit der aktuellen Kultur kulturspezifische Informationen, z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge der einzelnen Zeichen abgerufen.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Angenommen, eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder die Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen vor oder Führen Sie es aus.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Der Vergleich erfolgt mithilfe von Word-Sortierregeln.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">Beim Vergleichen von Zeichenfolgen, Sie sollten Aufrufen der <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> -Methode, die erfordert, dass Sie den Typ des Zeichenfolgenvergleichs explizit angeben, die die Methode verwendet.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Kann einem oder beiden verglichenen Elemente <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Zu diesem Zweck der richtige Code lautet wie folgt:</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method to compare three sets of strings.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> Methode, um drei Gruppen von Zeichenfolgen zu vergleichen.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>In the following example, the <ph id="ph1">`ReverseStringComparer`</ph> class demonstrates how you can evaluate two strings with the <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">`ReverseStringComparer`</ph> Klasse das Auswerten von zwei Zeichenfolgen mit veranschaulicht die <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String)" /&gt;</ph> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a culture-sensitive comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">Wenn auf der folgende Code ausführen, beispielsweise die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder später, wenn ein kulturabhängiger Vergleich von "Animal" mit "Ani-falsch" (mit einer bedingten Bindestrich oder U + 00AD), dass die beiden Zeichenfolgen äquivalent sind.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> method and supply a value of either <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">`comparisonType`</ph> parameter.</source>
          <target state="translated">Um Ignorierbare Zeichen in einen Zeichenfolgenvergleich kennen, rufen Sie die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> -Methode, und übergeben Sie entweder den Wert <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> für die <ph id="ph4">`comparisonType`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The first string to compare.</source>
          <target state="translated">Die erste zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The second string to compare.</source>
          <target state="translated">Die zweite zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Vergleicht zwei angegebene <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekte, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> steht in der Sortierreihenfolge vor <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> tritt in der Sortierreihenfolge an der gleichen Position wie <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> auf.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> steht in der Sortierreihenfolge hinter <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Der Vergleich wird mit der aktuellen Kultur kulturspezifische Informationen, z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge der einzelnen Zeichen abgerufen.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Angenommen, eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder die Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen vor oder Führen Sie es aus.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Der Vergleich erfolgt mithilfe von Word-Sortierregeln.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">Beim Vergleichen von Zeichenfolgen, Sie sollten Aufrufen der <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> -Methode, die erfordert, dass Sie den Typ des Zeichenfolgenvergleichs explizit angeben, die die Methode verwendet.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Kann einem oder beiden verglichenen Elemente <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Zu diesem Zweck der richtige Code lautet wie folgt:</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The following example demonstrates that the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29&gt;</ph> method is equivalent to using <ph id="ph2">&lt;xref:System.String.ToUpper%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.String.ToLower%2A&gt;</ph> when comparing strings.</source>
          <target state="translated">Das folgende Beispiel zeigt, dass die <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29&gt;</ph> Methode entspricht der Verwendung <ph id="ph2">&lt;xref:System.String.ToUpper%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.String.ToLower%2A&gt;</ph> beim Vergleichen von Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /&gt;</ph> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a culture-sensitive, case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">Wenn auf der folgende Code ausführen, beispielsweise die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher und ein Vergleich kulturabhängig, Groß-/Kleinschreibung "Animal" mit "Ani-falsch" (mit einer bedingten Bindestrich oder U + 00AD) gibt an, dass die beiden Zeichenfolgen äquivalent sind.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> method and supply a value of either <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Um Ignorierbare Zeichen in einen Zeichenfolgenvergleich kennen, rufen Sie die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> -Methode, und übergeben Sie entweder den Wert <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> für die <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The first string to compare.</source>
          <target state="translated">Die erste zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The second string to compare.</source>
          <target state="translated">Die zweite zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules to use in the comparison.</source>
          <target state="translated">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Vergleicht zwei angegebene <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekte gemäß den angegebenen Vergleichsregeln und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> steht in der Sortierreihenfolge vor <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> befindet sich in der Sortierreihenfolge an der gleichen Position wie <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> steht in der Sortierreihenfolge hinter <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</source>
          <target state="translated">Die <ph id="ph1">`comparisonType`</ph> Parameter gibt an, ob der Vergleich die aktuelle oder der invariante Kultur verwenden soll, berücksichtigen oder ignorieren die Groß-/Kleinschreibung der verglichenen Elemente angibt, oder mit Wörtern (kulturabhängig) oder (kulturunabhängige) Ordinalsortierung.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Kann einem oder beiden verglichenen Elemente <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</source>
          <target state="translated">Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, die Zeichenfolge mit den verbleibenden Zeichen größer angesehen.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Zu diesem Zweck der richtige Code lautet wie folgt:</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The following example compares three versions of the letter "I".</source>
          <target state="translated">Im folgenden Beispiel werden drei Versionen des Buchstabens "I".</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</source>
          <target state="translated">Die Ergebnisse sind betroffen, durch die Auswahl der Kultur, gibt an, ob die Groß-/Kleinschreibung ignoriert wird und ob ein ordinalen Vergleich ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> ist kein <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see cref="T:System.StringComparison" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.StringComparison" /&gt;</ph> wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Um Ignorierbare Zeichen, die den Vergleich zu kennen, geben Sie den Wert <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> oder <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> für die <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The first string to compare.</source>
          <target state="translated">Die erste zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The second string to compare.</source>
          <target state="translated">Die zweite zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific comparison information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Vergleicht zwei angegebene <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekte, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt und der Vergleich durch kulturspezifische Informationen beeinflusst wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> steht in der Sortierreihenfolge vor <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> tritt in der Sortierreihenfolge an der gleichen Position wie <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> auf.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> steht in der Sortierreihenfolge hinter <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Der Vergleich verwendet die <ph id="ph1">`culture`</ph> Parameter zum Abrufen von kulturspezifischen Informationen wie z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge der einzelnen Zeichen.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Angenommen, eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder die Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen vor oder Führen Sie es aus.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Der Vergleich erfolgt mithilfe von Word-Sortierregeln.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Kann einem oder beiden verglichenen Elemente <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Zu diesem Zweck der richtige Code lautet wie folgt:</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example demonstrates how culture can affect a comparison.</source>
          <target state="translated">Im folgende Beispiel wird veranschaulicht, wie die Kultur ein Vergleichs auswirken kann.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>In Czech - Czech Republic culture, "ch" is a single character that is greater than "d".</source>
          <target state="translated">Tschechisch - Tschechische Republik Kultur ist, ist "ch" ein einzelnes Zeichen, das größer als "d" ist.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>However, in English - United States culture, "ch" consists of two characters, and "c" is less than "d".</source>
          <target state="translated">Allerdings auf Englisch - USA-Kultur "ch" besteht aus zwei Zeichen, und "c" ist kleiner als "d".</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) using the invariant culture indicates that the two strings are equivalent.</source>
          <target state="translated">Angenommen, der folgende Code ausgeführt wird, auf die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher vornehmen, wobei Groß-und Kleinschreibung unterschieden von "Animal" mit "Ani-falsch" (mit einer bedingten Bindestrich oder U + 00AD) die invariante Kultur gibt an, dass die beiden Zeichenfolgen äquivalent sind.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method and supply a value of either <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">Um Ignorierbare Zeichen in einen Zeichenfolgenvergleich kennen, rufen Sie die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> -Methode, und übergeben Sie entweder den Wert <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> für die <ph id="ph4">&lt;paramref name="options" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The first string to compare.</source>
          <target state="translated">Die erste zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The second string to compare.</source>
          <target state="translated">Die zweite zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The culture that supplies culture-specific comparison information.</source>
          <target state="translated">Die Kultur, die kulturspezifische Vergleichsinformationen liefert.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Options to use when performing the comparison (such as ignoring case or symbols).</source>
          <target state="translated">Die beim Ausführen des Vergleichs zu verwendenden Optionen (z. B. Ignorieren von Groß- und Kleinschreibung oder Symbolen).</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</source>
          <target state="translated">Vergleicht zwei angegebene <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekte mit den festgelegten Vergleichsoptionen und kulturspezifischen Informationen, die den Vergleich beeinflussen, und gibt eine ganze Zahl zurück, die die Beziehung der beiden Zeichenfolgen zueinander in der Sortierreihenfolge angibt.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>A 32-bit signed integer that indicates the lexical relationship between <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> and <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>, as shown in the following table</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung zwischen <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> und <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> angibt, wie in der folgenden Tabelle veranschaulicht wird.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> steht in der Sortierreihenfolge vor <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> tritt in der Sortierreihenfolge an der gleichen Position wie <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> auf.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> steht in der Sortierreihenfolge hinter <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</source>
          <target state="translated">Der Vergleich verwendet die <ph id="ph1">`culture`</ph> Parameter zum Abrufen von kulturspezifischen Informationen, z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge einzelner Zeichen.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Z. B. eine bestimmte Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, dass Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden soll, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen, die vorausgehen Sie, und führen Sie es.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method is designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> Methode dient in erster Linie zur Verwendung in sortieren oder Alphabetisches Sortieren Vorgänge.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</source>
          <target state="translated">Es sollte nicht verwendet werden, wenn der primäre Zweck des Methodenaufrufs ist, um zu bestimmen, ob zwei Zeichenfolgen identisch sind (d. h., wenn der Zweck des Methodenaufrufs So testen Sie nach dem Rückgabewert 0 (null)).</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Um zu bestimmen, ob zwei Zeichenfolgen gleich sind, rufen Sie die <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison can be further specified by the <ph id="ph1">`options`</ph> parameter, which consists of one or more members of the <ph id="ph2">&lt;xref:System.Globalization.CompareOptions&gt;</ph> enumeration.</source>
          <target state="translated">Der Vergleich kann weiter angegeben werden, durch die <ph id="ph1">`options`</ph> -Parameter, der einen oder mehrere Member besteht aus den <ph id="ph2">&lt;xref:System.Globalization.CompareOptions&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> values have no effect.</source>
          <target state="translated">Jedoch, da der Zweck dieser Methode ist einen kulturabhängige Zeichenfolgenvergleich, für die Durchführung der <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> Werte haben keine Auswirkungen.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Either or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Können eine oder beide Vergleichswerten <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>By definition, any string, including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, compares greater than a null reference, and two null references compare equal to each other.</source>
          <target state="translated">Definitionsgemäß eine beliebige Zeichenfolge, einschließlich <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, Vergleich größer als ein null-Verweis, und zwei null-Verweise sind gleich sind.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</source>
          <target state="translated">Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, die Zeichenfolge mit den verbleibenden Zeichen größer angesehen.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The following example compares two strings in three different ways: using linguistic comparison for the en-US culture; using linguistic case-sensitive comparison for the en-US culture; and using an ordinal comparison.</source>
          <target state="translated">Das folgende Beispiel vergleicht zwei Zeichenfolgen auf drei verschiedene Arten: Verwenden von linguistischen Vergleich für die Kultur En-US Verwenden für die Kultur En-US linguistische Groß-/ kleinschreibungsvergleich; und verwenden einen Ordinalvergleich durch.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It illustrates how the three methods of comparison produce three different results.</source>
          <target state="translated">Es wird veranschaulicht, wie die drei Methoden des Vergleichs drei unterschiedlichen Ergebnissen führen.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> ist kein <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">Um Ignorierbare Zeichen, die den Vergleich zu kennen, geben Sie den Wert <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> oder <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> für die <ph id="ph3">&lt;paramref name="options" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Die erste im Vergleich zu verwendende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Position der Teilzeichenfolge innerhalb von <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Die zweite im Vergleich zu verwendende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Position der Teilzeichenfolge innerhalb von <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Vergleicht zwei angegebene <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>A 32-bit signed integer indicating the lexical relationship between the two comparands.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolge in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> ist der Teilzeichenfolge in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in der Sortierreihenfolge vorangestellt.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <ph id="ph3">&lt;paramref name="length" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolge in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> folgt der Teilzeichenfolge in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in der Sortierreihenfolge.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Starten Sie die zu vergleichenden Teilzeichenfolgen in <ph id="ph1">`strA`</ph> am <ph id="ph2">`indexA`</ph> und <ph id="ph3">`strB`</ph> am <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero.</source>
          <target state="translated">Beide <ph id="ph1">`indexA`</ph> und <ph id="ph2">`indexB`</ph> sind nullbasiert, d. h. das erste Zeichen in <ph id="ph3">`strA`</ph> und <ph id="ph4">`strB`</ph> an Position 0 (null) ist.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">Die Länge der ersten Teilzeichenfolge ist gleich der Länge des <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus eins.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">Die Länge der zweiten Teilzeichenfolge ist gleich der Länge des <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus eins.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Die Anzahl der zu vergleichenden Zeichen ist das kleinere der Längen der beiden Teilzeichenfolgen und <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated">Die <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, und <ph id="ph3">`length`</ph> Parameter dürfen nicht negativ sein.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Der Vergleich wird mit der aktuellen Kultur kulturspezifische Informationen, z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge der einzelnen Zeichen abgerufen.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Angenommen, eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder die Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen vor oder Führen Sie es aus.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Der Vergleich erfolgt mithilfe von Word-Sortierregeln.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">Beim Vergleichen von Zeichenfolgen, Sie sollten Aufrufen der <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> -Methode, die erfordert, dass Sie den Typ des Zeichenfolgenvergleichs explizit angeben, die die Methode verwendet.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Kann einem oder beiden verglichenen Elemente <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Zu diesem Zweck der richtige Code lautet wie folgt:</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The following example compares two substrings.</source>
          <target state="translated">Im folgende Beispiel werden zwei Teilzeichenfolgen verglichen.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="length" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated">Entweder <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>, und <ph id="ph4">&lt;paramref name="length" /&gt;</ph> ist größer als 0 (null).</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /&gt;</ph> Methode wird diese Zeichen beim Ausführen eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>To recognize ignorable characters in your comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method and supply a value of <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Um Ignorierbare Zeichen, die den Vergleich zu kennen, rufen Sie die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> Methode, und geben Sie den Wert <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> für die <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Die erste im Vergleich zu verwendende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Position der Teilzeichenfolge innerhalb von <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Die zweite im Vergleich zu verwendende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Position der Teilzeichenfolge innerhalb von <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Vergleicht Teilzeichenfolgen von zwei angegebenen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekten, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolge in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> ist der Teilzeichenfolge in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in der Sortierreihenfolge vorangestellt.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <ph id="ph3">&lt;paramref name="length" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolge in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> folgt der Teilzeichenfolge in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in der Sortierreihenfolge.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph>, and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Starten Sie die zu vergleichenden Teilzeichenfolgen in <ph id="ph1">`strA`</ph> am <ph id="ph2">`indexA`</ph>, und klicken Sie in <ph id="ph3">`strB`</ph> am <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero.</source>
          <target state="translated">Beide <ph id="ph1">`indexA`</ph> und <ph id="ph2">`indexB`</ph> sind nullbasiert, d. h. das erste Zeichen in <ph id="ph3">`strA`</ph> und <ph id="ph4">`strB`</ph> an Position 0 (null) ist.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">Die Länge der ersten Teilzeichenfolge ist gleich der Länge des <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus eins.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">Die Länge der zweiten Teilzeichenfolge ist gleich der Länge des <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus eins.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Die Anzahl der zu vergleichenden Zeichen ist das kleinere der Längen der beiden Teilzeichenfolgen und <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated">Die <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, und <ph id="ph3">`length`</ph> Parameter dürfen nicht negativ sein.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Der Vergleich wird mit der aktuellen Kultur kulturspezifische Informationen, z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge der einzelnen Zeichen abgerufen.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Angenommen, eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder die Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen vor oder Führen Sie es aus.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Der Vergleich erfolgt mithilfe von Word-Sortierregeln.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">Beim Vergleichen von Zeichenfolgen, Sie sollten Aufrufen der <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> -Methode, die erfordert, dass Sie den Typ des Zeichenfolgenvergleichs explizit angeben, die die Methode verwendet.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Kann einem oder beiden verglichenen Elemente <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The path name needs to be compared in an invariant manner.</source>
          <target state="translated">Der Pfadname muss auf eine invariante Weise verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The correct code to do this is as follows.</source>
          <target state="translated">Zu diesem Zweck der richtige Code lautet wie folgt.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The following example performs two comparisons of two substrings that only differ in case.</source>
          <target state="translated">Im folgende Beispiel werden zwei Vergleiche der beiden Teilzeichenfolgen, die unterscheiden sich nur im Fall ausgeführt.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The first comparison ignores case and the second comparison considers case.</source>
          <target state="translated">Der erste Vergleich die Groß-/Kleinschreibung ignoriert, und die zweite Vergleich berücksichtigt.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="length" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Either <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated">Entweder <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>, und <ph id="ph4">&lt;paramref name="length" /&gt;</ph> ist größer als 0 (null).</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /&gt;</ph> Methode wird diese Zeichen beim Ausführen eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>To recognize ignorable characters in your comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method and supply a value of <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Um Ignorierbare Zeichen, die den Vergleich zu kennen, rufen Sie die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> Methode, und geben Sie den Wert <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> für die <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Die erste im Vergleich zu verwendende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Position der Teilzeichenfolge innerhalb von <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Die zweite im Vergleich zu verwendende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Position der Teilzeichenfolge innerhalb von <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules to use in the comparison.</source>
          <target state="translated">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Vergleicht Teilzeichenfolgen von zwei angegebenen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekten gemäß den angegebenen Vergleichsregeln und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolge in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> ist der Teilzeichenfolge in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in der Sortierreihenfolge vorangestellt.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or the <ph id="ph3">&lt;paramref name="length" /&gt;</ph> parameter is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder der <ph id="ph3">&lt;paramref name="length" /&gt;</ph>-Parameter ist 0 (null).</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follllows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolge in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> folgt der Teilzeichenfolge in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in der Sortierreihenfolge.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Starten Sie die zu vergleichenden Teilzeichenfolgen in <ph id="ph1">`strA`</ph> am <ph id="ph2">`indexA`</ph> und <ph id="ph3">`strB`</ph> am <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero, not position one.</source>
          <target state="translated">Beide <ph id="ph1">`indexA`</ph> und <ph id="ph2">`indexB`</ph> sind nullbasiert, d. h. das erste Zeichen in <ph id="ph3">`strA`</ph> und <ph id="ph4">`strB`</ph> an position 0 (null) ist, nicht an der position einer.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">Die Länge der ersten Teilzeichenfolge ist gleich der Länge des <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus eins.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">Die Länge der zweiten Teilzeichenfolge ist gleich der Länge des <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus eins.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Die Anzahl der zu vergleichenden Zeichen ist das kleinere der Längen der beiden Teilzeichenfolgen und <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated">Die <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, und <ph id="ph3">`length`</ph> Parameter dürfen nicht negativ sein.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</source>
          <target state="translated">Die <ph id="ph1">`comparisonType`</ph> Parameter gibt an, ob der Vergleich die aktuelle oder der invariante Kultur verwenden soll, berücksichtigen oder ignorieren die Groß-/Kleinschreibung der verglichenen Elemente angibt, oder mit Wörtern (kulturabhängig) oder (kulturunabhängige) Ordinalsortierung.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Kann einem oder beiden verglichenen Elemente <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</source>
          <target state="translated">Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, die Zeichenfolge mit den verbleibenden Zeichen größer angesehen.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Zu diesem Zweck der richtige Code lautet wie folgt:</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The following example compares two substrings.</source>
          <target state="translated">Im folgende Beispiel werden zwei Teilzeichenfolgen verglichen.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="length" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Either <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated">Entweder <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>, und <ph id="ph4">&lt;paramref name="length" /&gt;</ph> ist größer als 0 (null).</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> ist kein <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> Methode wird diese Zeichen beim Ausführen eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Um Ignorierbare Zeichen, die den Vergleich zu kennen, geben Sie den Wert <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> oder <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> für die <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Die erste im Vergleich zu verwendende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Position der Teilzeichenfolge innerhalb von <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Die zweite im Vergleich zu verwendende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Position der Teilzeichenfolge innerhalb von <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific comparison information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Vergleicht Teilzeichenfolgen von zwei angegebenen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekten, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt und der Vergleich durch kulturspezifische Informationen beeinflusst wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>An integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Vergleichswerten angibt.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolge in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> ist der Teilzeichenfolge in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in der Sortierreihenfolge vorangestellt.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <ph id="ph3">&lt;paramref name="length" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolge in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> folgt der Teilzeichenfolge in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in der Sortierreihenfolge.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph>, and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Starten Sie die zu vergleichenden Teilzeichenfolgen in <ph id="ph1">`strA`</ph> am <ph id="ph2">`indexA`</ph>, und klicken Sie in <ph id="ph3">`strB`</ph> am <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero, not position one.</source>
          <target state="translated">Beide <ph id="ph1">`indexA`</ph> und <ph id="ph2">`indexB`</ph> sind nullbasiert, d. h. das erste Zeichen in <ph id="ph3">`strA`</ph> und <ph id="ph4">`strB`</ph> an position 0 (null) ist, nicht an der position einer.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">Die Länge der ersten Teilzeichenfolge ist gleich der Länge des <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus eins.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">Die Länge der zweiten Teilzeichenfolge ist gleich der Länge des <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus eins.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Die Anzahl der zu vergleichenden Zeichen ist das kleinere der Längen der beiden Teilzeichenfolgen und <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated">Die <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, und <ph id="ph3">`length`</ph> Parameter dürfen nicht negativ sein.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Der Vergleich verwendet die <ph id="ph1">`culture`</ph> Parameter zum Abrufen von kulturspezifischen Informationen wie z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge der einzelnen Zeichen.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Angenommen, eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder die Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen vor oder Führen Sie es aus.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Der Vergleich erfolgt mithilfe von Word-Sortierregeln.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Kann einem oder beiden verglichenen Elemente <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweise gleich miteinander vergleichen.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Beim Vergleichen von kulturspezifischen Groß-/Kleinschreibung-Regeln betroffen sind, können unerwartete Ergebnisse auftreten.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Ergibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse, da das Dateisystem in der Sortierung der türkischen Sprache nicht linguistische Schreibweise Regeln für den Buchstaben "i" verwendet in "File".</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Vergleichen Sie den Pfadnamen in "File", verwenden einen Ordinalvergleich durch.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Zu diesem Zweck der richtige Code lautet wie folgt:</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example compares two substrings using different cultures and ignoring the case of the substrings.</source>
          <target state="translated">Das folgende Beispiel vergleicht zwei mit verschiedenen anderen Kulturen und ignorieren die Groß-/Kleinschreibung der Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The choice of culture affects how the letter "I" is compared.</source>
          <target state="translated">Die Auswahl der Kultur auswirkt, wie der Buchstabe "I" ist im Vergleich.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="length" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Either <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated">Entweder <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>, und <ph id="ph4">&lt;paramref name="length" /&gt;</ph> ist größer als 0 (null).</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> Methode wird diese Zeichen beim Ausführen eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>To recognize ignorable characters in your comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method and supply a value of <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">Um Ignorierbare Zeichen, die den Vergleich zu kennen, rufen Sie die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> Methode, und geben Sie den Wert <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> für die <ph id="ph4">&lt;paramref name="options" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Die erste im Vergleich zu verwendende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The starting position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Anfangsposition der Teilzeichenfolge innerhalb des <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>-Parameters.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Die zweite im Vergleich zu verwendende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The starting position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Anfangsposition der Teilzeichenfolge innerhalb des <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>-Parameters.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>An object that supplies culture-specific comparison information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Options to use when performing the comparison (such as ignoring case or symbols).</source>
          <target state="translated">Die beim Ausführen des Vergleichs zu verwendenden Optionen (z. B. Ignorieren von Groß- und Kleinschreibung oder Symbolen).</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</source>
          <target state="translated">Vergleicht Teilzeichenfolgen von zwei angegebenen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekten mit den festgelegten Vergleichsoptionen und kulturspezifischen Informationen, die den Vergleich beeinflussen, und gibt eine ganze Zahl zurück, die die Beziehung der beiden Teilzeichenfolgen zueinander in der Sortierreihenfolge angibt.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>An integer that indicates the lexical relationship between the two substrings, as shown in the following table.</source>
          <target state="translated">Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Teilzeichenfolgen angibt, wie in der folgenden Tabelle veranschaulicht.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolge in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> ist der Teilzeichenfolge in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in der Sortierreihenfolge vorangestellt.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <ph id="ph3">&lt;paramref name="length" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolge in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> folgt der Teilzeichenfolge in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in der Sortierreihenfolge.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at position <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at position <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Starten Sie die zu vergleichenden Teilzeichenfolgen in <ph id="ph1">`strA`</ph> an Position <ph id="ph2">`indexA`</ph> und <ph id="ph3">`strB`</ph> an Position <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The length of the first substring is the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph>.</source>
          <target state="translated">Die Länge der ersten Teilzeichenfolge ist die Länge des <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph>.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The length of the second substring is the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph>.</source>
          <target state="translated">Die Länge der zweiten Teilzeichenfolge ist die Länge des <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Die Anzahl der zu vergleichenden Zeichen ist das kleinere der Längen der beiden Teilzeichenfolgen und <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated">Die <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, und <ph id="ph3">`length`</ph> Parameter dürfen nicht negativ sein.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</source>
          <target state="translated">Der Vergleich verwendet die <ph id="ph1">`culture`</ph> Parameter zum Abrufen von kulturspezifischen Informationen, z. B. Regeln Groß-und Kleinschreibung und die alphabetische Reihenfolge einzelner Zeichen.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Z. B. eine bestimmte Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, dass Groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden soll, oder, der die Sortierreihenfolge eines Zeichens ist abhängig von den Zeichen, die vorausgehen Sie, und führen Sie es.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method is designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> Methode dient in erster Linie zur Verwendung in sortieren oder Alphabetisches Sortieren Vorgänge.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</source>
          <target state="translated">Es sollte nicht verwendet werden, wenn der primäre Zweck des Methodenaufrufs ist, um festzustellen, ob zwei Teilzeichenfolgen identisch sind (d. h., wenn der Zweck des Methodenaufrufs So testen Sie nach dem Rückgabewert 0 (null)).</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Um zu bestimmen, ob zwei Zeichenfolgen gleich sind, rufen Sie die <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>One or both of <ph id="ph1">`strA`</ph> and <ph id="ph2">`strB`</ph> can be <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Eine oder beide der <ph id="ph1">`strA`</ph> und <ph id="ph2">`strB`</ph> kann <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>By definition, any string, including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, compares greater than a null reference, and two null references compare equal to each other.</source>
          <target state="translated">Definitionsgemäß eine beliebige Zeichenfolge, einschließlich <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, Vergleich größer als ein null-Verweis, und zwei null-Verweise sind gleich sind.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison can be further specified by the <ph id="ph1">`options`</ph> parameter, which consists of one or more members of the <ph id="ph2">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Der Vergleich kann weiter angegeben werden, durch die <ph id="ph1">`options`</ph> -Parameter, der einen oder mehrere Member besteht aus den <ph id="ph2">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> values have no effect.</source>
          <target state="translated">Jedoch, da der Zweck dieser Methode ist einen kulturabhängige Zeichenfolgenvergleich, für die Durchführung der <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> Werte haben keine Auswirkungen.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Der Vergleich beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</source>
          <target state="translated">Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über verbleibende Zeichen, die Zeichenfolge mit den verbleibenden Zeichen größer angesehen.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Der Rückgabewert ist das Ergebnis der letzten Vergleich durchgeführt.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method to compare the last names of two people.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> Methode, um den Nachnamen der beiden Personen verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It then lists them in alphabetical order.</source>
          <target state="translated">Anschließend werden diese in alphabetischer Reihenfolge aufgeführt.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> ist kein <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="length" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Either <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated">Entweder <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>, und <ph id="ph4">&lt;paramref name="length" /&gt;</ph> ist größer als 0 (null).</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> Methode wird diese Zeichen beim Ausführen eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">Um Ignorierbare Zeichen, die den Vergleich zu kennen, geben Sie den Wert <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> oder <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> für die <ph id="ph3">&lt;paramref name="options" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Compares two <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> objects in each string.</source>
          <target state="translated">Vergleicht zwei <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekte, indem die numerischen Werte der entsprechenden <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph>-Objekte in den Zeichenfolgen ausgewertet werden.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>The first string to compare.</source>
          <target state="translated">Die erste zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>The second string to compare.</source>
          <target state="translated">Die zweite zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> objects in each string.</source>
          <target state="translated">Vergleicht zwei <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekte, indem die numerischen Werte der entsprechenden <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph>-Objekte in den Zeichenfolgen ausgewertet werden.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>An integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Vergleichswerten angibt.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is less than <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> ist kleiner als <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> and <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> are equal.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> und <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> sind gleich.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is greater than <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> ist größer als <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>This method performs a case-sensitive comparison using ordinal sort rules.</source>
          <target state="translated">Diese Methode führt ein Groß-/ kleinschreibungsvergleich mithilfe von ordinalen Sortierregeln.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>To perform a case-insensitive comparison using ordinal sort rules, call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method with the <ph id="ph2">`comparisonType`</ph> argument set to <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Um mithilfe von ordinalen Sortierregeln Groß-und Kleinschreibung unterschieden auszuführen, rufen die <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> Methode mit der <ph id="ph2">`comparisonType`</ph> Argument festgelegt wird, um <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>Because <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> is a static method, <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> can be <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Da <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> ist eine statische Methode <ph id="ph2">`strA`</ph> und <ph id="ph3">`strB`</ph> kann <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>If both values are <ph id="ph1">`null`</ph>, the method returns 0 (zero), which indicates that <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> are equal.</source>
          <target state="translated">Wenn beide Werte sind <ph id="ph1">`null`</ph>, die Methode gibt 0 (null), der angibt, dass <ph id="ph2">`strA`</ph> und <ph id="ph3">`strB`</ph> gleich sind.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>If only one of the values is <ph id="ph1">`null`</ph>, the method considers the non-null value to be greater.</source>
          <target state="translated">Wenn nur einer der Werte ist <ph id="ph1">`null`</ph>, die Methode berücksichtigt, die nicht-Null-Wert größer sein.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>The following example performs and ordinal comparison of two strings that only differ in case.</source>
          <target state="translated">Im folgenden Beispiel wird und ordinalen Vergleich von zwei Zeichenfolgen unterscheiden sich nur hinsichtlich der Fall.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Die erste im Vergleich zu verwendende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The starting index of the substring in <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der Anfangsindex der Teilzeichenfolge in <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Die zweite im Vergleich zu verwendende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The starting index of the substring in <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der Anfangsindex der Teilzeichenfolge in <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> objects in each substring.</source>
          <target state="translated">Vergleicht Teilzeichenfolgen zweier angegebener <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekte, indem die numerischen Werte der entsprechenden <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph>-Objekte in den Teilzeichenfolgen ausgewertet werden.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is less than the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolge in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> ist kleiner als die Teilzeichenfolge in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings are equal, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolgen sind gleich, oder <ph id="ph3">&lt;paramref name="length" /&gt;</ph> ist 0.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is greater than the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die Teilzeichenfolge in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> ist größer als die Teilzeichenfolge in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated">Die <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, und <ph id="ph3">`length`</ph> Parameter dürfen nicht negativ sein.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The number of characters compared is the lesser of the length of <ph id="ph1">`strA`</ph> less <ph id="ph2">`indexA`</ph>, the length of <ph id="ph3">`strB`</ph> less <ph id="ph4">`indexB`</ph>, and <ph id="ph5">`length`</ph>.</source>
          <target state="translated">Die Anzahl der Zeichen im Vergleich ist kleiner als die Länge des <ph id="ph1">`strA`</ph> weniger <ph id="ph2">`indexA`</ph>, die Länge des <ph id="ph3">`strB`</ph> weniger <ph id="ph4">`indexB`</ph>, und <ph id="ph5">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>This method performs a case-sensitive comparison using ordinal sort rules.</source>
          <target state="translated">Diese Methode führt ein Groß-/ kleinschreibungsvergleich mithilfe von ordinalen Sortierregeln.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>To perform a case-insensitive comparison using ordinal sort rules, call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method with the <ph id="ph2">`comparisonType`</ph> argument set to <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Um mithilfe von ordinalen Sortierregeln Groß-und Kleinschreibung unterschieden auszuführen, rufen die <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> Methode mit der <ph id="ph2">`comparisonType`</ph> Argument festgelegt wird, um <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Because <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> is a static method, <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> can be <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Da <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> ist eine statische Methode <ph id="ph2">`strA`</ph> und <ph id="ph3">`strB`</ph> kann <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>If both values are <ph id="ph1">`null`</ph>, the method returns 0 (zero), which indicates that <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> are equal.</source>
          <target state="translated">Wenn beide Werte sind <ph id="ph1">`null`</ph>, die Methode gibt 0 (null), der angibt, dass <ph id="ph2">`strA`</ph> und <ph id="ph3">`strB`</ph> gleich sind.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>If only one of the values is <ph id="ph1">`null`</ph>, the method considers the non-null value to be greater.</source>
          <target state="translated">Wenn nur einer der Werte ist <ph id="ph1">`null`</ph>, die Methode berücksichtigt, die nicht-Null-Wert größer sein.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>This following example demonstrates that <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> use different sort orders.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, dass <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> unterschiedliche Sortierreihenfolgen verwenden.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph4">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph> und <ph id="ph3">&lt;paramref name="indexA" /&gt;</ph> ist größer als <ph id="ph4">&lt;paramref name="strA" /&gt;</ph><ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph> und <ph id="ph3">&lt;paramref name="indexB" /&gt;</ph> ist größer als <ph id="ph4">&lt;paramref name="strB" /&gt;</ph><ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="length" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Compares this instance with a specified object or <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and returns an integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified object or <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Vergleicht diese Instanz mit einem angegebenen Objekt oder <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> und gibt eine ganze Zahl zurück, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene Objekt oder <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> aufgeführt wird.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Both overloads of the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method perform culture-sensitive and case-sensitive comparison.</source>
          <target state="translated">Beide Überladungen der der <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> -Methode führen in der Vergleich kulturabhängig und Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You cannot use this method to perform culture-insensitive or ordinal comparisons.</source>
          <target state="translated">Diese Methode können keine kulturunabhängige bzw. Ordinalvergleichsregeln Vergleiche ausführen.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For code clarity, we recommend that you avoid the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method and call the <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> method instead.</source>
          <target state="translated">Aus Gründen der Übersichtlichkeit des Codes, sollten Sie vermeiden die <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> Methode, und rufen die <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> Methode stattdessen.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>An object that evaluates to a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das als <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> ausgewertet wird.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>Compares this instance with a specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Vergleicht diese Instanz mit einem angegebenen <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> aufgeführt wird.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie der <ph id="ph1">&lt;paramref name="value" /&gt;</ph>-Parameter aufgeführt wird.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance precedes <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Diese Instanz geht <ph id="ph3">&lt;paramref name="value" /&gt;</ph> voran.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance has the same position in the sort order as <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Diese Instanz hat in der Sortierreihenfolge dieselbe Position wie <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance follows <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Diese Instanz folgt <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">`value`</ph> must be a <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">`value`</ph> muss ein <ph id="ph2">&lt;xref:System.String&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method was designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> Methode ist darauf ausgelegt, in erster Linie zur Verwendung in sortieren oder Alphabetisches Sortieren Vorgänge.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</source>
          <target state="translated">Es sollte nicht verwendet werden, wenn der primäre Zweck des Methodenaufrufs ist, um zu bestimmen, ob zwei Zeichenfolgen gleich sind.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Um zu bestimmen, ob zwei Zeichenfolgen gleich sind, rufen Sie die <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">Diese Methode vergleicht Word (Groß-/Kleinschreibung beachtet und der Kultur) mit der aktuellen Kultur.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>For more information about the behavior of this method, see the Remarks section of the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Weitere Informationen über das Verhalten dieser Methode finden Sie im Abschnitt "Hinweise" der <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> Methode mit einem <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>Because it attempts to compare a <ph id="ph1">&lt;xref:System.String&gt;</ph> instance to a <ph id="ph2">`TestClass`</ph> object, the method throws an <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Weil er versucht, vergleichen Sie eine <ph id="ph1">&lt;xref:System.String&gt;</ph> -Instanz, auf eine <ph id="ph2">`TestClass`</ph> -Objekt löst die Methode eine <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist keine <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.Object)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.Object)" /&gt;</ph> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">Wenn auf der folgende Code ausführen, beispielsweise die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher und ein Vergleich des "Animal" mit "Ani-falsch" (mit einer bedingten Bindestrich oder U + 00AD) gibt an, dass die beiden Zeichenfolgen äquivalent sind.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> method.</source>
          <target state="translated">Um Ignorierbare Zeichen in einen Zeichenfolgenvergleich kennen, rufen Sie die <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>The string to compare with this instance.</source>
          <target state="translated">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>Compares this instance with a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.</source>
          <target state="translated">Vergleicht diese Instanz mit einem angegebenen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie die angegebene Zeichenfolge aufgeführt wird.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <ph id="ph1">&lt;paramref name="strB" /&gt;</ph> parameter.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie der <ph id="ph1">&lt;paramref name="strB" /&gt;</ph>-Parameter aufgeführt wird.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wert</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bedingung</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Kleiner als 0 (null)</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance precedes <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Diese Instanz geht <ph id="ph3">&lt;paramref name="strB" /&gt;</ph> voran.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance has the same position in the sort order as <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Diese Instanz hat in der Sortierreihenfolge dieselbe Position wie <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Größer als 0 (null)</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance follows <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Diese Instanz folgt <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">Diese Methode vergleicht Word (Groß-/Kleinschreibung beachtet und der Kultur) mit der aktuellen Kultur.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method was designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> Methode ist darauf ausgelegt, in erster Linie zur Verwendung in sortieren oder Alphabetisches Sortieren Vorgänge.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</source>
          <target state="translated">Es sollte nicht verwendet werden, wenn der primäre Zweck des Methodenaufrufs ist, um zu bestimmen, ob zwei Zeichenfolgen gleich sind.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Um zu bestimmen, ob zwei Zeichenfolgen gleich sind, rufen Sie die <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>For more information about the behavior of this method, see the Remarks section of the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">Weitere Informationen über das Verhalten dieser Methode finden Sie im Abschnitt "Hinweise" der <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>This method implements the <ph id="ph1">&lt;xref:System.IComparable%601?displayProperty=nameWithType&gt;</ph> interface and performs slightly better than the <ph id="ph2">&lt;xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, because it does not have to determine whether the <ph id="ph3">`strB`</ph> argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <ph id="ph4">&lt;xref:System.Object&gt;</ph> to a <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Diese Methode implementiert die <ph id="ph1">&lt;xref:System.IComparable%601?displayProperty=nameWithType&gt;</ph> Schnittstelle und führt etwas bessere Leistung als die <ph id="ph2">&lt;xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType&gt;</ph> -Methode, da sie keinen zu bestimmen, ob die <ph id="ph3">`strB`</ph> Argument ist eine änderbare Werttyp, der mittels Boxing konvertiert werden muss, und es muss keine umgewandelt seine Parameter aus einem <ph id="ph4">&lt;xref:System.Object&gt;</ph> auf eine <ph id="ph5">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method to compare the current string instance with another string.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> Methode, um die aktuellen Zeichenfolgeninstanz mit einer anderen Zeichenfolge vergleichen.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The following example demonstrates generic and non-generic versions of the CompareTo method for several value and reference types.</source>
          <target state="translated">Im folgende Beispiel werden die generische und nicht generischen Versionen der CompareTo-Methode für verschiedene Wert- und Referenztypen veranschaulicht.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.String)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.String)" /&gt;</ph> Methode berücksichtigt nicht solche Zeichen aus, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">Wenn auf der folgende Code ausführen, beispielsweise die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher und ein Vergleich des "Animal" mit "Ani-falsch" (mit einer bedingten Bindestrich oder U + 00AD) gibt an, dass die beiden Zeichenfolgen äquivalent sind.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> method.</source>
          <target state="translated">Um Ignorierbare Zeichen in einen Zeichenfolgenvergleich kennen, rufen Sie die <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Concatenates one or more instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, or the <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> representations of the values of one or more instances of <ph id="ph3">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Verkettet eine oder mehrere Instanzen von <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> oder die <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>-Darstellungen der Werte einer oder mehrerer Instanzen von <ph id="ph3">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>A collection object that implements <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> and whose generic type argument is <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Ein Auflistungsobjekt, das <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> implementiert und dessen generisches Typargument <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>Concatenates the members of a constructed <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> collection of type <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Verkettet die Member einer erstellten <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>-Auflistung vom Typ <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The concatenated strings in <ph id="ph1">&lt;paramref name="values" /&gt;</ph>, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph3">&lt;paramref name="values" /&gt;</ph> is an empty <ph id="ph4">&lt;see langword="IEnumerable(Of String)" /&gt;</ph>.</source>
          <target state="translated">Die verketteten Zeichenfolgen in <ph id="ph1">&lt;paramref name="values" /&gt;</ph> oder <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, wenn <ph id="ph3">&lt;paramref name="values" /&gt;</ph> ein leeres <ph id="ph4">&lt;see langword="IEnumerable(Of String)" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
          <target state="translated">Die Methode verkettet jedes Objekt in <ph id="ph1">`values`</ph>; Trennzeichen nicht hinzugefügt.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>To specify a delimiter between each member of <ph id="ph1">`values`</ph>, call the <ph id="ph2">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method.</source>
          <target state="translated">Als Trennzeichen zwischen den einzelnen Membern der angeben <ph id="ph1">`values`</ph>, rufen Sie die <ph id="ph2">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null element in <ph id="ph2">`values`</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> Zeichenfolge anstelle der null-Element im verwendet <ph id="ph2">`values`</ph>.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">`values`</ph> is an empty <ph id="ph2">`IEnumerable(Of String)`</ph>, the method returns <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`values`</ph> ist eine leere <ph id="ph2">`IEnumerable(Of String)`</ph>, gibt die Methode <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph> exception.</source>
          <target state="translated">Wenn <ph id="ph1">`values`</ph> ist <ph id="ph2">`null`</ph>, löst die Methode eine <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph> Ausnahme.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">`IEnumerable(Of String)`</ph> collection without first converting the elements to a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> ist eine bequeme Methode, mit der jedes Element in verketten kann eine <ph id="ph2">`IEnumerable(Of String)`</ph> Auflistung ohne zunächst die Elemente in einem Array von Zeichenfolgen konvertiert.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions.</source>
          <target state="translated">Dies ist besonders nützlich bei Abfrageausdrücken Language-Integrated Query (LINQ).</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example passes a <ph id="ph1">`List(Of String)`</ph> object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</source>
          <target state="translated">Das folgende Beispiel übergibt eine <ph id="ph1">`List(Of String)`</ph> Objekt, das die klein-oder Großbuchstaben und Buchstaben des Alphabets an einen Lambda-Ausdruck, die Buchstaben, die einem bestimmten Buchstaben enthält auswählt (d. h. im Beispiel "M") größer oder gleich sind.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The <ph id="ph1">`IEnumerable(Of String)`</ph> collection that is returned by the <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> method is passed to the <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method to display the result as a single string.</source>
          <target state="translated">Die <ph id="ph1">`IEnumerable(Of String)`</ph> -Auflistung, die von zurückgegeben wird das <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> an die Methode übergeben wird die <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> Methode, um das Ergebnis als einzelne Zeichenfolge anzuzeigen.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">Im folgenden Beispiel wird die Sieb des Eratosthenes-Algorithmus zum Berechnen von Primzahlen, die kleiner als oder gleich 100 sind.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>It assigns the result to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object of type <ph id="ph2">&lt;xref:System.String&gt;</ph>, which it then passes to the <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method.</source>
          <target state="translated">Weist das Ergebnis, das eine <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> Objekt des Typs <ph id="ph2">&lt;xref:System.String&gt;</ph>, übergibt sie dann an die <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object)">
          <source>The object to represent, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Das darzustellende Objekt oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object)">
          <source>Creates the string  representation of a specified object.</source>
          <target state="translated">Erstellt die Zeichenfolgendarstellung eines angegebenen Objekts.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object)">
          <source>The string representation of the value of <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph>, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph3">&lt;paramref name="arg0" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die Zeichenfolgendarstellung des Werts von <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph> oder <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, wenn <ph id="ph3">&lt;paramref name="arg0" /&gt;</ph> <ph id="ph4">&lt;see langword="null" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%29&gt;</ph> method represents <ph id="ph2">`arg0`</ph> as a string by calling its parameterless <ph id="ph3">`ToString`</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%29&gt;</ph> Methode stellt <ph id="ph2">`arg0`</ph> als Zeichenfolge durch Aufrufen der parameterlosen <ph id="ph3">`ToString`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>An object array that contains the elements to concatenate.</source>
          <target state="translated">Ein Objektarray, das die zu verkettenden Elemente enthält.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>Concatenates the string representations of the elements in a specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> array.</source>
          <target state="translated">Verkettet die Zeichenfolgendarstellungen der Elemente in einem angegebenen <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>-Array.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>The concatenated string representations of the values of the elements in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Die verketteten Zeichenfolgendarstellungen der Werte der Elemente in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>The method concatenates each object in <ph id="ph1">`args`</ph> by calling the parameterless <ph id="ph2">`ToString`</ph> method of that object; it does not add any delimiters.</source>
          <target state="translated">Die Methode verkettet jedes Objekt in <ph id="ph1">`args`</ph> durch Aufrufen der parameterlosen <ph id="ph2">`ToString`</ph> Methode des Objekts; alle Trennzeichen nicht hinzugefügt.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null object in the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> wird anstelle eines null-Objekts im Array verwendet.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Object&gt;</ph> array.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> Methode mit einem <ph id="ph2">&lt;xref:System.Object&gt;</ph> Array.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>Out of memory.</source>
          <target state="translated">Nicht genügend Arbeitsspeicher.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>This method is not called by C++ code.</source>
          <target state="translated">Diese Methode wird von C++-Code nicht aufgerufen.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>The C++ compiler resolves calls to <ph id="ph1">&lt;see cref="Overload:System.String.Concat" /&gt;</ph> that have four or more object parameters as a call to <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Der C++-Compiler löst Aufrufe von <ph id="ph1">&lt;see cref="Overload:System.String.Concat" /&gt;</ph> deren Objektparameter für vier oder mehr als ein Aufruf von <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>An array of string instances.</source>
          <target state="translated">Ein Array von Zeichenfolgeninstanzen.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>Concatenates the elements of a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> array.</source>
          <target state="translated">Verkettet die Elemente eines angegebenen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Arrays.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>The concatenated elements of <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</source>
          <target state="translated">Die verketteten Elemente von <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String[])">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
          <target state="translated">Die Methode verkettet jedes Objekt in <ph id="ph1">`values`</ph>; Trennzeichen nicht hinzugefügt.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String[])">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null object in the array.</source>
          <target state="translated">Eine <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> Zeichenfolge anstelle eines null-Objekts im Array verwendet wird.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String[])">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method with a <ph id="ph2">&lt;xref:System.String&gt;</ph> array.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> Methode mit einem <ph id="ph2">&lt;xref:System.String&gt;</ph> Array.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>Out of memory.</source>
          <target state="translated">Nicht genügend Arbeitsspeicher.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The first object to concatenate.</source>
          <target state="translated">Das erste zu verkettende Objekt.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The second object to concatenate.</source>
          <target state="translated">Das zweite zu verkettende Objekt.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>Concatenates the string representations of two specified objects.</source>
          <target state="translated">Verkettet die Zeichenfolgendarstellungen zweier angegebener Objekte.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The concatenated string representations of the values of <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph> and <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph>.</source>
          <target state="translated">Die verketteten Zeichenfolgendarstellungen der Werte von <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph> und <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The method concatenates <ph id="ph1">`arg0`</ph> and <ph id="ph2">`arg1`</ph> by calling the parameterless <ph id="ph3">`ToString`</ph> method of <ph id="ph4">`arg0`</ph> and <ph id="ph5">`arg1`</ph>; it does not add any delimiters.</source>
          <target state="translated">Die Methode verkettet <ph id="ph1">`arg0`</ph> und <ph id="ph2">`arg1`</ph> durch Aufrufen der parameterlosen <ph id="ph3">`ToString`</ph> Methode <ph id="ph4">`arg0`</ph> und <ph id="ph5">`arg1`</ph>; Trennzeichen nicht hinzugefügt.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> ist anstelle von null-Argument verwendet.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").</source>
          <target state="translated">Wenn entweder der Argumente Verweis auf ein Array ist, verkettet die Methode eine Zeichenfolgendarstellung dieses Arrays, anstelle von Membern (z. B. "System.String[]").</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>The first string to concatenate.</source>
          <target state="translated">Die erste zu verkettende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>The second string to concatenate.</source>
          <target state="translated">Die zweite zu verkettende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>Concatenates two specified instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Verkettet zwei angegebene Instanzen von <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>The concatenation of <ph id="ph1">&lt;paramref name="str0" /&gt;</ph> and <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>.</source>
          <target state="translated">Die Verkettung von <ph id="ph1">&lt;paramref name="str0" /&gt;</ph> und <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>The method concatenates <ph id="ph1">`str0`</ph> and <ph id="ph2">`str1`</ph>; it does not add any delimiters.</source>
          <target state="translated">Die Methode verkettet <ph id="ph1">`str0`</ph> und <ph id="ph2">`str1`</ph>; Trennzeichen nicht hinzugefügt.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
          <target state="translated">Sie können auch Ihre Sprache Operator für zeichenfolgenverkettungen, verwenden, z. B. <ph id="ph1">`+`</ph> in c# oder <ph id="ph2">`&amp;`</ph> und <ph id="ph3">`+`</ph> in Visual Basic)</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>, to concatenate strings.</source>
          <target state="translated">, um Zeichenfolgen zu verketten.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
          <target state="translated">Eine <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> Zeichenfolge anstelle von null-Argument verwendet wird.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>The following example concatenates a person's first, middle, and last name.</source>
          <target state="translated">Im folgende Beispiel werden die ersten, mittleren und den Nachnamen einer Person-Name verkettet.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The first object to concatenate.</source>
          <target state="translated">Das erste zu verkettende Objekt.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The second object to concatenate.</source>
          <target state="translated">Das zweite zu verkettende Objekt.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The third object to concatenate.</source>
          <target state="translated">Das dritte zu verkettende Objekt.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>Concatenates the string representations of three specified objects.</source>
          <target state="translated">Verkettet die Zeichenfolgendarstellungen von drei angegebenen Objekten.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The concatenated string representations of the values of <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="arg2" /&gt;</ph>.</source>
          <target state="translated">Die verketteten Zeichenfolgendarstellungen der Werte von <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph> und <ph id="ph3">&lt;paramref name="arg2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The method concatenates <ph id="ph1">`arg0`</ph>, <ph id="ph2">`arg1`</ph>, and <ph id="ph3">`arg2`</ph> by calling the parameterless <ph id="ph4">`ToString`</ph> method of each object; it does not add any delimiters.</source>
          <target state="translated">Die Methode verkettet <ph id="ph1">`arg0`</ph>, <ph id="ph2">`arg1`</ph>, und <ph id="ph3">`arg2`</ph> durch Aufrufen der parameterlosen <ph id="ph4">`ToString`</ph> -Methode aller Objekte; Trennzeichen nicht hinzugefügt.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> ist anstelle von null-Argument verwendet.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The first string to concatenate.</source>
          <target state="translated">Die erste zu verkettende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The second string to concatenate.</source>
          <target state="translated">Die zweite zu verkettende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The third string to concatenate.</source>
          <target state="translated">Die dritte zu verkettende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>Concatenates three specified instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Verkettet zwei angegebene Instanzen von <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The concatenation of <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="str2" /&gt;</ph>.</source>
          <target state="translated">Die Verkettung von <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph> und <ph id="ph3">&lt;paramref name="str2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The method concatenates <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, and <ph id="ph3">`str2`</ph>; it does not add any delimiters.</source>
          <target state="translated">Die Methode verkettet <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, und <ph id="ph3">`str2`</ph>; Trennzeichen nicht hinzugefügt.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
          <target state="translated">Sie können auch Ihre Sprache Operator für zeichenfolgenverkettungen, verwenden, z. B. <ph id="ph1">`+`</ph> in c# oder <ph id="ph2">`&amp;`</ph> und <ph id="ph3">`+`</ph> in Visual Basic)</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>, to concatenate strings.</source>
          <target state="translated">, um Zeichenfolgen zu verketten.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
          <target state="translated">Eine <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> Zeichenfolge anstelle von null-Argument verwendet wird.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method to concatenate three strings and displays the result.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> Methode zum Verketten von drei Zeigern auf Zeichenfolgen, und das Ergebnis wird angezeigt.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The first object to concatenate.</source>
          <target state="translated">Das erste zu verkettende Objekt.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The second object to concatenate.</source>
          <target state="translated">Das zweite zu verkettende Objekt.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The third object to concatenate.</source>
          <target state="translated">Das dritte zu verkettende Objekt.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The fourth object to concatenate.</source>
          <target state="translated">Das vierte zu verkettende Objekt.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</source>
          <target state="translated">Verkettet die Zeichenfolgenentsprechungen von vier angegebenen Objekten sowie aller in einer optionalen Parameterliste variabler Länger angegebenen Objekte.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The concatenated string representation of each value in the parameter list.</source>
          <target state="translated">Die verkettete Zeichenfolgendarstellung aller Werte in der Parameterliste.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Diese API ist nicht CLS-kompatibel.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The CLS-compliant alternative is <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Die CLS-kompatible Alternative ist <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The C# and Visual Basic compilers automatically resolve a call to this method as a call to <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Die C#- und Visual Basic-Compiler automatisch auflösen, einen Aufruf dieser Methode als Aufruf <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The method concatenates each object in the parameter list by calling its parameterless <ph id="ph1">`ToString`</ph> method; it does not add any delimiters.</source>
          <target state="translated">Die Methode verkettet jedes Objekt in der Parameterliste durch Aufrufen der parameterlosen <ph id="ph1">`ToString`</ph> Methode Trennzeichen nicht hinzugefügt.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> ist anstelle von null-Argument verwendet.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The last parameter of the  <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method is an optional comma-delimited list of one or more additional objects to concatenate.</source>
          <target state="translated">Der letzte Parameter von der <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> Methode ist eine optionale durch Trennzeichen getrennte Liste von einem oder mehreren zusätzlichen Objekten zu verketten.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> method to concatenate a list of variable parameters.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung der <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> Methode, um eine Liste der Variablenparameter verketten.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>In this case, the method is called with nine parameters.</source>
          <target state="translated">In diesem Fall wird die Methode mit neun Parametern aufgerufen.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>This method is marked with the <ph id="ph1">&lt;see langword="vararg" /&gt;</ph> keyword, which means that it supports a variable number of parameters.</source>
          <target state="translated">Diese Methode ist mit markiert die <ph id="ph1">&lt;see langword="vararg" /&gt;</ph> Schlüsselwort, das bedeutet, dass es sich um eine Variable Anzahl an Parametern unterstützt.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The method can be called from Visual C++, but it cannot be called from C# or Visual Basic code.</source>
          <target state="translated">Die Methode kann aufgerufen werden, von Visual C++, aber es kann nicht von c# oder Visual Basic-Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The C# and Visual Basic compilers resolve calls to <ph id="ph1">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph> as calls to <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object[])" /&gt;</ph>.</source>
          <target state="translated">Die C#- und Visual Basic-Compiler lösen Aufrufe an <ph id="ph1">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph> als Aufrufe von <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The first string to concatenate.</source>
          <target state="translated">Die erste zu verkettende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The second string to concatenate.</source>
          <target state="translated">Die zweite zu verkettende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The third string to concatenate.</source>
          <target state="translated">Die dritte zu verkettende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The fourth string to concatenate.</source>
          <target state="translated">Die vierte zu verkettende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>Concatenates four specified instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Verkettet zwei angegebene Instanzen von <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The concatenation of <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>, <ph id="ph3">&lt;paramref name="str2" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="str3" /&gt;</ph>.</source>
          <target state="translated">Die Verkettung von <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>, <ph id="ph3">&lt;paramref name="str2" /&gt;</ph> und <ph id="ph4">&lt;paramref name="str3" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The method concatenates <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, <ph id="ph3">`str2`</ph>, and <ph id="ph4">`str3`</ph>; it does not add any delimiters.</source>
          <target state="translated">Die Methode verkettet <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, <ph id="ph3">`str2`</ph>, und <ph id="ph4">`str3`</ph>; Trennzeichen nicht hinzugefügt.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
          <target state="translated">Sie können auch Ihre Sprache Operator für zeichenfolgenverkettungen, verwenden, z. B. <ph id="ph1">`+`</ph> in c# oder <ph id="ph2">`&amp;`</ph> und <ph id="ph3">`+`</ph> in Visual Basic)</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>, to concatenate strings.</source>
          <target state="translated">, um Zeichenfolgen zu verketten.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null object in the array.</source>
          <target state="translated">Eine <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> Zeichenfolge anstelle eines null-Objekts im Array verwendet wird.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The following example defines an array of four-letter words and stores their individual letters to a string array in order to scramble them.</source>
          <target state="translated">Im folgenden Beispiel definiert ein Array von Wörter und ihre einzelnen Buchstaben in einem Array von Zeichenfolgen speichert, um sie zu verschlüsseln.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29&gt;</ph> method to reassemble the scrambled words.</source>
          <target state="translated">Er ruft dann die <ph id="ph1">&lt;xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29&gt;</ph> Methode, um die verschlüsselte Wörter zu segmentieren.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The type of the members of <bpt id="p1">&lt;c&gt;</bpt>values<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der Typ der Elemente der <bpt id="p1">&lt;c&gt;</bpt>Werte<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>A collection object that implements the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> interface.</source>
          <target state="translated">Ein Auflistungsobjekt, das die <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>-Schnittstelle implementiert.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>Concatenates the members of an <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> implementation.</source>
          <target state="translated">Verkettet die Member einer <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>-Implementierung.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The concatenated members in <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</source>
          <target state="translated">Die verketteten Zeichenfolgen in <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
          <target state="translated">Die Methode verkettet jedes Objekt in <ph id="ph1">`values`</ph>; Trennzeichen nicht hinzugefügt.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
          <target state="translated">Eine <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> Zeichenfolge anstelle von null-Argument verwendet wird.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection without first converting the elements to strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> ist eine bequeme Methode, mit der jedes Element in verketten kann eine <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> Auflistung ohne die Elemente zunächst in Zeichenfolgen konvertiert.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions, as the example illustrates.</source>
          <target state="translated">Es ist besonders nützlich bei Abfrageausdrücken Language-Integrated Query (LINQ), wie im Beispiel veranschaulicht.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The string representation of each object in the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection is derived by calling that object's <ph id="ph2">`ToString`</ph> method.</source>
          <target state="translated">Die Zeichenfolgendarstellung für jedes Objekt in der <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> Auflistung wird durch Aufrufen des Objekts abgeleitet <ph id="ph2">`ToString`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The following example defines a very simple <ph id="ph1">`Animal`</ph> class that contains the name of an animal and the order to which it belongs.</source>
          <target state="translated">Das folgende Beispiel definiert eine sehr einfache <ph id="ph1">`Animal`</ph> Klasse enthält den Namen des Animal und die Reihenfolge, zu dem er gehört.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>It then defines a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object to contain a number of <ph id="ph2">`Animal`</ph> objects.</source>
          <target state="translated">Zudem definiert der Code eine <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> Objekt enthält eine Anzahl von <ph id="ph2">`Animal`</ph> Objekte.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> extension method is called to extract the <ph id="ph2">`Animal`</ph> objects whose <ph id="ph3">`Order`</ph> property equals "Rodent".</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> Erweiterungsmethode aufgerufen, um das Extrahieren der <ph id="ph2">`Animal`</ph> -Objekte, deren <ph id="ph3">`Order`</ph> Eigenschaft "Rodent" entspricht.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The result is passed to the <ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> method and displayed to the console.</source>
          <target state="translated">Das Ergebnis wird zum Übergeben der <ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> Methode und in der Konsole angezeigt.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source>The string to seek.</source>
          <target state="translated">Die zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source>Returns a value indicating whether a specified substring occurs within this string.</source>
          <target state="translated">Gibt einen Wert zurück, der angibt, ob eine angegebene untergeordnete Zeichenfolge in dieser Zeichenfolge vorkommt.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter occurs within this string, or if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is the empty string (""); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;paramref name="value" /&gt;</ph>-Parameter in dieser Zeichenfolge vorkommt oder <ph id="ph3">&lt;paramref name="value" /&gt;</ph> eine leere Zeichenfolge ("") ist; andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung beachtet und kulturunabhängige).</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The search begins at the first character position of this string and continues through the last character position.</source>
          <target state="translated">Die Suche beginnt an der ersten Zeichenposition der Zeichenfolge und wird fortgesetzt, bis der letzten Zeichenposition.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method.</source>
          <target state="translated">Um zu bestimmen, ob eine Zeichenfolge, enthält eine angegebene untergeordnete Zeichenfolge mit einem anderen Knotentyp als Ordinalvergleich (z. B. ein kulturabhängiger Vergleich oder Ordinalvergleich Groß-/Kleinschreibung), können Sie eine benutzerdefinierte Methode erstellen.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The following example illustrates one such approach.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht einen solchen Ansatz.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>It defines a <ph id="ph1">&lt;xref:System.String&gt;</ph> extension method  that includes a <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter and indicates whether a string contains a substring when using the specified form of string comparison.</source>
          <target state="translated">Definiert eine <ph id="ph1">&lt;xref:System.String&gt;</ph> Extension-Methode, enthält eine <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> Parameter und gibt an, ob eine Zeichenfolge eine Teilzeichenfolge enthält, bei Verwendung der angegebenen Form des Zeichenfolgenvergleichs.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The following example then calls the <ph id="ph1">`Contains`</ph> extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.</source>
          <target state="translated">Im folgende Beispiel ruft dann die <ph id="ph1">`Contains`</ph> Erweiterungsmethode, um zu bestimmen, ob eine Teilzeichenfolge in einer Zeichenfolge gefunden wird, wenn Ordinalvergleich und Groß-/Kleinschreibung Ordinalvergleich verwenden.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>If you are interested in the position of the substring <ph id="ph1">`value`</ph> in the current instance, you can call the <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to get the starting position of its first occurrence, or you can call the <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method to get the starting position of its last occurrence.</source>
          <target state="translated">Wenn Sie die Position der Teilzeichenfolge interessiert sind <ph id="ph1">`value`</ph> in der aktuellen Instanz ist, rufen Sie die <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode zum Abrufen der Anfangsposition des ersten Vorkommens, oder Sie können Aufrufen der <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> Methode zum Abrufen der ab position seine Letztes auftreten.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The example includes a call to the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method if a substring is found in a string instance.</source>
          <target state="translated">Das Beispiel enthält einen Aufruf an die <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> Methode, wenn eine Teilzeichenfolge in einer Zeichenfolgeninstanz gefunden wird.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The following example determines whether the string "fox" is a substring of a familiar quotation.</source>
          <target state="translated">Im folgenden Beispiel wird bestimmt, ob die Zeichenfolge "Fuchs" eine Teilzeichenfolge des ein Zitat vertraut ist.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>If "fox" is found in the string, it also displays its starting position.</source>
          <target state="translated">Wenn "Fuchs" in der Zeichenfolge gefunden werden, wird auch die Anfangsposition angezeigt.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source>The string to copy.</source>
          <target state="translated">Die zu kopierende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source>Creates a new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> with the same value as a specified <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Erstellt eine neue Instanz von <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> mit demselben Wert wie eine angegebene Instanz von <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source>A new string with the same value as <ph id="ph1">&lt;paramref name="str" /&gt;</ph>.</source>
          <target state="translated">Eine neue Zeichenfolge mit demselben Wert wie <ph id="ph1">&lt;paramref name="str" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.String&gt;</ph> object that has the same value as the original string but represents a different object reference.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> Methode gibt ein <ph id="ph2">&lt;xref:System.String&gt;</ph> Objekt hat den gleichen Wert wie die ursprüngliche Zeichenfolge, aber einen anderen Objektverweis darstellt.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>It differs from an assignment operation, which assigns an existing string reference to an additional object variable.</source>
          <target state="translated">Es unterscheidet sich vom eines Zuweisungsvorgangs, das wodurch einen Zeichenfolgenverweis auf eine zusätzliche Objektvariable zugewiesen.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>The example illustrates the difference.</source>
          <target state="translated">Das Beispiel veranschaulicht den Unterschied.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>The following example creates two string objects with different values.</source>
          <target state="translated">Im folgende Beispiel werden zwei Zeichenfolgenobjekte mit unterschiedlichen Werten erstellt.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>When it calls the <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> method to assign the first value to the second string, the output indicates that the strings represent different object references although their values are now equal.</source>
          <target state="translated">Wenn sie ruft die <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> Methode zum Zuweisen von des ersten Werts in der zweiten Zeichenfolge gibt die Ausgabe an, dass die Zeichenfolgen unterschiedliche Objektverweise darstellen, obwohl jetzt ihre Werte gleich sind.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>On the other hand, when the first string is assigned to the second string, the two strings have identical values because they represent the same object reference.</source>
          <target state="translated">Andererseits, wenn die erste Zeichenfolge, die zweite Zeichenfolge zugewiesen wird, werden die beiden Zeichenfolgen identische Werte haben, da sie den gleichen Objektverweis darstellen.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The index of the first character in this instance to copy.</source>
          <target state="translated">Der Index des ersten Zeichens in dieser Instanz, das kopiert werden soll.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>An array of Unicode characters to which characters in this instance are copied.</source>
          <target state="translated">Ein Array von Unicode-Zeichen, in das Zeichen in dieser Instanz kopiert werden.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The index in <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept> at which the copy operation begins.</source>
          <target state="translated">Der Index in <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept>, bei dem der Kopiervorgang beginnt.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The number of characters in this instance to copy to <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Anzahl der Zeichen in dieser Instanz, die nach <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept> kopiert werden sollen.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</source>
          <target state="translated">Kopiert eine angegebene Anzahl von Zeichen von einer angegebenen Position in dieser Instanz an eine angegebene Position in einem Array von Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>This method copies <ph id="ph1">`count`</ph> characters from the <ph id="ph2">`sourceIndex`</ph> position of this instance to the <ph id="ph3">`destinationIndex`</ph> position of <ph id="ph4">`destination`</ph> character array.</source>
          <target state="translated">Diese Methode kopiert <ph id="ph1">`count`</ph> Zeichen aus der <ph id="ph2">`sourceIndex`</ph> Position dieser Instanz in die <ph id="ph3">`destinationIndex`</ph> position <ph id="ph4">`destination`</ph> Zeichenarray.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>This method does not resize the <ph id="ph1">`destination`</ph> character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <ph id="ph2">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Diese Methode ändert nicht die Größe der <ph id="ph1">`destination`</ph> Zeichenarray; muss eine ausreichende Anzahl von Elementen für die kopierten Zeichen oder die Methode löst eine <ph id="ph2">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">`sourceIndex`</ph> and <ph id="ph2">`destinationIndex`</ph> are zero-based.</source>
          <target state="translated"><ph id="ph1">`sourceIndex`</ph> und <ph id="ph2">`destinationIndex`</ph> sind nullbasiert.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destination" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destination" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="count" /&gt;</ph> is negative</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="count" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> does not identify a position in the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> identifiziert keine Position in der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> does not identify a valid index in the <ph id="ph2">&lt;paramref name="destination" /&gt;</ph> array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> identifiziert keinen gültigen Index im <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>-Array.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of the substring from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of this instance</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist größer als die Länge der Teilzeichenfolge von <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> bis zum Ende dieser Instanz</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of the subarray from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of the <ph id="ph3">&lt;paramref name="destination" /&gt;</ph> array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist größer als die Länge des Teilarrays von <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> bis zum Ende des <ph id="ph3">&lt;paramref name="destination" /&gt;</ph>-Arrays.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="F:System.String.Empty">
          <source>Represents the empty string.</source>
          <target state="translated">Stellt die leere Zeichenfolge dar.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" uid="F:System.String.Empty">
          <source>This field is read-only.</source>
          <target state="translated">Dieses Feld ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.String.Empty">
          <source>The value of this field is the zero-length string, "".</source>
          <target state="translated">Der Wert dieses Felds ist die Zeichenfolge der Länge 0 (null), "".</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.String.Empty">
          <source>In application code, this field is most commonly used in assignments to initialize a string variable to an empty string.</source>
          <target state="translated">Im Anwendungscode ist dieses Feld am häufigsten in Zuweisungen verwendet, um eine String-Variable auf eine leere Zeichenfolge zu initialisieren.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.String.Empty">
          <source>To test whether the value of a string is either <ph id="ph1">`null`</ph> or <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, use the <ph id="ph3">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method.</source>
          <target state="translated">So testen Sie, ob der Wert einer Zeichenfolge entweder <ph id="ph1">`null`</ph> oder <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, verwenden Sie die <ph id="ph3">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Determines whether the end of this string instance matches a specified string.</source>
          <target state="translated">Bestimmt, ob das Ende dieser Zeichenfolgeninstanz mit einer angegebenen Zeichenfolge übereinstimmt.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source>The string to compare to the substring at the end of this instance.</source>
          <target state="translated">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source>Determines whether the end of this string instance matches the specified string.</source>
          <target state="translated">Bestimmt, ob das Ende dieser Zeichenfolgeninstanz mit der angegebenen Zeichenfolge übereinstimmt.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> matches the end of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="value" /&gt;</ph> mit dem Ende dieser Instanz übereinstimmt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>This method compares <ph id="ph1">`value`</ph> to the substring at the end of this instance that is the same length as <ph id="ph2">`value`</ph>, and returns an indication whether they are equal.</source>
          <target state="translated">Diese Methode vergleicht <ph id="ph1">`value`</ph> mit der Teilzeichenfolge am Ende dieser Instanz, die gleiche Länge wie <ph id="ph2">`value`</ph>, und gibt einen Wert zurück, ob sie gleich sind.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same instance or match the end of this instance.</source>
          <target state="translated">Gleich, <ph id="ph1">`value`</ph> muss ein Verweis auf die gleiche Instanz oder Übereinstimmung mit dem Ende dieser Instanz.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">Diese Methode vergleicht Word (Groß-/Kleinschreibung beachtet und der Kultur) mit der aktuellen Kultur.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>The following example indicates whether each string in an array ends with a period (".").</source>
          <target state="translated">Das folgende Beispiel gibt an, ob jede Zeichenfolge in ein Array mit einem Punkt endet (".").</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>The following example defines a <ph id="ph1">`StripEndTags`</ph> method that uses the <ph id="ph2">&lt;xref:System.String.EndsWith%28System.String%29&gt;</ph> method to remove HTML end tags from the end of a line.</source>
          <target state="translated">Das folgende Beispiel definiert eine <ph id="ph1">`StripEndTags`</ph> Methode, verwendet die <ph id="ph2">&lt;xref:System.String.EndsWith%28System.String%29&gt;</ph> Methode, um HTML-Endtags vom Ende einer Zeile zu entfernen.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>Note that the  <ph id="ph1">`StripEndTags`</ph> method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.</source>
          <target state="translated">Beachten Sie, dass die <ph id="ph1">`StripEndTags`</ph> Methode rekursiv aufgerufen, um sicherzustellen, dass mehrere HTML-Endtags am Ende der Zeile entfernt werden.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Wie in beschrieben <bpt id="p1">[</bpt>bewährte Methoden für die Verwendung von Zeichenfolgen<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>To determine whether a string ends with a particular substring by using the string comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Aufrufen, um zu bestimmen, ob eine Zeichenfolge mit einer bestimmten Teilzeichenfolge endet, mithilfe der Regeln für Zeichenfolgenvergleiche der aktuellen Kultur, die <ph id="ph1">&lt;see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /&gt;</ph> methodenüberladung mit einem Wert von <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> für seine <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The string to compare to the substring at the end of this instance.</source>
          <target state="translated">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>One of the enumeration values that determines how this string and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">Einer der Enumerationswerte, die bestimmen, wie diese Zeichenfolge und <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> verglichen werden.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</source>
          <target state="translated">Bestimmt, ob das Ende dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Vergleichsoption mit der angegebenen Zeichenfolge übereinstimmt.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter matches the end of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;paramref name="value" /&gt;</ph>-Parameter mit dem Ende dieser Zeichenfolge übereinstimmt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method compares the <ph id="ph2">`value`</ph> parameter to the substring at the end of this string and returns a value that indicates whether they are equal.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> -Methode vergleicht die <ph id="ph2">`value`</ph> Parameter mit der Teilzeichenfolge am Ende dieser Zeichenfolge und gibt einen Wert, der angibt, ob sie gleich sind.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same string, must be the empty string (""), or must match the end of this string.</source>
          <target state="translated">Als gleich ansehen <ph id="ph1">`value`</ph> ein Verweis auf die gleiche Zeichenfolge ist, eine leere Zeichenfolge (""), oder mit das Ende dieser Zeichenfolge übereinstimmt.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The type of comparison performed by the <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method depends on the value of the <ph id="ph2">`comparisonType`</ph> parameter.</source>
          <target state="translated">Der Typ des Vergleichs von ausgeführten der <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> Methode hängt vom Wert von der <ph id="ph2">`comparisonType`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The following example determines whether a string ends with a particular substring.</source>
          <target state="translated">Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge mit einer bestimmten Teilzeichenfolge endet.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</source>
          <target state="translated">Die Ergebnisse sind betroffen, durch die Auswahl der Kultur, gibt an, ob die Groß-/Kleinschreibung ignoriert wird und ob ein ordinalen Vergleich ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> ist kein <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The string to compare to the substring at the end of this instance.</source>
          <target state="translated">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Cultural information that determines how this instance and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">Kulturinformationen, die bestimmen, wie diese Instanz und <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> verglichen werden.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current culture is used.</source>
          <target state="translated">Wenn <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist, wird die aktuelle Kultur verwendet.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Determines whether the end of this string instance matches the specified string when compared using the specified culture.</source>
          <target state="translated">Bestimmt, ob das Ende dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Kultur mit der angegebenen Zeichenfolge übereinstimmt.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter matches the end of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;paramref name="value" /&gt;</ph>-Parameter mit dem Ende dieser Zeichenfolge übereinstimmt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method compares the <ph id="ph1">`value`</ph> parameter to the substring at the end of this string that is the same length as <ph id="ph2">`value`</ph>, and returns a value that indicates whether they are equal.</source>
          <target state="translated">Diese Methode vergleicht die <ph id="ph1">`value`</ph> Parameter mit der Teilzeichenfolge am Ende dieser Zeichenfolge, die gleiche Länge wie <ph id="ph2">`value`</ph>, und gibt einen Wert, der angibt, ob sie gleich sind.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same instance or match the end of this string.</source>
          <target state="translated">Gleich, <ph id="ph1">`value`</ph> muss ein Verweis auf die gleiche Instanz oder mit dem Ende dieser Zeichenfolge übereinstimmt.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method performs a word (culture-sensitive) comparison using the specified casing and culture.</source>
          <target state="translated">Diese Methode vergleicht Word (kulturabhängige) mit der angegebenen Groß-/Kleinschreibung und Kultur entspricht.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example determines whether a string occurs at the end of another string.</source>
          <target state="translated">Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge am Ende einer anderen Zeichenfolge auftritt.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> Methode wird aufgerufen, mehrmals mit Groß-/Kleinschreibung, Groß-/Kleinschreibung und andere Kulturen, die die Ergebnisse der Suche zu beeinflussen.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Determines whether two <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects have the same value.</source>
          <target state="translated">Bestimmt, ob zwei <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekte denselben Wert haben.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source>The string to compare to this instance.</source>
          <target state="translated">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source>Determines whether this instance and a specified object, which must also be a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object, have the same value.</source>
          <target state="translated">Bestimmt, ob diese Instanz und ein angegebenes Objekt, das ebenfalls ein <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt sein muss, denselben Wert haben.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> is a <ph id="ph3">&lt;see cref="T:System.String" /&gt;</ph> and its value is the same as this instance; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> ein <ph id="ph3">&lt;see cref="T:System.String" /&gt;</ph> ist und denselben Wert wie diese Instanz hat, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the method returns <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> gleich <ph id="ph2">&lt;see langword="null" /&gt;</ph> ist, gibt die Methode <ph id="ph3">&lt;see langword="false" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.Object)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung beachtet und kulturunabhängige).</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source>The string to compare to this instance.</source>
          <target state="translated">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source>Determines whether this instance and another specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object have the same value.</source>
          <target state="translated">Bestimmt, ob diese Instanz und ein anderes angegebenes <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt denselben Wert haben.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is the same as the value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;paramref name="value" /&gt;</ph>-Parameter und diese Instanz denselben Wert haben, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the method returns <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> gleich <ph id="ph2">&lt;see langword="null" /&gt;</ph> ist, gibt die Methode <ph id="ph3">&lt;see langword="false" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung beachtet und kulturunabhängige).</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.It compares the title-cased word "File" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I (U+0131) instead of LATIN SMALL LETTER I (U+0069).</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> Methode. Vergleicht das Title-Schreibweise angegeben Wort "File" ein Wort entspricht, dessen Entsprechung in Kleinbuchstaben, dessen Entsprechung in Großbuchstaben und ein Wort, das LATEINISCH kleine Buchstaben ohne Punkte I enthält (U + 0131) anstelle von kleinen Buchstaben LATEINISCH I (U + 0069).</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String)">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Equals%28System.String%29&gt;</ph> method performs an ordinal comparison, only the comparison with an identical word returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Da die <ph id="ph1">&lt;xref:System.String.Equals%28System.String%29&gt;</ph> -Methode führt einen Ordinalvergleich durch, nur für der Vergleich mit einer identischen Wort gibt <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die erste Zeichenfolge für den Vergleich oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die zweite Zeichenfolge für den Vergleich oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>Determines whether two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects have the same value.</source>
          <target state="translated">Bestimmt, ob zwei angegebene <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekte denselben Wert haben.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of <ph id="ph2">&lt;paramref name="a" /&gt;</ph> is the same as the value of <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="a" /&gt;</ph> und <ph id="ph3">&lt;paramref name="b" /&gt;</ph> denselben Wert haben, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>If both <ph id="ph1">&lt;paramref name="a" /&gt;</ph> and <ph id="ph2">&lt;paramref name="b" /&gt;</ph> are <ph id="ph3">&lt;see langword="null" /&gt;</ph>, the method returns <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="a" /&gt;</ph> und <ph id="ph2">&lt;paramref name="b" /&gt;</ph> <ph id="ph3">&lt;see langword="null" /&gt;</ph> sind, gibt diese Methode <ph id="ph4">&lt;see langword="true" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung beachtet und kulturunabhängige).</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The string to compare to this instance.</source>
          <target state="translated">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies how the strings will be compared.</source>
          <target state="translated">Einer der Enumerationswerte, die angeben, wie die Zeichenfolgen verglichen werden.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>Determines whether this string and a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object have the same value.</source>
          <target state="translated">Bestimmt, ob diese Zeichenfolge und ein angegebenes <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt denselben Wert haben.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>A parameter specifies the culture, case, and sort rules used in the comparison.</source>
          <target state="translated">Ein Parameter gibt die Kultur, Berücksichtigung von Groß- und Kleinschreibung und Sortierregeln, die für den Vergleich verwendet werden.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is the same as this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;paramref name="value" /&gt;</ph>-Parameter und diese Zeichenfolge denselben Wert haben; andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</source>
          <target state="translated">Die <ph id="ph1">`comparisonType`</ph> Parameter gibt an, ob der Vergleich die aktuelle oder der invariante Kultur verwenden soll, berücksichtigen ignorieren die Groß-/Kleinschreibung die zwei verglichenen Zeichenfolgen oder Word oder Ordinalsortierung verwenden.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The following example creates a string array that consists of an uppercase "I", a lowercase "i", and a dotless "ı".</source>
          <target state="translated">Das folgende Beispiel erstellt ein Array von Zeichenfolgen, die der Großbuchstabe "I", einen Kleinbuchstaben "i" und ohne Punkte "ı" besteht.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> method to compare them by using each possible <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration value.</source>
          <target state="translated">Er ruft dann die <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> Methode, um sie miteinander vergleichen mit jedem möglichen <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> -Enumerationswert.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The following example compares four sets of words by using each member of the <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Im folgenden Beispiel werden vier Sätze von Wörtern mit jedes Mitglied der <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</source>
          <target state="translated">Die Vergleiche, die Konventionen der Kulturen Nord-Sami (Schweden oberen) und Englisch (Vereinigte Staaten) verwenden.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</source>
          <target state="translated">Beachten Sie, dass die Zeichenfolgen "Encyclopædia" und "Enzyklopädie" entspricht in der Kultur En-US, aber nicht in der Kultur Nord-Sami (Schweden Nord) berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> ist kein <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die erste Zeichenfolge für den Vergleich oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die zweite Zeichenfolge für den Vergleich oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the comparison.</source>
          <target state="translated">Einer der Enumerationswerte, der die Regeln für den Vergleich angibt.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>Determines whether two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects have the same value.</source>
          <target state="translated">Bestimmt, ob zwei angegebene <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekte denselben Wert haben.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>A parameter specifies the culture, case, and sort rules used in the comparison.</source>
          <target state="translated">Ein Parameter gibt die Kultur, Berücksichtigung von Groß- und Kleinschreibung und Sortierregeln, die für den Vergleich verwendet werden.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;paramref name="a" /&gt;</ph> parameter is equal to the value of the <ph id="ph3">&lt;paramref name="b" /&gt;</ph> parameter; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Wert des <ph id="ph2">&lt;paramref name="a" /&gt;</ph>-Parameters dem Wert des <ph id="ph3">&lt;paramref name="b" /&gt;</ph>-Parameters entspricht, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</source>
          <target state="translated">Die <ph id="ph1">`comparisonType`</ph> Parameter gibt an, ob der Vergleich die aktuelle oder der invariante Kultur verwenden soll, berücksichtigen ignorieren die Groß-/Kleinschreibung die zwei verglichenen Zeichenfolgen oder Word oder Ordinalsortierung verwenden.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The following example compares four sets of words by using each member of the <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Im folgenden Beispiel werden vier Sätze von Wörtern mit jedes Mitglied der <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</source>
          <target state="translated">Die Vergleiche, die Konventionen der Kulturen Nord-Sami (Schweden oberen) und Englisch (Vereinigte Staaten) verwenden.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</source>
          <target state="translated">Beachten Sie, dass die Zeichenfolgen "Encyclopædia" und "Enzyklopädie" entspricht in der Kultur En-US, aber nicht in der Kultur Nord-Sami (Schweden Nord) berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> ist kein <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Converts the value of objects to strings based on the formats specified and inserts them into another string.</source>
          <target state="translated">Konvertiert auf der Grundlage der angegebenen Formate den Wert von Objekten in Zeichenfolgen und fügt sie in eine andere Zeichenfolge ein.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>If you are new to the <ph id="ph1">`String.Format`</ph> method, see the <bpt id="p1">[</bpt>Get started with the String.Format method<ept id="p1">](#Starting)</ept> section for a quick overview.</source>
          <target state="translated">Wenn Sie die <ph id="ph1">`String.Format`</ph>-Methode noch nicht kennen, lesen Sie den Abschnitt zur <bpt id="p1">[</bpt>String.Format-Methode<ept id="p1">](#Starting)</ept>, um sich einen Überblick zu verschaffen.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>See the <bpt id="p1">[</bpt>Remarks<ept id="p1">](#remarks-top)</ept> section for general documentation for the <ph id="ph1">`String.Format`</ph> method.</source>
          <target state="translated">Eine allgemeine Dokumentation zur <ph id="ph1">`String.Format`</ph>-Methode finden Sie im Abschnitt <bpt id="p1">[</bpt>Hinweise<ept id="p1">](#remarks-top)</ept>.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this section:</source>
          <target state="translated">In diesem Abschnitt</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Get started with the String.Format method<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Erste Schritte mit der String.Format-Methode<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#FTaskList)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Welche Methode werden aufgerufen?<ept id="p1">](#FTaskList)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Format method in brief<ept id="p1">](#Format_Brief)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>In Kürze die Format-Methode<ept id="p1">](#Format_Brief)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Format item<ept id="p1">](#FormatItem)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Das Formatelement<ept id="p1">](#FormatItem)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>How arguments are formatted<ept id="p1">](#HowFormatted)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Formatierung von Argumenten<ept id="p1">](#HowFormatted)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Format items that have the same index<ept id="p1">](#SameIndex)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Formatelemente, die den gleichen Index aufweisen.<ept id="p1">](#SameIndex)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Formatting and culture<ept id="p1">](#Format_Culture)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Formatierung und Kultur<ept id="p1">](#Format_Culture)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Custom formatting operations<ept id="p1">](#Format_Custom)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Benutzerdefinierte Formatierung Vorgänge<ept id="p1">](#Format_Custom)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>String.Format Q &amp; A<ept id="p1">](#QA)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>String.Format Fragen und Antworten<ept id="p1">](#QA)</ept></target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Get started with the String.Format method</source>
          <target state="translated">Erste Schritte mit der String.Format-Methode</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Use <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> if you need to insert the value of an object, variable, or expression into another string.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> , wenn den Wert eines Objekts, eine Variable oder ein Ausdruck in eine andere Zeichenfolge eingefügt werden müssen.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, you can insert the value of a <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> value into a string to display it to the user as a single string:</source>
          <target state="translated">Sie können beispielsweise den Wert des Einfügen einer <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> Wert in eine Zeichenfolge, die es dem Benutzer als einzelne Zeichenfolge anzuzeigen:</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>And you can control that value's formatting:</source>
          <target state="translated">Und Sie können die Formatierung des Werts steuern:</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Besides formatting, you can also control alignment and spacing.</source>
          <target state="translated">Neben dem formatieren, können Sie auch die Ausrichtung und Abstand steuern.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Inserting a string</source>
          <target state="translated">Eine Zeichenfolge eingefügt.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> starts with a format string, followed by one or more objects or expressions that will be converted to strings and inserted at a specified place in the format string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> beginnt mit einer Formatzeichenfolge, gefolgt von Objekten oder Ausdrücke, die in Zeichenfolgen konvertiert und an einem angegebenen Speicherort gespeichert, in der Formatzeichenfolge eingefügt werden.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example:</source>
          <target state="translated">Zum Beispiel:</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">`{0}`</ph> in the format string is a format item.</source>
          <target state="translated">Die <ph id="ph1">`{0}`</ph> im Format Zeichenfolge eines Formatelements ist.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`0`</ph> is the index of the object whose string value will be inserted at that position.</source>
          <target state="translated"><ph id="ph1">`0`</ph> ist der Index des Objekts, dessen Zeichenfolgenwert an dieser Position eingefügt werden soll.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(Indexes start at 0.) If the object to be inserted is not a string, its <ph id="ph1">`ToString`</ph> method is called to convert it to one before inserting it in the result string.</source>
          <target state="translated">(Indizes beginnen bei 0.) Wenn das einzufügende Objekt nicht um eine Zeichenfolge ist ihre <ph id="ph1">`ToString`</ph> Methode wird aufgerufen, um es zu einem vor dem Einfügen in die Ergebniszeichenfolge konvertieren.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's another example that uses two format items and two objects in the object list:</source>
          <target state="translated">Hier ist ein weiteres Beispiel, das zwei Formatelemente und zwei Objekte in der Objektliste verwendet:</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can have as many format items and as many objects in the object list as you want, as long as the index of every format item has a matching object in the object list.</source>
          <target state="translated">Sie können beliebig viele Formatelemente und wie viele Objekte in der Objektliste, wie Sie möchten, solange der Index der jedes Formatelement kein übereinstimmendes Objekt in der Objektliste verfügt.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You also don't have to worry about which overload you call; the compiler will select the appropriate one for you.</source>
          <target state="translated">Ferner müssen nicht Gedanken machen, rufen Sie über die Überlastung; der Compiler wird für Sie ausgewählt.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Controlling formatting</source>
          <target state="translated">Steuern der Formatierung</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can follow the index in a format item with a format string to control how an object is formatted.</source>
          <target state="translated">Führen Sie den Index in einem Formatelement mit einer Formatzeichenfolge steuern, wie ein Objekt formatiert ist.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, <ph id="ph1">`{0:d}`</ph> applies the "d" format string to the first object in the object list.</source>
          <target state="translated">Beispielsweise <ph id="ph1">`{0:d}`</ph> betrifft die Formatzeichenfolge "d" das erste Objekt in der Objektliste.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here is an example with a single object and two format items:</source>
          <target state="translated">Hier ist ein Beispiel mit einem einzelnen Objekt und zwei Elemente formatieren:</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A number of types support format strings, including all numeric types (both <bpt id="p1">[</bpt>standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>custom<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept> format strings), all dates and times (both <bpt id="p3">[</bpt>standard<ept id="p3">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p4">[</bpt>custom<ept id="p4">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept> format strings) and time intervals (both <bpt id="p5">[</bpt>standard<ept id="p5">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> and <bpt id="p6">[</bpt>custom<ept id="p6">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept> format strings), all enumeration types <bpt id="p7">[</bpt>enumeration types<ept id="p7">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>, and <bpt id="p8">[</bpt>GUIDs<ept id="p8">](https://msdn.microsoft.com/library/97af8hh4.aspx)</ept>.</source>
          <target state="translated">Eine Anzahl von Typen unterstützen Formatzeichenfolgen, einschließlich aller numerische Typen (sowohl <bpt id="p1">[</bpt>standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> und <bpt id="p2">[</bpt>benutzerdefinierte<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept> Formatieren von Zeichenfolgen), alle Datums- und Uhrzeitangaben (beide <bpt id="p3">[</bpt>standard<ept id="p3">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> und <bpt id="p4">[</bpt>benutzerdefinierte<ept id="p4">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept> Formatzeichenfolgen) und Zeitintervalle (sowohl <bpt id="p5">[</bpt>standard<ept id="p5">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> und <bpt id="p6">[</bpt>benutzerdefinierte<ept id="p6">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept> Formatieren von Zeichenfolgen), alle Enumerationstypen <bpt id="p7">[</bpt>Enumerationstypen <ept id="p7">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>, und <bpt id="p8">[</bpt>GUIDs<ept id="p8">](https://msdn.microsoft.com/library/97af8hh4.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also add support for format strings to your own types.</source>
          <target state="translated">Sie können auch Unterstützung für Formatzeichenfolgen für Ihre eigenen Typen hinzufügen.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Controlling spacing</source>
          <target state="translated">Steuern der Abstand</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can define the width of the string that is inserted into the result string by using syntax such as <ph id="ph1">`{0,12}`</ph>, which inserts a 12-character string.</source>
          <target state="translated">Sie können die Breite der Zeichenfolge, die in die Ergebniszeichenfolge eingefügt wird, wie z. B. mit der Syntax definieren <ph id="ph1">`{0,12}`</ph>, eine Zeichenfolge mit 12 Zeichen eingefügt.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this case, the string representation of the first object is right-aligned in the 12-character field.</source>
          <target state="translated">In diesem Fall wird die Zeichenfolgendarstellung des ersten Objekts rechtsbündig im Feld 12 Zeichen.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(If the string representation of the first object is more than 12 characters in length, though, the preferred field width is ignored, and the entire string is inserted into the result string.)</source>
          <target state="translated">(Ist die Zeichenfolgendarstellung des ersten Objekts maximal 12 Zeichen lang sein, jedoch die bevorzugte Feldbreite wird ignoriert, und die gesamte Zeichenfolge wird in die Ergebniszeichenfolge eingefügt.)</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example defines a 6-character field to hold the string "Year" and some year strings, as well as an 15-character field to hold the string "Population" and some population data.</source>
          <target state="translated">Das folgende Beispiel definiert ein Feld 6 Zeichen zum Speichern der Zeichenfolge "Year" und einige Jahr Zeichenfolgen, sowie ein Feld 15-Zeichen für die Zeichenfolge "Auffüllung" und einige Daten auffüllen.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that the characters are right-aligned in the field.</source>
          <target state="translated">Beachten Sie, dass die Zeichen rechtsbündig in das Feld.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Controlling alignment</source>
          <target state="translated">Steuern der Ausrichtung</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By default, strings are right-aligned within their field if you specify a field width.</source>
          <target state="translated">Standardmäßig sind Zeichenfolgen in ihren Feld rechtsbündig ausgerichtet, wenn Sie eine Feldbreite anzugeben.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To left-align strings in a field, you preface the field width with a negative sign, such as <ph id="ph1">`{0,-12}`</ph> to define a 12-character right-aligned field.</source>
          <target state="translated">Um Zeichenfolgen in einem Feld linksbündig, Sie voranstellen die Feldbreite ein negatives Vorzeichen, z. B. <ph id="ph1">`{0,-12}`</ph> so definieren Sie einen 12-stelligen-Feld rechtsbündig ausgerichtet.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example is similar to the previous one, except that it left-aligns both labels and data.</source>
          <target state="translated">Im folgende Beispiel ähnelt der vorherigen Abfrage, außer dass sie sowohl Daten als auch Bezeichnungen linksbündig ausgerichtet.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> makes use of the composite formatting feature.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> Verwenden der Funktion für kombinierte Formatierung.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Composite Formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Zusammengesetzte Formatierung<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Which method do I call?</source>
          <target state="translated">Welche Methode werden aufgerufen?</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To</source>
          <target state="translated">Beschreibung</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Call</source>
          <target state="translated">Call</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format one or more objects by using the conventions of the current culture.</source>
          <target state="translated">Ein oder mehrere Objekte mit den Konventionen der aktuellen Kultur zu formatieren.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Except for the overloads that include a <ph id="ph1">`provider`</ph> parameter, the remaining <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> overloads include a <ph id="ph3">&lt;xref:System.String&gt;</ph> parameter followed by one or more object parameters.</source>
          <target state="translated">Mit Ausnahme der Überladungen, die eine <ph id="ph1">`provider`</ph> Parameter, die verbleibenden <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> Überladungen enthalten einen <ph id="ph3">&lt;xref:System.String&gt;</ph> Parameter gefolgt von mindestens einem Objektparameter.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because of this, you don't have to determine which <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload you intend to call.</source>
          <target state="translated">Aus diesem Grund müssen Sie nicht ermitteln, welche <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> Überladung, die Sie aufrufen möchten.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Your language compiler selects the appropriate overload from among the overloads that don't have a <ph id="ph1">`provider`</ph> parameter, based on your argument list.</source>
          <target state="translated">Der Sprachcompiler wählt die entsprechende Überladung aus der Überladungen, die keine <ph id="ph1">`provider`</ph> basierend auf Ihrer Typargumentliste-Parameter.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if your argument list has five arguments, the compiler calls the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Z. B. Wenn Sie Ihrer Typargumentliste fünf Argumente verfügt, ruft der Compiler die <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format one or more objects by using the conventions of a specific culture.</source>
          <target state="translated">Ein oder mehrere Objekte mit den Konventionen einer bestimmten Kultur zu formatieren.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload that begins with a <ph id="ph2">`provider`</ph> parameter is followed by a <ph id="ph3">&lt;xref:System.String&gt;</ph> parameter and one or more object parameters.</source>
          <target state="translated">Jede <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> Überladung, die mit beginnt ein <ph id="ph2">`provider`</ph> Parameter gefolgt von einer <ph id="ph3">&lt;xref:System.String&gt;</ph> Parameter und mindestens einen Parameter-Objekt.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because of this, you don't have to determine which specific <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload you intend to call.</source>
          <target state="translated">Aus diesem Grund müssen Sie nicht bestimmen von welcher bestimmten <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> Überladung, die Sie aufrufen möchten.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Your language compiler selects the appropriate overload from among the overloads that have a <ph id="ph1">`provider`</ph> parameter, based on your argument list.</source>
          <target state="translated">Der Sprachcompiler wählt die entsprechende Überladung aus der Überladungen, die über eine <ph id="ph1">`provider`</ph> basierend auf Ihrer Typargumentliste-Parameter.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if your argument list has five arguments, the compiler calls the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Z. B. Wenn Sie Ihrer Typargumentliste fünf Argumente verfügt, ruft der Compiler die <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Perform a custom formatting operation either with an <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> implementation or an <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> implementation.</source>
          <target state="translated">Führen Sie einem benutzerdefinierten Formatierungsvorgang eine mit einer <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> Implementierung oder ein <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> Implementierung.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Any of the four overloads with a <ph id="ph1">`provider`</ph> parameter.</source>
          <target state="translated">Einer der vier Überladungen mit einem <ph id="ph1">`provider`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The compiler selects the appropriate overload from among the overloads that have a <ph id="ph1">`provider`</ph> parameter, based on your argument list.</source>
          <target state="translated">Der Compiler wählt die entsprechende Überladung aus der Überladungen, die über eine <ph id="ph1">`provider`</ph> basierend auf Ihrer Typargumentliste-Parameter.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The Format method in brief</source>
          <target state="translated">In Kürze die Format-Methode</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each overload of the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to include zero-based indexed placeholders, called <bpt id="p2">*</bpt>format items<ept id="p2">*</ept>, in a composite format string.</source>
          <target state="translated">Jeder Überladung der <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> -Methode verwendet die <bpt id="p1">[</bpt>Funktion für kombinierte Formatierung<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> einzuschließende nullbasierte indizierte Platzhaltern, aufgerufen <bpt id="p2">*</bpt>Elemente formatieren<ept id="p2">*</ept>, in eine zusammengesetzte Formatzeichenfolge.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>At run time, each format item is replaced with the string representation of the corresponding argument in a parameter list.</source>
          <target state="translated">Jedes Formatelement wird zur Laufzeit durch die Zeichenfolgendarstellung des entsprechenden Arguments in einer Parameterliste ersetzt.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the value of the argument is <ph id="ph1">`null`</ph>, the format item is replaced with <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn der Wert des Arguments <ph id="ph1">`null`</ph>, ersetzt das Formatelement mit <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following call to the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> method includes a format string with three format items, <ph id="ph2">{0}</ph>, <ph id="ph3">{1}</ph>, and <ph id="ph4">{2}</ph>, and an argument list with three items.</source>
          <target state="translated">Beispielsweise beim folgenden Aufruf der <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> Methode enthält eine Formatzeichenfolge mit drei Formatelementen, <ph id="ph2">{0}</ph>, <ph id="ph3">{1}</ph>, und <ph id="ph4">{2}</ph>, und eine Liste der Typargumente mit drei Elementen.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The format item</source>
          <target state="translated">Das Formatelement</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A format item has this syntax:</source>
          <target state="translated">Einem Formatelement hat folgende Syntax:</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Brackets denote optional elements.</source>
          <target state="translated">Klammern bezeichnen optionale Elemente.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The opening and closing braces are required.</source>
          <target state="translated">Die öffnende und schließende geschweifte Klammern sind erforderlich.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(To include a literal opening or closing brace in the format string, see the <bpt id="p1">[</bpt>Escaping Braces<ept id="p1">](~/docs/standard/base-types/composite-formatting.md#escaping-braces)</ept> section in the <bpt id="p2">[</bpt>Composite Formatting<ept id="p2">](~/docs/standard/base-types/composite-formatting.md)</ept> article.)</source>
          <target state="translated">(Umfassen eine literale öffnende oder schließende geschweifte Klammer in der Formatzeichenfolge finden Sie unter der <bpt id="p1">[</bpt>Klammern mit Escapezeichen<ept id="p1">](~/docs/standard/base-types/composite-formatting.md#escaping-braces)</ept> im Abschnitt der <bpt id="p2">[</bpt>kombinierte Formatierung<ept id="p2">](~/docs/standard/base-types/composite-formatting.md)</ept> Artikel.)</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a format item to format a currency value might appear like this:</source>
          <target state="translated">Einem Formatelement Währungswert formatieren kann beispielsweise wie folgt aussehen:</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A format item has the following elements:</source>
          <target state="translated">Einem Formatelement beinhaltet die folgenden Elemente:</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">*</bpt>index<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>index<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The zero-based index of the argument whose string representation is to be included at this position in the string.</source>
          <target state="translated">Der nullbasierte Index des Arguments, dessen zeichenfolgedarstellung werden an dieser Position in der Zeichenfolge enthalten.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If this argument is <ph id="ph1">`null`</ph>, an empty string will be included at this position in the string.</source>
          <target state="translated">Wenn dieses Argument <ph id="ph1">`null`</ph>, keine leere Zeichenfolge wird an dieser Position in der Zeichenfolge enthalten sein.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">*</bpt>alignment<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>Ausrichtung<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Optional.</source>
          <target state="translated">Dies ist optional.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A signed integer that indicates the total length of the field into which the argument is inserted and whether it is right-aligned (a positive integer) or left-aligned (a negative integer).</source>
          <target state="translated">Eine Ganzzahl mit Vorzeichen, die die Gesamtlänge des Felds angibt, in der das Argument eingefügt wird und ob sie rechtsbündig (eine positive ganze Zahl) oder linksbündig ausgerichtet (eine negative ganze Zahl).</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you omit <bpt id="p1">*</bpt>alignment<ept id="p1">*</ept>, the string representation of the corresponding argument is inserted in a field with no leading or trailing spaces.</source>
          <target state="translated">Wenn Sie weglassen <bpt id="p1">*</bpt>Ausrichtung<ept id="p1">*</ept>, die Zeichenfolgendarstellung des entsprechenden Arguments in einem Feld keine führenden oder nachgestellten Leerzeichen eingefügt wird.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the value of <bpt id="p1">*</bpt>alignment<ept id="p1">*</ept> is less than the length of the argument to be inserted, <bpt id="p2">*</bpt>alignment<ept id="p2">*</ept> is ignored and the length of the string representation of the argument is used as the field width.</source>
          <target state="translated">Wenn der Wert der <bpt id="p1">*</bpt>Ausrichtung<ept id="p1">*</ept> ist kleiner als die Länge des Arguments eingefügt werden, <bpt id="p2">*</bpt>Ausrichtung<ept id="p2">*</ept> wird ignoriert, und die Länge der Zeichenfolgendarstellung des Arguments wird als Feldbreite verwendet.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">*</bpt>formatString<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>formatString<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Optional.</source>
          <target state="translated">Dies ist optional.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string that specifies the format of the corresponding argument's result string.</source>
          <target state="translated">Eine Zeichenfolge, die das Format der Ergebniszeichenfolge das entsprechende Argument angibt.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you omit <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>, the corresponding argument's parameterless <ph id="ph1">`ToString`</ph> method is called to produce its string representation.</source>
          <target state="translated">Wenn Sie weglassen <bpt id="p1">*</bpt>"FormatString"<ept id="p1">*</ept>, das entsprechende Argument des parameterlosen <ph id="ph1">`ToString`</ph> Methode wird aufgerufen, um die Zeichenfolgendarstellung zu erzeugen.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you specify <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>, the argument referenced by the format item must implement the <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interface.</source>
          <target state="translated">Bei Angabe von <bpt id="p1">*</bpt>"FormatString"<ept id="p1">*</ept>, muss das Argument, das Formatelement verweist implementieren die <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Types that support format strings include:</source>
          <target state="translated">Die Formatzeichenfolgen unterstützen die folgenden Anweisungstypen:</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All integral and floating-point types.</source>
          <target state="translated">Alle Ganzzahl- und Gleitkommatypen.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>standardmäßige numerische Formatzeichenfolgen<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> und <bpt id="p2">[</bpt>benutzerdefinierte numerische Formatzeichenfolgen<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.DateTime&gt;</ph> and <ph id="ph2">&lt;xref:System.DateTimeOffset&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.DateTime&gt;</ph> und <ph id="ph2">&lt;xref:System.DateTimeOffset&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Formatzeichenfolgen Standardformatbezeichner für Datum und Uhrzeit<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> und <bpt id="p2">[</bpt>benutzerdefinierten Formatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All enumeration types.</source>
          <target state="translated">Alle Enumerationstypen.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Enumeration Format Strings<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Enumerationsformatzeichenfolgen<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph>-Werte sind.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Standard TimeSpan Format Strings<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom TimeSpan Format Strings<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>TimeSpan-Standardformatzeichenfolgen<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> und <bpt id="p2">[</bpt>benutzerdefinierte TimeSpan-Formatzeichenfolgen<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>GUIDs.</source>
          <target state="translated">GUIDs.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See the <ph id="ph1">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method.)</source>
          <target state="translated">(Siehe die <ph id="ph1">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> Methode.)</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, note that any custom type can implement <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> or extend an existing type's <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> implementation.</source>
          <target state="translated">Beachten Sie jedoch, dass jeder beliebige benutzerdefinierter Typ implementieren, kann <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> oder Erweitern eines vorhandenen Typs <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> Implementierung.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the <ph id="ph1">`alignment`</ph> and <ph id="ph2">`formatString`</ph> arguments to produce formatted output.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">`alignment`</ph> und <ph id="ph2">`formatString`</ph> Argumente formatierte Ausgabe zu erzeugen.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How arguments are formatted</source>
          <target state="translated">Formatierung von Argumenten</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format items are processed sequentially from the beginning of the string.</source>
          <target state="translated">Formatelement werden sequenziell vom Anfang der Zeichenfolge verarbeitet.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each format item has an index that corresponds to an object in the method's argument list.</source>
          <target state="translated">Jedes Formatelement verfügt über einen Index, der ein Objekt in der Argumentliste der Methode entspricht.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method retrieves the argument and derives its string representation as follows:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> Methode ruft das Argument und seine Zeichenfolgendarstellung wie folgt abgeleitet:</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the argument is <ph id="ph1">`null`</ph>, the method inserts <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> into the result string.</source>
          <target state="translated">Wenn das Argument ist <ph id="ph1">`null`</ph>, fügt die Methode <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> in der Ergebniszeichenfolge.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You don't have to be concerned with handling a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> for null arguments.</source>
          <target state="translated">Sie keine Behandlung achten eine <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> für null-Argumente.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you call the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> overload and the <ph id="ph2">`provider`</ph> object's <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType&gt;</ph> implementation returns a non-null <ph id="ph4">&lt;xref:System.ICustomFormatter&gt;</ph> implementation, the argument is passed to its <ph id="ph5">&lt;xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Beim Aufrufen der <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> überladen und die <ph id="ph2">`provider`</ph> des Objekts <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType&gt;</ph> Implementierung gibt eine Wert ungleich Null <ph id="ph4">&lt;xref:System.ICustomFormatter&gt;</ph> -Implementierung, mit das Argument übergeben wird seine <ph id="ph5">&lt;xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the format item includes a <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept> argument, it is passed as the first argument to the method.</source>
          <target state="translated">Wenn die Formatelement enthält eine <bpt id="p1">*</bpt>"FormatString"<ept id="p1">*</ept> Argument, es wird als erstes Argument an die Methode übergeben.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> implementation is available and produces a non-null string, that string is returned as the string representation of the argument; otherwise, the next step executes.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> ; Implementierung ist verfügbar und erzeugt eine Zeichenfolge ungleich Null, die Zeichenfolge als die Zeichenfolgendarstellung des Arguments zurückgegeben wird, andernfalls der nächste Schritt ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the argument implements the <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interface, its <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> implementation is called.</source>
          <target state="translated">Wenn das Argument implementiert die <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> -Schnittstelle, die <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> -Implementierung aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The argument's parameterless <ph id="ph1">`ToString`</ph> method, which either overrides or inherits from a base class implementation, is called.</source>
          <target state="translated">Das Argument des parameterlosen <ph id="ph1">`ToString`</ph> -Methode, die entweder überschreibt oder die Implementierung einer Basisklasse erbt, heißt.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For an example that intercepts calls to the <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> method and allows you to see what information the <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> method passes to a formatting method for each format item in a composite format string, see <bpt id="p1">[</bpt>Example: An intercept provider and Roman numeral formatter<ept id="p1">](#Format7_Example)</ept>.</source>
          <target state="translated">Ein Beispiel für die Aufrufe fängt die <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> Methode und ermöglicht Ihnen, welche Informationen finden Sie unter der <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> -Methode übergibt, einer Formatierungsmethode für jedes Formatelement in einer zusammengesetzten Formatzeichenfolge finden Sie unter <bpt id="p1">[</bpt>Beispiel: ein Intercept-Anbieter und Römische Zahlzeichen Formatierer<ept id="p1">](#Format7_Example)</ept>.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see the <bpt id="p1">[</bpt>Processing Order<ept id="p1">](~/docs/standard/base-types/composite-formatting.md##processing-order)</ept> section in the <bpt id="p2">[</bpt>Composite Formatting<ept id="p2">](~/docs/standard/base-types/composite-formatting.md)</ept> article.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <bpt id="p1">[</bpt>Verarbeitungsreihenfolge<ept id="p1">](~/docs/standard/base-types/composite-formatting.md##processing-order)</ept> im Abschnitt der <bpt id="p2">[</bpt>kombinierte Formatierung<ept id="p2">](~/docs/standard/base-types/composite-formatting.md)</ept> Artikel.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format items that have the same index</source>
          <target state="translated">Formatelemente, die den gleichen Index aufweisen.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.FormatException&gt;</ph> exception if the index of an index item is greater than or equal to the number of arguments in the argument list.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> -Methode löst eine <ph id="ph2">&lt;xref:System.FormatException&gt;</ph> -Ausnahme aus, wenn der Index eines Elements Index größer als oder gleich der Anzahl von Argumenten in der Argumentliste ist.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, <ph id="ph1">`format`</ph> can include more format items than there are arguments, as long as multiple format items have the same index.</source>
          <target state="translated">Allerdings <ph id="ph1">`format`</ph> zählen mehr Formatelementen, die als Argumente vorhanden sind, solange mehrere Formatelemente denselben Index verfügen.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the call to the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> method in following example, the argument list has a single argument, but the format string includes two format items: one displays the decimal value of a number, and the other displays its hexadecimal value.</source>
          <target state="translated">Im Aufruf der <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> Methode im folgenden Beispiel wird die Liste der Typargumente hat ein einzelnes Argument, aber die Formatzeichenfolge enthält zwei Formatelemente: eine zeigt den Dezimalwert einer Zahl und das andere seinem Hexadezimalwert.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting and culture</source>
          <target state="translated">Formatierung und Kultur</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Generally, objects in the argument list are converted to their string representations by using the conventions of the current culture, which is returned by the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Im Allgemeinen Objekte in der Argumentliste mit den Konventionen der aktuellen Kultur, die von zurückgegeben wird, deren zeichenfolgendarstellungen konvertiert werden die <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can control this behavior by calling one of the overloads of <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> that includes a <ph id="ph2">`provider`</ph> parameter.</source>
          <target state="translated">Sie können dieses Verhalten steuern, indem eine der Überladungen der Aufrufen <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> , umfasst eine <ph id="ph2">`provider`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation that supplies custom and culture-specific formatting information that is used to moderate the formatting process.</source>
          <target state="translated">Die <ph id="ph1">`provider`</ph> Parameter ist ein <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> Implementierung, die benutzerdefinierte und kulturspezifische Formatierungsinformationen bereitstellt, die verwendet wird, um die Formatierung Mittel zu verarbeiten.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> interface has a single member, <ph id="ph2">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph>, which is responsible for returning the object that provides formatting information.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> Schnittstelle verfügt über einen einzelnen Member, <ph id="ph2">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph>, die für das Objekt, das Formatierungsinformationen liefert zurückgeben verantwortlich ist.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework has three <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> implementations that provide culture-specific formatting:</source>
          <target state="translated">.NET Framework verfügt über drei <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> Implementierungen, die kulturspezifische Formatierung bereitstellen:</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph></target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns a culture-specific <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for formatting numeric values and a culture-specific <ph id="ph3">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph> object for formatting date and time values.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> Methodenrückgabe eine kulturspezifische <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> Objekt zum Formatieren von numerischen Werten und eine kulturspezifische <ph id="ph3">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph> Objekt zum Formatieren von Datums-und Uhrzeitwerte.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph>, which is used for culture-specific formatting of date and time values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph>, der kulturabhängige Formatierung von Datums-und Uhrzeitwerte verwendet wird.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A&gt;</ph> method returns itself.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A&gt;</ph> Methodenrückgabe selbst.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph>, which is used for culture-specific formatting of numeric values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph>, der kulturabhängige Formatierung von numerischen Werten verwendet wird.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> property returns itself.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> Eigenschaft gibt sich selbst zurück.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Custom formatting operations</source>
          <target state="translated">Benutzerdefinierte Formatierung Vorgänge</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also call the any of the overloads of the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method that have a <ph id="ph2">`provider`</ph> parameter of type <ph id="ph3">&lt;xref:System.IFormatProvider&gt;</ph> to perform custom formatting operations.</source>
          <target state="translated">Sie können auch eine der Überladungen der Aufrufen der <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> -Methode, die über eine <ph id="ph2">`provider`</ph> Parameter vom Typ <ph id="ph3">&lt;xref:System.IFormatProvider&gt;</ph> benutzerdefinierte Formatierung Operationen.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, you could format an integer as an identification number or as a telephone number.</source>
          <target state="translated">Sie konnten z. B. eine ganze Zahl als eine ID oder eine Telefonnummer formatieren.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To perform custom formatting, your <ph id="ph1">`provider`</ph> argument must implement both the <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> and <ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph> interfaces.</source>
          <target state="translated">Benutzerdefinierte Formatierung Ausführen Ihrer <ph id="ph1">`provider`</ph> Argument muss sowohl implementieren die <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> und <ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph> Schnittstellen.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method is passed an <ph id="ph2">&lt;xref:System.ICustomFormatter&gt;</ph> implementation as the <ph id="ph3">`provider`</ph> argument, the <ph id="ph4">&lt;xref:System.String.Format%2A&gt;</ph> method calls its   <ph id="ph5">&lt;xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType&gt;</ph> implementation and requests an object of type <ph id="ph6">&lt;xref:System.ICustomFormatter&gt;</ph>.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> -Methode übergeben ein <ph id="ph2">&lt;xref:System.ICustomFormatter&gt;</ph> Implementierung als die <ph id="ph3">`provider`</ph> Argument, die <ph id="ph4">&lt;xref:System.String.Format%2A&gt;</ph> Methodenaufrufe seine <ph id="ph5">&lt;xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType&gt;</ph> Implementierung und fordert ein Objekt vom Typ <ph id="ph6">&lt;xref:System.ICustomFormatter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It then calls the returned <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> object's <ph id="ph2">&lt;xref:System.ICustomFormatter.Format%2A&gt;</ph> method to format each format item in the composite string passed to it.</source>
          <target state="translated">Er ruft dann das zurückgegebene <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> des Objekts <ph id="ph2">&lt;xref:System.ICustomFormatter.Format%2A&gt;</ph> Methode so formatieren Sie jedes Formatelement in der zusammengesetzte Zeichenfolge übergeben.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about providing custom formatting solutions, see <bpt id="p1">[</bpt>How to: Define and Use Custom Numeric Format Providers<ept id="p1">](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)</ept> and <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zum Bereitstellen von Lösungen für benutzerdefinierte Formatierung finden Sie unter <bpt id="p1">[</bpt>wie: definieren und benutzerdefinierten numerischen Formatanbietern verwenden<ept id="p1">](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)</ept> und <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For an example that converts integers to formatted custom numbers, see <bpt id="p1">[</bpt>Example: A custom formatting operation<ept id="p1">](#Format6_Example)</ept>.</source>
          <target state="translated">Ein Beispiel für die ganze Zahlen in formatierte benutzerdefinierte Zahlen umwandelt, finden Sie unter <bpt id="p1">[</bpt>Beispiel: eine benutzerdefinierte Formatierungsvorgang<ept id="p1">](#Format6_Example)</ept>.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For an example that converts unsigned bytes to Roman numerals, see <bpt id="p1">[</bpt>Example: An intercept provider and Roman numeral formatter<ept id="p1">](#Format7_Example)</ept>.</source>
          <target state="translated">Ein Beispiel, das römische Ziffern Bytes ohne Vorzeichen konvertiert werden, finden Sie unter <bpt id="p1">[</bpt>Beispiel: ein Intercept-Anbieter und römische Zahlzeichen Formatierer<ept id="p1">](#Format7_Example)</ept>.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example: A custom formatting operation</source>
          <target state="translated">Beispiel: Eine benutzerdefinierte Formatierungsvorgang</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This example defines a format provider that formats an integer value as a customer account number in the form x-xxxxx-xx.</source>
          <target state="translated">In diesem Beispiel definiert einen Formatanbieter, der einen ganzzahligen Wert als die Kontonummer eines Kunden in der Form X-Xxxxx-Xx formatiert.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example: An intercept provider and Roman numeral formatter</source>
          <target state="translated">Beispiel: Ein Intercept-Anbieter und das römische Zahlzeichen Formatierer</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This example defines a custom format provider that implements the <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> and <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interfaces to do two things:</source>
          <target state="translated">In diesem Beispiel wird einen benutzerdefiniertes Format-Anbieter, implementiert die <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> und <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> Schnittstellen zwei Dinge tun:</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It displays the parameters passed to its <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">Es zeigt die Parameter, dessen <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> Implementierung.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This enables us to see what parameters the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method is passing to the custom formatting implementation for each object that it tries to format.</source>
          <target state="translated">Dies ermöglicht es, zu welchen Parameter finden Sie unter der <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> Methode für die benutzerdefinierte Formatierung Implementierung für jedes Objekt, das er versucht, formatieren Sie übergeben wird.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This can be useful when you're debugging your application.</source>
          <target state="translated">Dies kann nützlich sein, wenn Sie Ihre Anwendung debuggen.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the object to be formatted is an unsigned byte value that is to be formatted by using the "R" standard format string, the custom formatter formats the numeric value as a Roman numeral.</source>
          <target state="translated">Wenn das Objekt zu formatierenden ein Byte ohne Vorzeichen-Wert, der mit der Standardformatzeichenfolge "R" formatiert werden, formatiert das benutzerdefinierte Formatierungsprogramm den numerischen Wert als eine römische Zahlzeichen an.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String.Format Q &amp; A</source>
          <target state="translated">String.Format Fragen und Antworten</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Why do you recommend string interpolation over calls to the <ph id="ph1">`String.Format`</ph> method?</source>
          <target state="translated">Warum empfehlen Sie zeichenfolgeninterpolierung über Aufrufe an die <ph id="ph1">`String.Format`</ph> Methode?</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String interpolation is:</source>
          <target state="translated">Zeichenfolgeninterpolierung ist:</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>More flexible.</source>
          <target state="translated">Mehr Flexibilität bietet.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It can be used in any string without requiring a call to a method that supports composite formatting.</source>
          <target state="translated">Sie können in einer beliebigen Zeichenfolge ohne einen Aufruf einer Methode, die kombinierte Formatierung unterstützen verwendet werden.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Otherwise, you have to call the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method or another method that supports composite formatting, such as <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Andernfalls müssen Sie anrufen der <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> -Methode oder eine andere Methode, die kombinierte Formatierung, z. B. unterstützt <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph3">&lt;xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>More readable.</source>
          <target state="translated">Besser lesbar.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the expression to insert into a string appears in the interpolated expression rather than in a argument list, interpolated strings are far easier to code and to read.</source>
          <target state="translated">Da der Ausdruck zum Einfügen in eine Zeichenfolge in der interpolierte Ausdruck anstatt in einer Argumentliste angezeigt wird, sind interpolierte Zeichenfolgen viel leichter, um Code und lesen.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because of their greater readability, interpolated strings can replace not only calls to composite format methods, but they can also be used in string concatenation operations to produce more concise, clearer code.</source>
          <target state="translated">Aufgrund ihrer bessere Lesbarkeit können interpolierte Zeichenfolgen nicht nur Aufrufe von Methoden für kombinierte Formatierung, aber sie können auch in Verkettung Zeichenfolgenoperationen verwendet werden, um präziser, besseren Code zu erzeugen.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A comparison of the following two code examples illustrates the superiority of interpolated strings over string concatenation and calls to composite formatting methods.</source>
          <target state="translated">Ein Vergleich der folgenden zwei Codebeispiele veranschaulicht die Überlegenheit des interpolierte Zeichenfolgen verketten von Zeichenfolgen und Aufrufe von Methoden zur kombinierten Formatierung.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The use of multiple string concatenation operations in the following example produces verbose and hard-to-read code.</source>
          <target state="translated">Die Verwendung von mehreren Verkettung Zeichenfolgenoperationen im folgenden Beispiel werden ausführliche und schwer lesbaren Code erzeugt.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In contrast, the use of interpolated strings in the following example produce much clearer, more concise code than the string concatenation statement and the call to the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method in the previous example.</source>
          <target state="translated">Im Gegensatz dazu erzeugen die Verwendung von interpolierte Zeichenfolgen im folgenden Beispiel klarer, präziser Code als Zeichenfolge verketten-Anweisung und der Aufruf an die <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> Methode im vorherigen Beispiel.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Where can I find a list of the predefined format strings that can be used with format items?</source>
          <target state="translated">Wo finde ich eine Liste der vordefinierten Formatierungszeichenfolgen, die mit Formatelementen verwendet werden können?</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For all integral and floating-point types, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Alle Ganzzahl- und Gleitkommatypen finden Sie unter <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> und <bpt id="p2">[</bpt>benutzerdefinierte Zahlenformatzeichenfolgen<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For date and time values, see <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</source>
          <target state="translated">Datum und Uhrzeit-Werte finden Sie unter <bpt id="p1">[</bpt>Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> und <bpt id="p2">[</bpt>benutzerdefinierte Datums- und Uhrzeit-Formatzeichenfolgen<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For enumeration values, see <bpt id="p1">[</bpt>Enumeration Format Strings<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.</source>
          <target state="translated">Enumerationswerte finden Sie unter <bpt id="p1">[</bpt>Enumerationsformatzeichenfolgen<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> values, see  <bpt id="p1">[</bpt>Standard TimeSpan Format Strings<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom TimeSpan Format Strings<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.</source>
          <target state="translated">Für <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> -Werte finden Sie in <bpt id="p1">[</bpt>TimeSpan-Standardformatzeichenfolgen<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> und <bpt id="p2">[</bpt>benutzerdefinierte TimeSpan-Formatzeichenfolgen<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For <ph id="ph1">&lt;xref:System.Guid&gt;</ph> values, see the Remarks section of the <ph id="ph2">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> reference page.</source>
          <target state="translated">Für <ph id="ph1">&lt;xref:System.Guid&gt;</ph> -Werte finden Sie im Abschnitt "Hinweise" der <ph id="ph2">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> Referenzseite.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I control the alignment of the result strings that replace format items?</source>
          <target state="translated">Wie können die Ausrichtung des Ergebniszeichenfolgen werden gesteuert, die Formatelemente ersetzen?</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The general syntax of a format item is:</source>
          <target state="translated">Die allgemeine Syntax eines Formatelements ist:</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>where <bpt id="p1">*</bpt>alignment<ept id="p1">*</ept> is a signed integer that defines the field width.</source>
          <target state="translated">wobei <bpt id="p1">*</bpt>Ausrichtung<ept id="p1">*</ept> ist eine Ganzzahl mit Vorzeichen, die die Breite des Felds definiert.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If this value is negative, text in the field is left-aligned.</source>
          <target state="translated">Wenn dieser Wert negativ ist, wird Text im Feld linksbündig ausgerichtet.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If it is positive, text is right-aligned.</source>
          <target state="translated">Wenn er positiv ist, ist Text rechtsbündig ausgerichtet.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I control the number of digits after the decimal separator?</source>
          <target state="translated">Wie können die Anzahl der Ziffern nach dem Dezimaltrennzeichen werden gesteuert?</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All <bpt id="p1">[</bpt>standard numeric format strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> except "D" (which is used with integers only), "G", "R", and "X" allow a precision specifier that defines the number of decimal digits in the result string.</source>
          <target state="translated">Alle <bpt id="p1">[</bpt>standardmäßige numerische Formatzeichenfolgen<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> außer "D" (die mit nur ganze Zahlen verwendet wird), "G", "R" und "X" ermöglichen ein Genauigkeitsbezeichner angegeben, die die Anzahl von Dezimalstellen in der Ergebniszeichenfolge definiert.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses standard numeric format strings to control the number of decimal digits in the result string.</source>
          <target state="translated">Im folgenden Beispiel wird die standardmäßige numerische Formatzeichenfolgen, die Anzahl der Dezimalstellen in der Ergebniszeichenfolge steuern.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you're using a <bpt id="p1">[</bpt>custom numeric format string<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, use the "0" format specifier to control the number of decimal digits in the result string, as the following example shows.</source>
          <target state="translated">Bei Verwendung einer <bpt id="p1">[</bpt>benutzerdefinierte numerische Formatzeichenfolge<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, den Formatbezeichner "0" zum Steuern der Anzahl von Dezimalstellen in der Ergebniszeichenfolge an, wie im folgenden Beispiel gezeigt verwenden.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I control the number of integral digits?</source>
          <target state="translated">Wie können die Anzahl von ganzzahligen Ziffern werden gesteuert?</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By default, formatting operations only display non-zero integral digits.</source>
          <target state="translated">Standardmäßig werden Formatierungsvorgänge nur ganze Zahlen ungleich 0 (null) angezeigt.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you are formatting integers, you can use a precision specifier with the "D" and "X" standard format strings to control the number of digits.</source>
          <target state="translated">Wenn Sie ganze Zahlen formatieren, können Sie ein Genauigkeitsbezeichner angegeben, mit der "D" und "X" standard verwendete Formatzeichenfolgen, die Anzahl der Ziffern steuern.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can pad an integer or floating-point number with leading zeros to produce a result string with a specified number of integral digits by using the "0" <bpt id="p1">[</bpt>custom numeric format specifier<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, as the following example shows.</source>
          <target state="translated">Sie können eine ganze Zahl oder Gleitkommazahl mit führenden Nullen, um eine Ergebniszeichenfolge, die mit einer angegebenen Anzahl von ganzzahligen Ziffern zu erstellen, indem Sie mit dem Wert "0" Auffüllen <bpt id="p1">[</bpt>benutzerdefinierte numerische Formatbezeichner<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, wie das folgende Beispiel zeigt.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How many items can I include in the format list?</source>
          <target state="translated">Wie viele Elemente kann ich in der Formatliste aufnehmen?</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>There is no practical limit.</source>
          <target state="translated">Es gibt keine praktische Begrenzung.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The second parameter of the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method is tagged with the <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> attribute, which allows you to include either a delimited list or an object array as your format list.</source>
          <target state="translated">Der zweite Parameter von der <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> Methode wird mit markiert die <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> -Attribut, das Ihnen ermöglicht, eine durch Trennzeichen getrennte Liste oder einem Objektarray als Ihrer Formatliste enthalten.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I include literal braces ("{" and "}") in the result string?</source>
          <target state="translated">Wie schließen literal geschweifte Klammern ("{" und "}") in der Ergebniszeichenfolge?</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, how do you prevent the following method call from throwing a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> exception?</source>
          <target state="translated">Z. B. wie Sie, dass die folgenden Methodenaufruf aus Auslösen einer <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> Ausnahme?</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A single opening or closing brace is always interpreted as the beginning or end of a format item.</source>
          <target state="translated">Eine einzelne öffnende oder schließende geschweifte Klammer wird immer als Anfang oder Ende eines Formatelements interpretiert.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To be interpreted literally, it must be escaped.</source>
          <target state="translated">Um als Zeichenliteral interpretiert werden, müssen sie mit Escapezeichen versehen werden.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You escape a brace by adding another brace ("{{" and "}}" instead of "{" and "}"), as in the following method call:</source>
          <target state="translated">Sie eine geschweifte Klammer durch Hinzufügen von einem anderen geschweifte Klammer mit Escapezeichen versehen ("{{" und "}}" anstelle von "{" und "}"), wie im folgenden Methodenaufruf:</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, even escaped braces are easily misinterpreted.</source>
          <target state="translated">Geschweifte Klammern selbst mit Escapezeichen sind jedoch leicht fehlinterpretiert.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>We recommend that you include braces in the format list and use format items to insert them in the result string, as the following example shows.</source>
          <target state="translated">Es wird empfohlen, dass Sie die geschweiften Klammern, in der Formatliste einschließen und Formatelemente zum Einfügen in die Ergebniszeichenfolge wie im folgenden Beispiel gezeigt verwenden.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Why does my call to the String.Format method throw a FormatException?</source>
          <target state="translated">Warum wird meine Aufruf der Methode String.Format FormatException ausgelöst?</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The most common cause of the exception is that the index of a format item doesn't correspond to an object in the format list.</source>
          <target state="translated">Die häufigste Ursache der Ausnahme ist, dass der Index eines Formatelements ein Objekt in der Formatliste entsprechen nicht.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Usually this indicates that you've misnumbered the indexes of format items or you've forgotten to include an object in the format list.</source>
          <target state="translated">In der Regel bedeutet dies, dass haben Sie die Indizes der Formatelemente misnumbered, oder Sie vergessen haben, ein Objekt in der Formatliste enthalten.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Attempting to include an unescaped left or right brace character also throws a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph>.</source>
          <target state="translated">Bei dem Versuch, eine ohne Escapezeichen linke oder rechte Klammer enthalten Zeichen auch löst eine <ph id="ph1">&lt;xref:System.FormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Occasionally, the exception is the result of a typo; for example, a typical mistake is to mistype "[" (the left bracket) instead of "{" (the left brace).</source>
          <target state="translated">In einigen Fällen ist die Ausnahme das Ergebnis ein Tippfehler; Angenommen, ein typische Fehler falsch ist "[" (die öffnende spitze Klammer) anstelle von "{" (die linke geschweifte Klammer).</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the Format(System.IFormatProvider,System.String,System.Object[]) method supports parameter arrays, why does my code throw an exception when I use an array?</source>
          <target state="translated">Wenn die Methode Format(System.IFormatProvider,System.String,System.Object[]) Parameterarrays, warum mein Code eine Ausnahme auslöst unterstützt, wenn ich ein Array verwenden?</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following code throws a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> exception:</source>
          <target state="translated">Im folgenden Codebeispiel löst eine <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> Ausnahme:</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is a problem of compiler overload resolution.</source>
          <target state="translated">Dies ist ein Problem der Compiler überladungsauflösung gelten.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the compiler cannot convert an array of integers to an object array, it treats the integer array as a single argument, so it calls the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> method.</source>
          <target state="translated">Da der Compiler ein Array von Ganzzahlen in einem Objektarray konvertieren kann, behandelt das Array von Ganzzahlen als ein einziges Argument, damit aufruft die <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The exception is thrown because there are four format items but only a single item in the format list.</source>
          <target state="translated">Die Ausnahme wird ausgelöst, da es vier Formatelemente aber nur ein einzelnes Element in der Formatliste gibt.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because neither Visual Basic nor C# can convert an integer array to an object array, you have to perform the conversion yourself before calling the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Da weder Visual Basic oder c# ein Array von Ganzzahlen in einem Objektarray konvertieren kann, müssen Sie die Konvertierung ausführen selbst vor dem Aufruf der <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example provides one implementation.</source>
          <target state="translated">Im folgende Beispiel stellt eine Implementierung bereit.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Numerous examples that call the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method are interspersed through the <bpt id="p1">[</bpt>Remarks<ept id="p1">](#remarks)</ept> section of this article.</source>
          <target state="translated">Zahlreiche Beispiele, die aufgerufen werden der <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> Methode vermischt werden, über die <bpt id="p1">[</bpt>"Hinweise"<ept id="p1">](#remarks)</ept> Abschnitt dieses Artikels.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also download a complete set of <ph id="ph1">`String.Format`</ph> examples, which are included a <bpt id="p1">[</bpt>.NET Core 2.0 project for C#<ept id="p1">](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip)</ept> and a <bpt id="p2">[</bpt>.NET Core 2.0 project for Visual Basic<ept id="p2">](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip)</ept>, from the <bpt id="p3">[</bpt>dotnet/docs GitHub repository<ept id="p3">](https://github.com/dotnet/docs)</ept>.</source>
          <target state="translated">Sie können auch einen vollständigen Satz von herunterladen <ph id="ph1">`String.Format`</ph> Beispiele, die enthalten sind eine <bpt id="p1">[</bpt>.NET Core 2.0-Projekt für C#-<ept id="p1">](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip)</ept> und ein <bpt id="p2">[</bpt>.NET Core 2.0-Projekt für Visual Basic<ept id="p2">](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip)</ept>, aus der <bpt id="p3">[</bpt>Dotnet/Docs GitHub-Repository<ept id="p3">](https://github.com/dotnet/docs)</ept>.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following are some of the examples included in the article:</source>
          <target state="translated">Es folgen einige Beispiele, die im Artikel enthalten:</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a format string</source>
          <target state="translated">Erstellen Sie eine Formatzeichenfolge</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Inserting a string<ept id="p1">](#inserting-a-string)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Eine Zeichenfolge eingefügt.<ept id="p1">](#inserting-a-string)</ept></target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The format item<ept id="p1">](#the-format-item)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Das Formatelement<ept id="p1">](#the-format-item)</ept></target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Format items that have the same index<ept id="p1">](#format-items-that-have-the-same-index)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Formatelemente, die den gleichen Index aufweisen.<ept id="p1">](#format-items-that-have-the-same-index)</ept></target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Control formatted output</source>
          <target state="translated">Steuern Sie die formatierten Ausgabe</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling formatting<ept id="p1">](#controlling-formatting)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Steuern der Formatierung<ept id="p1">](#controlling-formatting)</ept></target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling spacing<ept id="p1">](#controlling-spacing)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Steuern der Abstand<ept id="p1">](#controlling-spacing)</ept></target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling alignment<ept id="p1">](#controlling-alignment)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Steuern der Ausrichtung<ept id="p1">](#controlling-alignment)</ept></target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling the number of integral digits<ept id="p1">](#how-do-i-control-the-number-of-integral-digits)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Steuern der Anzahl von ganzzahligen Ziffern<ept id="p1">](#how-do-i-control-the-number-of-integral-digits)</ept></target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling the number of digits after the decimal separator<ept id="p1">](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Steuern die Anzahl der Ziffern nach dem Dezimaltrennzeichen<ept id="p1">](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)</ept></target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Including literal braces in a result string<ept id="p1">](#braces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Literal geschweifte Klammern einschließlich in eine Ergebniszeichenfolge<ept id="p1">](#braces)</ept></target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Make format strings culture-sensitive</source>
          <target state="translated">Stellen Sie Formatzeichenfolgen kulturabhängige</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Culture-sensitive formatting<ept id="p1">](#culture-sensitive-formatting)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Kulturabhängige Formatierung<ept id="p1">](#culture-sensitive-formatting)</ept></target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Customize the formatting operation</source>
          <target state="translated">Anpassen des Formatierungsvorgangs</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>A custom formatting operation<ept id="p1">](#example-a-custom-formatting-operation)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Eine benutzerdefinierte Formatierungsvorgang<ept id="p1">](#example-a-custom-formatting-operation)</ept></target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>An intercept provider and Roman numeral formatter<ept id="p1">](#example-an-intercept-provider-and-roman-numeral-formatter)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Eine Konstante Glied-Anbieter und römische Zahlzeichen Formatierer<ept id="p1">](#example-an-intercept-provider-and-roman-numeral-formatter)</ept></target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated">Eine <bpt id="p1">[</bpt>kombinierte Formatzeichenfolge<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>The object to format.</source>
          <target state="translated">Das zu formatierende Objekt.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>Replaces one or more format items in a string with the string representation of a specified object.</source>
          <target state="translated">Ersetzt mindestens ein Formatelement in einer Zeichenfolge durch die Zeichenfolgendarstellung eines angegebenen Objekts.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which any format items are replaced by the string representation of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>.</source>
          <target state="translated">Eine Kopie von <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, in der alle Formatelemente durch die Zeichenfolgendarstellung von <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of an expression to its string representation and to embed that representation in a string.</source>
          <target state="translated">Diese Methode verwendet die <bpt id="p1">[</bpt>Funktion für kombinierte Formatierung<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> um den Wert eines Ausdrucks in seiner Zeichenfolgendarstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object)">
          <source>Example: Formatting a single argument</source>
          <target state="translated">Beispiel: Formatieren eines einzelnen Arguments</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> method to embed an individual's age in the middle of a string.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> Methode, um ein einzelnes Alter in der Mitte einer Zeichenfolge einzubetten.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>The format item in <ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated">Das Formatelement in <ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist ungültig.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>The index of a format item is not zero.</source>
          <target state="translated">Der Index eines Formatelements ist nicht 0 (null).</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated">Eine <bpt id="p1">[</bpt>kombinierte Formatzeichenfolge<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>An object array that contains zero or more objects to format.</source>
          <target state="translated">Ein Objektarray mit 0 (null) oder mehr zu formatierenden Objekten.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</source>
          <target state="translated">Ersetzt das Formatelement in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung eines entsprechenden Objekts in einem angegebenen Array.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representation of the corresponding objects in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Eine Kopie von <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, in der die Formatelemente durch die Zeichenfolgendarstellung der entsprechenden Objekte in <ph id="ph2">&lt;paramref name="args" /&gt;</ph> ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of four or more expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Diese Methode verwendet die <bpt id="p1">[</bpt>Funktion für kombinierte Formatierung<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> auf den Wert der vier oder mehr Ausdrücke, deren zeichenfolgendarstellungen konvertiert und die Darstellung in eine Zeichenfolge eingebettet werden sollen.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Since the <ph id="ph1">`args`</ph> parameter is marked with the <ph id="ph2">&lt;xref:System.ParamArrayAttribute?displayProperty=nameWithType&gt;</ph> attribute, you can pass the objects to the method as individual arguments or as an <ph id="ph3">&lt;xref:System.Object&gt;</ph> array.</source>
          <target state="translated">Da die <ph id="ph1">`args`</ph> Parameter entsprechend markiert ist, mit der <ph id="ph2">&lt;xref:System.ParamArrayAttribute?displayProperty=nameWithType&gt;</ph> -Attribut, Sie können die Objekte an die Methode übergeben als einzelne Argumente oder als ein <ph id="ph3">&lt;xref:System.Object&gt;</ph> Array.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Example: Formatting more than three arguments</source>
          <target state="translated">Beispiel: Formatieren von mehr als drei Argumente</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>This example creates a string that contains data on the high and low temperature on a particular date.</source>
          <target state="translated">Dieses Beispiel erstellt eine Zeichenfolge, die Daten auf den Höchst- und Tiefsttemperatur an einem bestimmten Datum enthält.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>The composite format string has five format items in the C# example and six in the Visual Basic example.</source>
          <target state="translated">Die zusammengesetzte Formatierungszeichenfolge verfügt über fünf Formatelemente im C#-Beispiel und sechs in Visual Basic-Beispiel.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Two of the format items define the width of their corresponding value's string representation, and the first format item also includes a standard date and time format string.</source>
          <target state="translated">Zwei der die Formatelemente definieren die Breite der Zeichenfolgendarstellung des Werts auf ihre entsprechenden, und das erste Formatelement enthält auch Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolge.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>You can also pass the objects to be formatted as an array rather than a an argument list.</source>
          <target state="translated">Sie können auch die Objekte, die als Array formatiert werden übergeben und nicht als eine Argumentliste.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> or <ph id="ph2">&lt;paramref name="args" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="args" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist ungültig.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>The index of a format item is less than zero, or greater than or equal to the length of the <ph id="ph1">&lt;paramref name="args" /&gt;</ph> array.</source>
          <target state="translated">Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich der Länge des <ph id="ph1">&lt;paramref name="args" /&gt;</ph>-Arrays.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated">Eine <bpt id="p1">[</bpt>kombinierte Formatzeichenfolge<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>The object to format.</source>
          <target state="translated">Das zu formatierende Objekt.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>Replaces the format item or items in a specified string with the string representation of the corresponding object.</source>
          <target state="translated">Ersetzt die Formatelemente in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung des angegebenen Objekts.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>A parameter supplies culture-specific formatting information.</source>
          <target state="translated">Ein Parameter liefert kulturspezifische Formatierungsinformationen.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format item or items have been replaced by the string representation of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>.</source>
          <target state="translated">Eine Kopie von <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, in der die Formatelemente durch die Zeichenfolgendarstellung von <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of an expression to its string representation and to embed that representation in a string.</source>
          <target state="translated">Diese Methode verwendet die <bpt id="p1">[</bpt>Funktion für kombinierte Formatierung<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> um den Wert eines Ausdrucks in seiner Zeichenfolgendarstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">Beim Ausführen der Konvertierung, verwendet die Methode kulturabhängige Formatierung oder ein benutzerdefiniertes Formatierungsprogramm.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>The method converts <ph id="ph1">`arg0`</ph> to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">Konvertiert die Methode <ph id="ph1">`arg0`</ph> in seine Zeichenfolgendarstellung durch Aufrufen seiner <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> Methode oder das Objekt entsprechende schließt Formatelement eine Formatzeichenfolge durch Aufrufen seiner <bpt id="p2">**</bpt>ToString ( String, IFormatProvider)<ept id="p2">**</ept> Methode.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">Wenn diese Methoden nicht vorhanden sind, ruft das Objekt des parameterlosen <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> Methode.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist ungültig.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>The index of a format item is not zero.</source>
          <target state="translated">Der Index eines Formatelements ist nicht 0 (null).</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated">Eine <bpt id="p1">[</bpt>kombinierte Formatzeichenfolge<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>An object array that contains zero or more objects to format.</source>
          <target state="translated">Ein Objektarray mit 0 (null) oder mehr zu formatierenden Objekten.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>Replaces the format items in a string with the string representations of corresponding objects in a specified array.</source>
          <target state="translated">Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellungen entsprechender Objekte in einem angegebenen Array.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>A parameter supplies culture-specific formatting information.</source>
          <target state="translated">Ein Parameter liefert kulturspezifische Formatierungsinformationen.</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representation of the corresponding objects in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Eine Kopie von <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, in der die Formatelemente durch die Zeichenfolgendarstellung der entsprechenden Objekte in <ph id="ph2">&lt;paramref name="args" /&gt;</ph> ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert four or more expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Diese Methode verwendet die <bpt id="p1">[</bpt>Funktion für kombinierte Formatierung<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> um vier oder mehr Ausdrücke, deren zeichenfolgendarstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge eingebettet werden sollen.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">Beim Ausführen der Konvertierung, verwendet die Methode kulturabhängige Formatierung oder ein benutzerdefiniertes Formatierungsprogramm.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>The method converts each <ph id="ph1">&lt;xref:System.Object&gt;</ph> argument to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">Die Methode konvertiert jedes <ph id="ph1">&lt;xref:System.Object&gt;</ph> Argument in seine Zeichenfolgendarstellung durch Aufrufen seiner <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> Methode oder das Objekt entsprechende schließt Formatelement eine Formatzeichenfolge durch Aufrufen seiner <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> Methode.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">Wenn diese Methoden nicht vorhanden sind, ruft das Objekt des parameterlosen <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> Methode.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>Example: Culture-sensitive formatting</source>
          <target state="translated">Beispiel: Kulturabhängige Formatierung</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>This example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method to display the string representation of some date and time values and numeric values by using several different cultures.</source>
          <target state="translated">Dieses Beispiel verwendet die <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> Methode, um die Zeichenfolgendarstellung für einige Datums-und Uhrzeitwerte und numerische Werte anzeigen, indem Sie verschiedene Kulturen verwenden.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> or <ph id="ph2">&lt;paramref name="args" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="args" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist ungültig.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>The index of a format item is less than zero, or greater than or equal to the length of the <ph id="ph1">&lt;paramref name="args" /&gt;</ph> array.</source>
          <target state="translated">Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich der Länge des <ph id="ph1">&lt;paramref name="args" /&gt;</ph>-Arrays.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated">Eine <bpt id="p1">[</bpt>kombinierte Formatzeichenfolge<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">Das erste zu formatierende Objekt.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">Das zweite zu formatierende Objekt.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of two specified objects.</source>
          <target state="translated">Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von zwei angegebenen Objekten.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which format items are replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> and <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>.</source>
          <target state="translated">Eine Kopie von <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, in der Formatelemente durch die Zeichenfolgendarstellung von <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> und <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of two expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Diese Methode verwendet die <bpt id="p1">[</bpt>Funktion für kombinierte Formatierung<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> , den Wert von zwei Ausdrücken, deren zeichenfolgendarstellungen konvertieren und diese Darstellungen in eine Zeichenfolge eingebettet werden sollen.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>Example: Formatting two arguments</source>
          <target state="translated">Beispiel: Formatieren von zwei Argumenten</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>This example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29&gt;</ph> method to display time and temperature data stored in a generic <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> object.</source>
          <target state="translated">Dieses Beispiel verwendet die <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29&gt;</ph> anzuzeigenden Zeit und die Temperatur Datenspeichern in eine generische Methode <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>Note that the format string has three format items, although there are only two objects to format.</source>
          <target state="translated">Beachten Sie, dass die Formatzeichenfolge drei Formatelemente, obwohl nur zwei Objekte so formatieren Sie vorhanden sind.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>This is because the first object in the list (a date and time value) is used by two format items: The first format item displays the time, and the second displays the date.</source>
          <target state="translated">Ursache hierfür ist das erste Objekt in der Liste (ein Wert für Datum und Uhrzeit) durch zwei Formatelementen verwendet wird: das erste Format Element zeigt die Zeit, während die zweite zeigt das Datum an.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist ungültig.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>The index of a format item is not zero or one.</source>
          <target state="translated">Der Index eines Formatelements ist nicht 0 (null) oder 1.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated">Eine <bpt id="p1">[</bpt>kombinierte Formatzeichenfolge<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">Das erste zu formatierende Objekt.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">Das zweite zu formatierende Objekt.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of two specified objects.</source>
          <target state="translated">Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von zwei angegebenen Objekten.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>A parameter supplies culture-specific formatting information.</source>
          <target state="translated">Ein Parameter liefert kulturspezifische Formatierungsinformationen.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which format items are replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> and <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>.</source>
          <target state="translated">Eine Kopie von <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, in der Formatelemente durch die Zeichenfolgendarstellung von <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> und <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert two expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Diese Methode verwendet die <bpt id="p1">[</bpt>Funktion für kombinierte Formatierung<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> zweier Ausdrücke in ihren zeichenfolgendarstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge eingebettet werden sollen.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">Beim Ausführen der Konvertierung, verwendet die Methode kulturabhängige Formatierung oder ein benutzerdefiniertes Formatierungsprogramm.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The method converts each <ph id="ph1">&lt;xref:System.Object&gt;</ph> argument to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">Die Methode konvertiert jedes <ph id="ph1">&lt;xref:System.Object&gt;</ph> Argument in seine Zeichenfolgendarstellung durch Aufrufen seiner <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> Methode oder das Objekt entsprechende schließt Formatelement eine Formatzeichenfolge durch Aufrufen seiner <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> Methode.</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">Wenn diese Methoden nicht vorhanden sind, ruft das Objekt des parameterlosen <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> Methode.</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist ungültig.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The index of a format item is not zero or one.</source>
          <target state="translated">Der Index eines Formatelements ist nicht 0 (null) oder 1.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated">Eine <bpt id="p1">[</bpt>kombinierte Formatzeichenfolge<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">Das erste zu formatierende Objekt.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">Das zweite zu formatierende Objekt.</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The third object to format.</source>
          <target state="translated">Das dritte zu formatierende Objekt.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of three specified objects.</source>
          <target state="translated">Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von drei angegebenen Objekten.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph>.</source>
          <target state="translated">Eine Kopie von <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, in der die Formatelemente durch die Zeichenfolgendarstellung von <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> und <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph> ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of three expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Diese Methode verwendet die <bpt id="p1">[</bpt>Funktion für kombinierte Formatierung<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> auf den Wert der drei Ausdrücke in ihren zeichenfolgendarstellungen konvertiert und die Darstellung in eine Zeichenfolge eingebettet werden sollen.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>Example: Formatting three arguments</source>
          <target state="translated">Beispiel: Formatieren von drei Argumenten</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>This example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> method to create a string that illustrates the result of a Boolean <ph id="ph2">`And`</ph> operation with two integer values.</source>
          <target state="translated">Dieses Beispiel verwendet die <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> Methode, um eine Zeichenfolge zu erstellen, die das Ergebnis ein boolescher Wert veranschaulicht <ph id="ph2">`And`</ph> -Operation mit zwei ganzzahligen Werten.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>Note that the format string includes six format items, but the method has only three items in its parameter list, because each item is formatted in two different ways.</source>
          <target state="translated">Beachten Sie, dass die Formatzeichenfolge sechs Formatelemente enthält, aber die Methode verfügt über nur drei Elemente in der Parameterliste, da jedes Element auf zwei unterschiedliche Arten formatiert wird.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist ungültig.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The index of a format item is less than zero, or greater than two.</source>
          <target state="translated">Der Index eines Formatelements ist kleiner als 0 (null) oder größer als 2.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated">Eine <bpt id="p1">[</bpt>kombinierte Formatzeichenfolge<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">Das erste zu formatierende Objekt.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">Das zweite zu formatierende Objekt.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The third object to format.</source>
          <target state="translated">Das dritte zu formatierende Objekt.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of three specified objects.</source>
          <target state="translated">Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von drei angegebenen Objekten.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>An parameter supplies culture-specific formatting information.</source>
          <target state="translated">Ein Parameter liefert kulturspezifische Formatierungsinformationen.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph>.</source>
          <target state="translated">Eine Kopie von <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, in der die Formatelemente durch die Zeichenfolgendarstellung von <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> und <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph> ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert three expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Diese Methode verwendet die <bpt id="p1">[</bpt>Funktion für kombinierte Formatierung<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> drei Ausdrücke in ihren zeichenfolgendarstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge eingebettet werden sollen.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">Beim Ausführen der Konvertierung, verwendet die Methode kulturabhängige Formatierung oder ein benutzerdefiniertes Formatierungsprogramm.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The method converts each <ph id="ph1">&lt;xref:System.Object&gt;</ph> argument to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">Die Methode konvertiert jedes <ph id="ph1">&lt;xref:System.Object&gt;</ph> Argument in seine Zeichenfolgendarstellung durch Aufrufen seiner <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> Methode oder das Objekt entsprechende schließt Formatelement eine Formatzeichenfolge durch Aufrufen seiner <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> Methode.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">Wenn diese Methoden nicht vorhanden sind, ruft das Objekt des parameterlosen <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> Methode.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> ist ungültig.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The index of a format item is less than zero, or greater than two.</source>
          <target state="translated">Der Index eines Formatelements ist kleiner als 0 (null) oder größer als 2.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" uid="M:System.String.GetEnumerator">
          <source>Retrieves an object that can iterate through the individual characters in this string.</source>
          <target state="translated">Ruft ein Objekt ab, das die einzelnen Zeichen dieser Zeichenfolge durchlaufen kann.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" uid="M:System.String.GetEnumerator">
          <source>An enumerator object.</source>
          <target state="translated">Ein Enumeratorobjekt.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>Rather than calling the <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.CharEnumerator&gt;</ph> object that you then use to enumerate a string, you should instead use your language's iteration construct ( in C#,  in C++/CLR, and  in Visual Basic).</source>
          <target state="translated">Anstatt Aufrufen der <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> Methode zum Abrufen einer <ph id="ph2">&lt;xref:System.CharEnumerator&gt;</ph> Objekt, das Sie dann verwenden, um eine Zeichenfolge aufzulisten, verwenden Sie stattdessen Ihre Sprachkonstrukt Iteration (in c# in C + c++ / CLR, und in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source><bpt id="p1">[</bpt>foreach<ept id="p1">](~/docs/csharp/language-reference/keywords/foreach-in.md)</ept> in C#,                  <bpt id="p2">[</bpt>for each<ept id="p2">](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79)</ept> in C++/CLR, and                  <bpt id="p3">[</bpt>For Each<ept id="p3">](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)</ept> in Visual Basic).</source>
          <target state="translated"><bpt id="p1">[</bpt>Foreach<ept id="p1">](~/docs/csharp/language-reference/keywords/foreach-in.md)</ept> in c# <bpt id="p2">[</bpt>für jede<ept id="p2">](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79)</ept> in C + c++ / CLR und <bpt id="p3">[</bpt>für jede<ept id="p3">](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)</ept> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>This method enables you to iterate the individual characters in a string.</source>
          <target state="translated">Diese Methode können Sie die einzelnen Zeichen in einer Zeichenfolge durchlaufen werden kann.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>For example, the Visual Basic <ph id="ph1">`For Each`</ph> and C# <ph id="ph2">`foreach`</ph> statements invoke this method to return a <ph id="ph3">&lt;xref:System.CharEnumerator&gt;</ph> object that can provide read-only access to the characters in this string instance.</source>
          <target state="translated">Z. B. Visual Basic <ph id="ph1">`For Each`</ph> und C#- <ph id="ph2">`foreach`</ph> Anweisungen rufen Sie diese Methode zum Zurückgeben einer <ph id="ph3">&lt;xref:System.CharEnumerator&gt;</ph> Objekt, das nur-Lese-Zugriff auf die Zeichen dieser Zeichenfolgeninstanz bereitstellen kann.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>The following example iterates the characters in several strings and displays information about their individual characters.</source>
          <target state="translated">Das folgende Beispiel durchläuft die Zeichen in mehreren Zeichenfolgen und zeigt Informationen zu den einzelnen Zeichen.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>It uses the language iteration construct rather than a call to the <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> method.</source>
          <target state="translated">Er verwendet die Iteration Sprachkonstrukt statt einen Aufruf der <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" uid="M:System.String.GetHashCode">
          <source>Returns the hash code for this string.</source>
          <target state="translated">Gibt den Hashcode für diese Zeichenfolge zurück.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" uid="M:System.String.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The behavior of <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> is dependent on its implementation, which might change from one version of the common language runtime to another.</source>
          <target state="translated">Das Verhalten des <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> ist abhängig von seiner Implementierung, die von einer Version der common Language Runtime in einen anderen ändern kann.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>A reason why this might happen is to improve the performance of <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">Ein Grund, warum dies vorkommen kann, wird zum Verbessern der Leistung von <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>If two string objects are equal, the <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> method returns identical values.</source>
          <target state="translated">Wenn zwei Zeichenfolgenobjekte gleich sind, die <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> -Methode identische Werte zurück.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>However, there is not a unique hash code value for each unique string value.</source>
          <target state="translated">Es ist jedoch kein eindeutigen Hashcodewert für jeden eindeutigen Zeichenfolgenwert.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Different strings can return the same hash code.</source>
          <target state="translated">Andere Zeichenfolgen können den gleichen Hashcode zurückgeben.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The hash code itself is not guaranteed to be stable.</source>
          <target state="translated">Der Hashcode selbst ist nicht garantiert stabil.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Hash codes for identical strings can differ across versions of the .NET Framework and across platforms (such as 32-bit and 64-bit) for a single version of the .NET Framework.</source>
          <target state="translated">Hashcodes für identische Zeichenfolgen können über den .NET Framework-Versionen und Plattformen (z. B. 32-Bit- und 64-Bit) für eine einzelne Version von .NET Framework unterscheiden.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>In some cases, they can even differ by application domain.</source>
          <target state="translated">In einigen Fällen können sie auch nach Anwendungsdomäne unterscheiden.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>This implies two subsequent runs of the same program may return different hash codes.</source>
          <target state="translated">Dies bedeutet, dass zwei nachfolgende Ausführungen desselben Programms möglicherweise unterschiedliche Hashcodes zurückgeben.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.</source>
          <target state="translated">Als Ergebnis Codes niemals außerhalb der Anwendungsdomäne verwendet werden sollte in der sie erstellt wurden, sollten niemals als Felder in einer Auflistung verwendet werden, und sie nie beibehalten werden soll.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Finally, don't use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</source>
          <target state="translated">Abschließend verwenden Sie keine des Hashcodes statt eines Werts von einer kryptografischen Hashfunktion zurückgegeben, wenn Sie einen kryptografisch starken Hash benötigen.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>For cryptographic hashes, use a class derived from the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">Verwenden Sie für kryptografische Hashes eine abgeleitete Klasse die <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>For more information about hash codes, see <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Hashcodes finden Sie unter <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>In desktop apps, you can use the             <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm&gt; element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept> to generate unique hash codes on a per application domain basis.</source>
          <target state="translated">Bei desktop-apps können Sie die <bpt id="p1">[</bpt> <ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm &gt;-Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept> zum Generieren eindeutiger Hashcodes für die eine pro Anwendungsdomäne.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</source>
          <target state="translated">Dies kann verringern Sie die Anzahl der Konflikte und verbessern die allgemeine Leistung der Einfüge- und Suchvorgänge, die Hashtabellen verwenden.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The following example shows how to use the                <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm&gt; element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die <bpt id="p1">[</bpt> <ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm &gt;-Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It defines a  to generate unique hash codes on a per application domain basis.</source>
          <target state="translated">Definiert eine zum Generieren eindeutiger Hashcodes für eine pro Anwendungsdomäne.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</source>
          <target state="translated">Dies kann verringern Sie die Anzahl der Konflikte und verbessern die allgemeine Leistung der Einfüge- und Suchvorgänge, die Hashtabellen verwenden.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The following example shows how to use the .</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It defines a <ph id="ph1">`DisplayString`</ph> class that includes a private string constant, <ph id="ph2">`s`</ph>, whose value is "This is a string."</source>
          <target state="translated">Definiert eine <ph id="ph1">`DisplayString`</ph> Klasse, die eine private Zeichenfolgenkonstante enthält <ph id="ph2">`s`</ph>, dessen Wert ist "This is String".</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It also includes a <ph id="ph1">`ShowStringHashCode`</ph> method that displays the string value and its hash code along with the name of the application domain in which the method is executing.</source>
          <target state="translated">Außerdem enthält sie eine <ph id="ph1">`ShowStringHashCode`</ph>-Methode, die den Zeichenfolgenwert und dessen Hashcode zusammen mit dem Namen der Anwendungsdomäne anzeigt, in der die Methode ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>When you run the example without supplying a configuration file, it displays output similar to the following.</source>
          <target state="translated">Wenn Sie das Beispiel ausführen, ohne eine Konfigurationsdatei anzugeben, wird die folgende Ausgabe angezeigt.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Note that the hash codes for the string are identical in the two application domains.</source>
          <target state="translated">Beachten Sie, dass die Hashcodes für die Zeichenfolge in den zwei Anwendungsdomänen identisch sind.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.</source>
          <target state="translated">Wenn Sie jedoch die folgende Konfigurationsdatei im Verzeichnis des Beispiels hinzufügen und dann das Beispiel ausführen, unterscheiden sich die Hashcodes je nach Anwendungsdomäne.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>When the configuration file is present, the example displays the following output:</source>
          <target state="translated">Wenn die Konfigurationsdatei vorhanden ist, zeigt das Beispiel die folgende Ausgabe an:</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Hash codes are used to insert and retrieve keyed objects from hash tables efficiently.</source>
          <target state="translated">Hashcodes sind zum Einfügen und Abrufen von Schlüsseln Objekten effizient Hashtabellen verwendet.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>However, hash codes don't uniquely identify strings.</source>
          <target state="translated">Allerdings identifizieren nicht Hashcodes Zeichenfolgen eindeutig.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings.</source>
          <target state="translated">Identische Zeichenfolgen haben gleich Hashcodes, aber die common Language Runtime kann auch den gleichen Hashcode in andere Zeichenfolgen zuweisen.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>In addition, hash codes can vary by version of the .NET Framework, by platform within a single version, and by application domain.</source>
          <target state="translated">Darüber hinaus variieren Hashcodes von .NET Framework-Version, von der Plattform in eine einzelne Version und nach Anwendungsdomäne.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.</source>
          <target state="translated">Aus diesem Grund sollten Sie nicht serialisieren oder Code Hashwerte beibehalten noch sollten Sie verwenden diese als Schlüssel in einer Hashtabelle oder dem Wörterbuch.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>For additional information about the use of hash codes and the <ph id="ph1">`GetHashCode`</ph> method, see <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Verwendung von Hashcodes und <ph id="ph1">`GetHashCode`</ph> -Methode finden Sie unter <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> method using various input strings.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> Methode, die mit verschiedenen Eingabezeichenfolgen.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The value returned by <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> is platform-dependent.</source>
          <target state="translated">Der Rückgabewert von <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> ist plattformabhängig.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It differs on the 32-bit and 64-bit versions of the .NET Framework.</source>
          <target state="translated">Es unterscheidet sich auf die 32-Bit und 64-Bit-Versionen von .NET Framework.</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It also can differ between versions of the .NET Framework.</source>
          <target state="translated">Sie können auch die unterscheidet sich zwischen verschiedenen Versionen von .NET Framework.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" uid="M:System.String.GetTypeCode">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.TypeCode" /&gt;</ph> for class <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Gibt einen <ph id="ph1">&lt;see cref="T:System.TypeCode" /&gt;</ph> für das <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" uid="M:System.String.GetTypeCode">
          <source>The enumerated constant, <ph id="ph1">&lt;see cref="F:System.TypeCode.String" /&gt;</ph>.</source>
          <target state="translated">Die Enumerationskonstante <ph id="ph1">&lt;see cref="F:System.TypeCode.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetTypeCode">
          <source>The following example displays the <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> enumerated constant for the <ph id="ph2">&lt;xref:System.String&gt;</ph> type.</source>
          <target state="translated">Das folgende Beispiel zeigt die <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> Enumerationskonstante, die für die <ph id="ph2">&lt;xref:System.String&gt;</ph> Typ.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the zero-based index of the first occurrence of a specified Unicode character or string within this instance.</source>
          <target state="translated">Gibt den NULL-basierten Index des ersten Vorkommens eines angegebenen Unicode-Zeichens oder einer angegebenen Unicode-Zeichenfolge in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the character or string is not found in this instance.</source>
          <target state="translated">Die Methode gibt -1 zurück, wenn das Zeichen oder die Zeichenfolge in dieser Instanz nicht gefunden wird.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char)">
          <source>A Unicode character to seek.</source>
          <target state="translated">Ein zu suchendes Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char)">
          <source>Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</source>
          <target state="translated">Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not.</source>
          <target state="translated">Die nullbasierte Indexposition von <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, wenn dieses Zeichen gefunden wurde, andernfalls -1.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Um eine kulturabhängige Suche durchzuführen, verwenden die <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>The following example demonstrates how you can search a <ph id="ph1">&lt;xref:System.String&gt;</ph> for a character using the <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Im folgende Beispiel wird veranschaulicht, wie Sie suchen können eine <ph id="ph1">&lt;xref:System.String&gt;</ph> für ein Zeichen unter Verwendung der <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>The string to seek.</source>
          <target state="translated">Die zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
          <target state="translated">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not.</source>
          <target state="translated">Die nullbasierte Indexposition von <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, wenn diese Zeichenfolge gefunden wurde, andernfalls -1.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is 0.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist, wird 0 zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Diese Methode führt eine Word (Groß-/Kleinschreibung beachtet und der Kultur)-Suche, die mit der aktuellen Kultur.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>The search begins at the first character position of this instance and continues until the last character position.</source>
          <target state="translated">Die Suche beginnt an der ersten Zeichenposition dieser Instanz und wird fortgesetzt, bis der letzten Zeichenposition.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Bei einer kulturabhängige Suche, bei der <ph id="ph1">`value`</ph> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</source>
          <target state="translated">Wenn <ph id="ph1">`value`</ph> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> Methode gibt immer 0 (null), um anzugeben, dass die Übereinstimmung am Anfang der aktuellen Instanz gefunden wird.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> Methode wird verwendet, um drei Teilzeichenfolgen (einen bedingten Bindestrich (U + 00AD), einen bedingten Bindestrich gefolgt von "n" und einen bedingten Bindestrich gefolgt von "m") in zwei Zeichenfolgen zu suchen.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in <ph id="ph2">`value`</ph>.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, auf die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher sind in jedem Fall, da der bedingte Bindestrich ein ignorierbares Zeichen ist das Ergebnis das gleiche wie bei der bedingten Bindestrich in nicht enthalten war <ph id="ph2">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.</source>
          <target state="translated">Bei der Suche nach nur einen bedingten Bindestrich gibt die Methode 0 (null), um anzugeben, dass es eine Übereinstimmung am Anfang der Zeichenfolge gefunden wurde.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>The following example searches for the "n" in "animal".</source>
          <target state="translated">Das folgende Beispiel sucht nach "n" in "Animal".</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Because string indexes begin at zero rather than one, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method indicates that the "n" is at position 1.</source>
          <target state="translated">Da die Zeichenfolge Indizes auf 0 (null) statt auf 1 beginnen die <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> Methode gibt an, dass die "n" an Position 1.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to determine the starting position of an animal name in a sentence.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode, um die Anfangsposition des Namens einer Eindringens in einem Satz zu bestimmen.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>It then uses this position to insert an adjective that describes the animal into the sentence.</source>
          <target state="translated">Anschließend wird dieser Position verwendet, um ein Adjektiv einfügen, die in den Satz der Tier beschreibt.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Wie in beschrieben <bpt id="p1">[</bpt>bewährte Methoden für die Verwendung von Zeichenfolgen<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>To find the first index of a substring within a string instance by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">`comparisonType`</ph> parameter.</source>
          <target state="translated">Um den ersten Index einer Teilzeichenfolge innerhalb einer Zeichenfolgeninstanz mithilfe der Vergleichsregeln der aktuellen Kultur zu suchen, rufen die <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> methodenüberladung mit einem Wert von <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> für seine <ph id="ph3">`comparisonType`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>A Unicode character to seek.</source>
          <target state="translated">Ein zu suchendes Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</source>
          <target state="translated">Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The search starts at a specified character position.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the string if that character is found, or -1 if it is not.</source>
          <target state="translated">Die nullbasierte Indexposition von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> ab dem Anfang der Zeichenfolge, wenn dieses Zeichen gefunden wurde, andernfalls -1.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>Index numbering starts from 0.</source>
          <target state="translated">Nummerierung beginnt bei 0.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Der <ph id="ph1">`startIndex`</ph>-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
          <target state="translated">Wenn <ph id="ph1">`startIndex`</ph> entspricht der Länge der Zeichenfolgeninstanz, die Methode gibt-1 zurück.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The search ranges from <ph id="ph1">`startIndex`</ph> to the end of the string.</source>
          <target state="translated">Die Suche erfolgt von <ph id="ph1">`startIndex`</ph> bis zum Ende der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Um eine kulturabhängige Suche durchzuführen, verwenden die <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 (zero) or greater than the length of the string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> ist kleiner als 0 (null) oder größer als die Länge der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">Die zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
          <target state="translated">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The search starts at a specified character position.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">Die nullbasierte Indexposition von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist, wird <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Index numbering starts from 0.</source>
          <target state="translated">Nummerierung beginnt bei 0.</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Der <ph id="ph1">`startIndex`</ph>-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
          <target state="translated">Wenn <ph id="ph1">`startIndex`</ph> entspricht der Länge der Zeichenfolgeninstanz, die Methode gibt-1 zurück.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Diese Methode führt eine Word (Groß-/Kleinschreibung beachtet und der Kultur)-Suche, die mit der aktuellen Kultur.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and continues until the last character position.</source>
          <target state="translated">Die Suche beginnt an der <ph id="ph1">`startIndex`</ph> Zeichenposition dieser Instanz und wird fortgesetzt, bis der letzten Zeichenposition.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Bei einer kulturabhängige Suche, bei der <ph id="ph1">`value`</ph> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Wenn <ph id="ph1">`value`</ph> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> immer Methodenrückgabe <ph id="ph3">`startIndex`</ph>, also die Zeichenposition, an dem die Suche beginnt.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> Methode wird verwendet, um die Position des (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" in zwei Zeichenfolgen zu suchen.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, auf die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder später in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The following example searches for all occurrences of a specified string within a target string.</source>
          <target state="translated">Das folgende Beispiel sucht nach allen Vorkommen einer angegebenen Zeichenfolge in eine Zielzeichenfolge.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 (zero) or greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> ist kleiner als 0 (null) oder größer als die Länge diese Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Wie in beschrieben <bpt id="p1">[</bpt>bewährte Methoden für die Verwendung von Zeichenfolgen<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>To find the first index of a substring that occurs after a particular character position by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">`comparisonType`</ph> parameter.</source>
          <target state="translated">Um den ersten Index einer Teilzeichenfolge, die auftritt, nach einer bestimmten Zeichenposition mithilfe der Vergleichsregeln der aktuellen Kultur zu suchen, rufen die <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> methodenüberladung mit einem Wert von <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> für seine <ph id="ph3">`comparisonType`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Die zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt an.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>A parameter specifies the type of search to use for the specified string.</source>
          <target state="translated">Ein Parameter gibt den Typ der Suche für die angegebene Zeichenfolge an.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not.</source>
          <target state="translated">Die Indexposition des <ph id="ph1">&lt;paramref name="value" /&gt;</ph>-Parameters, wenn diese Zeichenfolge gefunden wurde, andernfalls -1.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is 0.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist, wird 0 zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated">Die <ph id="ph1">`comparisonType`</ph> Parameter gibt an, dass für die Suche der <ph id="ph2">`value`</ph> Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung und mithilfe von Word oder Ordinalvergleichsregeln.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method that find the first occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Die folgenden Exampledemonstrates drei Überladungen, der die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> -Methode, die das erste Vorkommen einer Zeichenfolge in eine andere Zeichenfolge, die mit unterschiedlichen Werten suchen der <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> ist kein gültiger <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Bei einer kulturabhängige Suche (das heißt, wenn <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> nicht <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> ist), bei der <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> Methode gibt immer 0 (null), um anzugeben, dass die Übereinstimmung am Anfang der aktuellen Instanz gefunden wird.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> Methode wird verwendet, um drei Teilzeichenfolgen (einen bedingten Bindestrich (U + 00AD), einen bedingten Bindestrich gefolgt von "n" und einen bedingten Bindestrich gefolgt von "m") in zwei Zeichenfolgen zu suchen.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, auf die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher, da der bedingte Bindestrich ein ignorierbares Zeichen ist, eine kulturabhängige Suche derselbe Wert zurückgegeben, die es zurückgegeben würde, wenn der bedingte Bindestrich wurden nicht in der Suchzeichenfolge in enthalten.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</source>
          <target state="translated">Eine ordinale Suche erfolgreich sucht den bedingten Bindestrich in eine Zeichenfolge und gibt an, dass er nicht vorhanden ist aus der zweiten Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>A Unicode character to seek.</source>
          <target state="translated">Ein zu suchendes Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Die Anzahl der zu überprüfenden Zeichenpositionen.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified character in this instance.</source>
          <target state="translated">Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Zeichens in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the string if that character is found, or -1 if it is not.</source>
          <target state="translated">Die nullbasierte Indexposition von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> ab dem Anfang der Zeichenfolge, wenn dieses Zeichen gefunden wurde, andernfalls -1.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">Die Suche beginnt an <ph id="ph1">`startIndex`</ph> und weiterhin <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">Das Zeichen an der <ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph> ist in der Suche nicht enthalten.</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>Index numbering starts from 0 (zero).</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Der <ph id="ph1">`startIndex`</ph>-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Um eine kulturabhängige Suche durchzuführen, verwenden die <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> ist größer als die Länge dieser Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist größer als die Länge dieser Zeichenfolge minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">Die zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Die Anzahl der zu überprüfenden Zeichenpositionen.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
          <target state="translated">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">Die nullbasierte Indexposition von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist, wird <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Index numbering starts from 0 (zero).</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Der <ph id="ph1">`startIndex`</ph>-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Diese Methode führt eine Word (Groß-/Kleinschreibung beachtet und der Kultur)-Suche, die mit der aktuellen Kultur.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">Die Suche beginnt an <ph id="ph1">`startIndex`</ph> und weiterhin <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">Das Zeichen an der <ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph> ist in der Suche nicht enthalten.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Bei einer kulturabhängige Suche, bei der <ph id="ph1">`value`</ph> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Wenn <ph id="ph1">`value`</ph> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> immer Methodenrückgabe <ph id="ph3">`startIndex`</ph>, also die Zeichenposition, an dem die Suche beginnt.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Methode wird verwendet, um die Position des (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" ab dem dritten bis sechsten Zeichenpositionen werden in zwei Zeichenfolgen zu suchen.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, auf die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The following example finds the index of all occurrences of the string "he" within a substring of another string.</source>
          <target state="translated">Das folgende Beispiel sucht den Index der alle Vorkommen der Zeichenfolge "he" in einer Teilzeichenfolge einer anderen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Note that the number of characters to be searched must be recalculated for each search iteration.</source>
          <target state="translated">Beachten Sie, dass die Anzahl der Zeichen, die durchsucht werden für jede Iteration Suche neu berechnet werden muss.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> ist größer als die Länge dieser Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist größer als die Länge dieser Zeichenfolge minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Wie in beschrieben <bpt id="p1">[</bpt>bewährte Methoden für die Verwendung von Zeichenfolgen<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>To use the comparison rules of the current culture to perform this operation, call the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">`comparisonType`</ph> parameter.</source>
          <target state="translated">Um die Vergleichsregeln eines der aktuellen Kultur verwenden, um diesen Vorgang auszuführen, rufen die <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> methodenüberladung mit einem Wert von <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> für seine <ph id="ph3">`comparisonType`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Die zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt an.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Parameters specify the starting search position in the current string and the type of search to use for the specified string.</source>
          <target state="translated">Parameter geben die Anfangssuchposition in der aktuellen Zeichenfolge und den Typ der Suche an, die für die angegebene Zeichenfolge verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The zero-based index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">Die nullbasierte Indexposition des <ph id="ph1">&lt;paramref name="value" /&gt;</ph>-Parameters vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist, wird <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Index numbering starts from 0.</source>
          <target state="translated">Nummerierung beginnt bei 0.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Der <ph id="ph1">`startIndex`</ph>-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
          <target state="translated">Wenn <ph id="ph1">`startIndex`</ph> entspricht der Länge der Zeichenfolgeninstanz, die Methode gibt-1 zurück.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated">Die <ph id="ph1">`comparisonType`</ph> Parameter gibt an, dass für die Suche der <ph id="ph2">`value`</ph> Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung und mithilfe von Word oder Ordinalvergleichsregeln.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method that find the first occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Die folgenden Exampledemonstrates drei Überladungen, der die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> -Methode, die das erste Vorkommen einer Zeichenfolge in eine andere Zeichenfolge, die mit unterschiedlichen Werten suchen der <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 (zero) or greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> ist kleiner als 0 (null) oder größer als die Länge diese Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> ist kein gültiger <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Bei einer kulturabhängige Suche (das heißt, wenn <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> nicht <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> ist), bei der <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> immer Methodenrückgabe <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, also die Zeichenposition, an dem die Suche beginnt.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting with the third character position in two strings.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> Methode wird verwendet, um die Position des (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" beginnend mit der dritten Position des Zeichens in zwei Zeichenfolgen zu suchen.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn das Beispiel ausgeführt wird, auf die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Die zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Die Anzahl der zu überprüfenden Zeichenpositionen.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt an.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</source>
          <target state="translated">Parameter geben die Anfangssuchposition in der aktuellen Zeichenfolge, die Anzahl der Zeichen in der aktuellen Zeichenfolge und den Typ der Suche für die angegebene Zeichenfolge an.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The zero-based index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">Die nullbasierte Indexposition des <ph id="ph1">&lt;paramref name="value" /&gt;</ph>-Parameters vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist, wird <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Index numbering starts from 0 (zero).</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Der <ph id="ph1">`startIndex`</ph>-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">Die Suche beginnt an <ph id="ph1">`startIndex`</ph> und weiterhin <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">Das Zeichen an der <ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph> ist in der Suche nicht enthalten.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated">Die <ph id="ph1">`comparisonType`</ph> Parameter gibt an, dass für die Suche der <ph id="ph2">`value`</ph> Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung und mithilfe von Word oder Ordinalvergleichsregeln.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method that find the first occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Die folgenden Exampledemonstrates drei Überladungen, der die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> -Methode, die das erste Vorkommen einer Zeichenfolge in eine andere Zeichenfolge, die mit unterschiedlichen Werten suchen der <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> ist größer als die Länge dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist größer als die Länge dieser Zeichenfolge minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> ist kein gültiger <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Bei einer kulturabhängige Suche (das heißt, wenn <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> nicht <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> ist), bei der <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> immer Methodenrückgabe <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, also die Zeichenposition, an dem die Suche beginnt.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> Methode wird verwendet, um die Position des (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" ab dem dritten bis sechsten Zeichenpositionen werden in zwei Zeichenfolgen zu suchen.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, auf die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>When it performs an ordinal comparison, however, it finds the substring only in the first string.</source>
          <target state="translated">Wenn sie einen Ordinalvergleich ausführt, sucht es die Teilzeichenfolge jedoch nur in der ersten Zeichenfolge fest.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</source>
          <target state="translated">Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">Gibt den Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the characters in the array are not found in this instance.</source>
          <target state="translated">Die Methode gibt -1 zurück, wenn die Zeichen im Array nicht in dieser Instanz gefunden werden.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>The zero-based index position of the first occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> in dieser Instanz. -1, wenn kein Zeichen in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> gefunden wurde.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`anyOf`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>If <ph id="ph1">`anyOf`</ph> is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).</source>
          <target state="translated">Wenn <ph id="ph1">`anyOf`</ph> wird ein leeres Array, die Methode findet eine Übereinstimmung am Anfang der Zeichenfolge (d. h. am index 0 (null)).</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Um eine kulturabhängige Suche durchzuführen, verwenden die <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>The following example finds the first vowel in a string.</source>
          <target state="translated">Das folgende Beispiel sucht die erste Vokal in einer Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search starts at a specified character position.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The zero-based index position of the first occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> in dieser Instanz. -1, wenn kein Zeichen in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> gefunden wurde.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to one less than the length of the string instance.</source>
          <target state="translated">Die <ph id="ph1">`startIndex`</ph> -Parameter kann von 0 bis eins weniger als die Länge der Zeichenfolgeninstanz reichen.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search ranges from <ph id="ph1">`startIndex`</ph> to the end of the string.</source>
          <target state="translated">Die Suche erfolgt von <ph id="ph1">`startIndex`</ph> bis zum Ende der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`anyOf`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
          <target state="translated">Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwert identisch sind.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Um eine kulturabhängige Suche durchzuführen, verwenden die <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The following example finds the index of the occurrence of any character of the string "is" within a substring of another string.</source>
          <target state="translated">Im folgenden Beispiel wird der Index des Vorkommens eines beliebigen Zeichens der Zeichenfolge "is" in einer Teilzeichenfolge einer anderen Zeichenfolge gesucht.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the number of characters in this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> ist größer als die Anzahl der Zeichen in dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Die Anzahl der zu überprüfenden Zeichenpositionen.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The zero-based index position of the first occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> in dieser Instanz. -1, wenn kein Zeichen in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> gefunden wurde.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">Die Suche beginnt an <ph id="ph1">`startIndex`</ph> und weiterhin <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">Das Zeichen an der <ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph> ist in der Suche nicht enthalten.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to one less than the length of the string instance.</source>
          <target state="translated">Die <ph id="ph1">`startIndex`</ph> -Parameter kann von 0 bis eins weniger als die Länge der Zeichenfolgeninstanz reichen.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`anyOf`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
          <target state="translated">Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwert identisch sind.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Um eine kulturabhängige Suche durchzuführen, verwenden die <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The following example finds the index of the occurrence of any character of the string "aid" within a substring of another string.</source>
          <target state="translated">Das folgende Beispiel sucht den Index des Vorkommens eines beliebigen Zeichens der Zeichenfolge "Aid" in einer Teilzeichenfolge einer anderen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is greater than the number of characters in this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> ist größer als die Anzahl der Zeichen in dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The zero-based index position of the insertion.</source>
          <target state="translated">Die nullbasierte Indexposition für das Einfügen.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The string to insert.</source>
          <target state="translated">Die einzufügende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>Returns a new string in which a specified string is inserted at a specified index position in this instance.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, in der eine angegebene Zeichenfolge an einer angegebenen Indexposition in dieser Instanz eingefügt wird.</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>A new string that is equivalent to this instance, but with <ph id="ph1">&lt;paramref name="value" /&gt;</ph> inserted at position <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Eine neue Zeichenfolge, die dieser Instanz mit einem an der Position <ph id="ph1">&lt;paramref name="value" /&gt;</ph> eingefügten <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> entspricht.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to the length of this instance, <ph id="ph2">`value`</ph> is appended to the end of this instance.</source>
          <target state="translated">Wenn <ph id="ph1">`startIndex`</ph> ist gleich der Länge dieser Instanz <ph id="ph2">`value`</ph> am Ende dieser Instanz angefügt wird.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>Instead, it returns a new string in which <ph id="ph1">`value`</ph> is inserted into the current instance.</source>
          <target state="translated">Stattdessen gibt Sie eine neue Zeichenfolge zurück, in dem <ph id="ph1">`value`</ph> in der aktuellen Instanz eingefügt wird.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>For example, the return value of <ph id="ph1">`"abc".Insert(2, "XYZ")`</ph> is "abXYZc".</source>
          <target state="translated">Beispielsweise ist der Rückgabewert der <ph id="ph1">`"abc".Insert(2, "XYZ")`</ph> "AbXYZc" ist.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The following example inserts a space character in the fourth character position (the character at index 3) of a string.</source>
          <target state="translated">Das folgende Beispiel fügt ein Leerzeichen in der vierten Zeichenposition (das Zeichen am Index 3) einer Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The following console application prompts the users to enter one or more adjectives to describe two animals.</source>
          <target state="translated">Die folgende Konsolenanwendung fordert den Benutzer zur Eingabe von mindestens Adjektive um zwei Tieren zu beschreiben.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> method to insert the text entered by the user into a string.</source>
          <target state="translated">Er ruft dann die <ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> Methode, um die in eine Zeichenfolge vom Benutzer eingegebenen Text einzufügen.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is negative or greater than the length of this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> ist negativ oder größer als die Länge diese Instanz.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source>A string to search for in the intern pool.</source>
          <target state="translated">Eine im Internpool zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source>Retrieves the system's reference to the specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Ruft den Verweis des Systems auf den angegebenen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source>The system's reference to <ph id="ph1">&lt;paramref name="str" /&gt;</ph>, if it is interned; otherwise, a new reference to a string with the value of <ph id="ph2">&lt;paramref name="str" /&gt;</ph>.</source>
          <target state="translated">Der Verweis des Systems auf <ph id="ph1">&lt;paramref name="str" /&gt;</ph>, wenn dieser im Internpool vorhanden ist, andernfalls ein neuer Verweis auf eine Zeichenfolge mit dem Wert von <ph id="ph2">&lt;paramref name="str" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program.</source>
          <target state="translated">Die common Language Runtime behält Zeichenfolgenspeicher durch Verwalten einer Tabelle, die als Internpool, die einen einzelnen Verweis auf jedes eindeutigen Zeichenfolgenliterals deklariert oder programmgesteuert erstellt, in Ihrem Programm enthält bezeichnet wird.</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Consequently, an instance of a literal string with a particular value only exists once in the system.</source>
          <target state="translated">Folglich vorhanden eine Instanz einer Literalzeichenfolge mit einem bestimmten Wert nur einmal im System.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.</source>
          <target state="translated">Z. B. Wenn Sie mehrere Variablen mit die gleiche literale Zeichenfolge zuweisen, die Laufzeit ruft den gleichen Verweis auf die Literalzeichenfolge aus Internpool und jede Variable zugewiesen.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method uses the intern pool to search for a string equal to the value of <ph id="ph2">`str`</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> Methode verwendet den Internpool zum Suchen nach einer Zeichenfolge, die gleich dem Wert des <ph id="ph2">`str`</ph>.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>If such a string exists, its reference in the intern pool is returned.</source>
          <target state="translated">Wenn solch eine Zeichenfolge vorhanden ist, wird der Verweis im Internpool zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>If the string does not exist, a reference to <ph id="ph1">`str`</ph> is added to the intern pool, then that reference is returned.</source>
          <target state="translated">Wenn die Zeichenfolge nicht vorhanden ist, einen Verweis auf <ph id="ph1">`str`</ph> dem Internpool hinzugefügt wird, wird dieser Verweis zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program.</source>
          <target state="translated">Im folgenden Beispiel wird der Zeichenfolge s1 mit die Wert "MyTest", bereits Internpool, da es sich um ein Literal im Programm handelt.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.StringBuilder?displayProperty=nameWithType&gt;</ph> class generates a new string object that has the same value as s1.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.StringBuilder?displayProperty=nameWithType&gt;</ph> Klasse generiert ein neues Zeichenfolgenobjekt, das den gleichen Wert wie s1 verfügt.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>A reference to that string is assigned to s2.</source>
          <target state="translated">Ein Verweis auf diese Zeichenfolge wird in s2 zugewiesen.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method searches for a string that has the same value as s2.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> Methode sucht eine Zeichenfolge, die den gleichen Wert wie s2 hat.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Because such a string exists, the method returns the same reference that is assigned to s1.</source>
          <target state="translated">Da solch eine Zeichenfolge vorhanden ist, gibt die Methode die gleichen Verweis, der s1 zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>That reference is then assigned to s3.</source>
          <target state="translated">Dann wird dieser Verweis s3 zugewiesen.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.</source>
          <target state="translated">Die Verweise s1 und s2 sind ungleich, da sie auf unterschiedliche Objekte verweisen. Verweise s1 und s3 hingegen sind gleich, da sie auf die gleiche Zeichenfolge verweisen.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Compare this method to the <ph id="ph1">&lt;xref:System.String.IsInterned%2A&gt;</ph> method.</source>
          <target state="translated">Vergleichen Sie diese Methode, um die <ph id="ph1">&lt;xref:System.String.IsInterned%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Version Considerations</source>
          <target state="translated">Version-Überlegungen</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]</ph>die <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> Methode auf das Verhalten in .NET Framework 1.0 und 1.1 im Hinblick auf die leere Zeichenfolge Internalisierung zurückgesetzt.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the following example, the variable <ph id="ph1">`str1`</ph> is assigned a reference to <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>, and the variable <ph id="ph3">`str2`</ph> is assigned the reference to <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph> that is returned by calling the <ph id="ph5">&lt;xref:System.String.Intern%2A&gt;</ph> method after converting a <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph> object whose value is <ph id="ph7">&lt;xref:System.String.Empty&gt;</ph> to a string.</source>
          <target state="translated">Im folgenden Beispiel wird die Variable <ph id="ph1">`str1`</ph> erhält einen Verweis auf <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>, und die Variable <ph id="ph3">`str2`</ph> erhält den Verweis auf <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph> zurückgegeben, die durch Aufrufen der <ph id="ph5">&lt;xref:System.String.Intern%2A&gt;</ph> Methode nach der Konvertierung einer <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph>Objekt, dessen Wert <ph id="ph7">&lt;xref:System.String.Empty&gt;</ph> in eine Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Then the references contained in <ph id="ph1">`str1`</ph> and <ph id="ph2">`str2`</ph> are compared for equality.</source>
          <target state="translated">Klicken Sie dann die Verweise, die in enthaltenen <ph id="ph1">`str1`</ph> und <ph id="ph2">`str2`</ph> auf Gleichheit verglichen werden.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]</ph>, <ph id="ph2">[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>, <ph id="ph4">`str1`</ph> and <ph id="ph5">`str2`</ph> are equal.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]</ph>, <ph id="ph2">[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]</ph>, und <ph id="ph3">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>, <ph id="ph4">`str1`</ph> und <ph id="ph5">`str2`</ph> gleich sind.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph> and <ph id="ph2">[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]</ph>, <ph id="ph3">`str1`</ph> and <ph id="ph4">`str2`</ph> are not equal.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph> und <ph id="ph2">[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]</ph>, <ph id="ph3">`str1`</ph> und <ph id="ph4">`str2`</ph> ungleich sind.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Performance Considerations</source>
          <target state="translated">Überlegungen zur Leistung</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects.</source>
          <target state="translated">Wenn Sie versuchen, den Gesamtumfang des Arbeitsspeichers zu reduzieren die Anwendung belegt, sollten Sie bedenken, die eine Zeichenfolge Internalisierung zwei unerwünschte Nebeneffekte hat.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>First, the memory allocated for interned <ph id="ph1">&lt;xref:System.String&gt;</ph> objects is not likely be released until the common language runtime (CLR) terminates.</source>
          <target state="translated">Zunächst der zugeordnete Arbeitsspeicher für Internpool <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekte wird ist wahrscheinlich nicht freigegeben, bis die common Language Runtime (CLR) beendet wird.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The reason is that the CLR's reference to the interned <ph id="ph1">&lt;xref:System.String&gt;</ph> object can persist after your application, or even your application domain, terminates.</source>
          <target state="translated">Der Grund hierfür ist, die die CLR-Verweis auf die im Internpool vorhanden <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekts können nach Ihrer Anwendung oder sogar der Anwendungsdomäne beibehalten, beendet wird.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Second, to intern a string, you must first create the string.</source>
          <target state="translated">Um eine Zeichenfolge internalisiert, müssen Sie zweitens zunächst die Zeichenfolge erstellen.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The memory used by the <ph id="ph1">&lt;xref:System.String&gt;</ph> object must still be allocated, even though the memory will eventually be garbage collected.</source>
          <target state="translated">Die Speicherverwendung durch den <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt muss weiterhin zugeordnet werden, obwohl der Arbeitsspeicher schließlich Garbage Collection aufgenommen wird.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The .NET Framework version 2.0 introduces the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType&gt;</ph> enumeration member.</source>
          <target state="translated">.NET Framework, Version 2.0 führt die <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType&gt;</ph> Enumerationsmember.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> member marks an assembly as not requiring string-literal interning.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> Element kennzeichnet eine Assembly nicht erfordern, Internalisierung von Zeichenfolgenliteralen erfordert.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>You can apply <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> to an assembly using the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute&gt;</ph> attribute.</source>
          <target state="translated">Sie können anwenden <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> auf eine Assembly mit der <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute&gt;</ph> Attribut.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Also, when you use the <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> to compile an assembly in advance of run time, strings are not interned across modules.</source>
          <target state="translated">Auch bei Verwendung der <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> um eine Assembly im Vorfeld zur Laufzeit zu kompilieren, werden Zeichenfolgen nicht allen Modulen Internpool.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The following example uses three strings that are equal in value to determine whether a newly created string and an interned string are equal.</source>
          <target state="translated">Das folgende Beispiel verwendet drei Zeichenfolgen, die Wert zu bestimmen, ob eine neu erstellte Zeichenfolge identisch ist, und eine im Internpool vorhanden Zeichenfolge gleich sind.</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source>The string to search for in the intern pool.</source>
          <target state="translated">Die im Internpool zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source>Retrieves a reference to a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Ruft einen Verweis auf einen angegebenen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source>A reference to <ph id="ph1">&lt;paramref name="str" /&gt;</ph> if it is in the common language runtime intern pool; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Verweis auf <ph id="ph1">&lt;paramref name="str" /&gt;</ph>, wenn sich dieser im Internpool der Common Language Runtime befindet; andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <ph id="ph1">&lt;xref:System.String&gt;</ph> you add programmatically by calling the <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> method.</source>
          <target state="translated">Die common Language Runtime verwaltet automatisch eine Tabelle, die Internpool, die eine einzelne Instanz jedes eindeutigen Zeichenfolgenliterals Konstante deklariert, die in einem Programm als auch eine eindeutige Instanz enthält <ph id="ph1">&lt;xref:System.String&gt;</ph> programmgesteuert durch Aufrufen von hinzufügen die <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>The intern pool conserves string storage.</source>
          <target state="translated">Der Internpool erhält Zeichenfolgenspeicher.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <ph id="ph1">&lt;xref:System.String&gt;</ph> that have identical values.</source>
          <target state="translated">Wenn Sie eine literale Zeichenfolgenkonstante mehrere Variablen zuweisen, jede Variable wird festgelegt, auf die gleiche Konstante im Internpool anstelle von Verweisen auf mehrere unterschiedliche Instanzen verweisen <ph id="ph1">&lt;xref:System.String&gt;</ph> , die identische Werte haben.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>This method looks up <ph id="ph1">`str`</ph> in the intern pool.</source>
          <target state="translated">Diese Methode sucht <ph id="ph1">`str`</ph> im Internpool.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>If <ph id="ph1">`str`</ph> has already been interned, a reference to that instance is returned; otherwise, <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Wenn <ph id="ph1">`str`</ph> wurde bereits Internpool, ein Verweis auf diese Instanz wird zurückgegeben, andernfalls <ph id="ph2">`null`</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>Compare this method to the <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method.</source>
          <target state="translated">Vergleichen Sie diese Methode, um die <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>This method does not return a Boolean value.</source>
          <target state="translated">Diese Methode gibt keinen booleschen Wert zurück.</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.</source>
          <target state="translated">Wenn Sie die Methode aufrufen, da einen booleschen Wert, der angibt, ob eine bestimmte Zeichenfolge intern gespeichert werden soll, können Sie den folgenden Code.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> to install an assembly to the native image cache on a local computer.</source>
          <target state="translated">Beginnend mit .NET Framework, Version 2.0, können Sie die Verwendung von Internpool bei Verwendung von überschreiben die <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> , eine Assembly zum Cache für systemeigene Images auf einem lokalen Computer zu installieren.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>For more information, see Performance Considerations in the Remarks section for the <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> property.</source>
          <target state="translated">Weitere Informationen finden Sie unter Leistungsaspekte im Abschnitt "Hinweise", um die <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>The following example demonstrates that literal strings are interned automatically by the compiler.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, dass Literalzeichenfolgen automatisch vom Compiler intern gespeichert werden.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Indicates whether this string is in a particular Unicode normalization form.</source>
          <target state="translated">Gibt an, ob diese Zeichenfolge in einer bestimmten Unicode-Normalisierungsform vorliegt.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized">
          <source>Indicates whether this string is in Unicode normalization form C.</source>
          <target state="translated">Gibt an, ob diese Zeichenfolge in der Unicode-Normalisierungsform C vorliegt.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this string is in normalization form C; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn diese Zeichenfolge in der Normalisierungsform C vorliegt; andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">Einige Unicode-Zeichen enthalten, mehrere äquivalente binäre Darstellung bestehend aus Sätzen von Kombinieren von und/oder zusammengesetzte Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">Das Vorhandensein des mehrere Darstellungen für ein einzelnes Zeichen macht suchen, sortieren, Abgleich und andere Vorgänge.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">Im Unicode-standard definiert eine sogenannte Normalisierung, die eine binäre Darstellung, wenn keines der entsprechende binäre Darstellung eines Zeichens zurückgibt.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">Normalisierung kann mit mehreren Algorithmen, die Normalisierung Formulare, die verschiedene Regeln einhalten aufgerufen ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The .NET Framework currently supports normalization forms C, D, KC, and KD.</source>
          <target state="translated">.NET Framework unterstützt derzeit die Normalisierung Forms C, D, KC und KD.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung der unterstützte Unicode-Normalisierungsformen, finden Sie unter <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The following example determines whether a string is successfully normalized to various normalization forms.</source>
          <target state="translated">Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge erfolgreich in verschiedenen Normalisierungsformen normalisiert wird.</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> -Methode zurückkehrt <ph id="ph2">&lt;see langword="false" /&gt;</ph> , sobald das erste nicht normalisierte Zeichen in einer Zeichenfolge gefunden wird.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method will throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Aus diesem Grund, wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält die <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> Methode löst eine <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> zwar <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> gibt <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>A Unicode normalization form.</source>
          <target state="translated">Eine Unicode-Normalisierungsform.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Indicates whether this string is in the specified Unicode normalization form.</source>
          <target state="translated">Gibt an, ob diese Zeichenfolge in der angegebenen Unicode-Normalisierungsform vorliegt.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this string is in the normalization form specified by the <ph id="ph2">&lt;paramref name="normalizationForm" /&gt;</ph> parameter; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn diese Zeichenfolge in der vom <ph id="ph2">&lt;paramref name="normalizationForm" /&gt;</ph>-Parameter angegebenen Normalisierungsform vorliegt; andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">Einige Unicode-Zeichen enthalten, mehrere äquivalente binäre Darstellung bestehend aus Sätzen von Kombinieren von und/oder zusammengesetzte Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">Das Vorhandensein des mehrere Darstellungen für ein einzelnes Zeichen macht suchen, sortieren, Abgleich und andere Vorgänge.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">Im Unicode-standard definiert eine sogenannte Normalisierung, die eine binäre Darstellung, wenn keines der entsprechende binäre Darstellung eines Zeichens zurückgibt.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">Normalisierung kann mit mehreren Algorithmen, die Normalisierung Formulare, die verschiedene Regeln einhalten aufgerufen ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The .NET Framework currently supports normalization forms C, D, KC, and KD.</source>
          <target state="translated">.NET Framework unterstützt derzeit die Normalisierung Forms C, D, KC und KD.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung der unterstützte Unicode-Normalisierungsformen, finden Sie unter <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.IsNormalized%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Normalize%2A&gt;</ph> methods.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.IsNormalized%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.String.Normalize%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> -Methode zurückkehrt <ph id="ph2">&lt;see langword="false" /&gt;</ph> , sobald das erste nicht normalisierte Zeichen in einer Zeichenfolge gefunden wird.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method will throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Aus diesem Grund, wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält die <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> Methode löst eine <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> zwar <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> gibt <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>The string to test.</source>
          <target state="translated">Die zu testende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>Indicates whether the specified string is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> string.</source>
          <target state="translated">Gibt an, ob die angegebene Zeichenfolge <ph id="ph1">&lt;see langword="null" /&gt;</ph> oder eine <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>-Zeichenfolge ist.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty string (""); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;paramref name="value" /&gt;</ph>-Parameter <ph id="ph3">&lt;see langword="null" /&gt;</ph> oder eine leere Zeichenfolge ("") ist, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> is a convenience method that enables you to simultaneously test whether a <ph id="ph2">&lt;xref:System.String&gt;</ph> is <ph id="ph3">`null`</ph> or its value is <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> ist eine bequeme Methode, die Ihnen ermöglicht, die gleichzeitig zu testen, ob eine <ph id="ph2">&lt;xref:System.String&gt;</ph> ist <ph id="ph3">`null`</ph> oder ihr Wert <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Dies entspricht dem folgenden Code:</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method to test whether a string is <ph id="ph2">`null`</ph>, its value is <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>,  or it consists only of white-space characters.</source>
          <target state="translated">Können Sie die <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> Methode zum Testen, ob eine Zeichenfolge <ph id="ph2">`null`</ph>, ihr Wert ist <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, oder es besteht nur aus Leerstellen bestehen.</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>What is a null string?</source>
          <target state="translated">Was ist eine null-Zeichenfolge?</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>A string is <ph id="ph1">`null`</ph> if it has not been assigned a value (in C++ and Visual Basic) or if has explicitly been assigned a value of <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Eine Zeichenfolge ist <ph id="ph1">`null`</ph> , wenn sie keinen Wert (in C++ und Visual Basic) zugewiesen wurden oder wenn der Wert explizit zugewiesen wurde <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>Although the <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</source>
          <target state="translated">Obwohl die <bpt id="p1">[</bpt>kombinierte Formatierung<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> Funktion kann sauber eine null-Zeichenfolge, wie im folgenden Beispiel gezeigt, der versucht, eine aufzurufen, wenn Membern löst eine <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>What is an empty string?</source>
          <target state="translated">Was ist eine leere Zeichenfolge?</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>A string is empty if it  is explicitly assigned an empty string ("") or <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Eine Zeichenfolge ist leer, wenn er explizit eine leere Zeichenfolge zugewiesen ist ("") oder <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>An empty string has a <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> of 0.</source>
          <target state="translated">Eine leere Zeichenfolge ist ein <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> 0.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>The following example creates an empty string and displays its value and its length.</source>
          <target state="translated">Das folgende Beispiel erstellt eine leere Zeichenfolge und zeigt an, dessen Wert und ihre Länge.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>The following example examines three strings and determines whether each string has a value, is an empty string, or is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Im folgenden Beispiel werden drei Zeichenfolgen untersucht und bestimmt, ob jede Zeichenfolge ist, eine leere Zeichenfolge ist oder ist <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>The string to test.</source>
          <target state="translated">Die zu testende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>Indicates whether a specified string is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, empty, or consists only of white-space characters.</source>
          <target state="translated">Gibt an, ob eine angegebene Zeichenfolge <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist, leer ist oder nur aus Leerzeichen besteht.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or <ph id="ph4">&lt;see cref="F:System.String.Empty" /&gt;</ph>, or if <ph id="ph5">&lt;paramref name="value" /&gt;</ph> consists exclusively of white-space characters.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;paramref name="value" /&gt;</ph>-Parameter <ph id="ph3">&lt;see langword="null" /&gt;</ph> oder <ph id="ph4">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist oder wenn <ph id="ph5">&lt;paramref name="value" /&gt;</ph> ausschließlich aus Leerzeichen besteht.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> is a convenience method that is similar to the following  code, except that it offers superior performance:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> ist eine Hilfsmethode, die ähnlich dem folgenden Code wird mit dem Unterschied, dass es sich um eine bessere Leistung bietet:</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>White-space characters are defined by the Unicode standard.</source>
          <target state="translated">Leerzeichen werden durch den Unicode-Standard definiert.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method interprets any character that returns a value of <ph id="ph2">`true`</ph> when it is passed to the <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method as a white-space character.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> Methode interpretiert alle Zeichen, die einen Wert zurückgibt <ph id="ph2">`true`</ph> wann erfolgt eine Übergabe an die <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> Methode als ein Leerzeichen.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>The following example creates a string array, and then passes each element of the array to the <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel erstellt ein Array von Zeichenfolgen, und übergibt dann jedes Element des Arrays, das die <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Concatenates the elements of a specified array or the members of a collection, using the specified separator between each element or member.</source>
          <target state="translated">Verkettet die Elemente eines angegebenen Arrays oder die Member einer Auflistung und verwendet das angegebene Trennzeichen zwischen jedem Element bzw. Member.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The string to use as a separator.<bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated">Die als Trennzeichen zu verwendende Zeichenfolge. <bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> ist nur in der zurückgegebenen Zeichenfolge enthalten, wenn <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> mehr als ein Element enthält.</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>A collection that contains the strings to concatenate.</source>
          <target state="translated">Eine Auflistung, die die zu verkettenden Zeichenfolgen enthält.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>Concatenates the members of a constructed <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> collection of type <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>, using the specified separator between each member.</source>
          <target state="translated">Verkettet die Member einer erstellten <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>-Auflistung vom Typ <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> und verwendet das angegebene Trennzeichen zwischen den einzelnen Membern.</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>A string that consists of the members of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Eine Zeichenfolge, die aus den Membern von <ph id="ph1">&lt;paramref name="values" /&gt;</ph> besteht, getrennt durch die <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>-Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">&lt;paramref name="values" /&gt;</ph> has no members, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="values" /&gt;</ph> keine Mitglieder hat, gibt die Methode <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Wenn <ph id="ph1">`separator`</ph> ist <ph id="ph2">`null`</ph>, eine leere Zeichenfolge (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) wird stattdessen verwendet.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>If any member of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">Wenn alle Member des <ph id="ph1">`values`</ph> ist <ph id="ph2">`null`</ph>, eine leere Zeichenfolge wird stattdessen verwendet.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">`IEnumerable(Of String)`</ph> collection without first converting the elements to a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> ist eine bequeme Methode, mit der jedes Element in verketten kann eine <ph id="ph2">`IEnumerable(Of String)`</ph> Auflistung ohne zunächst die Elemente in einem Array von Zeichenfolgen konvertiert.</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions.</source>
          <target state="translated">Dies ist besonders nützlich bei Abfrageausdrücken Language-Integrated Query (LINQ).</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example passes a <ph id="ph1">`List(Of String)`</ph> object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</source>
          <target state="translated">Das folgende Beispiel übergibt eine <ph id="ph1">`List(Of String)`</ph> Objekt, das die klein-oder Großbuchstaben und Buchstaben des Alphabets an einen Lambda-Ausdruck, die Buchstaben, die einem bestimmten Buchstaben enthält auswählt (d. h. im Beispiel "M") größer oder gleich sind.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The <ph id="ph1">`IEnumerable(Of String)`</ph> collection returned by the <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> method is passed to the <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method to display the result as a single string.</source>
          <target state="translated">Die <ph id="ph1">`IEnumerable(Of String)`</ph> zurückgegebene Auflistung der <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> an die Methode übergeben wird die <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> Methode, um das Ergebnis als einzelne Zeichenfolge anzuzeigen.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">Im folgenden Beispiel wird die Sieb des Eratosthenes-Algorithmus zum Berechnen von Primzahlen, die kleiner als oder gleich 100 sind.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>It assigns the result to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object of type <ph id="ph2">&lt;xref:System.String&gt;</ph>, which it then passes to the <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method.</source>
          <target state="translated">Weist das Ergebnis, das eine <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> Objekt des Typs <ph id="ph2">&lt;xref:System.String&gt;</ph>, übergibt sie dann an die <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The string to use as a separator.</source>
          <target state="translated">Die Zeichenfolge, die als Trennzeichen verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> mehr als ein Element enthält.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>An array that contains the elements to concatenate.</source>
          <target state="translated">Ein Array, das die zu verkettenden Elemente enthält.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>Concatenates the elements of an object array, using the specified separator between each element.</source>
          <target state="translated">Verkettet die Elemente eines Objektarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>A string that consists of the elements of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Eine Zeichenfolge, die aus den Membern von <ph id="ph1">&lt;paramref name="values" /&gt;</ph> besteht, getrennt durch die <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>-Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>If <ph id="ph1">&lt;paramref name="values" /&gt;</ph> is an empty array, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="values" /&gt;</ph> eine leeres Array ist, gibt die Methode <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph> or if any element of <ph id="ph3">`values`</ph> other than the first element is <ph id="ph4">`null`</ph>, an empty string (<ph id="ph5">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Wenn <ph id="ph1">`separator`</ph> ist <ph id="ph2">`null`</ph> oder, wenn ein beliebiges Element von <ph id="ph3">`values`</ph> anders als das erste Element ist <ph id="ph4">`null`</ph>, eine leere Zeichenfolge (<ph id="ph5">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) wird stattdessen verwendet.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>See the Notes for Callers section if the first element of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Finden Sie Hinweise für Aufruferabschnitt aus, wenn das erste Element des <ph id="ph1">`values`</ph> ist <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> ist eine bequeme Methode, mit der jedes Element in einem Objektarray verketten, ohne Sie explizit seine Elemente in Zeichenfolgen konvertiert werden können.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The string representation of each object in the array is derived by calling that object's <ph id="ph1">`ToString`</ph> method.</source>
          <target state="translated">Die Zeichenfolgendarstellung für jedes Objekt im Array wird durch Aufrufen des Objekts abgeleitet <ph id="ph1">`ToString`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">Im folgenden Beispiel wird die Sieb des Eratosthenes-Algorithmus zum Berechnen von Primzahlen, die kleiner als oder gleich 100 sind.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>It assigns the result to a integer array, which it then passes to the <ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Er weist das Ergebnis ein Array von Ganzzahlen, übergibt sie dann an die <ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>If the first element of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the <ph id="ph3">&lt;see cref="M:System.String.Join(System.String,System.Object[])" /&gt;</ph> method does not concatenate the elements in <ph id="ph4">&lt;paramref name="values" /&gt;</ph> but instead returns <ph id="ph5">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Wenn das erste Element des <ph id="ph1">&lt;paramref name="values" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.String.Join(System.String,System.Object[])" /&gt;</ph> Methode verketten keine Elemente im <ph id="ph4">&lt;paramref name="values" /&gt;</ph> , sondern stattdessen zurückgibt <ph id="ph5">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>A number of workarounds for this issue are available.</source>
          <target state="translated">Eine Reihe von problemumgehungen für dieses Problem sind verfügbar.</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The easiest is to assign a value of <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> to the first element of the array, as the following example shows.</source>
          <target state="translated">Die einfachste Möglichkeit besteht darin, einen Wert zuzuweisen <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> auf das erste Element des Arrays, wie im folgenden Beispiel dargestellt.</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>The string to use as a separator.</source>
          <target state="translated">Die Zeichenfolge, die als Trennzeichen verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> mehr als ein Element enthält.</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>An array that contains the elements to concatenate.</source>
          <target state="translated">Ein Array, das die zu verkettenden Elemente enthält.</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>Concatenates all the elements of a string array, using the specified separator between each element.</source>
          <target state="translated">Verkettet alle Elemente eines Zeichenfolgenarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>A string that consists of the elements in <ph id="ph1">&lt;paramref name="value" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Eine Zeichenfolge, die aus den Membern von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> besteht, getrennt durch die <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>-Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is an empty array, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> eine leeres Array ist, gibt die Methode <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>For example, if <ph id="ph1">`separator`</ph> is ", " and the elements of <ph id="ph2">`value`</ph> are "apple", "orange", "grape", and "pear", <ph id="ph3">`Join(separator, value)`</ph> returns "apple, orange, grape, pear".</source>
          <target state="translated">Z. B. wenn <ph id="ph1">`separator`</ph> ist "," und die Elemente der <ph id="ph2">`value`</ph> sind "Apple", "Orange", "Pflaume" und "Birne", <ph id="ph3">`Join(separator, value)`</ph> "Apple, Orange, Pflaume, Birne" zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Wenn <ph id="ph1">`separator`</ph> ist <ph id="ph2">`null`</ph>, eine leere Zeichenfolge (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) wird stattdessen verwendet.</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>If any element in <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">Wenn ein Element in <ph id="ph1">`value`</ph> ist <ph id="ph2">`null`</ph>, eine leere Zeichenfolge wird stattdessen verwendet.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The string to use as a separator.</source>
          <target state="translated">Die Zeichenfolge, die als Trennzeichen verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> mehr als ein Element enthält.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>An array that contains the elements to concatenate.</source>
          <target state="translated">Ein Array, das die zu verkettenden Elemente enthält.</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The first element in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Das erste zu verwendende Element aus <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The number of elements of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Die Anzahl der zu verwendenden Elemente aus <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>Concatenates the specified elements of a string array, using the specified separator between each element.</source>
          <target state="translated">Verkettet die angegebenen Elemente eines Zeichenfolgenarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>A string that consists of the strings in <ph id="ph1">&lt;paramref name="value" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Eine Zeichenfolge, die aus den Zeichenfolgen in <ph id="ph1">&lt;paramref name="value" /&gt;</ph> besteht, getrennt durch die <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>-Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is zero, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> has no elements, or <ph id="ph4">&lt;paramref name="separator" /&gt;</ph> and all the elements of <ph id="ph5">&lt;paramref name="value" /&gt;</ph> are <ph id="ph6">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 0 (null) ist, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> keine Elemente enthält oder <ph id="ph4">&lt;paramref name="separator" /&gt;</ph> und alle Elemente von <ph id="ph5">&lt;paramref name="value" /&gt;</ph> <ph id="ph6">&lt;see cref="F:System.String.Empty" /&gt;</ph> sind.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>For example, if <ph id="ph1">`separator`</ph> is ", " and the elements of <ph id="ph2">`value`</ph> are "apple", "orange", "grape", and "pear", <ph id="ph3">`Join(separator, value, 1, 2)`</ph> returns "orange, grape".</source>
          <target state="translated">Z. B. wenn <ph id="ph1">`separator`</ph> ist "," und die Elemente der <ph id="ph2">`value`</ph> sind "Apple", "Orange", "Pflaume" und "Birne", <ph id="ph3">`Join(separator, value, 1, 2)`</ph> gibt "Orange, Pflaume".</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Wenn <ph id="ph1">`separator`</ph> ist <ph id="ph2">`null`</ph>, eine leere Zeichenfolge (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) wird stattdessen verwendet.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>If any element in <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">Wenn ein Element in <ph id="ph1">`value`</ph> ist <ph id="ph2">`null`</ph>, eine leere Zeichenfolge wird stattdessen verwendet.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The following example concatenates two elements from an array of names of fruit.</source>
          <target state="translated">Im folgende Beispiel werden zwei Elemente aus einem Array mit Namen von Früchten verkettet.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist kleiner als 0 (null).</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is greater than the number of elements in <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist größer als die Anzahl von Elementen in <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>Out of memory.</source>
          <target state="translated">Nicht genügend Arbeitsspeicher.</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The type of the members of <bpt id="p1">&lt;c&gt;</bpt>values<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der Typ der Elemente der <bpt id="p1">&lt;c&gt;</bpt>Werte<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The string to use as a separator.<bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated">Die als Trennzeichen zu verwendende Zeichenfolge. <bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> ist nur in der zurückgegebenen Zeichenfolge enthalten, wenn <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> mehr als ein Element enthält.</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>A collection that contains the objects to concatenate.</source>
          <target state="translated">Eine Auflistung, die die zu verkettenden Objekte enthält.</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>Concatenates the members of a collection, using the specified separator between each member.</source>
          <target state="translated">Verkettet die Member einer Auflistung und verwendet das angegebene Trennzeichen zwischen den einzelnen Membern.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>A string that consists of the members of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Eine Zeichenfolge, die aus den Membern von <ph id="ph1">&lt;paramref name="values" /&gt;</ph> besteht, getrennt durch die <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>-Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>If <ph id="ph1">&lt;paramref name="values" /&gt;</ph> has no members, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="values" /&gt;</ph> keine Mitglieder hat, gibt die Methode <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Wenn <ph id="ph1">`separator`</ph> ist <ph id="ph2">`null`</ph>, eine leere Zeichenfolge (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) wird stattdessen verwendet.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>If any member of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">Wenn alle Member des <ph id="ph1">`values`</ph> ist <ph id="ph2">`null`</ph>, eine leere Zeichenfolge wird stattdessen verwendet.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> is a convenience method that lets you concatenate each member of an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection without first converting them to strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> ist eine bequeme Methode, mit dem Sie verketten, jedes Mitglied einer <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> Auflistung ohne sie in Zeichenfolgen konvertieren.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The string representation of each object in the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection is derived by calling that object's <ph id="ph2">`ToString`</ph> method.</source>
          <target state="translated">Die Zeichenfolgendarstellung für jedes Objekt in der <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> Auflistung wird durch Aufrufen des Objekts abgeleitet <ph id="ph2">`ToString`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>This method is particular useful with Language-Integrated Query (LINQ) query expressions.</source>
          <target state="translated">Diese Methode ist insbesondere nützlich sein, die Language-Integrated Query (LINQ)-Abfrageausdrücke.</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>For example, the following code defines a very simple <ph id="ph1">`Animal`</ph> class that contains the name of an animal and the order to which it belongs.</source>
          <target state="translated">Der folgende Code definiert z. B. eine sehr einfache <ph id="ph1">`Animal`</ph> Klasse enthält den Namen des Animal und die Reihenfolge, zu dem er gehört.</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>It then defines a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object that contains a number of <ph id="ph2">`Animal`</ph> objects.</source>
          <target state="translated">Zudem definiert der Code eine <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> -Objekt, das eine Anzahl von enthält <ph id="ph2">`Animal`</ph> Objekte.</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> extension method is called to extract the <ph id="ph2">`Animal`</ph> objects whose <ph id="ph3">`Order`</ph> property equals "Rodent".</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> Erweiterungsmethode aufgerufen, um das Extrahieren der <ph id="ph2">`Animal`</ph> -Objekte, deren <ph id="ph3">`Order`</ph> Eigenschaft "Rodent" entspricht.</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The result is passed to the <ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> method.</source>
          <target state="translated">Das Ergebnis wird zum Übergeben der <ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">Im folgenden Beispiel wird die Sieb des Eratosthenes-Algorithmus zum Berechnen von Primzahlen, die kleiner als oder gleich 100 sind.</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>It assigns the result to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object of type integer, which it then passes to the <ph id="ph2">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> method.</source>
          <target state="translated">Weist das Ergebnis, das eine <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> Objekt vom Typ Integer, übergibt sie dann an die <ph id="ph2">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character or string within this instance.</source>
          <target state="translated">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens oder einer angegebenen Unicode-Zeichenfolge in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the character or string is not found in this instance.</source>
          <target state="translated">Die Methode gibt -1 zurück, wenn das Zeichen oder die Zeichenfolge in dieser Instanz nicht gefunden wird.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The Unicode character to seek.</source>
          <target state="translated">Das zu suchende Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char)">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</source>
          <target state="translated">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not.</source>
          <target state="translated">Die nullbasierte Indexposition von <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, wenn dieses Zeichen gefunden wurde, andernfalls -1.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Diese Methode beginnt die Suche an der letzten Zeichenposition dieser Instanz und wird rückwärts bis entweder fortgesetzt <ph id="ph1">`value`</ph> gefunden wird oder die Position des erste Zeichens überprüft wurde.</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The search is case-sensitive.</source>
          <target state="translated">Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind.</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Um eine kulturabhängige Suche durchzuführen, verwenden die <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The following example defines an <ph id="ph1">`ExtractFilename`</ph> method that uses the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.Char%29&gt;</ph> method to find the last directory separator character in a string and to extract the string's file name.</source>
          <target state="translated">Das folgende Beispiel definiert eine <ph id="ph1">`ExtractFilename`</ph> Methode, verwendet die <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.Char%29&gt;</ph> Methode, um das letzte Verzeichnistrennzeichen in einer Zeichenfolge gesucht und Dateinamen der Zeichenfolge zu extrahieren.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>If the file exists, the method returns the file name without its path.</source>
          <target state="translated">Wenn die Datei vorhanden ist, gibt die Methode den Dateinamen ohne Pfad zurück.</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>The string to seek.</source>
          <target state="translated">Die zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>The zero-based starting index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not.</source>
          <target state="translated">Die nullbasierte Indexposition von <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, wenn diese Zeichenfolge gefunden wurde, andernfalls -1.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the last index position in this instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist, ist der Rückgabewert die letzte Indexposition in dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>The search begins at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Die Suche beginnt an der letzten Zeichenposition dieser Instanz und wird rückwärts bis entweder fortgesetzt <ph id="ph1">`value`</ph> gefunden wird oder die Position des erste Zeichens überprüft wurde.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Diese Methode führt eine Word (Groß-/Kleinschreibung beachtet und der Kultur)-Suche, die mit der aktuellen Kultur.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Bei einer kulturabhängige Suche, bei der <ph id="ph1">`value`</ph> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> method always returns <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph> – 1, which represents the last index position in the current instance.</source>
          <target state="translated">Wenn <ph id="ph1">`value`</ph> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> immer Methodenrückgabe <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph> – 1, der die letzte Indexposition in der aktuellen Instanz darstellt.</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> Methode wird verwendet, um drei Teilzeichenfolgen (einen bedingten Bindestrich (U + 00AD), einen bedingten Bindestrich gefolgt von "n" und einen bedingten Bindestrich gefolgt von "m") in zwei Zeichenfolgen zu suchen.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich.</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in <ph id="ph2">`value`</ph>.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, auf die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher sind in jedem Fall, da der bedingte Bindestrich ein ignorierbares Zeichen ist das Ergebnis das gleiche wie bei der bedingten Bindestrich in nicht enthalten war <ph id="ph2">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>When searching for a soft hyphen only, the method returns 6 and 5.</source>
          <target state="translated">Bei der Suche nach nur einen bedingten Bindestrich erfolgt die Methodenrückgabe 6 und 5.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>These values correspond to the index of the last character in the two strings.</source>
          <target state="translated">Diese Werte entsprechen den Index des letzten Zeichens in die zwei Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>The following example removes opening and closing HTML tags from a string if the tags begin and end the string.</source>
          <target state="translated">Im folgende Beispiel entfernt die Start- und Endtags HTML-Zeichenfolge, wenn die Tags beginnen und am Ende der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>If a string ends with a closing bracket character ("&gt;"), the example uses the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method to locate the start of the end tag.</source>
          <target state="translated">Wenn das Ende einer Zeichenfolge mit einer schließenden Klammer Zeichen ("&gt;"), im Beispiel wird die <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> Methode, um den Start des Endtags zu suchen.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Wie in beschrieben <bpt id="p1">[</bpt>bewährte Methoden für die Verwendung von Zeichenfolgen<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>To find the last index of a substring within a string instance by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Um den letzten Index einer Teilzeichenfolge innerhalb einer Zeichenfolgeninstanz mithilfe der Vergleichsregeln der aktuellen Kultur zu suchen, rufen die <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> methodenüberladung mit einem Wert von <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> für seine <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The Unicode character to seek.</source>
          <target state="translated">Das zu suchende Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The starting position of the search.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Die Suche wird von <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> bis zum Anfang dieser Instanz fortgesetzt.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</source>
          <target state="translated">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Die nullbasierte Indexposition von <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, wenn dieses Zeichen gefunden wurde, oder -1, wenn es nicht gefunden wurde oder die aktuelle Instanz gleich <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.This method begins searching at the <ph id="ph2">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning of the current instance until either <ph id="ph3">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> -1. dieser Methode beginnt die Suche an den <ph id="ph2">`startIndex`</ph> Zeichenposition dieser Instanz und wird rückwärts bis zum Anfang der aktuellen Instanz erst dann fortgesetzt <ph id="ph3">`value`</ph> gefunden wird oder die Position des erste Zeichens überprüft wurde.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
          <target state="translated">Z. B. wenn <ph id="ph1">`startIndex`</ph> ist <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, sucht die Methode alle Zeichen aus dem letzten Zeichen in der Zeichenfolge am Anfang.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Um eine kulturabhängige Suche durchzuführen, verwenden die <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The following example finds the index of all occurrences of a character in a string, working from the end of the string to the start of the string.</source>
          <target state="translated">Im folgende Beispiel sucht den Index, der alle Vorkommen eines Zeichens in einer Zeichenfolge, aus dem Ende der Zeichenfolge am Anfang der Zeichenfolge arbeiten.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than or equal to the length of this instance.</source>
          <target state="translated">Die aktuelle Instanz entspricht nicht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist kleiner als 0 (null) oder größer oder gleich der Länge dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">Die zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Die Suche wird von <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> bis zum Anfang dieser Instanz fortgesetzt.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The zero-based starting index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Die nullbasierte Anfangsindexposition von <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist, ist der Rückgabewert der kleinere <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> und die letzte Indexposition in dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either <ph id="ph2">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Die Suche beginnt an der <ph id="ph1">`startIndex`</ph> Zeichenposition dieser Instanz und wird fortgesetzt, bis entweder rückwärts <ph id="ph2">`value`</ph> gefunden wird oder die Position des erste Zeichens überprüft wurde.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
          <target state="translated">Z. B. wenn <ph id="ph1">`startIndex`</ph> ist <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, sucht die Methode alle Zeichen aus dem letzten Zeichen in der Zeichenfolge am Anfang.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Diese Methode führt eine Word (Groß-/Kleinschreibung beachtet und der Kultur)-Suche, die mit der aktuellen Kultur.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Bei einer kulturabhängige Suche, bei der <ph id="ph1">`value`</ph> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Wenn <ph id="ph1">`value`</ph> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> immer Methodenrückgabe <ph id="ph3">`startIndex`</ph>, also die Zeichenposition, an dem die Suche beginnt.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> Methode wird verwendet, um eine Teilzeichenfolge gefunden werden, enthält einen bedingten Bindestrich (U + 00AD) und vorausgeht oder der endgültige "m" in einer Zeichenfolge enthält.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n".</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, auf die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher, da in der Suchzeichenfolge in der bedingten Bindestrich ignoriert wird, einen Aufruf der Methode während aufrufen, um eine Substrin suchen Suchen, der den bedingten Bindestrich und "m" besteht, Teilzeichenfolge gibt die Position des "m" in der Zeichenfolge zurück. g, der den bedingten Bindestrich und "n" besteht, gibt die Position der "n" zurück.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of <ph id="ph1">`startIndex`</ph>.</source>
          <target state="translated">Wenn die Suchzeichenfolge nur für den bedingten Bindestrich enthält, gibt die Methode den Index des "m", die den Wert darstellt <ph id="ph1">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The following example finds the index of all occurrences of a string in target string, working from the end of the target string to the start of the target string.</source>
          <target state="translated">Im folgende Beispiel sucht den Index, der alle Vorkommen einer Zeichenfolge in der Zielzeichenfolge, am Ende der Zielzeichenfolge am Anfang der Zielzeichenfolge arbeiten.</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than the length of the current instance.</source>
          <target state="translated">Die aktuelle Instanz entspricht nicht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist kleiner als 0 (null) oder größer als die Länge der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">Die aktuelle Instanz entspricht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist kleiner als -1 oder größer als 0 (null).</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Wie in beschrieben <bpt id="p1">[</bpt>bewährte Methoden für die Verwendung von Zeichenfolgen<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen.</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>To find the index of a substring that precedes a particular character position by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Um den Index einer Teilzeichenfolge suchen, der eine bestimmten Zeichenposition vorausgeht, mithilfe der Vergleichsregeln der aktuellen Kultur, rufen die <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> methodenüberladung mit einem Wert von <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> für seine <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Die zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Reports the zero-based index of the last occurrence of a specified string within the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Gibt den NULL-basierten Index des letzten Vorkommens einer angegebenen Zeichenfolge im aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt an.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>A parameter specifies the type of search to use for the specified string.</source>
          <target state="translated">Ein Parameter gibt den Typ der Suche für die angegebene Zeichenfolge an.</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The zero-based starting index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not.</source>
          <target state="translated">Die nullbasierte Indexposition des <ph id="ph1">&lt;paramref name="value" /&gt;</ph>-Parameters, wenn diese Zeichenfolge gefunden wurde, andernfalls -1.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the last index position in this instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist, ist der Rückgabewert die letzte Indexposition in dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated">Die <ph id="ph1">`comparisonType`</ph> Parameter gibt an, dass für die Suche der <ph id="ph2">`value`</ph> Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung und mithilfe von Word oder Ordinalvergleichsregeln.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The search begins at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Die Suche beginnt an der letzten Zeichenposition dieser Instanz und wird rückwärts bis entweder fortgesetzt <ph id="ph1">`value`</ph> gefunden wird oder die Position des erste Zeichens überprüft wurde.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method that find the last occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Die folgenden Exampledemonstrates drei Überladungen, der die <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> -Methode, die das letzte Vorkommen einer Zeichenfolge in eine andere Zeichenfolge, die mit unterschiedlichen Werten suchen der <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> ist kein gültiger <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Bei einer kulturabhängige Suche (das heißt, wenn <ph id="ph1">&lt;paramref name="options" /&gt;</ph> nicht <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> ist), bei der <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph> – 1, which represents the last index position in the current instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> immer Methodenrückgabe <ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph> – 1, der die letzte Indexposition in der aktuellen Instanz darstellt.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> Methode wird verwendet, um drei Teilzeichenfolgen (einen bedingten Bindestrich (U + 00AD), einen bedingten Bindestrich gefolgt von "n" und einen bedingten Bindestrich gefolgt von "m") in zwei Zeichenfolgen zu suchen.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, auf die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher, da der bedingte Bindestrich ein ignorierbares Zeichen ist, eine kulturabhängige Suche derselbe Wert zurückgegeben, die es zurückgegeben würde, wenn der bedingte Bindestrich wurden nicht in der Suchzeichenfolge in enthalten.</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</source>
          <target state="translated">Eine ordinale Suche erfolgreich sucht den bedingten Bindestrich in eine Zeichenfolge und gibt an, dass er nicht vorhanden ist aus der zweiten Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The Unicode character to seek.</source>
          <target state="translated">Das zu suchende Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The starting position of the search.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Die Suche wird von <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> bis zum Anfang dieser Instanz fortgesetzt.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Die Anzahl der zu überprüfenden Zeichenpositionen.</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance.</source>
          <target state="translated">Gibt die NULL-basierte Indexposition des letzten Vorkommens des angegebenen Unicode-Zeichens in einer Teilzeichenfolge dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Die nullbasierte Indexposition von <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, wenn dieses Zeichen gefunden wurde, oder -1, wenn es nicht gefunden wurde oder die aktuelle Instanz gleich <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward toward the beginning of this instance until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">Diese Methode beginnt die Suche an den <ph id="ph1">`startIndex`</ph> Zeichen Position und wird rückwärts bis zum Anfang dieser Instanz erst dann fortgesetzt <ph id="ph2">`value`</ph> gefunden wird oder <ph id="ph3">`count`</ph> Zeichenpositionen überprüft wurden.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
          <target state="translated">Z. B. wenn <ph id="ph1">`startIndex`</ph> ist <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, sucht die Methode rückwärts <ph id="ph3">`count`</ph> Zeichen aus dem letzten Zeichen in der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
          <target state="translated">Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwert identisch sind.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Um eine kulturabhängige Suche durchzuführen, verwenden die <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The following example finds the index of all occurrences of a character in a substring, working from the end of the substring to the start of the substring.</source>
          <target state="translated">Im folgende Beispiel sucht den Index, der alle Vorkommen eines Zeichens in einer Teilzeichenfolge, arbeiten an den Anfang der Teilzeichenfolge am Ende der Teilzeichenfolge.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than or equal to the length of this instance.</source>
          <target state="translated">Die aktuelle Instanz entspricht nicht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist kleiner als 0 (null) oder größer oder gleich der Länge dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph> + 1 is less than zero.</source>
          <target state="translated">Die aktuelle Instanz entspricht nicht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph> + 1 ist kleiner als 0 (null).</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">Die zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Die Suche wird von <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> bis zum Anfang dieser Instanz fortgesetzt.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Die Anzahl der zu überprüfenden Zeichenpositionen.</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The zero-based starting index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Die nullbasierte Anfangsindexposition von <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist, ist der Rückgabewert der kleinere <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> und die letzte Indexposition in dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">Die Suche beginnt an der <ph id="ph1">`startIndex`</ph> Zeichenposition dieser Instanz und wird fortgesetzt, bis entweder rückwärts <ph id="ph2">`value`</ph> gefunden wird oder <ph id="ph3">`count`</ph> Zeichenpositionen überprüft wurden.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
          <target state="translated">Z. B. wenn <ph id="ph1">`startIndex`</ph> ist <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, sucht die Methode rückwärts <ph id="ph3">`count`</ph> Zeichen aus dem letzten Zeichen in der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Diese Methode führt eine Word (Groß-/Kleinschreibung beachtet und der Kultur)-Suche, die mit der aktuellen Kultur.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Bei einer kulturabhängige Suche, bei der <ph id="ph1">`value`</ph> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Wenn <ph id="ph1">`value`</ph> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> immer Methodenrückgabe <ph id="ph3">`startIndex`</ph>, also die Zeichenposition, an dem die Suche beginnt.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> Methode wird verwendet, um die Position des einen bedingten Bindestrich (U + 00AD) in den beiden Zeichen suchen, die die endgültige "m" von zwei Zeichenfolgen vorausgehen.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, auf die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The following example finds the index of all occurrences of a string in substring, working from the end of the substring to the start of the substring.</source>
          <target state="translated">Im folgende Beispiel sucht den Index, der alle Vorkommen einer Zeichenfolge in Teilzeichenfolgen, arbeiten an den Anfang der Teilzeichenfolge am Ende der Teilzeichenfolge.</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated">Die aktuelle Instanz entspricht nicht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated">Die aktuelle Instanz entspricht nicht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist größer als die Länge dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph>+ 1 specifies a position that is not within this instance.</source>
          <target state="translated">Die aktuelle Instanz entspricht nicht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph>+ 1 gibt eine Position an, die nicht innerhalb dieser Instanz liegt.</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="start" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">Die aktuelle Instanz entspricht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="start" /&gt;</ph> ist kleiner als -1 oder größer als 0 (null).</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is greater than 1.</source>
          <target state="translated">Die aktuelle Instanz entspricht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist größer als 1.</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Wie in beschrieben <bpt id="p1">[</bpt>bewährte Methoden für die Verwendung von Zeichenfolgen<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen.</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>To perform this operation by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Um diesen Vorgang auszuführen, mithilfe der Vergleichsregeln der aktuellen Kultur, rufen die <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> methodenüberladung mit einem Wert von <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> für seine <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Die zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Die Suche wird von <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> bis zum Anfang dieser Instanz fortgesetzt.</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index of the last occurrence of a specified string within the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Gibt den NULL-basierten Index des letzten Vorkommens einer angegebenen Zeichenfolge im aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt an.</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>A parameter specifies the type of comparison to perform when searching for the specified string.</source>
          <target state="translated">Ein Parameter gibt den Typ des bei der Suche nach der angegebenen Zeichenfolge auszuführenden Vergleichs an.</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The zero-based starting index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Die nullbasierte Anfangsindexposition des <ph id="ph1">&lt;paramref name="value" /&gt;</ph>-Parameters, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist, ist der Rückgabewert der kleinere <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> und die letzte Indexposition in dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward until either <ph id="ph2">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Die Suche beginnt an der <ph id="ph1">`startIndex`</ph> Zeichen Position und wird fortgesetzt, bis entweder rückwärts <ph id="ph2">`value`</ph> gefunden wird oder die Position des erste Zeichens überprüft wurde.</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
          <target state="translated">Z. B. wenn <ph id="ph1">`startIndex`</ph> ist <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, sucht die Methode alle Zeichen aus dem letzten Zeichen in der Zeichenfolge am Anfang.</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated">Die <ph id="ph1">`comparisonType`</ph> Parameter gibt an, dass für die Suche der <ph id="ph2">`value`</ph> Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung und mithilfe von Word oder Ordinalvergleichsregeln.</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method that find the last occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Die folgenden Exampledemonstrates drei Überladungen, der die <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> -Methode, die das letzte Vorkommen einer Zeichenfolge in eine andere Zeichenfolge, die mit unterschiedlichen Werten suchen der <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than the length of the current instance.</source>
          <target state="translated">Die aktuelle Instanz entspricht nicht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist kleiner als 0 (null) oder größer als die Länge der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">Die aktuelle Instanz entspricht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist kleiner als -1 oder größer als 0 (null).</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> ist kein gültiger <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Bei einer kulturabhängige Suche (das heißt, wenn <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> nicht <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> ist), bei der <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> immer Methodenrückgabe <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, also die Zeichenposition, an dem die Suche beginnt.</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m", starting with the final "m" in two strings.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> Methode wird verwendet, um die Position des (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m", beginnend mit dem letzten "m" in zwei Zeichenfolgen zu suchen.</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge.</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, auf die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Die zu suchende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Die Suche wird von <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> bis zum Anfang dieser Instanz fortgesetzt.</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Die Anzahl der zu überprüfenden Zeichenpositionen.</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>A parameter specifies the type of comparison to perform when searching for the specified string.</source>
          <target state="translated">Ein Parameter gibt den Typ des bei der Suche nach der angegebenen Zeichenfolge auszuführenden Vergleichs an.</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The zero-based starting index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Die nullbasierte Anfangsindexposition des <ph id="ph1">&lt;paramref name="value" /&gt;</ph>-Parameters, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist, ist der Rückgabewert der kleinere <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> und die letzte Indexposition in dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">D. h. das erste Zeichen in der Zeichenfolge ist, bei Index 0 (null) und das letzte liegt bei <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">Die Suche beginnt an der <ph id="ph1">`startIndex`</ph> Zeichen Position und wird fortgesetzt, bis entweder rückwärts <ph id="ph2">`value`</ph> gefunden wird oder <ph id="ph3">`count`</ph> Zeichenpositionen überprüft wurden.</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
          <target state="translated">Z. B. wenn <ph id="ph1">`startIndex`</ph> ist <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, sucht die Methode rückwärts <ph id="ph3">`count`</ph> Zeichen aus dem letzten Zeichen in der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated">Die <ph id="ph1">`comparisonType`</ph> Parameter gibt an, dass für die Suche der <ph id="ph2">`value`</ph> Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung und mithilfe von Word oder Ordinalvergleichsregeln.</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method that find the last occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Die folgenden Exampledemonstrates drei Überladungen, der die <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> -Methode, die das letzte Vorkommen einer Zeichenfolge in eine andere Zeichenfolge, die mit unterschiedlichen Werten suchen der <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated">Die aktuelle Instanz entspricht nicht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated">Die aktuelle Instanz entspricht nicht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> ist größer als die Länge dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> + 1 - <ph id="ph3">&lt;paramref name="count" /&gt;</ph> specifies a position that is not within this instance.</source>
          <target state="translated">Die aktuelle Instanz entspricht nicht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> + 1 - <ph id="ph3">&lt;paramref name="count" /&gt;</ph> gibt eine Position an, die nicht innerhalb dieser Instanz liegt.</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="start" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">Die aktuelle Instanz entspricht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="start" /&gt;</ph> ist kleiner als -1 oder größer als 0 (null).</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is greater than 1.</source>
          <target state="translated">Die aktuelle Instanz entspricht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist größer als 1.</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> ist kein gültiger <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Bei einer kulturabhängige Suche (das heißt, wenn <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> nicht <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> ist), bei der <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> besteht ausschließlich aus ein oder mehrere Ignorierbare Zeichen, die <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> immer Methodenrückgabe <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, also die Zeichenposition, an dem die Suche beginnt.</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in all but the first character position before the final "m" in two strings.</source>
          <target state="translated">Im folgenden Beispiel die <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> Methode wird verwendet, um die Position des (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" in allen jedoch der ersten Zeichenposition vor dem letzten "m" in zwei Zeichenfolgen zu suchen.</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge.</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, auf die <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> oder höher in beiden Fällen, da der bedingte Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>When it performs an ordinal comparison, however, it finds the substring only in the first string.</source>
          <target state="translated">Wenn sie einen Ordinalvergleich ausführt, sucht es die Teilzeichenfolge jedoch nur in der ersten Zeichenfolge fest.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</source>
          <target state="translated">Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt, wenn ein kulturabhängiger Vergleich ausgeführt.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the characters in the array are not found in this instance.</source>
          <target state="translated">Die Methode gibt -1 zurück, wenn die Zeichen im Array nicht in dieser Instanz gefunden werden.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>The index position of the last occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> in dieser Instanz. -1, wenn kein Zeichen in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> gefunden wurde.</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph1">`anyOf`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Diese Methode beginnt die Suche an dieser Instanz der letzten Zeichenposition und verläuft rückwärts zum Anfang, bis entweder ein Zeichen in <ph id="ph1">`anyOf`</ph> gefunden wird oder die Position des erste Zeichens überprüft wurde.</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>The search is case-sensitive.</source>
          <target state="translated">Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind.</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Um eine kulturabhängige Suche durchzuführen, verwenden die <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>The following example finds the index of the last occurrence of any character in the string "is" within another string.</source>
          <target state="translated">Im folgenden Beispiel wird der Index des letzten Vorkommens eines beliebigen Zeichens aus der Zeichenfolge "is" innerhalb einer anderen Zeichenfolge gesucht.</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Die Suche wird von <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> bis zum Anfang dieser Instanz fortgesetzt.</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The index position of the last occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found or if the current instance equals <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> in dieser Instanz. -1, wenn kein Zeichen in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> gefunden wurde, oder wenn die aktuelle Instanz gleich <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph2">`anyOf`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Diese Methode beginnt die Suche an den <ph id="ph1">`startIndex`</ph> Zeichenposition dieser Instanz und wird fortgesetzt, bis entweder ein Zeichen in rückwärts <ph id="ph2">`anyOf`</ph> gefunden wird oder die Position des erste Zeichens überprüft wurde.</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind.</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Um eine kulturabhängige Suche durchzuführen, verwenden die <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The following example finds the index of the last occurrence of any character in the string "is" within a substring of another string.</source>
          <target state="translated">Im folgenden Beispiel wird der Index des letzten Vorkommens eines beliebigen Zeichens aus der Zeichenfolge "is" in einer Teilzeichenfolge einer anderen Zeichenfolge gesucht.</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> specifies a position that is not within this instance.</source>
          <target state="translated">Die aktuelle Instanz entspricht nicht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> gibt eine Position an, die nicht innerhalb dieser Instanz liegt.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Die Anfangsposition der Suche.</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Die Suche wird von <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> bis zum Anfang dieser Instanz fortgesetzt.</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Die Anzahl der zu überprüfenden Zeichenpositionen.</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
          <target state="translated">Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The index position of the last occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found or if the current instance equals <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> in dieser Instanz. -1, wenn kein Zeichen in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> gefunden wurde, oder wenn die aktuelle Instanz gleich <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Nummerierung beginnt bei 0 (null).</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph2">`anyOf`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">Diese Methode beginnt die Suche an den <ph id="ph1">`startIndex`</ph> Zeichenposition dieser Instanz und wird fortgesetzt, bis entweder ein Zeichen in rückwärts <ph id="ph2">`anyOf`</ph> gefunden wird oder <ph id="ph3">`count`</ph> Zeichenpositionen überprüft wurden.</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Diese Methode führt eine Ordinalsuche (kulturunabhängige), in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur, wenn ihre Unicode-Skalarwerten identisch sind.</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Um eine kulturabhängige Suche durchzuführen, verwenden die <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> -Methode, in ein Unicode-Skalarwert, der ein zusammengesetztes Zeichen darstellt, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen von Komponenten das Zeichen in der Beheben Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), abhängig von der Kultur.</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The following example finds the index of the last occurrence of any character in the string "aid" within a substring of another string.</source>
          <target state="translated">Das folgende Beispiel sucht den Index des letzten Vorkommens eines beliebigen Zeichens aus der Zeichenfolge "Aid" in einer Teilzeichenfolge einer anderen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> or <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated">Die aktuelle Instanz entspricht nicht <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> minus <ph id="ph3">&lt;paramref name="count" /&gt;</ph> + 1 is less than zero.</source>
          <target state="translated">Die aktuelle Instanz ist nicht gleich <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, und <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> minus <ph id="ph3">&lt;paramref name="count" /&gt;</ph> + 1 ist weniger als 0 (null).</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" uid="P:System.String.Length">
          <source>Gets the number of characters in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Ruft die Anzahl der Zeichen im aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt ab.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The number of characters in the current string.</source>
          <target state="translated">Die Anzahl der Zeichen in der aktuellen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property returns the number of <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects in this instance, not the number of Unicode characters.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> Eigenschaft gibt die Anzahl der <ph id="ph2">&lt;xref:System.Char&gt;</ph> Objekte in dieser Instanz, die nicht die Anzahl von Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The reason is that a Unicode character might be represented by more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</source>
          <target state="translated">Der Grund hierfür ist, dass ein Unicode-Zeichen kann, von mehreren dargestellt werden <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> class to work with each Unicode character instead of each <ph id="ph2">&lt;xref:System.Char&gt;</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> -Klasse verwendet jedes Unicode-Zeichen anstelle von einzelnen <ph id="ph2">&lt;xref:System.Char&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>In some languages, such as C and C++, a null character indicates the end of a string.</source>
          <target state="translated">In einigen Sprachen, z. B. C und C++ gibt ein Null-Zeichen das Ende einer Zeichenfolge an.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>In the .NET Framework, a null character can be embedded in a string.</source>
          <target state="translated">In .NET Framework kann ein Null-Zeichen in einer Zeichenfolge eingebettet sein.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>When a string includes one or more null characters, they are included in the length of the total string.</source>
          <target state="translated">Wenn eine Zeichenfolge ein oder mehrere Null-Zeichen enthält, werden sie in die Länge der Zeichenfolge enthalten.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>For example, in the following string, the substrings "abc" and "def" are separated by a null character.</source>
          <target state="translated">Beispielsweise ist in der folgenden Zeichenfolge, die Teilzeichenfolgen "Abc" und "Def" durch ein Null-Zeichen getrennt sind.</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> Eigenschaft gibt 7 gibt an, dass sie die sechs Buchstaben als auch für das Null-Zeichen enthalten.</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string whose binary representation is in a particular Unicode normalization form.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, deren binäre Darstellung in einer bestimmten Unicode-Normalisierungsform vorliegt.</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" uid="M:System.String.Normalize">
          <source>Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der Unicode-Normalisierungsform C vorliegt.</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" uid="M:System.String.Normalize">
          <source>A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</source>
          <target state="translated">Eine neue normalisierte Zeichenfolge, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der Normalisierungsform C vorliegt.</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">Einige Unicode-Zeichen enthalten, mehrere äquivalente binäre Darstellung bestehend aus Sätzen von Kombinieren von und/oder zusammengesetzte Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>For example, any of the following code points can represent the letter "ắ":</source>
          <target state="translated">Beispielsweise kann eine der folgenden Codepunkte den Buchstaben "ắ" darstellen:</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>U+1EAF</source>
          <target state="translated">U + 1EAF</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>U+0103 U+0301</source>
          <target state="translated">U + 0103 U + 0301</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>U+0061 U+0306 U+0301</source>
          <target state="translated">U + 0061 U + 0306 U + 0301</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">Das Vorhandensein des mehrere Darstellungen für ein einzelnes Zeichen macht suchen, sortieren, Abgleich und andere Vorgänge.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">Im Unicode-standard definiert eine sogenannte Normalisierung, die eine binäre Darstellung, wenn keines der entsprechende binäre Darstellung eines Zeichens zurückgibt.</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">Normalisierung kann mit mehreren Algorithmen, die Normalisierung Formulare, die verschiedene Regeln einhalten aufgerufen ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, theycan be compared by using ordinal comparison.</source>
          <target state="translated">.NET Framework unterstützt die vier Normalisierungsformen (C, D, KC und KD), die durch die Unicode-Standard definiert sind. Wenn zwei Zeichenfolgen in der gleichen Normalisierungsform dargestellt werden, werden mithilfe von ordinalen Vergleich verglichen.</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>To normalize and compare two strings, do the following:</source>
          <target state="translated">Um zu normalisieren, und Vergleichen von zwei Zeichenfolgen, führen Sie folgende Schritte aus:</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Obtain the strings to be compared from an input source, such as a file or a user input device.</source>
          <target state="translated">Rufen Sie die Zeichenfolgen, aus der Eingabequelle, z. B. eine Datei oder ein Benutzer Eingabegerät verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Call the <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> method to normalize the strings to normalization form C.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> Methode zum Normalisieren der Zeichenfolgen in der Normalisierungsform c vorliegt.</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>To compare two strings, call a method that supports ordinal string comparison, such as the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, and supply a value of <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> as the <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> argument.</source>
          <target state="translated">Rufen Sie zum Vergleichen von zwei Zeichenfolgen eine Methode, z. B. ordinal Zeichenfolgenvergleich, unterstützt, die <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> -Methode, und geben Sie den Wert <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> oder <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> als die <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> Argument.</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>To sort an array of normalized strings, pass a <ph id="ph1">`comparer`</ph> value of <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> to an appropriate overload of <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Um ein Array von normalisierte Zeichenfolgen zu sortieren, übergeben Sie eine <ph id="ph1">`comparer`</ph> Wert <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> an eine entsprechende Überladung der <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Emit the strings in the sorted output based on the order indicated by the previous step.</source>
          <target state="translated">Geben Sie die Zeichenfolgen in der sortierten Ausgabe basierend auf den im vorherigen Schritt angegebenen Reihenfolge.</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung der unterstützte Unicode-Normalisierungsformen, finden Sie unter <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</source>
          <target state="translated">Das folgende Beispiel eine Zeichenfolge in alle vier Normalisierungsformen normalisiert, bestätigt die Zeichenfolge wurde in die angegebene Normalisierungsform normalisiert die Codepunkte der normalisierte Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" uid="M:System.String.Normalize">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> -Methode zurückkehrt <ph id="ph2">&lt;see langword="false" /&gt;</ph> , sobald das erste nicht normalisierte Zeichen in einer Zeichenfolge gefunden wird.</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method will throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Aus diesem Grund, wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält die <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> Methode löst eine <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> zwar <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> gibt <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>A Unicode normalization form.</source>
          <target state="translated">Eine Unicode-Normalisierungsform.</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der angegebenen Unicode-Normalisierungsform vorliegt.</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <ph id="ph1">&lt;paramref name="normalizationForm" /&gt;</ph> parameter.</source>
          <target state="translated">Eine neue Zeichenfolge, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der im <ph id="ph1">&lt;paramref name="normalizationForm" /&gt;</ph>-Parameter angegebenen Normalisierungsform vorliegt.</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">Einige Unicode-Zeichen enthalten, mehrere äquivalente binäre Darstellung bestehend aus Sätzen von Kombinieren von und/oder zusammengesetzte Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">Das Vorhandensein des mehrere Darstellungen für ein einzelnes Zeichen macht suchen, sortieren, Abgleich und andere Vorgänge.</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">Im Unicode-standard definiert eine sogenannte Normalisierung, die eine binäre Darstellung, wenn keines der entsprechende binäre Darstellung eines Zeichens zurückgibt.</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">Normalisierung kann mit mehreren Algorithmen, die Normalisierung Formulare, die verschiedene Regeln einhalten aufgerufen ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</source>
          <target state="translated">.NET Framework unterstützt die vier Normalisierungsformen (C, D, KC und KD), die durch die Unicode-Standard definiert sind. Wenn zwei Zeichenfolgen in der gleichen Normalisierungsform dargestellt werden, können sie mithilfe von ordinalen Vergleich verglichen werden.</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>To normalize and compare two strings, do the following:</source>
          <target state="translated">Um zu normalisieren, und Vergleichen von zwei Zeichenfolgen, führen Sie folgende Schritte aus:</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Obtain the strings to be compared from an input source, such as a file or a user input device.</source>
          <target state="translated">Rufen Sie die Zeichenfolgen, aus der Eingabequelle, z. B. eine Datei oder ein Benutzer Eingabegerät verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Call the <ph id="ph1">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> method to normalize the strings to a specified normalization form.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> Methode, um die Zeichenfolgen in einer angegebenen Normalisierungsform zu normalisieren.</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>To compare two strings, call a method that supports ordinal string comparison, such as the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, and supply a value of <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> as the <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> argument.</source>
          <target state="translated">Rufen Sie zum Vergleichen von zwei Zeichenfolgen eine Methode, z. B. ordinal Zeichenfolgenvergleich, unterstützt, die <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> -Methode, und geben Sie den Wert <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> oder <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> als die <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> Argument.</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>To sort an array of normalized strings, pass a <ph id="ph1">`comparer`</ph> value of <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> to an appropriate overload of <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Um ein Array von normalisierte Zeichenfolgen zu sortieren, übergeben Sie eine <ph id="ph1">`comparer`</ph> Wert <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> an eine entsprechende Überladung der <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Emit the strings in the sorted output based on the order indicated by the previous step.</source>
          <target state="translated">Geben Sie die Zeichenfolgen in der sortierten Ausgabe basierend auf den im vorherigen Schritt angegebenen Reihenfolge.</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung der unterstützte Unicode-Normalisierungsformen, finden Sie unter <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</source>
          <target state="translated">Das folgende Beispiel eine Zeichenfolge in alle vier Normalisierungsformen normalisiert, bestätigt die Zeichenfolge wurde in die angegebene Normalisierungsform normalisiert die Codepunkte der normalisierte Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> -Methode zurückkehrt <ph id="ph2">&lt;see langword="false" /&gt;</ph> , sobald das erste nicht normalisierte Zeichen in einer Zeichenfolge gefunden wird.</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method may throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Aus diesem Grund, wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält die <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> Methode Auslösen einer <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> zwar <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> gibt <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die erste Zeichenfolge für den Vergleich oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die zweite Zeichenfolge für den Vergleich oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>Determines whether two specified strings have the same value.</source>
          <target state="translated">Bestimmt, ob zwei angegebene Zeichenfolgen denselben Wert haben.</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of <ph id="ph2">&lt;paramref name="a" /&gt;</ph> is the same as the value of <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="a" /&gt;</ph> und <ph id="ph3">&lt;paramref name="b" /&gt;</ph> denselben Wert haben, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> method defines the operation of the equality operator for the <ph id="ph2">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> Methode definiert, den Vorgang des Gleichheitsoperators für die <ph id="ph2">&lt;xref:System.String&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>It enables code such as that shown in the Example section.</source>
          <target state="translated">Sie können Code wie im Beispielabschnitt.</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The operator, in turn, calls the static <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Der Operator ruft wiederum die statische <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> -Methode, die einen Ordinalvergleich (Groß-/Kleinschreibung beachtet und kulturunabhängige) ausführt.</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The Visual Basic compiler does not resolve the equality operator as a call to the <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> method.</source>
          <target state="translated">Visual Basic-Compiler löst nicht den Gleichheitsoperator als Aufruf an die <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>Instead, the equality operator wraps a call to the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Stattdessen der Gleichheitsoperator dient als Wrapper für einen Aufruf der <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The following example demonstrates the equality operator.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht den Gleichheitsoperator.</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die erste Zeichenfolge für den Vergleich oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die zweite Zeichenfolge für den Vergleich oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>Determines whether two specified strings have different values.</source>
          <target state="translated">Bestimmt, ob zwei angegebene Zeichenfolgen verschiedene Werte haben.</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of <ph id="ph2">&lt;paramref name="a" /&gt;</ph> is different from the value of <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Wert von <ph id="ph2">&lt;paramref name="a" /&gt;</ph> vom Wert von <ph id="ph3">&lt;paramref name="b" /&gt;</ph> verschieden ist, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for the <ph id="ph2">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> -Methode definiert die Operation des Ungleichheitsoperators für die <ph id="ph2">&lt;xref:System.String&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>It enables code such as that shown in the Examples section.</source>
          <target state="translated">Sie können Code wie im Abschnitt "Beispiele".</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> operator in turn calls the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> Operator wiederum ruft die statische <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> -Methode, die einen Ordinalvergleich (Groß-/Kleinschreibung beachtet und kulturunabhängige) ausführt.</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The Visual Basic compiler does not resolve the inequality operator as a call to the <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> method.</source>
          <target state="translated">Visual Basic-Compiler löst nicht den Ungleichheitsoperator als Aufruf an die <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>Instead, the inequality operator wraps a call to the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Stattdessen Ungleichheitsoperators dient als Wrapper für einen Aufruf der <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The following example demonstrates the inequality operator.</source>
          <target state="translated">Das folgende Beispiel zeigt den Ungleichheitsoperator.</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string of a specified length in which the beginning of the current string is padded with spaces or with a specified Unicode character.</source>
          <target state="translated">Gibt eine neue Zeichenfolge mit einer angegebenen Länge zurück, in der der Anfang der aktuellen Zeichenfolge mit Leerzeichen oder einem angegebenen Unicode-Zeichen aufgefüllt wird.</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, bei der die Zeichen in dieser Instanz rechtsbündig ausgerichtet werden, indem die linke Seite mit Leerzeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit Leerzeichen aufgefüllt ist, sodass die Länge <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> erreicht wird.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück.</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>A Unicode space is defined as hexadecimal 0x0020.</source>
          <target state="translated">Ein Unicode-Leerzeichen ist definiert als hexadezimale 0 x 0020.</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%29&gt;</ph> method pads the beginning of the returned string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%29&gt;</ph> -Methode füllt den Anfang der zurückgegebenen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>This means that, when used with right-to-left languages, it pads the right portion of the string.</source>
          <target state="translated">Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen den rechten Teil der Zeichenfolge aufgefüllt.</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> Methode füllt die aktuelle Instanz mit Leerzeichen, diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>Instead, it returns a new string that is padded with leading white space so that its total length is <ph id="ph1">`totalWidth`</ph> characters.</source>
          <target state="translated">Stattdessen gibt es eine neue Zeichenfolge, die mit einem führenden Leerzeichen aufgefüllt wird, damit die Gesamtlänge zu erreichen ist <ph id="ph1">`totalWidth`</ph> Zeichen.</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>A Unicode padding character.</source>
          <target state="translated">Ein Unicode-Füllzeichen.</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, bei der die Zeichen in dieser Instanz rechtsbündig ausgerichtet werden, indem die linke Seite mit einem angegebenen Unicode-Zeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph> characters as needed to create a length of <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph>-Zeichen aufgefüllt ist, sodass die Länge <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph> erreicht wird.</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29&gt;</ph> method pads the beginning of the returned string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29&gt;</ph> -Methode füllt den Anfang der zurückgegebenen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>This means that, when used with right-to-left languages, it pads the right portion of the string.</source>
          <target state="translated">Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen den rechten Teil der Zeichenfolge aufgefüllt.</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> Methode füllt die aktuelle Instanz mit Leerzeichen, diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>Instead, it returns a new string that is padded with leading <ph id="ph1">`paddingChar`</ph> characters so that its total length is <ph id="ph2">`totalWidth`</ph> characters.</source>
          <target state="translated">Stattdessen gibt es eine neue Zeichenfolge, die mit vorangestellten Schrägstrich aufgefüllt wird <ph id="ph1">`paddingChar`</ph> Zeichen, damit die Gesamtlänge zu erreichen ist <ph id="ph2">`totalWidth`</ph> Zeichen.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string of a specified length in which the end of the current string is padded with spaces or with a specified Unicode character.</source>
          <target state="translated">Gibt eine neue Zeichenfolge mit einer angegebenen Länge zurück, in der das Ende der aktuellen Zeichenfolge mit Leerzeichen oder einem angegebenen Unicode-Zeichen aufgefüllt wird.</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, deren Zeichen linksbündig ausgerichtet werden, indem die rechte Seite mit Leerzeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit Leerzeichen aufgefüllt ist, sodass die Länge <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> erreicht wird.</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück.</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>A Unicode space is defined as hexadecimal 0x0020.</source>
          <target state="translated">Ein Unicode-Leerzeichen ist definiert als hexadezimale 0 x 0020.</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%29&gt;</ph> method pads the end of the returned string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%29&gt;</ph> -Methode füllt das Ende der zurückgegebenen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>This means that, when used with right-to-left languages, it pads the left portion of the string.</source>
          <target state="translated">Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen den linken Teil der Zeichenfolge aufgefüllt.</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> Methode füllt die aktuelle Instanz mit Leerzeichen, diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>Instead, it returns a new string that is padded with trailing white space so that its total length is <ph id="ph1">`totalWidth`</ph> characters.</source>
          <target state="translated">Stattdessen gibt es eine neue Zeichenfolge, die mit nachfolgenden Leerzeichen aufgefüllt wird, damit die Gesamtlänge zu erreichen ist <ph id="ph1">`totalWidth`</ph> Zeichen.</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>A Unicode padding character.</source>
          <target state="translated">Ein Unicode-Füllzeichen.</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, deren Zeichen linksbündig ausgerichtet werden, indem die rechte Seite mit einem angegebenen Unicode-Zeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph> characters as needed to create a length of <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph>-Zeichen aufgefüllt ist, sodass die Länge <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph> erreicht wird.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück.</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%2CSystem.Char%29&gt;</ph> method pads the end of the returned string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%2CSystem.Char%29&gt;</ph> -Methode füllt das Ende der zurückgegebenen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>This means that, when used with right-to-left languages, it pads the left portion of the string.</source>
          <target state="translated">Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen den linken Teil der Zeichenfolge aufgefüllt.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> Methode füllt die aktuelle Instanz mit Leerzeichen, diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>Instead, it returns a new string that is padded with trailing <ph id="ph1">`paddingChar`</ph> characters so that its total length is <ph id="ph2">`totalWidth`</ph> characters.</source>
          <target state="translated">Stattdessen gibt es eine neue Zeichenfolge, die mit nachfolgenden Leerzeichen aufgefüllt ist <ph id="ph1">`paddingChar`</ph> Zeichen, damit die Gesamtlänge zu erreichen ist <ph id="ph2">`totalWidth`</ph> Zeichen.</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string in which a specified number of characters from the current string are deleted.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, in der eine angegebene Anzahl von Zeichen aus der aktuellen Zeichenfolge gelöscht wurde.</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>The zero-based position to begin deleting characters.</source>
          <target state="translated">Die nullbasierte Position, ab der Zeichen gelöscht werden sollen.</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, in der alle Zeichen in der aktuellen Instanz, beginnend an einer angegebenen Position und sich über die letzte Position fortsetzend, gelöscht wurden.</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>A new string that is equivalent to this string except for the removed characters.</source>
          <target state="translated">Eine neue Zeichenfolge, die dieser Zeichenfolge ohne die entfernten Zeichen entspricht.</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, strings are zero-based.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, Zeichenfolgen sind nullbasiert.</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The value of the <ph id="ph1">`startIndex`</ph> parameter can range from zero to one less than the length of the string instance.</source>
          <target state="translated">Der Wert, der die <ph id="ph1">`startIndex`</ph> -Parameter kann von 0 (null) bis eins weniger als die Länge der Zeichenfolgeninstanz reichen.</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>Instead, it returns a new string in which all characters from position <ph id="ph1">`startIndex`</ph> to the end of the original string have been removed.</source>
          <target state="translated">Stattdessen wird eine neue Zeichenfolge in der alle Zeichen ab Position <ph id="ph1">`startIndex`</ph> bis zum Ende der ursprünglichen Zeichenfolge entfernt wurden.</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The next-to-last case removes all text starting from the specified index through the end of the string.</source>
          <target state="translated">Die nächsten vorletztes Groß-/Kleinschreibung entfernt den gesamten Text aus dem angegebenen Index bis zum Ende der Zeichenfolge ab.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The last case removes three characters starting from the specified index.</source>
          <target state="translated">Im letzte Fall werden drei Zeichen beginnend am angegebenen Index entfernt.</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> specifies a position that is not within this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> gibt eine Position an, die sich nicht innerhalb dieser Zeichenfolge befindet.</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The zero-based position to begin deleting characters.</source>
          <target state="translated">Die nullbasierte Position, ab der Zeichen gelöscht werden sollen.</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The number of characters to delete.</source>
          <target state="translated">Die Anzahl der zu löschenden Zeichen.</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, in der eine bestimmte Anzahl von Zeichen in er aktuellen Instanz, beginnend an einer angegebenen Position, gelöscht wurden.</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>A new string that is equivalent to this instance except for the removed characters.</source>
          <target state="translated">Eine neue Zeichenfolge, die dieser Instanz ohne die entfernten Zeichen entspricht.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, strings are zero-based.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, Zeichenfolgen sind nullbasiert.</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The value of the <ph id="ph1">`startIndex`</ph> parameter can range from zero to one less than the length of the string instance.</source>
          <target state="translated">Der Wert, der die <ph id="ph1">`startIndex`</ph> -Parameter kann von 0 (null) bis eins weniger als die Länge der Zeichenfolgeninstanz reichen.</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>Instead, it returns a new string in which the number of characters specified by the <ph id="ph1">`count`</ph> parameter have been removed.</source>
          <target state="translated">Stattdessen gibt es eine neue Zeichenfolge, die in der die Anzahl von Zeichen, durch angegeben die <ph id="ph1">`count`</ph> Parameter wurden entfernt.</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The characters are removed at the position specified by <ph id="ph1">`startIndex`</ph>.</source>
          <target state="translated">Die Zeichen an der angegebenen Position entfernt <ph id="ph1">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The following example demonstrates how you can remove the middle name from a complete name.</source>
          <target state="translated">Im folgende Beispiel wird veranschaulicht, wie Sie aus dem vollständigen Namen des zweiten Vornamens entfernen können.</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="count" /&gt;</ph> specify a position outside this instance.</source>
          <target state="translated">Die Summe von <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> bezeichnet eine Position außerhalb dieser Instanz.</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string in which all occurrences of a specified Unicode character or <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> in the current string are replaced with another specified Unicode character or <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen von einem angegebenen Unicode-Zeichen oder <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> in der aktuellen Zeichenfolge durch ein anderes angegebenes Unicode-Zeichen oder einen anderen <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> ersetzt werden.</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The Unicode character to be replaced.</source>
          <target state="translated">Das zu ersetzende Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The Unicode character to replace all occurrences of <bpt id="p1">&lt;c&gt;</bpt>oldChar<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das Unicode-Zeichen, das jedes Vorkommen von <bpt id="p1">&lt;c&gt;</bpt>oldChar<ept id="p1">&lt;/c&gt;</ept> ersetzen soll.</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen eines angegebenen Unicode-Zeichens in dieser Instanz durch ein anderes angegebenes Unicode-Zeichen ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>A string that is equivalent to this instance except that all instances of <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> are replaced with <ph id="ph2">&lt;paramref name="newChar" /&gt;</ph>.</source>
          <target state="translated">Eine Zeichenfolge, die dieser Instanz entspricht, außer dass alle Instanzen von <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> durch <ph id="ph2">&lt;paramref name="newChar" /&gt;</ph> ersetzt werden.</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>If <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> is not found in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> nicht in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) search to find <ph id="ph1">`oldChar`</ph>.</source>
          <target state="translated">Diese Methode führt eine ordinale (Groß-/Kleinschreibung beachtet und kulturunabhängige) Suche nach <ph id="ph1">`oldChar`</ph>.</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Instead, it returns a new string in which all occurrences of <ph id="ph1">`oldChar`</ph> are replaced by <ph id="ph2">`newChar`</ph>.</source>
          <target state="translated">Stattdessen gibt Sie eine neue Zeichenfolge zurück, in der alle Vorkommen von <ph id="ph1">`oldChar`</ph> ersetzt durch <ph id="ph2">`newChar`</ph>.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Because this method returns the modified string, you can chain together successive calls to the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to perform multiple replacements on the original string.</source>
          <target state="translated">Da diese Methode die geänderte Zeichenfolge zurückgibt, Sie können Verketten von aufeinander folgenden Aufrufen der <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> Methode zum Ausführen von mehreren Ersetzungen für die ursprüngliche Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Method calls are executed from left to right.</source>
          <target state="translated">Methodenaufrufe werden von links nach rechts ausgeführt.</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The following example provides an illustration.</source>
          <target state="translated">Dies wird im folgenden Beispiel veranschaulicht.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The following example creates a comma separated value list by substituting commas for the blanks between a series of numbers.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Liste von durch Trennzeichen getrennte Werte durch Kommas, die Leerzeichen zwischen einer Reihe von Zahlen zu ersetzen.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>The string to be replaced.</source>
          <target state="translated">Die zu ersetzende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>The string to replace all occurrences of <bpt id="p1">&lt;c&gt;</bpt>oldValue<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Zeichenfolge, die jedes Vorkommen von <bpt id="p1">&lt;c&gt;</bpt>oldValue<ept id="p1">&lt;/c&gt;</ept> ersetzen soll.</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen einer angegebenen Zeichenfolge in der aktuellen Instanz durch eine andere angegebene Zeichenfolge ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>A string that is equivalent to the current string except that all instances of <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> are replaced with <ph id="ph2">&lt;paramref name="newValue" /&gt;</ph>.</source>
          <target state="translated">Eine Zeichenfolge, die der aktuellen Zeichenfolge entspricht, außer dass alle Instanzen von <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> durch <ph id="ph2">&lt;paramref name="newValue" /&gt;</ph> ersetzt werden.</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> is not found in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> nicht in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>If <ph id="ph1">`newValue`</ph> is <ph id="ph2">`null`</ph>, all occurrences of <ph id="ph3">`oldValue`</ph> are removed.</source>
          <target state="translated">Wenn <ph id="ph1">`newValue`</ph> ist <ph id="ph2">`null`</ph>, alle Vorkommen von <ph id="ph3">`oldValue`</ph> werden entfernt.</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>Instead, it returns a new string in which all occurrences of <ph id="ph1">`oldValue`</ph> are replaced by <ph id="ph2">`newValue`</ph>.</source>
          <target state="translated">Stattdessen gibt Sie eine neue Zeichenfolge zurück, in der alle Vorkommen von <ph id="ph1">`oldValue`</ph> ersetzt durch <ph id="ph2">`newValue`</ph>.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) search to find <ph id="ph1">`oldValue`</ph>.</source>
          <target state="translated">Diese Methode führt eine ordinale (Groß-/Kleinschreibung beachtet und kulturunabhängige) Suche nach <ph id="ph1">`oldValue`</ph>.</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>Because this method returns the modified string, you can chain together successive calls to the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to perform multiple replacements on the original string.</source>
          <target state="translated">Da diese Methode die geänderte Zeichenfolge zurückgibt, Sie können Verketten von aufeinander folgenden Aufrufen der <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> Methode zum Ausführen von mehreren Ersetzungen für die ursprüngliche Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>Method calls are executed from left to right.</source>
          <target state="translated">Methodenaufrufe werden von links nach rechts ausgeführt.</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>The following example provides an illustration.</source>
          <target state="translated">Dies wird im folgenden Beispiel veranschaulicht.</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>The following example demonstrates how you can use the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to correct a spelling error.</source>
          <target state="translated">Im folgende Beispiel wird veranschaulicht, wie Sie können die <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> Methode zum Rechtschreibfehler zu beheben.</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> ist die leere Zeichenfolge ("").</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a string array that contains the substrings in this instance that are delimited by elements of a specified string or Unicode character array.</source>
          <target state="translated">Gibt ein Zeichenfolgenarray zurück, das die Teilzeichenfolgen dieser Instanz enthält, die durch Elemente eines angegebenen Zeichenfolgen- oder Unicode-Zeichenarrays getrennt sind.</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> is used to break a delimited string into substrings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> wird verwendet, um eine durch Trennzeichen getrennte Zeichenfolge in Teilzeichenfolgen zu unterteilen.</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can use either a character array to specify zero, one, or multiple delimiting characters (the <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method), or you can use a character array to specify zero, one, or multiple delimiting strings.</source>
          <target state="translated">Sie können entweder ein Zeichenarray 0 (null), einer oder mehrerer Trennzeichen angeben (die <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> Methode), oder Sie können ein Array von Zeichen verwenden, um 0 (null), einer oder mehrerer begrenzenden Zeichenfolgen angeben.</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Overloads of the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method allow you to limit the number of substrings returned by the method (the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29&gt;</ph> method), to determine whether empty strings are included in the returned substrings (the <ph id="ph3">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> and <ph id="ph4">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> methods, or to do both (the <ph id="ph5">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> and <ph id="ph6">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> methods).</source>
          <target state="translated">Überladungen der der <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode ermöglichen es Ihnen, begrenzen die Anzahl von Teilzeichenfolgen, die von der Methode zurückgegeben (die <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29&gt;</ph> Methode), um zu bestimmen, ob leere Zeichenfolgen in der zurückgegebenen Teilzeichenfolgen enthalten sind (die <ph id="ph3">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> und <ph id="ph4">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> Methoden, oder Beide Methoden (die <ph id="ph5">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> und <ph id="ph6">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> Methoden).</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more detailed information on the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method, as well as for examples that call each overload, see the documentation for the individual overloads of <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</source>
          <target state="translated">Detaillierte Informationen auf der <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> -Methode, wie sowie Beispiele, in denen aufrufen jede Überladung, finden in der Dokumentation für die einzelnen Überladungen <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method is not always the best way to break a delimited string into substrings.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode ist nicht immer die beste Möglichkeit, eine durch Trennzeichen getrennte Zeichenfolge in Teilzeichenfolgen unterteilt.</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</source>
          <target state="translated">Wenn nicht alle Teilzeichenfolgen einer durch Trennzeichen getrennten Zeichenfolge extrahiert werden sollen oder eine Zeichenfolge, die basierend auf einem Muster, anstatt einen Satz von Trennzeichen analysiert werden sollen, sollten Sie die folgenden Alternativen.</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Regular expressions</source>
          <target state="translated">Reguläre Ausdrücke</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</source>
          <target state="translated">Wenn Zeichenfolgen einem festen Muster entsprechen, können Sie einen regulären Ausdruck zum Extrahieren und ihre Elemente zu behandeln.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if strings take the form "<bpt id="p1">*</bpt>number<ept id="p1">*</ept> <bpt id="p2">*</bpt>operand<ept id="p2">*</ept> <bpt id="p3">*</bpt>number<ept id="p3">*</ept>" you can use a <bpt id="p4">[</bpt>regular expression<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> to extract and handle the string's elements.</source>
          <target state="translated">Z. B. Zeichenfolgen handeln "<bpt id="p1">*</bpt>Anzahl<ept id="p1">*</ept> <bpt id="p2">*</bpt>Operand<ept id="p2">*</ept> <bpt id="p3">*</bpt>Anzahl<ept id="p3">*</ept>" können Sie eine <bpt id="p4">[</bpt>reguläre<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> extrahieren und Verarbeiten der Elemente mit der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's an example:</source>
          <target state="translated">Im Folgenden ein Beispiel:</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The regular expression pattern <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> is defined like this:</source>
          <target state="translated">Muster für reguläre Ausdrücke <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> wird wie folgt definiert:</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Entsprechung für mindestens eine Dezimalstelle finden.</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the first capturing group.</source>
          <target state="translated">Dies ist die erste Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">Übereinstimmung mit mindestens ein Leerzeichen Zeichen.</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match an arithmetic operator sign (+, -, *, or /).</source>
          <target state="translated">Entspricht einem arithmetischen Operator Vorzeichen (+, -, *, oder /).</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the second capturing group.</source>
          <target state="translated">Dies ist die zweite Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">Übereinstimmung mit mindestens ein Leerzeichen Zeichen.</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Entsprechung für mindestens eine Dezimalstelle finden.</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the third capturing group.</source>
          <target state="translated">Dies ist die dritte Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</source>
          <target state="translated">Einen regulären Ausdruck können auch um Teilzeichenfolgen aus einer Zeichenfolge basierend auf einen festen Satz von Zeichen, anstatt ein Muster zu extrahieren.</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is a common scenario when either of these conditions occurs:</source>
          <target state="translated">Dies ist ein gängiges Szenario, wenn eine dieser Bedingungen auftritt:</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>One or more of the delimiter characters does not always serve as a delimiter in the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated">Mindestens eines der Trennzeichen immer verarbeitet nicht als Trennzeichen in der <ph id="ph1">&lt;xref:System.String&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sequence and number of delimiter characters is variable or unknown.</source>
          <target state="translated">Die Reihenfolge und die Anzahl der Zeichen, Trennzeichen ist variabel oder unbekannt.</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method cannot be used to split the following string, because the number of <ph id="ph2">`\n`</ph> (in C#) or <ph id="ph3">`vbCrLf`</ph> (in Visual Basic) characters is variable, and they don't always serve as delimiters.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode kann nicht so teilen Sie die folgende Zeichenfolge verwendet werden, da die Anzahl der <ph id="ph2">`\n`</ph> (in c#) oder <ph id="ph3">`vbCrLf`</ph> (in Visual Basic) Zeichen ist variabel, und sie nicht immer als Trennzeichen dienen.</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A regular expression can split this string easily, as the following example shows.</source>
          <target state="translated">Diese Zeichenfolge kann einfach, wie das folgende Beispiel zeigt ein regulärer Ausdruck unterteilt werden.</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The regular expression pattern <ph id="ph1">`\[([^\[\]]+)\]`</ph> is defined like this:</source>
          <target state="translated">Muster für reguläre Ausdrücke <ph id="ph1">`\[([^\[\]]+)\]`</ph> wird wie folgt definiert:</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match an opening bracket.</source>
          <target state="translated">Übereinstimmung mit einer öffnenden Klammer.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match any character that is not an opening or a closing bracket one or more times.</source>
          <target state="translated">Übereinstimmung mit beliebigem Zeichen, die kein öffnendes oder eine schließende Klammer ein- oder mehrmals ist ein.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the first capturing group.</source>
          <target state="translated">Dies ist die erste Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match a closing bracket.</source>
          <target state="translated">Übereinstimmung mit einer schließenden Klammer.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method is almost identical to <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> Methode entspricht weitgehend dem <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, außer dass es sich um eine Zeichenfolge, die basierend auf das Muster eines regulären Ausdrucks anstelle einer festen Zeichensatz unterteilt.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</source>
          <target state="translated">Z. B. im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> Methode zum Aufteilen einer Zeichenfolge, die durch verschiedene Kombinationen von Bindestrichen und andere Zeichen als Trennzeichen für Teilzeichenfolgen enthält.</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The regular expression pattern <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> is defined like this:</source>
          <target state="translated">Muster für reguläre Ausdrücke <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> wird wie folgt definiert:</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match a whitespace character followed by a hyphen.</source>
          <target state="translated">Entspricht einem Leerzeichen, gefolgt von einem Bindestrich.</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">Übereinstimmung mit keinem oder einem Leerzeichen Zeichen.</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match zero or one occurrence of either the + or * character.</source>
          <target state="translated">Übereinstimmung mit keinem oder einem Vorkommen entweder das + oder * Zeichen.</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">Übereinstimmung mit keinem oder einem Leerzeichen Zeichen.</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match a hyphen followed by a whitespace character.</source>
          <target state="translated">Übereinstimmung mit einem Bindestrich gefolgt von einem Leerzeichen.</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Search methods and the Substring method</source>
          <target state="translated">Suchen von Methoden und der Substring-Methode</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</source>
          <target state="translated">Wenn Sie nicht alle der Teilzeichenfolgen in einer Zeichenfolge interessiert sind, empfiehlt es sich, arbeiten mit einer der Methoden zum Zeichenfolgenvergleich, die den Index zurückgibt, an dem der Vergleich beginnt.</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can then call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract the substring that you want.</source>
          <target state="translated">Rufen Sie dann die <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> Methode, um die Teilzeichenfolge extrahiert, die Sie möchten.</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The string comparison methods include:</source>
          <target state="translated">Die Methoden zum Zeichenfolgenvergleich gehören:</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, die den nullbasierten Index des ersten Vorkommens eines Zeichens oder einer Zeichenfolge in eine Zeichenfolgeninstanz zurückgibt.</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, die den nullbasierten Index in der aktuellen Zeichenfolgeninstanz des ersten Vorkommens eines beliebigen Zeichens aus einem Array von Zeichen zurückgibt.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, die den nullbasierten Index des letzten Vorkommens eines Zeichens oder einer Zeichenfolge in eine Zeichenfolgeninstanz zurückgibt.</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, womit einen nullbasierten Index in der aktuellen Zeichenfolgeninstanz des letzten Vorkommens eines beliebigen Zeichens aus einem Array von Zeichen zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to find the periods in a string.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode, um die Punkte in einer Zeichenfolge zu ermitteln.</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It then uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to return full sentences.</source>
          <target state="translated">Es verwendet dann die <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> Methode, um vollständige Sätze zurückzugeben.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>Splits a string into substrings that are based on the characters in an array.</source>
          <target state="translated">Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>An array whose elements contain the substrings from this instance that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Ein Array, dessen Elemente die Teilzeichenfolgen von dieser Instanz enthält, die durch ein oder mehr Zeichen aus <ph id="ph1">&lt;paramref name="separator" /&gt;</ph> getrennt sind.</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt "Hinweise".</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>When a string is delimited by a known set of characters, you can use the <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method to separate it into substrings.</source>
          <target state="translated">Wenn eine Zeichenfolge von einem bekannten Satz von Zeichen getrennt sind, können Sie die <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> Methode in Teilzeichenfolgen abzugrenzen.</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For other ways to extract substrings from a string, see the <bpt id="p1">[</bpt>Alternatives to String.Split<ept id="p1">](#Alternatives)</ept> section.</source>
          <target state="translated">Andere Möglichkeiten, um Teilzeichenfolgen aus einer Zeichenfolge zu extrahieren, finden Sie unter der <bpt id="p1">[</bpt>Alternativen zu String.Split<ept id="p1">](#Alternatives)</ept> Abschnitt.</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Return value details</source>
          <target state="translated">Rückgabewert-details</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
          <target state="translated">Trennzeichen sind nicht in den Elementen im zurückgegebenen Array enthalten.</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, if the separator array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
          <target state="translated">Beispielsweise enthält das Array Trennzeichen das Zeichen "-" und der Wert der aktuellen Zeichenfolgeninstanz "aa-bb-cc", die Methode gibt ein Array, das drei Elemente enthält: "aa", "bb" und "cc".</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Wenn keine Zeichen in dieser Instanz enthält <ph id="ph1">`separator`</ph>, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält.</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
          <target state="translated">Jedes Element der <ph id="ph1">`separator`</ph> ein separates Trennzeichen definiert.</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Wenn zwei Trennzeichen angrenzen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält das entsprechende Element im zurückgegebenen Array <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Here are some examples:</source>
          <target state="translated">Hier einige Beispiele:</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>String value</source>
          <target state="translated">Zeichenfolgenwert</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Separator</source>
          <target state="translated">Trennzeichen</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Returned array</source>
          <target state="translated">Zurückgegebene array</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"42, 12, 19"</source>
          <target state="translated">"42, 12, 19"</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {',', ' '} (C#)</source>
          <target state="translated">neue Char [] {',', ' '} (c#)</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {","c, " "c}) (Visual Basic)</source>
          <target state="translated">Char() = {"," c "" C}) (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"42", "", "12", "", "19"}</source>
          <target state="translated">{"42", "", "12", "", "19"}</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"42..12..19"</source>
          <target state="translated">"42..12..19"</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {'.'}</source>
          <target state="translated">new Char[] {'.'}</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char() = {"." c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"42", "", "12", "", "19"}</source>
          <target state="translated">{"42", "", "12", "", "19"}</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Banana"</source>
          <target state="translated">"Banane"</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {'.'}</source>
          <target state="translated">new Char[] {'.'}</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char() = {"." c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"Banana"}</source>
          <target state="translated">{"Banana"}</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (c#)</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; VbLf &amp; "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] <ph id="ph1">{}</ph> (C#)</source>
          <target state="translated">neue Char [] <ph id="ph1">{}</ph> (c#)</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = <ph id="ph1">{}</ph> (Visual Basic)</source>
          <target state="translated">Char() = <ph id="ph1">{}</ph> (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{"Darb", "Smarba"}</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (c#)</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; VbLf &amp; "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>null (C#)</source>
          <target state="translated">null (C#)</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Nothing (Visual Basic)</source>
          <target state="translated">Nothing (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{"Darb", "Smarba"}</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The separator array</source>
          <target state="translated">Das Separator-array</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Each element of separator defines a separate delimiter that consists of a single character.</source>
          <target state="translated">Jedes Element des Trennzeichens definiert ein separaten Trennzeichen, das ein einzelnes Zeichen besteht.</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If the <ph id="ph1">`separator`</ph> argument is <ph id="ph2">`null`</ph> or contains no characters, the method treats white-space characters as the delimiters.</source>
          <target state="translated">Wenn die <ph id="ph1">`separator`</ph> Argument ist <ph id="ph2">`null`</ph> oder keine Zeichen enthält, die Methode behandelt Leerzeichen als Trennzeichen.</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>White-space characters are defined by the Unicode standard; they return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Leerzeichen werden durch die Unicode-standard definiert. Diese zurückgeben <ph id="ph1">`true`</ph> Wenn es sich bei der Übergabe an die <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>String.Split(Char[]) and compiler overload resolution</source>
          <target state="translated">Auflösen der Überladung String.Split(Char[]) und compiler</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Although the single parameter for this overload of <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> is a character array, you can call it with a single character, as the following example shows.</source>
          <target state="translated">Obwohl die einzelnen Parameter für diese Überladung der <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> ist ein Array von Zeichen, wie im folgenden Beispiel gezeigt mit einem einzelnen Zeichen aufrufen.</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Because the <ph id="ph1">`separator`</ph> parameter is decorated  with the <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> attribute, compilers will interpret a single character as a single-element character array.</source>
          <target state="translated">Da die <ph id="ph1">`separator`</ph> Parameter ergänzt wird, mit der <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> -Attribut, Compiler ein einzelnes Zeichen als ein Array von Einzelelement-Zeichen interpretiert werden.</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is not the case for other <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> overloads that include a <ph id="ph2">`separator`</ph> parameter; you must explicitly pass these overloads a character array as the <ph id="ph3">`separator`</ph> argument.</source>
          <target state="translated">Dies gilt nicht für andere <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> Überladungen, die eine <ph id="ph2">`separator`</ph> -Parameter müssen Sie explizit übergeben diese Überladungen ein Array von Zeichen als die <ph id="ph3">`separator`</ph> Argument.</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Comparison details</source>
          <target state="translated">Von Vergleichsdetails</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the characters in the <ph id="ph2">`separator`</ph> array, and returns those substrings as elements of an array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> Methode extrahiert die Teilzeichenfolgen in dieser Zeichenfolge, die durch eine oder mehrere Zeichen getrennt sind die <ph id="ph2">`separator`</ph> array und gibt diese Teilzeichenfolgen als Elemente eines Arrays zurück.</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> Methode sucht nach Trennzeichen, durch das Durchführen von Vergleichen mit Ordinalsortierung Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter der <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Alternatives to String.Split</source>
          <target state="translated">Alternativen zu String.Split</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method is not always the best way to break a delimited string into substrings.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode ist nicht immer die beste Möglichkeit, eine durch Trennzeichen getrennte Zeichenfolge in Teilzeichenfolgen unterteilt.</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</source>
          <target state="translated">Wenn nicht alle Teilzeichenfolgen einer durch Trennzeichen getrennten Zeichenfolge extrahiert werden sollen oder eine Zeichenfolge, die basierend auf einem Muster, anstatt einen Satz von Trennzeichen analysiert werden sollen, sollten Sie die folgenden Alternativen.</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Regular expressions</source>
          <target state="translated">Reguläre Ausdrücke</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</source>
          <target state="translated">Wenn Zeichenfolgen einem festen Muster entsprechen, können Sie einen regulären Ausdruck zum Extrahieren und ihre Elemente zu behandeln.</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, if strings take the form "<bpt id="p1">*</bpt>number<ept id="p1">*</ept> <bpt id="p2">*</bpt>operand<ept id="p2">*</ept> <bpt id="p3">*</bpt>number<ept id="p3">*</ept>" you can use a <bpt id="p4">[</bpt>regular expression<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> to extract and handle the string's elements.</source>
          <target state="translated">Z. B. Zeichenfolgen handeln "<bpt id="p1">*</bpt>Anzahl<ept id="p1">*</ept> <bpt id="p2">*</bpt>Operand<ept id="p2">*</ept> <bpt id="p3">*</bpt>Anzahl<ept id="p3">*</ept>" können Sie eine <bpt id="p4">[</bpt>reguläre<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> extrahieren und Verarbeiten der Elemente mit der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Here's an example:</source>
          <target state="translated">Im Folgenden ein Beispiel:</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The regular expression pattern <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> is defined like this:</source>
          <target state="translated">Muster für reguläre Ausdrücke <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> wird wie folgt definiert:</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Entsprechung für mindestens eine Dezimalstelle finden.</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the first capturing group.</source>
          <target state="translated">Dies ist die erste Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">Übereinstimmung mit mindestens ein Leerzeichen Zeichen.</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match an arithmetic operator sign (+, -, *, or /).</source>
          <target state="translated">Entspricht einem arithmetischen Operator Vorzeichen (+, -, *, oder /).</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the second capturing group.</source>
          <target state="translated">Dies ist die zweite Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">Übereinstimmung mit mindestens ein Leerzeichen Zeichen.</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Entsprechung für mindestens eine Dezimalstelle finden.</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the third capturing group.</source>
          <target state="translated">Dies ist die dritte Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</source>
          <target state="translated">Einen regulären Ausdruck können auch um Teilzeichenfolgen aus einer Zeichenfolge basierend auf einen festen Satz von Zeichen, anstatt ein Muster zu extrahieren.</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is a common scenario when either of these conditions occurs:</source>
          <target state="translated">Dies ist ein gängiges Szenario, wenn eine dieser Bedingungen auftritt:</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>One or more of the delimiter characters does not always serve as a delimiter in the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated">Mindestens eines der Trennzeichen immer verarbeitet nicht als Trennzeichen in der <ph id="ph1">&lt;xref:System.String&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The sequence and number of delimiter characters is variable or unknown.</source>
          <target state="translated">Die Reihenfolge und die Anzahl der Zeichen, Trennzeichen ist variabel oder unbekannt.</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method cannot be used to split the following string, because the number of <ph id="ph2">`\n`</ph> (in C#) or <ph id="ph3">`vbCrLf`</ph> (in Visual Basic) characters is variable, and they don't always serve as delimiters.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode kann nicht so teilen Sie die folgende Zeichenfolge verwendet werden, da die Anzahl der <ph id="ph2">`\n`</ph> (in c#) oder <ph id="ph3">`vbCrLf`</ph> (in Visual Basic) Zeichen ist variabel, und sie nicht immer als Trennzeichen dienen.</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>A regular expression can split this string easily, as the following example shows.</source>
          <target state="translated">Diese Zeichenfolge kann einfach, wie das folgende Beispiel zeigt ein regulärer Ausdruck unterteilt werden.</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The regular expression pattern <ph id="ph1">`\[([^\[\]]+)\]`</ph> is defined like this:</source>
          <target state="translated">Muster für reguläre Ausdrücke <ph id="ph1">`\[([^\[\]]+)\]`</ph> wird wie folgt definiert:</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match an opening bracket.</source>
          <target state="translated">Übereinstimmung mit einer öffnenden Klammer.</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match any character that is not an opening or a closing bracket one or more times.</source>
          <target state="translated">Übereinstimmung mit beliebigem Zeichen, die kein öffnendes oder eine schließende Klammer ein- oder mehrmals ist ein.</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the first capturing group.</source>
          <target state="translated">Dies ist die erste Erfassungsgruppe.</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match a closing bracket.</source>
          <target state="translated">Übereinstimmung mit einer schließenden Klammer.</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method is almost identical to <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> Methode entspricht weitgehend dem <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, außer dass es sich um eine Zeichenfolge, die basierend auf das Muster eines regulären Ausdrucks anstelle einer festen Zeichensatz unterteilt.</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, the following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</source>
          <target state="translated">Z. B. im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> Methode zum Aufteilen einer Zeichenfolge, die durch verschiedene Kombinationen von Bindestrichen und andere Zeichen als Trennzeichen für Teilzeichenfolgen enthält.</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The regular expression pattern <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> is defined like this:</source>
          <target state="translated">Muster für reguläre Ausdrücke <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> wird wie folgt definiert:</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Pattern</source>
          <target state="translated">Muster</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match a whitespace character followed by a hyphen.</source>
          <target state="translated">Entspricht einem Leerzeichen, gefolgt von einem Bindestrich.</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">Übereinstimmung mit keinem oder einem Leerzeichen Zeichen.</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match zero or one occurrence of either the + or * character.</source>
          <target state="translated">Übereinstimmung mit keinem oder einem Vorkommen entweder das + oder * Zeichen.</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">Übereinstimmung mit keinem oder einem Leerzeichen Zeichen.</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match a hyphen followed by a whitespace character.</source>
          <target state="translated">Übereinstimmung mit einem Bindestrich gefolgt von einem Leerzeichen.</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Search methods and the Substring method</source>
          <target state="translated">Suchen von Methoden und der Substring-Methode</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</source>
          <target state="translated">Wenn Sie nicht alle der Teilzeichenfolgen in einer Zeichenfolge interessiert sind, empfiehlt es sich, arbeiten mit einer der Methoden zum Zeichenfolgenvergleich, die den Index zurückgibt, an dem der Vergleich beginnt.</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>You can then call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract the substring that you want.</source>
          <target state="translated">Rufen Sie dann die <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> Methode, um die Teilzeichenfolge extrahiert, die Sie möchten.</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The string comparison methods include:</source>
          <target state="translated">Die Methoden zum Zeichenfolgenvergleich gehören:</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, die den nullbasierten Index des ersten Vorkommens eines Zeichens oder einer Zeichenfolge in eine Zeichenfolgeninstanz zurückgibt.</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, die den nullbasierten Index in der aktuellen Zeichenfolgeninstanz des ersten Vorkommens eines beliebigen Zeichens aus einem Array von Zeichen zurückgibt.</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, die den nullbasierten Index des letzten Vorkommens eines Zeichens oder einer Zeichenfolge in eine Zeichenfolgeninstanz zurückgibt.</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, womit einen nullbasierten Index in der aktuellen Zeichenfolgeninstanz des letzten Vorkommens eines beliebigen Zeichens aus einem Array von Zeichen zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to find the periods in a string.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode, um die Punkte in einer Zeichenfolge zu ermitteln.</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>It then uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to return full sentences.</source>
          <target state="translated">Es verwendet dann die <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> Methode, um vollständige Sätze zurückzugeben.</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Performance Considerations</source>
          <target state="translated">Überlegungen zur Leistung</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methoden von Arbeitsspeicher für das zurückgegebene Array-Objekt und ein <ph id="ph2">&lt;xref:System.String&gt;</ph> -Objekt für jedes Arrayelement.</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Ihre Anwendung eine optimale Leistung erfordert oder Verwalten von speicherbelegung in Ihrer Anwendung wichtig ist, sollten Sie mithilfe der <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>You also have the option of using the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to locate a substring within a string.</source>
          <target state="translated">Sie haben auch die Möglichkeit der Verwendung der <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> Methode, um eine Teilzeichenfolge innerhalb einer Zeichenfolge suchen.</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>To split a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Um eine Zeichenfolge an einem Trennzeichen teilen möchten, verwenden Sie die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> Methode zum Suchen eines Trennzeichens in der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>To split a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Um eine Zeichenfolge an einem Trennzeichen teilen möchten, verwenden die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen.</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Verwenden Sie dann die <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen der Zeichenfolge als Trennzeichen gleich sind.</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen und in jedem Methodenaufruf darauf verweisen.</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Dies verringert erheblich den Mehraufwand von jedem Methodenaufruf.</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The following example demonstrates how to extract individual words from a block of text by treating white space and punctuation marks as delimiters.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie einzelne Wörter aus einem Text-Block zum Behandeln von Leerzeichen und Satzzeichen, als Trennzeichen zu extrahieren.</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The character array passed to the <ph id="ph1">`separator`</ph> parameter of the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method consists of a space character and a tab character, together with some common punctuation symbols.</source>
          <target state="translated">Das Zeichenarray übergeben, um die <ph id="ph1">`separator`</ph> Parameter von der <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> Methode besteht aus einem Leerzeichen und einem Tabstoppzeichen, zusammen mit einigen häufig verwendeten Interpunktionszeichen.</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> und frühere Versionen, wenn die <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> -Methode übergeben eine <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> also <ph id="ph4">&lt;see langword="null" /&gt;</ph> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen der Zeichenfolge als die <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> Methode bewirkt Kürzen Sie die Zeichenfolge ein.</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, beide Methoden verwenden einen identischen Satz von Unicode-Leerzeichen.</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The maximum number of substrings to return.</source>
          <target state="translated">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Splits a string into a maximum number of substrings based on the characters in an array.</source>
          <target state="translated">Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in eine maximale Anzahl von Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>You also specify the maximum number of substrings to return.</source>
          <target state="translated">Sie geben außerdem die maximale Anzahl der zurückzugebenden Teilzeichenfolgen an.</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>An array whose elements contain the substrings in this instance that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Instanz enthält, die durch ein oder mehr Zeichen aus <ph id="ph1">&lt;paramref name="separator" /&gt;</ph> getrennt sind.</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt "Hinweise".</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
          <target state="translated">Trennzeichen sind nicht in den Elementen im zurückgegebenen Array enthalten.</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Wenn keine Zeichen in dieser Instanz enthält <ph id="ph1">`separator`</ph>, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält.</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is zero, an empty array is returned.</source>
          <target state="translated">Wenn <ph id="ph1">`count`</ph> NULL ist, wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Wenn die <ph id="ph1">`separator`</ph> Parameter ist <ph id="ph2">`null`</ph> oder keine Zeichen enthält Leerzeichen wird angenommen, dass die Trennzeichen.</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Leerzeichen werden durch die Unicode-standard und return definiert <ph id="ph1">`true`</ph> Wenn es sich bei der Übergabe an die <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
          <target state="translated">Jedes Element der <ph id="ph1">`separator`</ph> ein separates Trennzeichen definiert.</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Wenn zwei Trennzeichen angrenzen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält das entsprechende Arrayelement <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
          <target state="translated">Treten mehr als <ph id="ph1">`count`</ph> Teilzeichenfolgen in dieser Instanz, die die erste <ph id="ph2">`count`</ph> 1 Teilzeichenfolgen sind in der ersten zurückgegebenen <ph id="ph3">`count`</ph> minus 1 Elemente zurückgegeben und die übrigen Zeichen in dieser Instanz werden in den letzten zurückgegeben Element des Rückgabewerts.</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
          <target state="translated">Wenn <ph id="ph1">`count`</ph> ist größer als die Anzahl von Teilzeichenfolgen auf, werden die verfügbaren Teilzeichenfolgen zurückgegeben und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The following table provides examples.</source>
          <target state="translated">Die folgende Tabelle enthält Beispiele.</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>String value</source>
          <target state="translated">Zeichenfolgenwert</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Separator</source>
          <target state="translated">Trennzeichen</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Count</source>
          <target state="translated">Anzahl</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Returned array</source>
          <target state="translated">Zurückgegebene array</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"42, 12, 19"</source>
          <target state="translated">"42, 12, 19"</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {',', ' '} (C#)</source>
          <target state="translated">neue Char [] {',', ' '} (c#)</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {","c, " "c} (Visual Basic)</source>
          <target state="translated">Char() = {"," c "" C} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"42", " 12, 19"}</source>
          <target state="translated">{"42", " 12, 19"}</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"42..12..19"</source>
          <target state="translated">"42..12..19"</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {'.'}</source>
          <target state="translated">new Char[] {'.'}</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char() = {"." c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"42", "", "12", ".19"}</source>
          <target state="translated">{"42", "", "12", ".19"}</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Banana"</source>
          <target state="translated">"Banane"</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {'.'}</source>
          <target state="translated">new Char[] {'.'}</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char() = {"." c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Banana"}</source>
          <target state="translated">{"Banana"}</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (c#)</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; VbLf &amp; "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] <ph id="ph1">{}</ph> (C#)</source>
          <target state="translated">neue Char [] <ph id="ph1">{}</ph> (c#)</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = <ph id="ph1">{}</ph> (Visual Basic)</source>
          <target state="translated">Char() = <ph id="ph1">{}</ph> (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Darb\nSmarba"} (C#)</source>
          <target state="translated">{"Darb\nSmarba"} (C#)</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; VbLf &amp; "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (c#)</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; VbLf &amp; "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] null (C#)</source>
          <target state="translated">neue Char [] null (c#)</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = Nothing</source>
          <target state="translated">Char() = Nothing</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{"Darb", "Smarba"}</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">"Darb\nSmarba" (c#)</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">"Darb" &amp; VbLf &amp; "Smarba" (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] null (C#)</source>
          <target state="translated">neue Char [] null (c#)</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = Nothing</source>
          <target state="translated">Char() = Nothing</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>100</source>
          <target state="translated">100</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{"Darb", "Smarba"}</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Performance Considerations</source>
          <target state="translated">Überlegungen zur Leistung</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methoden von Arbeitsspeicher für das zurückgegebene Array-Objekt und ein <ph id="ph2">&lt;xref:System.String&gt;</ph> -Objekt für jedes Arrayelement.</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Wenn Ihre Anwendung eine optimale Leistung erfordert oder Verwalten von speicherbelegung in Ihrer Anwendung wichtig ist, sollten Sie mithilfe der <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> -Methode, und optional die <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> Methode, um eine Teilzeichenfolge innerhalb einer Zeichenfolge zu suchen.</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> Methode zum Suchen eines Trennzeichens in der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen.</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Verwenden Sie dann die <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen der Zeichenfolge als Trennzeichen gleich sind.</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen und in jedem Methodenaufruf darauf verweisen.</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Dies verringert erheblich den Mehraufwand von jedem Methodenaufruf.</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The following example demonstrates how <ph id="ph1">`count`</ph> affects the number of strings returned by <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</source>
          <target state="translated">Im folgende Beispiel wird veranschaulicht, wie <ph id="ph1">`count`</ph> wirkt sich auf die Anzahl der Zeichenfolgen zurückgegebenes <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> und frühere Versionen, wenn die <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> -Methode übergeben eine <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> also <ph id="ph4">&lt;see langword="null" /&gt;</ph> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen der Zeichenfolge als die <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> Methode bewirkt Kürzen Sie die Zeichenfolge ein.</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, beide Methoden verwenden einen identischen Satz von Unicode-Leerzeichen.</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph>, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph>, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Splits a string into substrings based on the characters in an array.</source>
          <target state="translated">Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>You can specify whether the substrings include empty array elements.</source>
          <target state="translated">Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichen aus <ph id="ph1">&lt;paramref name="separator" /&gt;</ph> getrennt sind.</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt "Hinweise".</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Return value details</source>
          <target state="translated">Rückgabewert-details</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Delimiter characters (the characters in the <ph id="ph1">`separator`</ph> array) are not included in the elements of the returned array.</source>
          <target state="translated">Trennzeichen (die Zeichen in der <ph id="ph1">`separator`</ph> Array) sind nicht in den Elementen im zurückgegebenen Array enthalten.</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For example, if the <ph id="ph1">`separator`</ph> array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
          <target state="translated">Beispielsweise, wenn die <ph id="ph1">`separator`</ph> Array enthält das Zeichen "-" und der Wert der aktuellen Zeichenfolgeninstanz "aa-bb-cc", die Methode gibt ein Array, das drei Elemente enthält: "aa", "bb" und "cc".</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Wenn keine Zeichen in dieser Instanz enthält <ph id="ph1">`separator`</ph>, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält.</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, the method returns an empty array.</source>
          <target state="translated">Wenn die <ph id="ph1">`options`</ph> Parameter ist <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> und die Länge dieser Instanz ist NULL, wird die Methode ein leeres Array zurück.</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of a single character.</source>
          <target state="translated">Jedes Element der <ph id="ph1">`separator`</ph> definiert ein separates Trennzeichen, die ein einzelnes Zeichen besteht.</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> argument is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn die <ph id="ph1">`options`</ph> Argument ist <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, und zwei Trennzeichen angrenzen oder am Anfang oder Ende dieser Instanz ein Trennzeichen gefunden wird, enthält das entsprechende Arrayelement <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For example, if <ph id="ph1">`separator`</ph> includes  two elements, "-" and "<ph id="ph2">\_</ph>", the value of the string instance is "-<ph id="ph3">\_</ph>aa-<ph id="ph4">\_</ph>", and the value of   the <ph id="ph5">`options`</ph> argument is <ph id="ph6">&lt;xref:System.StringSplitOptions.None&gt;</ph>, the method returns a string array with the following five elements:</source>
          <target state="translated">Z. B. wenn <ph id="ph1">`separator`</ph> enthält zwei Elemente, die "-" und "<ph id="ph2">\_</ph>", ist der Wert der Zeichenfolgeninstanz "-<ph id="ph3">\_</ph>aa -<ph id="ph4">\_</ph>", und der Wert des der <ph id="ph5">`options`</ph> Argument ist <ph id="ph6">&lt;xref:System.StringSplitOptions.None&gt;</ph>, die Methode gibt ein Zeichenfolgenarray mit zurück. die folgenden fünf Elemente:</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that precedes the "-" character at index 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, das darstellt, dass der leeren Zeichenfolge, die vor der "-"-Zeichen am Index 0.</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, das darstellt, dass der leeren Zeichenfolge zwischen dem "-"-Zeichen am Index 0 und das Zeichen "_" am Index 1.</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>"aa",</source>
          <target state="translated">"aa",</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "_" character at index 4.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, die die leere Zeichenfolge, die das Zeichen "_" Index 4 folgt darstellt.</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "-" character at index 5.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, der darstellt, dass der leeren Zeichenfolge, die folgt der "-"-Zeichen am Index 5.</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The separator array</source>
          <target state="translated">Das Separator-array</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Wenn die <ph id="ph1">`separator`</ph> Parameter ist <ph id="ph2">`null`</ph> oder keine Zeichen enthält Leerzeichen wird angenommen, dass die Trennzeichen.</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Leerzeichen werden durch die Unicode-standard und return definiert <ph id="ph1">`true`</ph> Wenn es sich bei der Übergabe an die <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">Wenn die <ph id="ph1">`separator`</ph> Parameter im Aufruf der Überladung dieser Methode ist <ph id="ph2">`null`</ph>, Compiler überladungsauflösung ein Fehler auftritt.</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Um die aufgerufene Methode eindeutig identifizieren zu können, muss Ihr Code geben den Typ der der <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">Das folgende Beispiel zeigt mehrere Möglichkeiten, diese Überladung eindeutig zu identifizieren.</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Comparison details</source>
          <target state="translated">Von Vergleichsdetails</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the characters in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode extrahiert die Teilzeichenfolgen in dieser Zeichenfolge, die durch eine oder mehrere Zeichen getrennt sind die <ph id="ph2">`separator`</ph> Parameter, und gibt diese Teilzeichenfolgen als Elemente eines Arrays zurück.</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode sucht nach Trennzeichen, durch das Durchführen von Vergleichen mit Ordinalsortierung Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter der <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Performance Considerations</source>
          <target state="translated">Überlegungen zur Leistung</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methoden von Arbeitsspeicher für das zurückgegebene Array-Objekt und ein <ph id="ph2">&lt;xref:System.String&gt;</ph> -Objekt für jedes Arrayelement.</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Wenn Ihre Anwendung eine optimale Leistung erfordert oder Verwalten von speicherbelegung in Ihrer Anwendung wichtig ist, sollten Sie mithilfe der <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> -Methode, und optional die <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> Methode, um eine Teilzeichenfolge innerhalb einer Zeichenfolge zu suchen.</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> Methode zum Suchen eines Trennzeichens in der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen.</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Verwenden Sie dann die <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen der Zeichenfolge als Trennzeichen gleich sind.</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen und in jedem Methodenaufruf darauf verweisen.</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Dies verringert erheblich den Mehraufwand von jedem Methodenaufruf.</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumeration to include or exclude substrings generated by the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> Enumeration zum ein- bzw. Ausschließen von generierte Teilzeichenfolgen die <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> entspricht keinem der <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> und frühere Versionen, wenn die <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> -Methode übergeben eine <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> also <ph id="ph4">&lt;see langword="null" /&gt;</ph> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen der Zeichenfolge als die <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> Methode bewirkt Kürzen Sie die Zeichenfolge ein.</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, beide Methoden verwenden einen identischen Satz von Unicode-Leerzeichen.</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Array mit Zeichenfolgen, die die Teilzeichenfolgen in dieser Zeichenfolge trennen, ein leeres Array ohne Trennzeichen oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph>, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph>, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Splits a string into substrings based on the strings in an array.</source>
          <target state="translated">Unterteilt eine Zeichenfolge anhand der Zeichenfolgen in einem Array in Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>You can specify whether the substrings include empty array elements.</source>
          <target state="translated">Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more strings in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichenfolgen aus <ph id="ph1">&lt;paramref name="separator" /&gt;</ph> getrennt sind.</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt "Hinweise".</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>When a string is delimited by a known set of strings, you can use the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method to separate it into substrings.</source>
          <target state="translated">Wenn eine Zeichenfolge von einem bekannten Satz von Zeichenfolgen getrennt ist, können Sie die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode in Teilzeichenfolgen abzugrenzen.</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Return value details</source>
          <target state="translated">Rückgabewert-details</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Delimiter strings are not included in the elements of the returned array.</source>
          <target state="translated">Trennzeichen-Zeichenfolgen werden nicht in den Elementen im zurückgegebenen Array enthalten.</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, if the <ph id="ph1">`separator`</ph> array includes the string "--" and the value of the current string instance is "aa--bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
          <target state="translated">Beispielsweise, wenn die <ph id="ph1">`separator`</ph> Array enthält die Zeichenfolge "--" und der Wert der aktuellen Zeichenfolgeninstanz "aa - bb-cc", die Methode gibt ein Array, das drei Elemente enthält: "aa", "bb" und "cc".</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If this instance does not contain any of the strings in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Wenn keine der Zeichenfolgen in dieser Instanz enthält <ph id="ph1">`separator`</ph>, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält.</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, the method returns an empty array.</source>
          <target state="translated">Wenn die <ph id="ph1">`options`</ph> Parameter ist <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> und die Länge dieser Instanz ist NULL, wird die Methode ein leeres Array zurück.</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of one or more characters.</source>
          <target state="translated">Jedes Element der <ph id="ph1">`separator`</ph> definiert ein separates Trennzeichen, die aus einem oder mehreren Zeichen besteht.</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> argument is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn die <ph id="ph1">`options`</ph> Argument ist <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, und zwei Trennzeichen angrenzen oder am Anfang oder Ende dieser Instanz ein Trennzeichen gefunden wird, enthält das entsprechende Arrayelement <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, if <ph id="ph1">`separator`</ph> includes  two elements, "-" and "_", the value of the string instance is "-_aa-<ph id="ph2">\_</ph>", and the value of   the <ph id="ph3">`options`</ph> argument is <ph id="ph4">&lt;xref:System.StringSplitOptions.None&gt;</ph>, the method returns a sting array with the following five elements:</source>
          <target state="translated">Z. B. wenn <ph id="ph1">`separator`</ph> enthält zwei Elemente, die "-" und "_", um der Wert der Zeichenfolgeninstanz ist "- _aa -<ph id="ph2">\_</ph>", und der Wert von der <ph id="ph3">`options`</ph> Argument ist <ph id="ph4">&lt;xref:System.StringSplitOptions.None&gt;</ph>, die Methode gibt ein Sting-Array mit den folgenden fünf Elementen zurück:</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that precedes the "-" substring at index 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, das darstellt, dass der leeren Zeichenfolge, die vor der "-" Teilzeichenfolge am Index 0.</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string between the "-" substring at index 0 and the "_" substring at index 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, das darstellt, dass der leeren Zeichenfolge zwischen dem "-" Teilzeichenfolge am Index 0 und die Teilzeichenfolge "_" am Index 1.</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>"aa",</source>
          <target state="translated">"aa",</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "_" substring at index 4.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, die die leere Zeichenfolge, die die Teilzeichenfolge "_" Index 4 folgt darstellt.</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "-" substring at index 5.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, der darstellt, dass der leeren Zeichenfolge, die folgt der "-" Teilzeichenfolge am Index 5.</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The separator array</source>
          <target state="translated">Das Separator-array</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If any of the elements in <ph id="ph1">`separator`</ph> consists of multiple characters, the entire substring is considered a delimiter.</source>
          <target state="translated">Wenn keines der Elemente im <ph id="ph1">`separator`</ph> besteht aus mehreren Zeichen, gilt die gesamte Teilzeichenfolge ein Trennzeichen.</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, if one of the elements in <ph id="ph1">`separator`</ph> is "10", attempting to split the string "This10is10a10string."</source>
          <target state="translated">Angenommen, sofern der Elemente im <ph id="ph1">`separator`</ph> ist "10", bei dem Versuch, teilen die Zeichenfolge "This10is10a10string."</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>returns the following four-element array: { "This", "is", "a", "string."</source>
          <target state="translated">Gibt die folgenden vier Elementen Array: {"This", "is", "a", "String".</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>}.</source>
          <target state="translated">}.</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Wenn die <ph id="ph1">`separator`</ph> Parameter ist <ph id="ph2">`null`</ph> oder keine Zeichen enthält Leerzeichen wird angenommen, dass die Trennzeichen.</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Leerzeichen werden durch die Unicode-standard und return definiert <ph id="ph1">`true`</ph> Wenn es sich bei der Übergabe an die <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">Wenn die <ph id="ph1">`separator`</ph> Parameter im Aufruf der Überladung dieser Methode ist <ph id="ph2">`null`</ph>, Compiler überladungsauflösung ein Fehler auftritt.</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Um die aufgerufene Methode eindeutig identifizieren zu können, muss Ihr Code geben den Typ der der <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">Das folgende Beispiel zeigt mehrere Möglichkeiten, diese Überladung eindeutig zu identifizieren.</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Comparison details</source>
          <target state="translated">Von Vergleichsdetails</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the strings in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode extrahiert die Teilzeichenfolgen in dieser Zeichenfolge, die durch mindestens eine der Zeichenfolgen in begrenzt werden die <ph id="ph2">`separator`</ph> Parameter, und gibt diese Teilzeichenfolgen als Elemente eines Arrays zurück.</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode sucht nach Trennzeichen, durch das Durchführen von Vergleichen mit Ordinalsortierung Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter der <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method ignores any element of <ph id="ph2">`separator`</ph> whose value is <ph id="ph3">`null`</ph> or the empty string ("").</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode ignoriert alle Elemente von <ph id="ph2">`separator`</ph> , dessen Wert <ph id="ph3">`null`</ph> oder eine leere Zeichenfolge ("").</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>To avoid ambiguous results when strings in <ph id="ph1">`separator`</ph> have characters in common, the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in <ph id="ph3">`separator`</ph> that is equal to a delimiter in the instance.</source>
          <target state="translated">Um mehrdeutige Ergebnisse zu vermeiden bei Zeichenfolgen im <ph id="ph1">`separator`</ph> haben Zeichen gemeinsam, die <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> Vorgang vom Anfang bis zum Ende des Werts der Instanz wird fortgesetzt, und entspricht dem ersten Element in <ph id="ph3">`separator`</ph> , die gleich ein Trennzeichen in der -Instanz.</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The order in which substrings are encountered in the instance takes precedence over the order of elements in <ph id="ph1">`separator`</ph>.</source>
          <target state="translated">Die Reihenfolge, in der Teilzeichenfolgen in der Instanz, hat Vorrang vor der Reihenfolge der Elemente im <ph id="ph1">`separator`</ph>.</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, consider an instance whose value is "abcdef".</source>
          <target state="translated">Betrachten Sie beispielsweise eine Instanz, deren Wert "Abcdef".</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the first element in <ph id="ph1">`separator`</ph> was "ef" and the second element was "bcde", the result of the split operation would be a string array that contains two elements, "a" and "f".</source>
          <target state="translated">Wenn das erste Element im <ph id="ph1">`separator`</ph> "Ef" und das zweite Element "bcde", ist das Ergebnis des Split-Vorgangs wäre ein Zeichenfolgenarray, das zwei Elemente enthält "a" und "f".</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This is because the substring in the instance, "bcde", is encountered and matches an element in <ph id="ph1">`separator`</ph> before the substring "f" is encountered.</source>
          <target state="translated">Grund hierfür ist die Teilzeichenfolge in der Instanz "bcde" überein, festgestellt wird, und entspricht einem Element im <ph id="ph1">`separator`</ph> vor dem Auftreten der Teilzeichenfolge "f".</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>However, if the first element of <ph id="ph1">`separator`</ph> was "bcd" and the second element was "bc", the result of the split operation would be a string array that contains two elements, "a" and "ef".</source>
          <target state="translated">Jedoch, wenn das erste Element des <ph id="ph1">`separator`</ph> "bcd" und das zweite Element wurde "bc", ist das Ergebnis des Split-Vorgangs wäre ein Zeichenfolgenarray, das zwei Elemente enthält "a" und "Ef".</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This is because "bcd" is the first delimiter in <ph id="ph1">`separator`</ph> that matches a delimiter in the instance.</source>
          <target state="translated">Dies liegt daran "bcd" das erste Trennzeichen in <ph id="ph1">`separator`</ph> , ein Trennzeichen in der Instanz entspricht.</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be a string array that contains two elements,  "a" and "def".</source>
          <target state="translated">Wenn die Reihenfolge der Trennzeichen umgekehrt wird, sodass das erste Element "bc" wurde und das zweite Element wurde "bcd", das Ergebnis wäre ein Zeichenfolgenarray, das zwei Elemente enthält "a" und "Def".</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Performance considerations</source>
          <target state="translated">Überlegungen zur Leistung</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methoden von Arbeitsspeicher für das zurückgegebene Array-Objekt und ein <ph id="ph2">&lt;xref:System.String&gt;</ph> -Objekt für jedes Arrayelement.</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Wenn Ihre Anwendung eine optimale Leistung erfordert oder Verwalten von speicherbelegung in Ihrer Anwendung wichtig ist, sollten Sie mithilfe der <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> -Methode, und optional die <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> Methode, um eine Teilzeichenfolge innerhalb einer Zeichenfolge zu suchen.</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> Methode zum Suchen eines Trennzeichens in der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen.</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Verwenden Sie dann die <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen der Zeichenfolge als Trennzeichen gleich sind.</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen und in jedem Methodenaufruf darauf verweisen.</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Dies verringert erheblich den Mehraufwand von jedem Methodenaufruf.</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The following example illustrates the difference in the arrays returned by calling a string's <ph id="ph1">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType&gt;</ph> method with its <ph id="ph2">`options`</ph> parameter equal to <ph id="ph3">&lt;xref:System.StringSplitOptions.None?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht den Unterschied zwischen den Arrays zurückgegeben, indem einer Zeichenfolge <ph id="ph1">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType&gt;</ph> Methode mit seiner <ph id="ph2">`options`</ph> Parameter gleich <ph id="ph3">&lt;xref:System.StringSplitOptions.None?displayProperty=nameWithType&gt;</ph> und <ph id="ph4">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The following example defines an array of separators that include punctuation and white-space characters.</source>
          <target state="translated">Das folgende Beispiel definiert ein Array von Trennzeichen, die Interpunktion und Leerzeichen enthalten.</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Passing this array along with a value of <ph id="ph1">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph> to the <ph id="ph2">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> method returns an array that consists of the individual words from the string.</source>
          <target state="translated">Übergibt dieses Array zusammen mit einem Wert von <ph id="ph1">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph> auf die <ph id="ph2">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> -Methode gibt ein Array, aus denen die einzelne Wörter aus der Zeichenfolge besteht.</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Note that the method is called with the <ph id="ph1">`options`</ph> argument set to <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Beachten Sie, die die Methode aufgerufen wird, mit der <ph id="ph1">`options`</ph> Argument festgelegt wird, um <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This prevents the returned array from including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> values that represent empty substring matches between punctuation marks and white-space characters.</source>
          <target state="translated">Dadurch wird verhindert, dass das zurückgegebene Array einschließlich <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> Werten, leeren Teilzeichenfolge Übereinstimmungen zwischen Satzzeichen und Leerzeichen darstellen.</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> entspricht keinem der <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> und frühere Versionen, wenn die <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> -Methode übergeben eine <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> also <ph id="ph4">&lt;see langword="null" /&gt;</ph> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen der Zeichenfolge als die <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> Methode bewirkt Kürzen Sie die Zeichenfolge ein.</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, beide Methoden verwenden einen identischen Satz von Unicode-Leerzeichen.</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The maximum number of substrings to return.</source>
          <target state="translated">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph>, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph>, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Splits a string into a maximum number of substrings based on the characters in an array.</source>
          <target state="translated">Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in eine maximale Anzahl von Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichen aus <ph id="ph1">&lt;paramref name="separator" /&gt;</ph> getrennt sind.</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt "Hinweise".</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
          <target state="translated">Trennzeichen sind nicht in den Elementen im zurückgegebenen Array enthalten.</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, or the <ph id="ph2">`count`</ph> parameter is 1, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Wenn keine Zeichen in dieser Instanz enthält <ph id="ph1">`separator`</ph>, oder die <ph id="ph2">`count`</ph> Parameter ist 1, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält.</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Wenn die <ph id="ph1">`separator`</ph> Parameter ist <ph id="ph2">`null`</ph> oder keine Zeichen enthält Leerzeichen wird angenommen, dass die Trennzeichen.</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Leerzeichen werden durch die Unicode-standard und return definiert <ph id="ph1">`true`</ph> Wenn es sich bei der Übergabe an die <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>However, if the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">Jedoch, wenn die <ph id="ph1">`separator`</ph> Parameter im Aufruf der Überladung dieser Methode ist <ph id="ph2">`null`</ph>, Compiler überladungsauflösung ein Fehler auftritt.</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the null.</source>
          <target state="translated">Um die aufgerufene Methode eindeutig zu identifizieren, muss der Code den Typ der Null angeben.</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">Das folgende Beispiel zeigt mehrere Möglichkeiten, diese Überladung eindeutig zu identifizieren.</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`count`</ph> parameter is zero, or the <ph id="ph2">`options`</ph> parameter is <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, an empty array is returned.</source>
          <target state="translated">Wenn die <ph id="ph1">`count`</ph> -Parameter ist 0 (null), oder die <ph id="ph2">`options`</ph> Parameter ist <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> und die Länge dieser Instanz ist 0 (null), wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
          <target state="translated">Jedes Element der <ph id="ph1">`separator`</ph> ein separates Trennzeichen definiert.</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Wenn die <ph id="ph1">`options`</ph> Parameter ist <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, und zwei Trennzeichen angrenzen oder am Anfang oder Ende dieser Instanz ein Trennzeichen gefunden wird, enthält das entsprechende Arrayelement <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
          <target state="translated">Treten mehr als <ph id="ph1">`count`</ph> Teilzeichenfolgen in dieser Instanz, die die erste <ph id="ph2">`count`</ph> 1 Teilzeichenfolgen sind in der ersten zurückgegebenen <ph id="ph3">`count`</ph> minus 1 Elemente zurückgegeben und die übrigen Zeichen in dieser Instanz werden in den letzten zurückgegeben Element des Rückgabewerts.</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
          <target state="translated">Wenn <ph id="ph1">`count`</ph> ist größer als die Anzahl von Teilzeichenfolgen auf, werden die verfügbaren Teilzeichenfolgen zurückgegeben und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Performance Considerations</source>
          <target state="translated">Überlegungen zur Leistung</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methoden von Arbeitsspeicher für das zurückgegebene Array-Objekt und ein <ph id="ph2">&lt;xref:System.String&gt;</ph> -Objekt für jedes Arrayelement.</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Wenn Ihre Anwendung eine optimale Leistung erfordert oder Verwalten von speicherbelegung in Ihrer Anwendung wichtig ist, sollten Sie mithilfe der <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> -Methode, und optional die <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> Methode, um eine Teilzeichenfolge innerhalb einer Zeichenfolge zu suchen.</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> Methode zum Suchen eines Trennzeichens in der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen.</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Verwenden Sie dann die <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen der Zeichenfolge als Trennzeichen gleich sind.</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen und in jedem Methodenaufruf darauf verweisen.</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Dies verringert erheblich den Mehraufwand von jedem Methodenaufruf.</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumeration to include or exclude substrings generated by the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> Enumeration zum ein- bzw. Ausschließen von generierte Teilzeichenfolgen die <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> entspricht keinem der <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> und frühere Versionen, wenn die <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> -Methode übergeben eine <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> also <ph id="ph4">&lt;see langword="null" /&gt;</ph> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen der Zeichenfolge als die <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> Methode bewirkt Kürzen Sie die Zeichenfolge ein.</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, beide Methoden verwenden einen identischen Satz von Unicode-Leerzeichen.</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Array mit Zeichenfolgen, die die Teilzeichenfolgen in dieser Zeichenfolge trennen, ein leeres Array ohne Trennzeichen oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The maximum number of substrings to return.</source>
          <target state="translated">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph>, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph>, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Splits a string into a maximum number of substrings based on the strings in an array.</source>
          <target state="translated">Unterteilt eine Zeichenfolge anhand der Zeichenfolgen in einem Array in eine maximale Anzahl von Teilzeichenfolgen.</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>You can specify whether the substrings include empty array elements.</source>
          <target state="translated">Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more strings in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichenfolgen aus <ph id="ph1">&lt;paramref name="separator" /&gt;</ph> getrennt sind.</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt "Hinweise".</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Return value details</source>
          <target state="translated">Rückgabewert-details</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Delimiter strings are not included in the elements of the returned array.</source>
          <target state="translated">Trennzeichen-Zeichenfolgen werden nicht in den Elementen im zurückgegebenen Array enthalten.</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If this instance does not contain any of the strings in <ph id="ph1">`separator`</ph>, or the <ph id="ph2">`count`</ph> parameter is 1, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Wenn keine der Zeichenfolgen in dieser Instanz enthält <ph id="ph1">`separator`</ph>, oder die <ph id="ph2">`count`</ph> Parameter ist 1, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält.</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Wenn die <ph id="ph1">`separator`</ph> Parameter ist <ph id="ph2">`null`</ph> oder keine Zeichen enthält Leerzeichen wird angenommen, dass die Trennzeichen.</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Leerzeichen werden durch die Unicode-standard und return definiert <ph id="ph1">`true`</ph> Wenn es sich bei der Übergabe an die <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>However, if the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">Jedoch, wenn die <ph id="ph1">`separator`</ph> Parameter im Aufruf der Überladung dieser Methode ist <ph id="ph2">`null`</ph>, Compiler überladungsauflösung ein Fehler auftritt.</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Um die aufgerufene Methode eindeutig identifizieren zu können, muss Ihr Code geben den Typ der der <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">Das folgende Beispiel zeigt mehrere Möglichkeiten, diese Überladung eindeutig zu identifizieren.</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`count`</ph> parameter is zero, or the <ph id="ph2">`options`</ph> parameter is <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, an empty array is returned.</source>
          <target state="translated">Wenn die <ph id="ph1">`count`</ph> -Parameter ist 0 (null), oder die <ph id="ph2">`options`</ph> Parameter ist <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> und die Länge dieser Instanz ist 0 (null), wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of one or more characters.</source>
          <target state="translated">Jedes Element der <ph id="ph1">`separator`</ph> definiert ein separates Trennzeichen, die aus einem oder mehreren Zeichen besteht.</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Wenn die <ph id="ph1">`options`</ph> Parameter ist <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, und zwei Trennzeichen angrenzen oder am Anfang oder Ende dieser Instanz ein Trennzeichen gefunden wird, enthält das entsprechende Arrayelement <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
          <target state="translated">Treten mehr als <ph id="ph1">`count`</ph> Teilzeichenfolgen in dieser Instanz, die die erste <ph id="ph2">`count`</ph> 1 Teilzeichenfolgen sind in der ersten zurückgegebenen <ph id="ph3">`count`</ph> minus 1 Elemente zurückgegeben und die übrigen Zeichen in dieser Instanz werden in den letzten zurückgegeben Element des Rückgabewerts.</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
          <target state="translated">Wenn <ph id="ph1">`count`</ph> ist größer als die Anzahl von Teilzeichenfolgen auf, werden die verfügbaren Teilzeichenfolgen zurückgegeben und keine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The separator array</source>
          <target state="translated">Das Separator-array</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If any of the elements in <ph id="ph1">`separator`</ph> consists of multiple characters, the entire substring is considered a delimiter.</source>
          <target state="translated">Wenn keines der Elemente im <ph id="ph1">`separator`</ph> besteht aus mehreren Zeichen, gilt die gesamte Teilzeichenfolge ein Trennzeichen.</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For example, if one of the elements in <ph id="ph1">`separator`</ph> is "10", attempting to split the string "This10is10a10string."</source>
          <target state="translated">Angenommen, sofern der Elemente im <ph id="ph1">`separator`</ph> ist "10", bei dem Versuch, teilen die Zeichenfolge "This10is10a10string."</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>returns this four-element array: { "This", "is", "a", "string."</source>
          <target state="translated">Gibt dieses Array mit vier Elementen: {"This", "is", "a", "String".</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>}.</source>
          <target state="translated">}.</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Comparison details</source>
          <target state="translated">Von Vergleichsdetails</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the strings in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode extrahiert die Teilzeichenfolgen in dieser Zeichenfolge, die durch mindestens eine der Zeichenfolgen in begrenzt werden die <ph id="ph2">`separator`</ph> Parameter, und gibt diese Teilzeichenfolgen als Elemente eines Arrays zurück.</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode sucht nach Trennzeichen, durch das Durchführen von Vergleichen mit Ordinalsortierung Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Weitere Informationen zu Word, Zeichenfolgen- und ordinal sortiert, finden Sie unter der <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method ignores any element of <ph id="ph2">`separator`</ph> whose value is <ph id="ph3">`null`</ph> or the empty string ("").</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methode ignoriert alle Elemente von <ph id="ph2">`separator`</ph> , dessen Wert <ph id="ph3">`null`</ph> oder eine leere Zeichenfolge ("").</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>To avoid ambiguous results when strings in <ph id="ph1">`separator`</ph> have characters in common, the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method proceeds from the beginning to the end of the value of the instance, and matches the first element in <ph id="ph3">`separator`</ph> that is equal to a delimiter in the instance.</source>
          <target state="translated">Um mehrdeutige Ergebnisse zu vermeiden bei Zeichenfolgen im <ph id="ph1">`separator`</ph> haben Zeichen gemeinsam, die <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> Methode geht von Anfang bis zum Ende des Werts der Instanz, und entspricht dem ersten Element in <ph id="ph3">`separator`</ph> , die gleich ein Trennzeichen in der -Instanz.</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The order in which substrings are encountered in the instance takes precedence over the order of elements in <ph id="ph1">`separator`</ph>.</source>
          <target state="translated">Die Reihenfolge, in der Teilzeichenfolgen in der Instanz, hat Vorrang vor der Reihenfolge der Elemente im <ph id="ph1">`separator`</ph>.</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For example, consider an instance whose value is "abcdef".</source>
          <target state="translated">Betrachten Sie beispielsweise eine Instanz, deren Wert "Abcdef".</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the first element in <ph id="ph1">`separator`</ph> was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f".</source>
          <target state="translated">Wenn das erste Element im <ph id="ph1">`separator`</ph> "Ef" und das zweite Element "bcde", ist das Ergebnis des Split-Vorgangs wäre "a" und "f".</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>This is because the substring in the instance, "bcde", is encountered and matches an element in <ph id="ph1">`separator`</ph> before the substring "f" is encountered.</source>
          <target state="translated">Grund hierfür ist die Teilzeichenfolge in der Instanz "bcde" überein, festgestellt wird, und entspricht einem Element im <ph id="ph1">`separator`</ph> vor dem Auftreten der Teilzeichenfolge "f".</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>However, if the first element of <ph id="ph1">`separator`</ph> was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef".</source>
          <target state="translated">Jedoch, wenn das erste Element des <ph id="ph1">`separator`</ph> "bcd" und das zweite Element wurde "bc", ist das Ergebnis des Split-Vorgangs wäre "a" und "Ef".</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>This is because "bcd" is the first delimiter in <ph id="ph1">`separator`</ph> that matches a delimiter in the instance.</source>
          <target state="translated">Dies liegt daran "bcd" das erste Trennzeichen in <ph id="ph1">`separator`</ph> , ein Trennzeichen in der Instanz entspricht.</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def".</source>
          <target state="translated">Wenn die Reihenfolge der Trennzeichen umgekehrt wird, sodass das erste Element "bc" wurde und das zweite Element wurde "bcd", wäre das Ergebnis "a" und "Def".</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Performance considerations</source>
          <target state="translated">Überlegungen zur Leistung</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methoden von Arbeitsspeicher für das zurückgegebene Array-Objekt und ein <ph id="ph2">&lt;xref:System.String&gt;</ph> -Objekt für jedes Arrayelement.</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Wenn Ihre Anwendung eine optimale Leistung erfordert oder Verwalten von speicherbelegung in Ihrer Anwendung wichtig ist, sollten Sie mithilfe der <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> -Methode, und optional die <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> Methode, um eine Teilzeichenfolge innerhalb einer Zeichenfolge zu suchen.</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> Methode zum Suchen eines Trennzeichens in der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen.</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Verwenden Sie dann die <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen der Zeichenfolge als Trennzeichen gleich sind.</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen und in jedem Methodenaufruf darauf verweisen.</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Dies verringert erheblich den Mehraufwand von jedem Methodenaufruf.</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumeration to include or exclude substrings generated by the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> Enumeration zum ein- bzw. Ausschließen von generierte Teilzeichenfolgen die <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> entspricht keinem der <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> und frühere Versionen, wenn die <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> -Methode übergeben eine <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> also <ph id="ph4">&lt;see langword="null" /&gt;</ph> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen der Zeichenfolge als die <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> Methode bewirkt Kürzen Sie die Zeichenfolge ein.</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">In der <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, beide Methoden verwenden einen identischen Satz von Unicode-Leerzeichen.</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Determines whether the beginning of this string instance matches a specified string.</source>
          <target state="translated">Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz mit einer angegebenen Zeichenfolge übereinstimmt.</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source>The string to compare.</source>
          <target state="translated">Die zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source>Determines whether the beginning of this string instance matches the specified string.</source>
          <target state="translated">Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz mit der angegebenen Zeichenfolge übereinstimmt.</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> matches the beginning of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="value" /&gt;</ph> mit dem Anfang dieser Zeichenfolge übereinstimmt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>This method compares <ph id="ph1">`value`</ph> to the substring at the beginning of this instance that is the same length as <ph id="ph2">`value`</ph>, and returns an indication whether they are equal.</source>
          <target state="translated">Diese Methode vergleicht <ph id="ph1">`value`</ph> mit der Teilzeichenfolge am Anfang dieser Instanz, die die gleiche Länge wie <ph id="ph2">`value`</ph>, und gibt einen Wert zurück, ob sie gleich sind.</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be an empty string (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), must be a reference to this same instance, or must match the beginning of this instance.</source>
          <target state="translated">Gleich, <ph id="ph1">`value`</ph> muss eine leere Zeichenfolge (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), muss ein Verweis auf die gleiche Instanz oder der Anfang dieser Instanz müssen übereinstimmen.</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">Diese Methode vergleicht Word (Groß-/Kleinschreibung beachtet und der Kultur) mit der aktuellen Kultur.</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>The following example defines a <ph id="ph1">`StripStartTags`</ph> method that uses the <ph id="ph2">&lt;xref:System.String.StartsWith%28System.String%29&gt;</ph> method to remove HTML start tags from the beginning of a string.</source>
          <target state="translated">Das folgende Beispiel definiert eine <ph id="ph1">`StripStartTags`</ph> Methode, verwendet die <ph id="ph2">&lt;xref:System.String.StartsWith%28System.String%29&gt;</ph> -Methode zum Entfernen von HTML-Starttags vom Anfang einer Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>Note that the <ph id="ph1">`StripStartTags`</ph> method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed.</source>
          <target state="translated">Beachten Sie, dass die <ph id="ph1">`StripStartTags`</ph> Methode rekursiv aufgerufen, um sicherzustellen, dass mehrere HTML-Tags mit Beginn am Anfang der Zeile entfernt werden.</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>The example does not remove HTML tags embedded in a string.</source>
          <target state="translated">Im Beispiel werden keine HTML-Tags, eingebettet in einer Zeichenfolge entfernt.</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Wie in beschrieben <bpt id="p1">[</bpt>bewährte Methoden für die Verwendung von Zeichenfolgen<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, sollten Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen.</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>To determine whether a string begins with a particular substring by using the string comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Aufrufen, um zu bestimmen, ob eine Zeichenfolge mit einer bestimmten Teilzeichenfolge beginnt, mithilfe der Regeln für Zeichenfolgenvergleiche der aktuellen Kultur, die <ph id="ph1">&lt;see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /&gt;</ph> methodenüberladung mit einem Wert von <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> für seine <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The string to compare.</source>
          <target state="translated">Die zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>One of the enumeration values that determines how this string and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">Einer der Enumerationswerte, die bestimmen, wie diese Zeichenfolge und <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> verglichen werden.</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</source>
          <target state="translated">Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Vergleichsoption mit der angegebenen Zeichenfolge übereinstimmt.</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this instance begins with <ph id="ph2">&lt;paramref name="value" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn diese Instanz mit <ph id="ph2">&lt;paramref name="value" /&gt;</ph> beginnt; andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method compares the <ph id="ph2">`value`</ph> parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> -Methode vergleicht die <ph id="ph2">`value`</ph> Parameter mit der Teilzeichenfolge am Anfang dieser Zeichenfolge und gibt einen Wert, der angibt, ob sie gleich sind.</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same string, must be the empty string (""), or must match the beginning of this string.</source>
          <target state="translated">Als gleich ansehen <ph id="ph1">`value`</ph> ein Verweis auf die gleiche Zeichenfolge ist, eine leere Zeichenfolge (""), oder mit den Anfang dieser Zeichenfolge übereinstimmt.</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The type of comparison performed by the <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method depends on the value of the <ph id="ph2">`comparisonType`</ph> parameter.</source>
          <target state="translated">Der Typ des Vergleichs von ausgeführten der <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> Methode hängt vom Wert von der <ph id="ph2">`comparisonType`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The comparison can use the conventions of the current culture (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>) or the invariant culture (<ph id="ph3">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>), or it can consist of a character-by-character comparison of code points (<ph id="ph5">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Der Vergleich können die Konventionen der aktuellen Kultur (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>) oder der invarianten Kultur (<ph id="ph3">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph> und <ph id="ph4">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>), oder es kann besteht aus einem Zeichen für Zeichen Vergleich Codepunkte (<ph id="ph5">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> oder <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The comparison can also be case-sensitive (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>), or it can ignore case (<ph id="ph4">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Der Vergleich kann auch Groß-/Kleinschreibung beachtet werden (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph>, oder <ph id="ph3">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>), oder sie können die Groß-/Kleinschreibung ignorieren (<ph id="ph4">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The following example searches for the string "the" at the beginning of a longer string that begins with the word "The".</source>
          <target state="translated">Das folgende Beispiel sucht nach der Zeichenfolge "the" am Anfang eine längere Zeichenfolge, die beginnt mit dem Wort "The".</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>As the output from the example shows, a call to the <ph id="ph1">&lt;xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29&gt;</ph> method that performs a culture-insensitive but case-sensitive comparison fails to match the string, while a call that performs a culture- and case-insensitive comparison matches the string.</source>
          <target state="translated">Wie die Ausgabe des Beispiels zeigt, die einen Aufruf der <ph id="ph1">&lt;xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29&gt;</ph> -Methode, die eine kulturunabhängige jedoch die Groß-/Kleinschreibung Vergleich ein Fehler auftritt, mit die Zeichenfolge übereinstimmen, während ein Aufrufs an, die eine Kultur und Fall insensitive Vergleich der Zeichenfolge übereinstimmt.</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The following example determines whether a string starts with a particular substring.</source>
          <target state="translated">Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge mit einer bestimmten Teilzeichenfolge beginnt.</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>It initializes a two-dimensional string array.</source>
          <target state="translated">Ein zweidimensionales Array initialisiert.</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The first element in the second dimension contains a string, and the second element contains the string to search for at the start of the first string.</source>
          <target state="translated">Das erste Element der zweiten Dimension enthält eine Zeichenfolge, und das zweite Element enthält die Zeichenfolge, die am Anfang der ersten Zeichenfolge suchen.</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</source>
          <target state="translated">Die Ergebnisse sind betroffen, durch die Auswahl der Kultur, gibt an, ob die Groß-/Kleinschreibung ignoriert wird und ob ein ordinalen Vergleich ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>Note that when the string instance contains a ligature, culture-sensitive comparisons with its consecutive characters successfully match.</source>
          <target state="translated">Beachten Sie, dass bei die Zeichenfolgeninstanz eine Ligatur enthält, kulturabhängigen vergleichen mit aufeinander folgenden Zeichen erfolgreich entsprechen.</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> ist kein <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The string to compare.</source>
          <target state="translated">Die zu vergleichende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Cultural information that determines how this string and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">Kulturinformationen, die bestimmen, wie diese Instanz und <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> verglichen werden.</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current culture is used.</source>
          <target state="translated">Wenn <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist, wird die aktuelle Kultur verwendet.</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</source>
          <target state="translated">Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Kultur mit der angegebenen Zeichenfolge übereinstimmt.</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter matches the beginning of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;paramref name="value" /&gt;</ph>-Parameter mit dem Anfang dieser Zeichenfolge übereinstimmt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method compares the <ph id="ph1">`value`</ph> parameter to the substring at the beginning of this string that is the same length as <ph id="ph2">`value`</ph>, and returns a value that indicates whether they are equal.</source>
          <target state="translated">Diese Methode vergleicht die <ph id="ph1">`value`</ph> Parameter mit der Teilzeichenfolge am Anfang dieser Zeichenfolge, die gleiche Länge wie <ph id="ph2">`value`</ph>, und gibt einen Wert, der angibt, ob sie gleich sind.</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be an empty string (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), must be a reference to this same instance, or must match the beginning of this instance.</source>
          <target state="translated">Gleich, <ph id="ph1">`value`</ph> muss eine leere Zeichenfolge (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), muss ein Verweis auf die gleiche Instanz oder der Anfang dieser Instanz müssen übereinstimmen.</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method performs a comparison using the specified casing and culture.</source>
          <target state="translated">Diese Methode führt einen Vergleich mit der angegebenen Groß-/Kleinschreibung und Kultur entspricht.</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example determines whether a string occurs at the beginning of another string.</source>
          <target state="translated">Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge am Anfang einer anderen Zeichenfolge auftritt.</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> Methode wird aufgerufen, mehrmals mit Groß-/Kleinschreibung, Groß-/Kleinschreibung und andere Kulturen, die die Ergebnisse der Suche zu beeinflussen.</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Retrieves a substring from this instance.</source>
          <target state="translated">Ruft eine Teilzeichenfolge dieser Instanz ab.</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>This member is overloaded.</source>
          <target state="translated">Dieser Member wird überladen.</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>For complete information about this member, including syntax, usage, and examples, click a name in the overload list.</source>
          <target state="translated">Klicken Sie auf einen Namen in der Überladungsliste, um vollständige Informationen zu diesem Member sowie zu Syntax, Nutzung und Beispielen zu erhalten.</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>The zero-based starting character position of a substring in this instance.</source>
          <target state="translated">Die nullbasierte Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>Retrieves a substring from this instance.</source>
          <target state="translated">Ruft eine Teilzeichenfolge dieser Instanz ab.</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>The substring starts at a specified character position and continues to the end of the string.</source>
          <target state="translated">Die untergeordnete Zeichenfolge beginnt in einer angegebenen Zeichenposition und wird an das Ende der Zeichenfolge fortgesetzt.</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>A string that is equivalent to the substring that begins at <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> in this instance, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is equal to the length of this instance.</source>
          <target state="translated">Eine Zeichenfolge, die der Teilzeichenfolge ab <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> in dieser Instanz entspricht, oder <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, wenn <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> gleich der Länge dieser Instanz ist.</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract a substring from a string that begins at a specified character position and ends at the end of the string.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> Methode, um eine Unterzeichenfolge aus einer Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und endet am Ende der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</source>
          <target state="translated">Die Anfangsposition ist eine nullbasiert. Das heißt, ist das erste Zeichen in der Zeichenfolge am Index 0 (null) nicht Index 1 ein.</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>To extract a substring that begins at a specified character position and ends before to the end of the string, call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method.</source>
          <target state="translated">Um eine Teilzeichenfolge, die an einer angegebenen Zeichenposition beginnt und endet vor bis zum Ende der Zeichenfolge zu extrahieren, rufen Sie die <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>Instead, it returns a new string that begins at the <ph id="ph1">`startIndex`</ph> position in the current string.</source>
          <target state="translated">Stattdessen gibt es eine neue Zeichenfolge, die bei beginnt die <ph id="ph1">`startIndex`</ph> Position in der aktuellen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>To extract a substring that begins with a particular character or character sequence, call a method such as  <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> to get the value of <ph id="ph3">`startIndex`</ph>.</source>
          <target state="translated">Um eine Teilzeichenfolge extrahiert, die mit einem bestimmten Zeichen oder die Zeichenfolge beginnt, eine Methode aufrufen, z. B. <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> zum Abrufen des Werts <ph id="ph3">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The second example illustrates this; it extracts a key value that begins one character position after the "=" character.</source>
          <target state="translated">Das zweite Beispiel veranschaulicht dies. extrahiert einen Schlüssel-Wert, der eine Zeichenposition nach dem Zeichen "=" beginnt.</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to zero, the method returns the original string unchanged.</source>
          <target state="translated">Wenn <ph id="ph1">`startIndex`</ph> ist gleich 0 (null), die Methode gibt die ursprüngliche Zeichenfolge unverändert.</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The following example demonstrates obtaining a substring from a string.</source>
          <target state="translated">Das folgende Beispiel zeigt eine Teilzeichenfolge aus einer Zeichenfolge abrufen.</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to separate key/value pairs that are delimited by an equals ("=") character.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> Methode zum Trennen von Schlüssel/Wert-Paaren, die durch ein Gleichheitszeichen getrennt sind ("=") Zeichen.</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method is used to get the position of the equals character in the string..</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode wird verwendet, um die Position des Zeichens ist gleich in der Zeichenfolge abzurufen...</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Der Aufruf der <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> Methode extrahiert der Schlüsselname angegeben., der vom ersten Zeichen in der Zeichenfolge beginnt und für die Anzahl der Zeichen, die vom Aufruf zurückgegebene erweitert die <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> method then extracts the value assigned to the key.</source>
          <target state="translated">Der Aufruf der <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> Methode extrahiert dann den Wert, der dem Schlüssel zugeordnet.</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>It starts at one character position beyond the equals character and extends to the end of the string.</source>
          <target state="translated">Er beginnt an einer Position des Zeichens hinter dem Gleichheitszeichen und reicht bis zum Ende der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than the length of this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The zero-based starting character position of a substring in this instance.</source>
          <target state="translated">Die nullbasierte Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The number of characters in the substring.</source>
          <target state="translated">Die Anzahl der Zeichen in der Teilzeichenfolge.</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>Retrieves a substring from this instance.</source>
          <target state="translated">Ruft eine Teilzeichenfolge dieser Instanz ab.</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The substring starts at a specified character position and has a specified length.</source>
          <target state="translated">Die Teilzeichenfolge beginnt an einer angegebenen Zeichenposition und hat eine angegebene Länge.</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>A string that is equivalent to the substring of length <ph id="ph1">&lt;paramref name="length" /&gt;</ph> that begins at <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> in this instance, or <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> is equal to the length of this instance and <ph id="ph5">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated">Eine Zeichenfolge, die der Teilzeichenfolge mit der Länge <ph id="ph1">&lt;paramref name="length" /&gt;</ph> ab <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> in dieser Instanz entspricht, oder <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>, wenn <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> gleich der Länge dieser Instanz und <ph id="ph5">&lt;paramref name="length" /&gt;</ph> 0 (null) ist.</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method to extract a substring from a string that begins at a specified character position and ends before the end of the string.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> Methode, um eine Unterzeichenfolge aus einer Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und endet vor dem Ende der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</source>
          <target state="translated">Die Anfangsposition ist eine nullbasiert. Das heißt, ist das erste Zeichen in der Zeichenfolge am Index 0 (null) nicht Index 1 ein.</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>To extract a substring that begins at a specified character position and continues to the end of the string, call the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> method.</source>
          <target state="translated">Um eine Teilzeichenfolge, die an einer angegebenen Zeichenposition beginnt und bis zum Ende der Zeichenfolge zu extrahieren, rufen Sie die <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>Instead, it returns a new string with <ph id="ph1">`length`</ph> characters starting from the <ph id="ph2">`startIndex`</ph> position in the current string.</source>
          <target state="translated">Stattdessen gibt es eine neue Zeichenfolge mit <ph id="ph1">`length`</ph> Zeichen ab der der <ph id="ph2">`startIndex`</ph> Position in der aktuellen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`length`</ph> parameter represents the total number of characters to extract from the current string instance.</source>
          <target state="translated">Die <ph id="ph1">`length`</ph> Parameter stellt die Gesamtzahl der Zeichen, die aus der aktuellen Zeichenfolgeninstanz zu extrahieren.</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This includes the starting character found at index  <ph id="ph1">`startIndex`</ph>.</source>
          <target state="translated">Dies schließt das erste Zeichen am Index gefunden <ph id="ph1">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>In other words, the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method attempts to extract characters from index <ph id="ph2">`startIndex`</ph> to index <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph> - 1.</source>
          <target state="translated">Das heißt, die <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> Methode versucht, das Extrahieren von Zeichen aus dem Index <ph id="ph2">`startIndex`</ph> Index <ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph> - 1.</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>To extract a substring that begins with a particular character or character sequence, call a method such as  <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> to get the value of <ph id="ph3">`startIndex`</ph>.</source>
          <target state="translated">Um eine Teilzeichenfolge extrahiert, die mit einem bestimmten Zeichen oder die Zeichenfolge beginnt, eine Methode aufrufen, z. B. <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> zum Abrufen des Werts <ph id="ph3">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If the substring extends from <ph id="ph1">`startIndex`</ph> to a specified character sequence, you can call a method such as  <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> to get the index of the ending character or character sequence.</source>
          <target state="translated">Wenn die Teilzeichenfolge vom erstreckt <ph id="ph1">`startIndex`</ph> auf eine angegebene Zeichenfolge können Sie z. B. eine Methode aufrufen <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> den Index der Endzeichen oder Zeichenfolge abgerufen.</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>You can then convert that value to an index position in the string as follows:</source>
          <target state="translated">Sie können dann wie folgt diesen Wert an eine Indexposition in der Zeichenfolge konvertieren:</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If you've searched for a single character that is to mark the end of the substring, the <ph id="ph1">`length`</ph> parameter equals  <ph id="ph2">`endIndex`</ph><ph id="ph3"> - </ph><ph id="ph4">`startIndex`</ph> + 1, where <ph id="ph5">`endIndex`</ph> is the return value of the <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein einzelnes Zeichen gesucht haben, das das Ende der Teilzeichenfolge, markieren der <ph id="ph1">`length`</ph> entspricht <ph id="ph2">`endIndex`</ph> <ph id="ph3"> - </ph> <ph id="ph4">`startIndex`</ph> + 1, in dem <ph id="ph5">`endIndex`</ph> ist der Rückgabewert von der <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example extracts a continuous block of "b" characters from a string.</source>
          <target state="translated">Das folgende Beispiel extrahiert einen kontinuierlichen Speicherplatzblock "b"-Zeichen aus einer Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If you've searched for multiple characters that are to mark the end of the substring, the <ph id="ph1">`length`</ph> parameter equals  <ph id="ph2">`endIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`endMatchLength`</ph><ph id="ph5"> - </ph><ph id="ph6">`startIndex`</ph>, where <ph id="ph7">`endIndex`</ph> is the return value of the <ph id="ph8">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph9">&lt;xref:System.String.IndexOf%2A&gt;</ph> method., and <ph id="ph10">`endMatchLength`</ph> is the length of the character sequence that marks the end of the substring.</source>
          <target state="translated">Wenn Sie mehrere Zeichen gesucht haben, die das Ende der Teilzeichenfolge, markieren das <ph id="ph1">`length`</ph> entspricht <ph id="ph2">`endIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`endMatchLength`</ph> <ph id="ph5"> - </ph> <ph id="ph6">`startIndex`</ph>, wobei <ph id="ph7">`endIndex`</ph> ist der Rückgabewert von der <ph id="ph8">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph9">&lt;xref:System.String.IndexOf%2A&gt;</ph> -Methode. und <ph id="ph10">`endMatchLength`</ph> ist die Länge der Zeichenfolge ist, die das Ende der Teilzeichenfolge markiert.</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example extracts a block of text that contains an XML <ph id="ph1">`&lt;definition&gt;`</ph> element.</source>
          <target state="translated">Das folgende Beispiel extrahiert einen Textblock an, die eine XML-Datei enthält <ph id="ph1">`&lt;definition&gt;`</ph> Element.</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If the character or character sequence is not included in the end of the substring, the <ph id="ph1">`length`</ph> parameter equals <ph id="ph2">`endIndex`</ph><ph id="ph3"> - </ph><ph id="ph4">`startIndex`</ph>, where <ph id="ph5">`endIndex`</ph> is the return value of the <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Wenn das Zeichen oder die Zeichenfolge am Ende der Teilzeichenfolge, nicht enthalten ist die <ph id="ph1">`length`</ph> entspricht <ph id="ph2">`endIndex`</ph> <ph id="ph3"> - </ph> <ph id="ph4">`startIndex`</ph>, wobei <ph id="ph5">`endIndex`</ph> ist der Rückgabewert von der <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> oder <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to zero and  equals the length of the current string, the method returns the original string unchanged.</source>
          <target state="translated">Wenn <ph id="ph1">`startIndex`</ph> ist gleich 0 (null) und ist gleich der Länge der aktuellen Zeichenfolge, die Methode gibt die ursprüngliche Zeichenfolge unverändert zurück.</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example illustrates a simple call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method that extracts two characters from a string starting at the sixth character position (that is, at index five).</source>
          <target state="translated">Das folgende Beispiel veranschaulicht einen einfache Aufruf der <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> -Methode, die zwei Zeichen aus einer Zeichenfolge, beginnend an der Zeichenposition der sechsten extrahiert (d. h. am index 5).</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method in the following three cases to isolate substrings within a string.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> Methode in den folgenden drei Fällen Teilzeichenfolgen innerhalb einer Zeichenfolge isoliert.</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>In two cases the substrings are used in comparisons, and in the third case an exception is thrown because invalid parameters are specified.</source>
          <target state="translated">In beiden Fällen werden die Teilzeichenfolgen in Vergleichen verwendet, und im dritten Fall wird eine Ausnahme ausgelöst, weil ungültige Parameter angegeben werden.</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It extracts the single character and the third position in the string (at index 2) and compares it with a "c".</source>
          <target state="translated">Extrahiert das einzelne Zeichen und der dritten Position in der Zeichenfolge (am Index 2), und vergleicht ihn mit einem "c".</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This comparison returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Dieser Vergleich gibt <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It extracts zero characters starting at the fourth position in the string (at index 3) and passes it to the <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method.</source>
          <target state="translated">0 (null) Zeichen ab der vierten Position in der Zeichenfolge (am Index 3) extrahiert und übergibt es an die <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This returns true because the call to the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method returns <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Dies gibt "true", da der Aufruf der <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> -Methode zurückkehrt <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It attempts to extract one character starting at the fourth position in the string.</source>
          <target state="translated">Es versucht, ein Zeichen ab der vierten Position in der Zeichenfolge zu extrahieren.</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>Because there is no character at that position, the method call throws an <ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> exception.</source>
          <target state="translated">Da es kein Zeichen an dieser Position ist, löst der Methodenaufruf eine <ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> Ausnahme.</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to separate key/value pairs that are delimited by an equals ("=") character.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> Methode zum Trennen von Schlüssel/Wert-Paaren, die durch ein Gleichheitszeichen getrennt sind ("=") Zeichen.</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method is used to get the position of the equals character in the string..</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode wird verwendet, um die Position des Zeichens ist gleich in der Zeichenfolge abzurufen...</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Der Aufruf der <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> Methode extrahiert der Schlüsselname angegeben., der vom ersten Zeichen in der Zeichenfolge beginnt und für die Anzahl der Zeichen, die vom Aufruf zurückgegebene erweitert die <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> method then extracts the value assigned to the key.</source>
          <target state="translated">Der Aufruf der <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> Methode extrahiert dann den Wert, der dem Schlüssel zugeordnet.</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It starts at one character position beyond the equals character and extends to the end of the string.</source>
          <target state="translated">Er beginnt an einer Position des Zeichens hinter dem Gleichheitszeichen und reicht bis zum Ende der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="length" /&gt;</ph> indicates a position not within this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="length" /&gt;</ph> gibt eine Position außerhalb dieser Instanz an.</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>Returns an enumerator that iterates through the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Gibt einen Enumerator zurück, der das aktuelle <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt durchläuft.</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>A strongly-typed enumerator that can be used to iterate through the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Ein stark typisierter Enumerator, der zum Durchlaufen des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface object.</source>
          <target state="translated">Kann verwendet werden nur, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph> Instanz umgewandelt wird ein <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> -Schnittstellenobjekt.</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method.</source>
          <target state="translated">Weitere Informationen finden Sie unter der Methode <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>Returns an enumerator that iterates through the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Gibt einen Enumerator zurück, der das aktuelle <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt durchläuft.</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>An enumerator that can be used to iterate through the current string.</source>
          <target state="translated">Ein Enumerator, mit dem die Elemente in der aktuellen Zeichenfolge durchlaufen werden können.</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Weitere Informationen finden Sie unter der Methode <ph id="ph1">&lt;xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Dieser Parameter wird ignoriert.</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the current string is <ph id="ph2">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph>; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the value of the current string is <ph id="ph4">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Wert der aktuellen Zeichenfolge <ph id="ph2">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph> ist. <ph id="ph3">&lt;see langword="false" /&gt;</ph>, wenn der Wert der aktuellen Zeichenfolge <ph id="ph4">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>The value of the current string is not <ph id="ph1">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>.</source>
          <target state="translated">Der Wert der aktuellen Zeichenfolge lautet nicht <ph id="ph1">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph> oder <ph id="ph2">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Der konvertierte Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts kann nicht analysiert werden.</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.Byte.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.Byte.MinValue" /&gt;</ph>.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts ist eine Zahl größer als <ph id="ph2">&lt;see cref="F:System.Byte.MaxValue" /&gt;</ph> oder kleiner als <ph id="ph3">&lt;see cref="F:System.Byte.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>The character at index 0 in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Das Zeichen am Index 0 im aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Der konvertierte Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Der konvertierte Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts kann nicht analysiert werden.</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number less than <ph id="ph2">&lt;see cref="F:System.Decimal.MinValue" /&gt;</ph> or than <ph id="ph3">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph> greater.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts ist eine Zahl kleiner als <ph id="ph2">&lt;see cref="F:System.Decimal.MinValue" /&gt;</ph> oder größer als <ph id="ph3">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Der konvertierte Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts kann nicht analysiert werden.</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number less than <ph id="ph2">&lt;see cref="F:System.Double.MinValue" /&gt;</ph> or greater than <ph id="ph3">&lt;see cref="F:System.Double.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts ist eine Zahl kleiner als <ph id="ph2">&lt;see cref="F:System.Double.MinValue" /&gt;</ph> oder größer als <ph id="ph3">&lt;see cref="F:System.Double.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Der konvertierte Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts kann nicht analysiert werden.</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph>.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts ist eine Zahl größer als <ph id="ph2">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph> oder kleiner als <ph id="ph3">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Der konvertierte Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Der konvertierte Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Der konvertierte Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts kann nicht analysiert werden.</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph>.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts ist eine Zahl größer als <ph id="ph2">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph> oder kleiner als <ph id="ph3">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Der konvertierte Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The type of the returned object.</source>
          <target state="translated">Der Typ des zurückgegebenen Objekts.</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Der konvertierte Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ChangeType%2A&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ChangeType%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be converted to the type specified by the <ph id="ph2">&lt;paramref name="type" /&gt;</ph> parameter.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts kann nicht in den durch den <ph id="ph2">&lt;paramref name="type" /&gt;</ph>-Parameter angegebenen Typ konvertiert werden.</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Der konvertierte Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts kann nicht analysiert werden.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.UInt16.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.UInt16.MinValue" /&gt;</ph>.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts ist eine Zahl größer als <ph id="ph2">&lt;see cref="F:System.UInt16.MaxValue" /&gt;</ph> oder kleiner als <ph id="ph3">&lt;see cref="F:System.UInt16.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Der konvertierte Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts kann nicht analysiert werden.</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater <ph id="ph2">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.UInt32.MinValue" /&gt;</ph></source>
          <target state="translated">Der Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts ist eine Zahl größer als <ph id="ph2">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph> oder kleiner als <ph id="ph3">&lt;see cref="F:System.UInt32.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Der konvertierte Wert des aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.String&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die empfohlene Alternative ist das Aufrufen der <ph id="ph1">&lt;xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Copies the characters in this instance to a Unicode character array.</source>
          <target state="translated">Kopiert die Zeichen dieser Instanz in ein Array von Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray">
          <source>Copies the characters in this instance to a Unicode character array.</source>
          <target state="translated">Kopiert die Zeichen dieser Instanz in ein Array von Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray">
          <source>A Unicode character array whose elements are the individual characters of this instance.</source>
          <target state="translated">Ein Array von Unicode-Zeichen, dessen Elemente die einzelnen Zeichen dieser Instanz darstellen.</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray">
          <source>If this instance is an empty string, the returned array is empty and has a zero length.</source>
          <target state="translated">Wenn diese Instanz eine leere Zeichenfolge ist, ist das zurückgegebene Array leer und hat die Länge 0.</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>This method copies each character (that is, each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object) in a string to a character array.</source>
          <target state="translated">Diese Methode kopiert jedes Zeichen (d. h. jede <ph id="ph1">&lt;xref:System.Char&gt;</ph> Objekt) in einer Zeichenfolge in ein Zeichenarray.</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>The first character copied is at index zero of the returned character array; the last character copied is at index <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> – 1.</source>
          <target state="translated">Das erste Zeichen kopiert ist am Index 0 (null), der das Zeichenarray zurückgegebenen. das letzte Zeichen am Index ist <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> – 1.</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>To create a string from the characters in a character array, call the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> constructor.</source>
          <target state="translated">Rufen Sie zum Erstellen einer Zeichenfolge von Zeichen in ein Array von Zeichen der <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>To create a byte array that contains the encoded characters in a string, instantiate the appropriate <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object and call its <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Um ein Byte-Array zu erstellen, das die codierten Zeichen in einer Zeichenfolge enthält, instanziieren Sie den entsprechenden <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> Objekt, und rufen die <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>Some of the standard encodings available in the .NET Framework include the following:</source>
          <target state="translated">Einige der standard in .NET Framework verfügbaren Codierungen umfassen Folgendes:</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>Encoding</source>
          <target state="translated">Codierung</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>Object</source>
          <target state="translated">Object</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>ASCII</source>
          <target state="translated">ASCII</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>For more information, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> method to extract the characters in a string to a character array.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> Methode, um die Zeichen in einer Zeichenfolge in ein Zeichenarray zu extrahieren.</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>It then displays the original string and the elements in the array.</source>
          <target state="translated">Sie zeigt dann die ursprüngliche Zeichenfolge und die Elemente im Array.</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>The following example defines a string containing the characters that serve as delimiters in a delimited string.</source>
          <target state="translated">Das folgende Beispiel definiert eine Zeichenfolge, die mit den Zeichen, das als Trennzeichen in einer durch Trennzeichen getrennten Zeichenfolge dienen.</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> method to create a character array that can be passed to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method to separate the delimited string into its individual substrings.</source>
          <target state="translated">Er ruft dann die <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> Methode, um ein Array von Zeichen zu erstellen, die übergeben werden kann die <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> Methode, um die durch Trennzeichen getrennte Zeichenfolge in seine einzelnen Teilzeichenfolgen zu trennen.</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The starting position of a substring in this instance.</source>
          <target state="translated">Die Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The length of the substring in this instance.</source>
          <target state="translated">Die Länge einer Teilzeichenfolge innerhalb dieser Instanz.</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Copies the characters in a specified substring in this instance to a Unicode character array.</source>
          <target state="translated">Kopiert die Zeichen einer angegebenen Teilzeichenfolge dieser Instanz in ein Array von Unicode-Zeichen.</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>A Unicode character array whose elements are the <ph id="ph1">&lt;paramref name="length" /&gt;</ph> number of characters in this instance starting from character position <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Ein Array von Unicode-Zeichen, dessen Elemente die <ph id="ph1">&lt;paramref name="length" /&gt;</ph>-Zeichen dieser Instanz ab Zeichenposition <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> sind.</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>This method copies the characters in a portion of a string to a character array.</source>
          <target state="translated">Diese Methode kopiert die Zeichen in einem Teil einer Zeichenfolge in ein Zeichenarray.</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>To create a string from a range of characters in a character array, call the  <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Um eine Zeichenfolge aus einem Bereich von Zeichen in ein Zeichenarray zu erstellen, rufen die <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter is zero-based.</source>
          <target state="translated">Die <ph id="ph1">`startIndex`</ph> Parameter ist nullbasiert.</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>That is, the index of the first character in the string instance is zero.</source>
          <target state="translated">Der Index des ersten Zeichens in der Zeichenfolgeninstanz ist 0 (null).</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`length`</ph> is zero, the returned array is empty and has a zero length.</source>
          <target state="translated">Wenn <ph id="ph1">`length`</ph> NULL ist, ist das zurückgegebene Array leer und hat die Länge 0.</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>If this instance is <ph id="ph1">`null`</ph> or an empty string (""), the returned array is empty and has a zero length.</source>
          <target state="translated">Wenn diese Instanz <ph id="ph1">`null`</ph> oder eine leere Zeichenfolge (""), das zurückgegebene Array leer und hat die Länge 0.</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object and call its <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Um ein Byte-Array zu erstellen, das die codierten Zeichen in einem Teil einer Zeichenfolge enthält, instanziieren Sie den entsprechenden <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> Objekt, und rufen die <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Some of the standard encodings available in the .NET Framework include the following:</source>
          <target state="translated">Einige der standard in .NET Framework verfügbaren Codierungen umfassen Folgendes:</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Encoding</source>
          <target state="translated">Codierung</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Object</source>
          <target state="translated">Object</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>ASCII</source>
          <target state="translated">ASCII</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Zeichencodierung in .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The following example converts a substring within a string to an array of characters, then enumerates and displays the elements of the array.</source>
          <target state="translated">Im folgenden Beispiel wird eine Teilzeichenfolge innerhalb einer Zeichenfolge in ein Array von Zeichen, konvertiert und dann listet auf und zeigt die Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated">Die Summe von <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ist größer als die Länge dieser Instanz.</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a copy of this string converted to lowercase.</source>
          <target state="translated">Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" uid="M:System.String.ToLower">
          <source>Returns a copy of this string converted to lowercase.</source>
          <target state="translated">Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" uid="M:System.String.ToLower">
          <source>A string in lowercase.</source>
          <target state="translated">Eine Zeichenfolge aus Kleinbuchstaben.</target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>This method takes into account the casing rules of the current culture.</source>
          <target state="translated">Diese Methode berücksichtigt die Regeln der Groß-und Kleinschreibung der aktuellen Kultur.</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
          <target state="translated">Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert wurden zurückgegeben.</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>Security Considerations</source>
          <target state="translated">Sicherheitsüberlegungen</target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>The casing operation that results from calling the <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> method takes the casing conventions of the current culture into account.</source>
          <target state="translated">Die Schreibweise-Vorgang, der aus den Aufrufen resultiert die <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> Methode berücksichtigt die Groß-/ Kleinschreibungskonventionen der aktuellen Kultur.</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
          <target state="translated">Wenn Sie die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners, z. B. einen Dateinamen benötigen benannte Pipe oder einen Registrierungsschlüssel verwenden die <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>This produces the same result in every culture (unlike the <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> method) and performs more efficiently.</source>
          <target state="translated">Hierdurch wird das gleiche Ergebnis in jede Kultur (im Gegensatz zu den <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> Methode) und effizienter ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>The following example converts several mixed case strings to lowercase.</source>
          <target state="translated">Im folgende Beispiel werden mehrere gemischte Groß-/Kleinschreibung Zeichenfolgen in Kleinbuchstaben konvertiert.</target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Wie in beschrieben <bpt id="p1">[</bpt>bewährte Methoden für die Verwendung von Zeichenfolgen<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, sollten Sie vermeiden Zeichenfolge Groß-/Kleinschreibung Methoden aufrufen, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen.</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>To convert a character to lowercase by using the casing conventions of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> parameter.</source>
          <target state="translated">Um ein Zeichen in Kleinbuchstaben mit die Groß-/ Kleinschreibungskonventionen der aktuellen Kultur zu konvertieren, rufen die <ph id="ph1">&lt;see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /&gt;</ph> methodenüberladung mit einem Wert von <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> für seine <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific casing rules.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</source>
          <target state="translated">Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück, wobei die Regeln der Groß- und Kleinschreibung der angegebenen Kultur verwendet werden.</target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The lowercase equivalent of the current string.</source>
          <target state="translated">Die Entsprechung der aktuellen Zeichenfolge in Kleinbuchstaben.</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The casing rules of the culture specified by the <ph id="ph1">`culture`</ph> parameter determine the way the case of the string is changed.</source>
          <target state="translated">Die Regeln der Groß-und Kleinschreibung der Kultur angegeben werden, indem die <ph id="ph1">`culture`</ph> Parameter zu bestimmen, wie die Groß-/Kleinschreibung der Zeichenfolge geändert wird.</target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
          <target state="translated">Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert wurden zurückgegeben.</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>Security Considerations</source>
          <target state="translated">Sicherheitsüberlegungen</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>If you pass the <ph id="ph1">&lt;xref:System.String.ToLower%28System.Globalization.CultureInfo%29&gt;</ph> method a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object other than <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, the casing operation will take culture-specific rules into account.</source>
          <target state="translated">Wenn Sie übergeben die <ph id="ph1">&lt;xref:System.String.ToLower%28System.Globalization.CultureInfo%29&gt;</ph> Methode eine <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> Objekt außer <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, der Vorgang zur Groß-und Kleinschreibung wird berücksichtigt kulturspezifischen Regeln.</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners, z. B. einen Dateinamen benötigen benannte Pipe oder einen Registrierungsschlüssel verwenden die <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>This produces the same result in every culture and performs more efficiently.</source>
          <target state="translated">Dies führt zum gleichen Ergebnis in jede Kultur und effizienter ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The following example converts two strings of uppercase characters to lowercase characters using the English-United States and Turkish-Turkey cultures, then compares the lowercase strings.</source>
          <target state="translated">Im folgende Beispiel zwei Zeichenfolgen in Großbuchstaben in Kleinbuchstaben unter Verwendung der Kulturen Englisch-USA und Türkisch-Türkei konvertiert, und vergleicht dann die Kleinbuchstaben Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</source>
          <target state="translated">Die Zeichenfolgen in Großbuchstaben sind identisch, außer dass für jedes Vorkommen des Unicode-LATIN CAPITAL LETTER I in eine Zeichenfolge, die andere Zeichenfolge LATIN CAPITAL LETTER I mit Punkt oben enthält.</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" uid="M:System.String.ToLowerInvariant">
          <source>Returns a copy of this <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object converted to lowercase using the casing rules of the invariant culture.</source>
          <target state="translated">Gibt eine in Kleinbuchstaben konvertierte Kopie dieses <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts zurück, wobei die Regeln der Groß- und Kleinschreibung der invarianten Kultur verwendet werden.</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" uid="M:System.String.ToLowerInvariant">
          <source>The lowercase equivalent of the current string.</source>
          <target state="translated">Die Entsprechung der aktuellen Zeichenfolge in Kleinbuchstaben.</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The invariant culture represents a culture that is culture-insensitive.</source>
          <target state="translated">Die invariante Kultur darstellt, eine Kultur, die kulturunabhängig ist.</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>It is associated with the English language but not with a specific country or region.</source>
          <target state="translated">Verknüpft ist mit der englischen Sprache jedoch nicht mit einem bestimmten Land oder Region.</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Weitere Informationen finden Sie in den Ausführungen zur <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>-Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Ihre Anwendung hängt von der Groß-/Kleinschreibung einer Zeichenfolge in einer vorhersagbaren Weise, die von der aktuellen Kultur verwenden nicht betroffen ist ändern die <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method is equivalent to <ph id="ph2">`ToLower(CultureInfo.InvariantCulture)`</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> Methode entspricht <ph id="ph2">`ToLower(CultureInfo.InvariantCulture)`</ph>.</target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</source>
          <target state="translated">Die Methode wird empfohlen, wenn eine Auflistung von Zeichenfolgen in einer vorhersagbaren Reihenfolge in einem Steuerelement der Benutzeroberfläche angezeigt werden muss.</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
          <target state="translated">Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert wurden zurückgegeben.</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>Security Considerations</source>
          <target state="translated">Sicherheitsüberlegungen</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
          <target state="translated">Wenn Sie die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners, z. B. einen Dateinamen benötigen benannte Pipe oder einen Registrierungsschlüssel verwenden die <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The following example defines a string array that contains a single word in a number of languages.</source>
          <target state="translated">Das folgende Beispiel definiert ein Array von Zeichenfolgen, die ein einzelnes Wort in mehrere Sprachen enthält.</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> Methode wird verwendet, um die Elemente eines Arrays parallel mit der Groß-/Kleinschreibung Version jedes Worts aufzufüllen.</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method is used to sort the case-sensitive array based on the order of elements in the lowercase array to ensure that elements appear in the same order regardless of language.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> Methode wird verwendet, um die Groß-/Kleinschreibung beachtet, entsprechend der Reihenfolge der Elemente im Array um sicherzustellen, dass die Elemente in der gleichen Reihenfolge unabhängig von der Sprache angezeigt Kleinbuchstaben Array zu sortieren.</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Converts the value of this instance to a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Konvertiert den Wert dieser Instanz in einen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" uid="M:System.String.ToString">
          <source>Returns this instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>; no actual conversion is performed.</source>
          <target state="translated">Gibt diese Instanz von <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> zurück. Es wird keine wirkliche Konvertierung durchgeführt.</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" uid="M:System.String.ToString">
          <source>The current string.</source>
          <target state="translated">Die aktuelle Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>Because this method simply returns the current string unchanged, there is no need to call it directly.</source>
          <target state="translated">Da diese Methode einfach die aktuelle Zeichenfolge unverändert zurückgibt, ist es nicht erforderlich, es direkt aufzurufen.</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>It is usually called implicitly in a composite formatting operation, as the example shows.</source>
          <target state="translated">In der Regel wird es implizit in eine zur kombinierten Formatierung Vorgang, wie im Beispiel gezeigt aufgerufen.</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.ToString%2A&gt;</ph> method.Note that the example does not explicitly call the <ph id="ph2">&lt;xref:System.String.ToString%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.String.ToString%2A&gt;</ph> Methode. Beachten Sie, die im Beispiel nicht explizit aufrufen, wird die <ph id="ph2">&lt;xref:System.String.ToString%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>Instead, the method is called implicitly by the <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature.</source>
          <target state="translated">Stattdessen die Methode wird aufgerufen, implizit von der <bpt id="p1">[</bpt>kombinierte Formatierung<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> Funktion.</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>(Reserved) An object that supplies culture-specific formatting information.</source>
          <target state="translated">(Reserviert) Ein Objekt, das kulturabhängige Formatierungsinformationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>Returns this instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>; no actual conversion is performed.</source>
          <target state="translated">Gibt diese Instanz von <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> zurück. Es wird keine wirkliche Konvertierung durchgeführt.</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>The current string.</source>
          <target state="translated">Die aktuelle Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString(System.IFormatProvider)">
          <source><ph id="ph1">`provider`</ph> is reserved, and does not currently participate in this operation.</source>
          <target state="translated"><ph id="ph1">`provider`</ph> ist reserviert und derzeit nicht bei diesem Vorgang beteiligt.</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>Because this method simply returns the current string unchanged, there is no need to call it directly.</source>
          <target state="translated">Da diese Methode einfach die aktuelle Zeichenfolge unverändert zurückgibt, ist es nicht erforderlich, es direkt aufzurufen.</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a copy of this string converted to uppercase.</source>
          <target state="translated">Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper">
          <source>Returns a copy of this string converted to uppercase.</source>
          <target state="translated">Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper">
          <source>The uppercase equivalent of the current string.</source>
          <target state="translated">Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent.</source>
          <target state="translated">Diese Methode verwendet die Regeln der Groß-und Kleinschreibung der aktuellen Kultur, um jedes Zeichen in der aktuellen Instanz in dessen Entsprechung in Großbuchstaben zu konvertieren.</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>If a character does not have an uppercase equivalent, it is included unchanged in the returned string.</source>
          <target state="translated">Wenn ein Zeichen nicht über eine Entsprechung in Großbuchstaben verfügt, ist es unverändert in der zurückgegebenen Zeichenfolge enthalten.</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
          <target state="translated">Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert wurden zurückgegeben.</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> Methode wird häufig verwendet, um eine Zeichenfolge in Großbuchstaben zu konvertieren, damit es in einem Vergleich Groß-/Kleinschreibung verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>A better method to perform case-insensitive comparison is to call a string comparison method that has a <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> parameter whose value you set to <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph> for a culture-sensitive, case-insensitive comparison.</source>
          <target state="translated">Eine bessere Methode zum Ausführen von Groß-und Kleinschreibung unterschieden wird, aufzurufenden verfügt über eine Methode zum Zeichenfolgenvergleich einer <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> , dessen Wert Sie zum Festlegen des Parameters <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph> für einen Vergleich kulturabhängig, Groß-/Kleinschreibung.</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>Security Considerations</source>
          <target state="translated">Sicherheitsüberlegungen</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>The casing operation that results from calling the <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> method takes the casing conventions of the current culture into account.</source>
          <target state="translated">Die Schreibweise-Vorgang, der aus den Aufrufen resultiert die <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> Methode berücksichtigt die Groß-/ Kleinschreibungskonventionen der aktuellen Kultur.</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners, z. B. einen Dateinamen benötigen benannte Pipe oder einen Registrierungsschlüssel verwenden die <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>This produces the same result in every culture (unlike the <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> method) and performs more efficiently.</source>
          <target state="translated">Hierdurch wird das gleiche Ergebnis in jede Kultur (im Gegensatz zu den <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> Methode) und effizienter ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> method to convert a series of one-character strings that contain each character in the Basic Latin, Latin-1 Supplement, and Latin Extended-A character sets.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> Methode, um eine Reihe von einem Zeichen von Zeichenfolgen zu konvertieren, die jedes Zeichen in die lateinischen Latein-1, Ergänzung und Latin Extended-A-Zeichensätze enthalten.</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>It then displays each string whose uppercase character is different from its lowercase character.</source>
          <target state="translated">Es zeigt dann jede Zeichenfolge, deren Großbuchstaben von seinem Kleinbuchstaben unterscheidet.</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Wie in beschrieben <bpt id="p1">[</bpt>bewährte Methoden für die Verwendung von Zeichenfolgen<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, sollten Sie vermeiden Zeichenfolge Groß-/Kleinschreibung Methoden aufrufen, die Standardwerte zu ersetzen, und stattdessen Methoden aufzurufen, Parameter explizit angegeben werden müssen.</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>To convert a string to uppercase by using the casing conventions of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> parameter.</source>
          <target state="translated">Rufen Sie zum Konvertieren einer Zeichenfolge in Großbuchstaben unter Verwendung der Groß-/ Kleinschreibungskonventionen der aktuellen Kultur der <ph id="ph1">&lt;see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /&gt;</ph> methodenüberladung mit einem Wert von <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> für seine <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific casing rules.</source>
          <target state="translated">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</source>
          <target state="translated">Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück, wobei die Regeln der Groß- und Kleinschreibung der angegebenen Kultur verwendet werden.</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The uppercase equivalent of the current string.</source>
          <target state="translated">Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The casing rules of the culture specified by the <ph id="ph1">`culture`</ph> parameter determine the way the case of a string is changed.</source>
          <target state="translated">Die Regeln der Groß-und Kleinschreibung der Kultur angegeben werden, indem die <ph id="ph1">`culture`</ph> Parameter zu bestimmen, wie die Groß-/Kleinschreibung einer Zeichenfolge geändert wird.</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
          <target state="translated">Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert wurden zurückgegeben.</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>Security Considerations</source>
          <target state="translated">Sicherheitsüberlegungen</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>If you pass the <ph id="ph1">&lt;xref:System.String.ToUpper%28System.Globalization.CultureInfo%29&gt;</ph> method a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object other than <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, the casing operation will take culture-specific rules into account.</source>
          <target state="translated">Wenn Sie übergeben die <ph id="ph1">&lt;xref:System.String.ToUpper%28System.Globalization.CultureInfo%29&gt;</ph> Methode eine <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> Objekt außer <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, der Vorgang zur Groß-und Kleinschreibung wird berücksichtigt kulturspezifischen Regeln.</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners, z. B. einen Dateinamen benötigen benannte Pipe oder einen Registrierungsschlüssel verwenden die <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>This produces the same result in every culture and performs more efficiently.</source>
          <target state="translated">Dies führt zum gleichen Ergebnis in jede Kultur und effizienter ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The following example converts a string of lowercase characters to two strings of uppercase characters using the English-United States and Turkish-Turkey cultures, then compares the uppercase strings.</source>
          <target state="translated">Das folgende Beispiel konvertiert eine Zeichenfolge von Kleinbuchstaben in Großbuchstaben unter Verwendung der Kulturen Englisch-USA und Türkisch-Türkei zwei Zeichenfolgen und vergleicht dann die Zeichenfolgen in Großbuchstaben.</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</source>
          <target state="translated">Die Zeichenfolgen in Großbuchstaben sind identisch, außer dass für jedes Vorkommen des Unicode-LATIN CAPITAL LETTER I in eine Zeichenfolge, die andere Zeichenfolge LATIN CAPITAL LETTER I mit Punkt oben enthält.</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" uid="M:System.String.ToUpperInvariant">
          <source>Returns a copy of this <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object converted to uppercase using the casing rules of the invariant culture.</source>
          <target state="translated">Gibt eine in Großbuchstaben konvertierte Kopie dieses <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekts zurück, wobei die Regeln der Groß- und Kleinschreibung der invarianten Kultur verwendet werden.</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" uid="M:System.String.ToUpperInvariant">
          <source>The uppercase equivalent of the current string.</source>
          <target state="translated">Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The invariant culture represents a culture that is culture-insensitive.</source>
          <target state="translated">Die invariante Kultur darstellt, eine Kultur, die kulturunabhängig ist.</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>It is associated with the English language but not with a specific country or region.</source>
          <target state="translated">Verknüpft ist mit der englischen Sprache jedoch nicht mit einem bestimmten Land oder Region.</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Weitere Informationen finden Sie in den Ausführungen zur <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>-Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Ihre Anwendung hängt von der Groß-/Kleinschreibung einer Zeichenfolge in einer vorhersagbaren Weise, die von der aktuellen Kultur verwenden nicht betroffen ist ändern die <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method is equivalent to <ph id="ph2">`ToUpper(CultureInfo.InvariantCulture)`</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> Methode entspricht <ph id="ph2">`ToUpper(CultureInfo.InvariantCulture)`</ph>.</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</source>
          <target state="translated">Die Methode wird empfohlen, wenn eine Auflistung von Zeichenfolgen in einer vorhersagbaren Reihenfolge in einem Steuerelement der Benutzeroberfläche angezeigt werden muss.</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
          <target state="translated">Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert wurden zurückgegeben.</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>Security Considerations</source>
          <target state="translated">Sicherheitsüberlegungen</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
          <target state="translated">Wenn Sie die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners, z. B. einen Dateinamen benötigen benannte Pipe oder einen Registrierungsschlüssel verwenden die <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The following example defines a string array that contains a single word in a number of languages.</source>
          <target state="translated">Das folgende Beispiel definiert ein Array von Zeichenfolgen, die ein einzelnes Wort in mehrere Sprachen enthält.</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> Methode wird verwendet, um die Elemente eines Arrays parallel mit der Groß-/Kleinschreibung Version jedes Worts aufzufüllen.</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method is used to sort the case-sensitive array based on the order of elements in the uppercase array to ensure that elements appear in the same order regardless of language.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> Methode wird verwendet, um die Groß-/Kleinschreibung beachtet, entsprechend der Reihenfolge der Elemente im Array in Großbuchstaben um sicherzustellen, dass die Elemente in der gleichen Reihenfolge unabhängig von der Sprache angezeigt Array zu sortieren.</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string in which all leading and trailing occurrences of a set of specified characters from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object are removed.</source>
          <target state="translated">Gibt eine neue Zeichenfolge zurück, in der alle führenden und nachgestellten Vorkommen eines Satzes von angegebenen Zeichen aus dem aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt entfernt wurden.</target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" uid="M:System.String.Trim">
          <source>Removes all leading and trailing white-space characters from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Entfernt alle führenden und nachgestellten Leerraumzeichen aus dem aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" uid="M:System.String.Trim">
          <source>The string that remains after all white-space characters are removed from the start and end of the current string.</source>
          <target state="translated">Die resultierende Zeichenfolge nach dem Entfernen alle Leerraumzeichen am Anfang und Ende der aktuellen Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" uid="M:System.String.Trim">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes from the current string all leading and trailing white-space characters.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> -Methode aus der aktuellen Zeichenfolge alle führende und nachfolgende Leerzeichen entfernt.</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Each leading and trailing trim operation stops when a non-white-space character is encountered.</source>
          <target state="translated">Jede führende und nachfolgende Entfernungsvorgang beendet, wenn ein nicht-Leerzeichen gefunden wird.</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>For example, if the current string is "   abc   xyz   ", the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method returns "abc   xyz".</source>
          <target state="translated">Wenn die aktuelle Zeichenfolge "Abc Xyz" ist beispielsweise die <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> Methodenrückgabe "Abc Xyz".</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>To remove white-space characters between words in a string, use a <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
          <target state="translated">Verwenden Sie zum Entfernen von Leerzeichen zwischen Wörtern in einer Zeichenfolge einen <bpt id="p1">[</bpt>reguläre Ausdrücke von .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>If the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> -Methode entfernt alle Zeichen aus der aktuellen Instanz, die diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.</source>
          <target state="translated">Stattdessen wird eine neue Zeichenfolge, die in der alle führenden und nachfolgenden Leerzeichen in der aktuellen Instanz gefunden entfernt werden zurückgegeben.</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>If the current string equals <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> or all the characters in the current instance consist of white-space characters, the method returns <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Wenn die aktuelle Zeichenfolge entspricht <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> oder alle Zeichen in der aktuellen Instanz bestehen aus Leerstellen bestehen, der Methodenrückgabe <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>White-space characters are defined by the Unicode standard.</source>
          <target state="translated">Leerzeichen werden durch den Unicode-Standard definiert.</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim&gt;</ph> method removes any leading and trailing characters that produce a return value of <ph id="ph2">`true`</ph> when they are passed to the <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Trim&gt;</ph> -Methode entfernt alle führenden und nachgestellten Zeichen, die einen Rückgabewert von erzeugen <ph id="ph2">`true`</ph> Wenn sie übergeben die <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Trim?displayProperty=nameWithType&gt;</ph> method to remove any extra white space from strings entered by the user before concatenating them.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.Trim?displayProperty=nameWithType&gt;</ph> Methode, um zusätzliche Leerzeichen in Zeichenfolgen, die vom Benutzer eingegeben werden, bevor Sie verketten zu entfernen.</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintain an internal list of white-space characters that this method trims.</source>
          <target state="translated">Die <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> und frühere Versionen behalten eine interne Liste von Leerzeichen, die diese Methode abschneidet.</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph2">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph3">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, schneidet die Methode alle Unicode-Leerzeichen (d. h. Zeichen, erzeugen eine <ph id="ph2">&lt;see langword="true" /&gt;</ph> Wert zurückgeben, wenn es sich bei der Übergabe an die <ph id="ph3">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> Methode).</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>and later versions does not remove.</source>
          <target state="translated">Aufgrund dieser Änderung der <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> Methode in der <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> und frühere Versionen werden zwei Zeichen, NULLBREITE (U + 200 b) und 0 (null) Breite geschütztes Leerzeichen (U + FEFF) entfernt, die die <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> Methode in der <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>und höhere Versionen ist nicht entfernen.</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">Darüber hinaus die <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> Methode in der <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> und frühere Versionen nicht abtrennt drei Unicode-Leerzeichen: MONGOLISCH VOKALTRENNZEICHEN (U + 180E), SCHMALE geschütztes Leerzeichen (U + 202F) und Mittel MATHEMATISCHE Leerzeichen (U + 205F).</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>An array of Unicode characters to remove, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Array mit den zu entfernenden Unicode-Zeichen oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>Removes all leading and trailing occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Entfernt alle führenden und nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>The string that remains after all occurrences of the characters in the <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> parameter are removed from the start and end of the current string.</source>
          <target state="translated">Die resultierende Zeichenfolge, nachdem alle im <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph>-Parameter übergebenen Zeichen am Anfang und Ende der aktuellen Zeichenfolge entfernt wurden.</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>If <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty array, white-space characters are removed instead.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> <ph id="ph2">&lt;see langword="null" /&gt;</ph> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt.</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes from the current string all leading and trailing characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> -Methode entfernt aus der aktuellen Zeichenfolge alle führende und nachgestellte Zeichen in der <ph id="ph2">`trimChars`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Each leading and trailing trim operation stops when a character that is not in <ph id="ph1">`trimChars`</ph> is encountered.</source>
          <target state="translated">Jede führende und nachfolgende trim-Vorgang wird beendet, wenn ein Zeichen, der nicht <ph id="ph1">`trimChars`</ph> festgestellt wird.</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.Trim%2A&gt;</ph> method returns "abc456xyz".</source>
          <target state="translated">Wenn die aktuelle Zeichenfolge "123abc456xyz789" lautet beispielsweise und <ph id="ph1">`trimChars`</ph> die Ziffern von "1" bis "9", enthält die <ph id="ph2">&lt;xref:System.String.Trim%2A&gt;</ph> Methodenrückgabe "abc456xyz".</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>If the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> -Methode entfernt alle Zeichen aus der aktuellen Instanz, die diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Instead, it returns a new string in which all leading and trailing <ph id="ph1">`trimChars`</ph> characters found in the current instance are removed.</source>
          <target state="translated">Stattdessen gibt Sie eine neue Zeichenfolge zurück, in dem alle führenden und nachfolgenden <ph id="ph1">`trimChars`</ph> Zeichen, die in der aktuellen Instanz gefunden werden entfernt.</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>If the current string equals <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> or all the characters in the current instance consist of characters in the <ph id="ph2">`trimChars`</ph> array, the method returns <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Ist gleich die aktuelle Zeichenfolge <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> oder alle Zeichen in der aktuellen Instanz bestehen, der Zeichen in der <ph id="ph2">`trimChars`</ph> array, der Methodenrückgabe <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>If <ph id="ph1">`trimChars`</ph> is <ph id="ph2">`null`</ph> or an empty array, this method removes any leading or trailing characters that result in the method returning <ph id="ph3">`true`</ph> when they are passed to the <ph id="ph4">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method,</source>
          <target state="translated">Wenn <ph id="ph1">`trimChars`</ph> ist <ph id="ph2">`null`</ph> oder ein leeres Array, das diese Methode entfernt keine führenden oder nachgestellten Zeichen, die in der Methode zurückgeben <ph id="ph3">`true`</ph> Wenn sie übergeben die <ph id="ph4">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> -Methode</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method to remove space, asterisk (*), and apostrophe (') characters from a string.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> Methode, um Speicherplatz, Sternchen (*) und Apostroph (') Zeichen aus einer Zeichenfolge zu entfernen.</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintains an internal list of white-space characters that this method trims if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array.</source>
          <target state="translated">Die <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> und frühere Versionen verwaltet eine interne Liste von Leerzeichen, die diese Methode abschneidet, wenn <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph> oder ein leeres Array.</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph4">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, wenn <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph> oder ein leeres Array, die Methode kürzt alle Unicode-Leerzeichen (d. h. Zeichen, erzeugen eine <ph id="ph4">&lt;see langword="true" /&gt;</ph> Wert zurückgeben, wenn es sich bei der Übergabe an die <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> Methode).</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>and later versions does not remove.</source>
          <target state="translated">Aufgrund dieser Änderung der <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> Methode in der <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> und frühere Versionen werden zwei Zeichen, NULLBREITE (U + 200 b) und 0 (null) Breite geschütztes Leerzeichen (U + FEFF) entfernt, die die <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> Methode in der <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>und höhere Versionen ist nicht entfernen.</target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">Darüber hinaus die <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> Methode in der <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> und frühere Versionen nicht abtrennt drei Unicode-Leerzeichen: MONGOLISCH VOKALTRENNZEICHEN (U + 180E), SCHMALE geschütztes Leerzeichen (U + 202F) und Mittel MATHEMATISCHE Leerzeichen (U + 205F).</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>An array of Unicode characters to remove, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Array mit den zu entfernenden Unicode-Zeichen oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Removes all trailing occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Entfernt alle nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The string that remains after all occurrences of the characters in the <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> parameter are removed from the end of the current string.</source>
          <target state="translated">Die resultierende Zeichenfolge, nachdem alle im <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph>-Parameter übergebenen Zeichen am Ende der aktuellen Zeichenfolge entfernt wurden.</target>       </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>If <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty array, Unicode white-space characters are removed instead.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> <ph id="ph2">&lt;see langword="null" /&gt;</ph> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt.</target>       </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</target>       </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method removes from the current string all trailing characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> Methode entfernt aus der aktuellen Zeichenfolge alle Zeichen, die in der <ph id="ph2">`trimChars`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The trim operation stops when the first character that is not in <ph id="ph1">`trimChars`</ph> is encountered at the end of the string.</source>
          <target state="translated">Der Vorgang wird beendet, wenn das erste Zeichen, die nicht <ph id="ph1">`trimChars`</ph> auftritt, wird am Ende der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method returns "123abc456xyz".</source>
          <target state="translated">Wenn die aktuelle Zeichenfolge "123abc456xyz789" lautet beispielsweise und <ph id="ph1">`trimChars`</ph> die Ziffern von "1" bis "9", enthält die <ph id="ph2">&lt;xref:System.String.TrimEnd%2A&gt;</ph> Methodenrückgabe "123abc456xyz zurück".</target>       </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>If the <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> -Methode entfernt alle Zeichen aus der aktuellen Instanz, die diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Instead, it returns a new string in which all trailing characters found in <ph id="ph1">`trimChars`</ph> are removed from the current string.</source>
          <target state="translated">Stattdessen gibt Sie eine neue Zeichenfolge zurück, in der alle nachfolgenden Zeichen gefunden <ph id="ph1">`trimChars`</ph> aus der aktuellen Zeichenfolge entfernt werden.</target>       </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The following example demonstrates how you can use the <ph id="ph1">&lt;xref:System.String.TrimEnd%28System.Char%5B%5D%29&gt;</ph> method to trim white space or punctuation marks from the end of a string.</source>
          <target state="translated">Im folgende Beispiel wird veranschaulicht, wie Sie können die <ph id="ph1">&lt;xref:System.String.TrimEnd%28System.Char%5B%5D%29&gt;</ph> Methode, um Leerzeichen oder Satzzeichen vom Ende einer Zeichenfolge abzuschneiden.</target>       </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintains an internal list of white-space characters that this method trims if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array.</source>
          <target state="translated">Die <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> und frühere Versionen verwaltet eine interne Liste von Leerzeichen, die diese Methode abschneidet, wenn <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph> oder ein leeres Array.</target>       </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph4">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, wenn <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph> oder ein leeres Array, die Methode kürzt alle Unicode-Leerzeichen (d. h. Zeichen, erzeugen eine <ph id="ph4">&lt;see langword="true" /&gt;</ph> Wert zurückgeben, wenn es sich bei der Übergabe an die <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> Methode).</target>       </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> and later versions does not remove.</source>
          <target state="translated">Aufgrund dieser Änderung der <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> Methode in der <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> und frühere Versionen werden zwei Zeichen, NULLBREITE (U + 200 b) und 0 (null) Breite geschütztes Leerzeichen (U + FEFF) entfernt, die die <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> Methode in der <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> und höhere Versionen ist nicht entfernen.</target>       </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">Darüber hinaus die <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> Methode in der <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> und frühere Versionen nicht abtrennt drei Unicode-Leerzeichen: MONGOLISCH VOKALTRENNZEICHEN (U + 180E), SCHMALE geschütztes Leerzeichen (U + 202F) und Mittel MATHEMATISCHE Leerzeichen (U + 205F).</target>       </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>An array of Unicode characters to remove, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Array mit den zu entfernenden Unicode-Zeichen oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>Removes all leading occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Entfernt alle nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem aktuellen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>The string that remains after all occurrences of characters in the <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> parameter are removed from the start of the current string.</source>
          <target state="translated">Die resultierende Zeichenfolge, nachdem alle im <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph>-Parameter übergebenen Zeichen am Anfang der aktuellen Zeichenfolge entfernt wurden.</target>       </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>If <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty array, white-space characters are removed instead.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> <ph id="ph2">&lt;see langword="null" /&gt;</ph> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt.</target>       </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method removes from the current string all leading characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> Methode entfernt aus der aktuellen Zeichenfolge alle Zeichen, die in der <ph id="ph2">`trimChars`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The trim operation stops when a character that is not in <ph id="ph1">`trimChars`</ph> is encountered.</source>
          <target state="translated">Der Entfernungsvorgang beendet, wenn ein Zeichen, der nicht <ph id="ph1">`trimChars`</ph> festgestellt wird.</target>       </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> method returns "abc456xyz789".</source>
          <target state="translated">Wenn die aktuelle Zeichenfolge "123abc456xyz789" lautet beispielsweise und <ph id="ph1">`trimChars`</ph> die Ziffern von "1" bis "9", enthält die <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> Methodenrückgabe "abc456xyz789".</target>       </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>If the <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> -Methode entfernt alle Zeichen aus der aktuellen Instanz, die diese Methode ändert nicht den Wert der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>Instead, it returns a new string in which all leading white space characters found in the current instance are removed.</source>
          <target state="translated">Stattdessen wird eine neue Zeichenfolge, die in der alle führenden Leerzeichen in der aktuellen Instanz gefunden entfernt werden zurückgegeben.</target>       </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method to trim white space and comment characters from lines of source code.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> Methode, um Leerraum und kommentierungszeichen von Quellcodezeilen zu kürzen.</target>       </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">`StripComments`</ph> method wraps a call to <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> and passes it a character array that contains a space and the comment character, which is an apostrophe ( ' ) in Visual Basic and a slash ( / ) in C#.</source>
          <target state="translated">Die <ph id="ph1">`StripComments`</ph> Methode bindet einen Aufruf von <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> und übergibt ein Array von Zeichen, die ein Leerzeichen und die Kommentarzeichen, also ein Apostroph (') in Visual Basic und ein Schrägstrich (/) in c# enthält.</target>       </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method is also called to remove leading white space when evaluating whether a string is a comment.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> Methode auch aufgerufen, um führende Leerzeichen zu entfernen, wenn zu bewerten, ob eine Zeichenfolge ein Kommentar ist.</target>       </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The following example then illustrates a call to the <ph id="ph1">`StripComments`</ph> method.</source>
          <target state="translated">Im folgenden Beispiel wird ein Aufruf der <ph id="ph1">`StripComments`</ph>-Methode veranschaulicht.</target>       </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintains an internal list of white-space characters that this method trims if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array.</source>
          <target state="translated">Die <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> und frühere Versionen verwaltet eine interne Liste von Leerzeichen, die diese Methode abschneidet, wenn <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph> oder ein leeres Array.</target>       </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph4">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, wenn <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph> oder ein leeres Array, die Methode kürzt alle Unicode-Leerzeichen (d. h. Zeichen, erzeugen eine <ph id="ph4">&lt;see langword="true" /&gt;</ph> Wert zurückgeben, wenn es sich bei der Übergabe an die <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> Methode).</target>       </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> and later versions does not remove.</source>
          <target state="translated">Aufgrund dieser Änderung der <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> Methode in der <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> und frühere Versionen werden zwei Zeichen, NULLBREITE (U + 200 b) und 0 (null) Breite geschütztes Leerzeichen (U + FEFF) entfernt, die die <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> Methode in der <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> und höhere Versionen ist nicht entfernen.</target>       </trans-unit>
        <trans-unit id="3655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">Darüber hinaus die <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> Methode in der <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> und frühere Versionen nicht abtrennt drei Unicode-Leerzeichen: MONGOLISCH VOKALTRENNZEICHEN (U + 180E), SCHMALE geschütztes Leerzeichen (U + 202F) und Mittel MATHEMATISCHE Leerzeichen (U + 205F).</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>