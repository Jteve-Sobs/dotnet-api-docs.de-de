<Type Name="ClaimsPrincipalPermission" FullName="System.IdentityModel.Services.ClaimsPrincipalPermission">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2fb06ec7390b39d257cf72931b0cf79b68925403" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70715025" /></Metadata><TypeSignature Language="C#" Value="public sealed class ClaimsPrincipalPermission : System.Security.IPermission, System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit ClaimsPrincipalPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClaimsPrincipalPermission&#xA;Implements IPermission, IUnrestrictedPermission" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClaimsPrincipalPermission sealed : System::Security::IPermission, System::Security::Permissions::IUnrestrictedPermission" />
  <TypeSignature Language="F#" Value="type ClaimsPrincipalPermission = class&#xA;    interface IPermission&#xA;    interface ISecurityEncodable&#xA;    interface IUnrestrictedPermission" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel.Services</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.ISecurityEncodable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.Permissions.IUnrestrictedPermission</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Berechtigung dar, die eine <see cref="T:System.Security.Claims.ClaimsAuthorizationManager" />-Implementierung verwendet, mit der bestimmt wird, ob dem aktiven Prinzipal der Zugriff auf eine Ressource gewährt werden sollte. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> -Klasse bietet die Möglichkeit, imperative Zugriffs Überprüfungen mithilfe der <xref:System.Security.Claims.ClaimsAuthorizationManager> auszuführen, die für eine Anwendung konfiguriert ist. Indem Sie die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> -Methode oder die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A> statische-Methode aufrufen, können Sie den Schutz von Ressourcen innerhalb des Ausführungs Pfads Ihres Codes entsprechend der Autorisierungs Richtlinie bereitstellen, die für Ihren anspruchsauthentifizierungs-Manager definiert wurde. Deklarative Zugriffs Überprüfungen können mithilfe der <xref:System.IdentityModel.Services.ClaimsPrincipalPermissionAttribute> -Klasse ausgeführt werden.  
  
> [!IMPORTANT]
>  Die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> -Klasse verwendet den anspruchsautorisierungs- <xref:System.IdentityModel.Configuration.IdentityConfiguration> Manager <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType> , der von der-Eigenschaft konfiguriert wird Dies gilt in allen Fällen, auch in Szenarien, in denen der WS-Verbund nicht verwendet wird. beispielsweise aktive (WCF) Webanwendungen und Konsolen Anwendungen. Sie können den Anspruchs Autorisierungs-Manager entweder in der Konfiguration oder Programm gesteuert angeben. Um den Anspruchs Autorisierungs-Manager in einer Konfigurationsdatei anzugeben, legen Sie das [ &lt;ClaimsAuthorizationManager&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/claimsauthorizationmanager.md) -Element unter einem [ &lt;&gt; identityconfiguration](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/identityconfiguration.md) -Element fest, und stellen Sie sicher, dass dies auf die Identitäts Konfiguration wird durch das [ &lt;federationconfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/federationconfiguration.md) -Element verwiesen, das von der Laufzeit geladen wird (z. `identityConfigurationName` b. durch Festlegen des-Attributs). Um den Anspruchs Autorisierungs-Manager Programm gesteuert festzulegen, stellen Sie <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfigurationCreated?displayProperty=nameWithType> einen Handler für das-Ereignis bereit.  
  
 Auf einer Ebene ähnelt die von <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> bereitgestellte Funktionalität den rollenbasierten Zugriffs Überprüfungen (Role-Based Access Checks, RBAC), die über die <xref:System.Security.Claims.ClaimsAuthorizationManager> <xref:System.Security.Permissions.PrincipalPermission> -Klasse bereitgestellt werden. die-Klasse führt jedoch Überprüfungen auf der Grundlage der vom aktiven Prinzipal dargestellten Ansprüche aus. Dies ermöglicht eine weitaus höhere Granularität als durch die reine RBAC verfügbar ist, bei der viele Berechtigungen in der Regel unter einer einzigen Rolle gesammelt werden. Vielleicht noch wichtiger ist, dass die Anspruchs basierte Autorisierung eine bessere Trennung von Geschäftslogik und Autorisierungs Richtlinien ermöglicht, da die Berechtigung für eine bestimmte Aktion für eine Ressource im Code angefordert werden kann, und die Back-End-Richtlinie kann verwendet werden, um zu konfigurieren, welche Ansprüche die Darstellung der Entität muss besitzen, um die Anforderung zu erfüllen. Wie bei der Rollen <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> basierten Zugriffs Steuerung führt eine benutzerbasierte Zugriffs Überprüfung durch, d. h. im Unterschied zur Code Zugriffssicherheit <xref:System.Security.CodeAccessPermission> , die von Klassen implementiert wird, die von der-Klasse abgeleitet sind, und mit einem Stackwalk sicherzustellen, dass allen Aufrufern des Codes eine Berechtigung  <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> erteilt führt die Überprüfung nur für den aktuellen Prinzipal aus.  
  
 Die statische <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A> -Methode überprüft den Zugriff für eine angegebene Aktion auf einer angegebenen Ressource. Die Ressource und die Aktion sind beide Zeichen folgen und sind in der Regel URIs. Sie können auch eine Instanz von <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> mit einer Aktion und einer Ressource initialisieren und die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> -Methode aufzurufen. Obwohl der Konstruktor nur eine einzelne Ressource und eine Aktion annimmt <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> , können-Objekte über die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Union%2A> - <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect%2A> Methode und die-Methode kombiniert werden. Eine Berechtigung, die mithilfe dieser Methoden erstellt wurde, kann mehrere Ressourcen Aktions Paare enthalten.  
  
 Beide Methoden bestimmen den Zugriff, indem <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType> Sie die-Methode des konfigurierten Anspruchs Autorisierungs-Managers mit einem <xref:System.Security.Claims.AuthorizationContext> zusammen<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>gesetzten aus dem aktiven Prinzipal (), der-Ressource und der-Aktion aufrufen. Sie lösen eine <xref:System.Security.SecurityException> aus, wenn der aktuelle Prinzipal nicht zum Ausführen der Aktion für die Ressource autorisiert ist. andernfalls wird die Ausführung fortgesetzt.  
  
 Im Fall einer <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> , die mehrere Ressourcen Aktions Paare enthält, wird die <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType> -Methode für jedes der in der Berechtigung enthaltenen Ressourcen Aktions Paare aufgerufen.  Damit der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> -Befehl erfolgreich ausgeführt werden kann, muss der aktive Prinzipal für alle in der Berechtigung enthaltenen Ressourcen Aktions Paare autorisiert werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine Ressource mit der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> -Methode, der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A> -Methode oder einer <xref:System.IdentityModel.Services.ClaimsPrincipalPermissionAttribute> -Deklaration geschützt wird. In jedem Fall wird der konfigurierte <xref:System.Security.Claims.ClaimsAuthorizationManager> aufgerufen, um den aktuellen Prinzipal mit der angegebenen Ressource und Aktion auszuwerten. Wenn der aktuelle Prinzipal für die angegebene Aktion für die angegebene Ressource nicht autorisiert ist, <xref:System.Security.SecurityException> wird eine ausgelöst. andernfalls wird die Ausführung fortgesetzt.  
  
 [!code-csharp[WifCppWithCam#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcppwithcam/cs/wifcppwithcam/program.cs#1)]  
  
 Der folgende XML-Code zeigt die Mindestanforderungen für die Verwendung eines benutzerdefinierten Anspruchs Autorisierungs <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> -Managers mit der-Klasse. Sie müssen `system.identityModel` mindestens die `system.identityModel.services` Abschnitte und im `<configSection>` -Element deklarieren und dann Ihren Autorisierungs-Manager in einem [ &lt;ClaimsAuthorizationManager&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/claimsauthorizationmanager.md) -Element unter der standardmäßige Identitäts Konfiguration. Dadurch wird sichergestellt, dass auf den Autorisierungs-Manager von der Standard Verbund Konfiguration verwiesen wird. Alternativ können Sie den Namen der Identitäts Konfiguration angeben, unter der der Autorisierungs-Manager im `identityConfigurationName` -Attribut [ &lt;des federationconfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/federationconfiguration.md) -Elements angegeben ist.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
  <configSections>  
    <!-- WIF configuration sections -->  
    <section name="system.identityModel" type="System.IdentityModel.Configuration.SystemIdentityModelSection, System.IdentityModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>  
    <section name="system.identityModel.services" type="System.IdentityModel.Services.Configuration.SystemIdentityModelServicesSection, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>  
  </configSections>  
  
  <startup>  
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
  </startup>  
  
  <system.identityModel>  
    <identityConfiguration>  
      <claimsAuthorizationManager type ="MyClaimsAuthorizationManager.MyClaimsAuthorizationManager, MyClaimsAuthorizationManager"/>  
    </identityConfiguration>  
  </system.identityModel>  
  
</configuration>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Services.ClaimsPrincipalPermissionAttribute" />
    <altmember cref="P:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration" />
    <altmember cref="T:System.Security.Claims.ClaimsAuthorizationManager" />
    <related type="Article" href="https://msdn.microsoft.com/library/8b14054c-6d07-46ab-ab58-03f14beac0f2">&lt;federationConfiguration&gt;</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ClaimsPrincipalPermission (string resource, string action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string resource, string action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resource As String, action As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ClaimsPrincipalPermission(System::String ^ resource, System::String ^ action);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Services.ClaimsPrincipalPermission : string * string -&gt; System.IdentityModel.Services.ClaimsPrincipalPermission" Usage="new System.IdentityModel.Services.ClaimsPrincipalPermission (resource, action)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resource" Type="System.String" />
        <Parameter Name="action" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resource">Die Ressource, auf der der Prinzipal autorisiert werden soll.</param>
        <param name="action">Die Aktion, für die der Prinzipal autorisiert werden soll.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> Objekt wird mit dem angegebenen Ressourcen Aktions paar initialisiert. Sie können die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> -Methode aufrufen, um eine Zugriffs Überprüfung durchzuführen.  
  
 Obwohl der Konstruktor nur eine einzelne Ressource und eine Aktion annimmt <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> , können-Objekte über die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Union%2A> - <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect%2A> Methode und die-Methode kombiniert werden. Die über diese Methoden erstellte Berechtigung kann mehrere Ressourcen Aktions Paare enthalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="resource" /> ist <see langword="null" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public static void CheckAccess (string resource, string action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckAccess(string resource, string action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CheckAccess (resource As String, action As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CheckAccess(System::String ^ resource, System::String ^ action);" />
      <MemberSignature Language="F#" Value="static member CheckAccess : string * string -&gt; unit" Usage="System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess (resource, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2103:ReviewImperativeSecurity", Justification="It is expected that the runtime’s behavior would rely on changing data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resource" Type="System.String" />
        <Parameter Name="action" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resource">Die Ressource, auf der der Prinzipal autorisiert werden soll.</param>
        <param name="action">Die Aktion, für die der Prinzipal autorisiert werden soll.</param>
        <summary>Überprüft, ob der aktuelle Prinzipal berechtigt ist, um die angegebene Aktion für die angegebene Ressource auszuführen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Prinzipal muss für die angegebene Aktion für die angegebene Ressource autorisiert werden, <xref:System.Security.SecurityException> oder die Ausnahme wird ausgelöst.  
  
 Die <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType> -Methode des konfigurierten anspruchsautorisierungs-Managers <xref:System.Security.Claims.AuthorizationContext> wird mit einem-Wert aus<xref:System.Threading.Thread.CurrentPrincipal%2A>dem aktiven Prinzipal (), der-Ressource und der-Aktion aufgerufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine Ressource mit der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A> -Methode geschützt wird. Der konfigurierte anspruchsautorisierungs-Manager wird aufgerufen, um den aktuellen Prinzipal anhand der angegebenen Ressource und Aktion auszuwerten. Wenn der aktuelle Prinzipal für die angegebene Aktion für die angegebene Ressource nicht autorisiert ist, <xref:System.Security.SecurityException> wird eine ausgelöst. andernfalls wird die Ausführung fortgesetzt.  
  
 [!code-csharp[WifCppWithCam#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifcppwithcam/cs/wifcppwithcam/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Prinzipal ist nicht von <see cref="T:System.Security.Claims.ClaimsPrincipal" /> zuweisbar.  
  
- oder - 
Es ist kein <see cref="T:System.Security.Claims.ClaimsAuthorizationManager" /> konfiguriert.</exception>
        <exception cref="T:System.Security.SecurityException">Die Autorisierungsprüfung ist fehlgeschlagen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission&#xA;override this.Copy : unit -&gt; System.Security.IPermission" Usage="claimsPrincipalPermission.Copy " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Copy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2103:ReviewImperativeSecurity", Justification="It is expected that the runtime’s behavior would rely on changing data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Kopie der aktuellen <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />-Instanz zurück.</summary>
        <returns>Eine <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />, die aus der aktuellen Instanz kopiert wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit&#xA;override this.Demand : unit -&gt; unit" Usage="claimsPrincipalPermission.Demand " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überprüft, ob der aktuelle Prinzipal für die Ressourcen-Aktionspaare autorisiert ist, die der aktuellen Instanz zugeordnet sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der aktuelle Prinzipal muss für alle der Instanz zugeordneten Ressourcen Aktions Paare autorisiert sein, oder die <xref:System.Security.SecurityException> Ausnahme wird ausgelöst.  
  
 Obwohl der Konstruktor nur eine einzelne Ressource und eine Aktion annimmt <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> , können-Objekte über die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Union%2A> - <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect%2A> Methode und die-Methode kombiniert werden. Die über diese Methoden erstellte Berechtigung kann mehrere Ressourcen Aktions Paare enthalten.  
  
 Die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> -Methode ruft <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType> die-Methode des konfigurierten anspruchsautorisierungs-Managers mit einem <xref:System.Security.Claims.AuthorizationContext> -<xref:System.Threading.Thread.CurrentPrincipal%2A>bestehend aus dem aktiven Prinzipal (), der Ressource und der Aktion für jedes enthaltene Ressourcen Aktions paar auf. in der Berechtigung. Damit der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> für erfolgreich ist, muss der aktive Prinzipal für alle in der Berechtigung enthaltenen Ressourcen Aktions Paare autorisiert werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine Ressource mit der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> -Methode geschützt wird. Der konfigurierte anspruchsautorisierungs-Manager wird aufgerufen, um den aktuellen Prinzipal anhand der angegebenen Ressource und Aktion auszuwerten. Wenn der aktuelle Prinzipal für die angegebene Aktion für die angegebene Ressource nicht autorisiert ist, <xref:System.Security.SecurityException> wird eine ausgelöst. andernfalls wird die Ausführung fortgesetzt.  
  
 [!code-csharp[WifCppWithCam#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcppwithcam/cs/wifcppwithcam/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Prinzipal ist nicht von <see cref="T:System.Security.Claims.ClaimsPrincipal" /> zuweisbar.  
  
- oder - 
Es ist kein <see cref="T:System.Security.Claims.ClaimsAuthorizationManager" /> konfiguriert.</exception>
        <exception cref="T:System.Security.SecurityException">Die Autorisierungsprüfung ist fehlgeschlagen.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public void FromXml (System.Security.SecurityElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FromXml (element As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void FromXml(System::Security::SecurityElement ^ element);" />
      <MemberSignature Language="F#" Value="abstract member FromXml : System.Security.SecurityElement -&gt; unit&#xA;override this.FromXml : System.Security.SecurityElement -&gt; unit" Usage="claimsPrincipalPermission.FromXml element" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.FromXml(System.Security.SecurityElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="element">Die XML-Codierung zur Wiederherstellung der Berechtigung.</param>
        <summary>Erstellt die aktuelle Berechtigung und ihren Zustand aus der angegebenen XML-Codierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rekonstruiert eine Berechtigung aus der XML-Codierung, die durch einen Aufrufder <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.ToXml%2A> -Methode erstellt wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Codierung enthält nicht erkannte Elemente oder Attribute oder nicht ordnungsgemäß gebildetes XML.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="claimsPrincipalPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Intersect(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Eine Berechtigung, deren Schnittmenge mit der aktuellen Berechtigung gebildet wird. Muss eine Instanz von <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> sein.</param>
        <summary>Gibt eine neue Berechtigung zurück, die den Kreuzungspunkt der aktuellen und der angegebenen Berechtigung ist.</summary>
        <returns>Eine neue <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />, die die Schnittmenge der aktuellen und der angegeben Berechtigung darstellt, oder <see langword="null" />, wenn <paramref name="target" /> gleich <paramref name="null" /> oder keine Instanz von <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Berechtigung verfügt nur über die Resource-Action-Paare, die sowohl in der aktuellen Berechtigung als auch in der angegebenen Berechtigung vorhanden waren. Ressourcen-Aktions Paare, die nur in einer oder den anderen Berechtigungen vorhanden waren, sind nicht eingeschlossen. Damit eine <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> mit der neuen Berechtigung erfolgreich ist, muss der aktuelle Prinzipal nur für die Ressourcen Aktions Paare autorisiert werden, die der aktuellen Berechtigung und der angegebenen Berechtigung gemeinsam waren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool&#xA;override this.IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="claimsPrincipalPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Die Berechtigung, für die geprüft werden soll, ob sie eine Teilmenge einer anderen Berechtigung ist. Muss eine Instanz von <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> sein.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Berechtigung eine Teilmenge der angegebenen Berechtigung ist.</summary>
        <returns><see langword="true" />, wenn die aktuelle Berechtigung eine Teilmenge der angegebenen Berechtigung darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle Berechtigung ist eine Teilmenge der angegebenen Berechtigung, wenn alle in der aktuellen Berechtigung enthaltenen Ressourcen Aktions Paare auch in der angegebenen Berechtigung vorhanden sind. Wenn `target` <xref:System.IdentityModel.Services.ClaimsPrincipalPermission>ist `null` oder keine Instanz von ist, <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.IsSubsetOf%2A> gibt zurück `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnrestricted">
      <MemberSignature Language="C#" Value="public bool IsUnrestricted ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsUnrestricted() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.IsUnrestricted" />
      <MemberSignature Language="VB.NET" Value="Public Function IsUnrestricted () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsUnrestricted();" />
      <MemberSignature Language="F#" Value="abstract member IsUnrestricted : unit -&gt; bool&#xA;override this.IsUnrestricted : unit -&gt; bool" Usage="claimsPrincipalPermission.IsUnrestricted " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.Permissions.IUnrestrictedPermission.IsUnrestricted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob die Berechtigung uneingeschränkt ist.</summary>
        <returns><see langword="true" />, wenn die Berechtigung uneingeschränkt ist, andernfalls <see langword="false" />. Gibt immer <see langword="true" /> zurück, was angibt, dass die Berechtigung uneingeschränkt ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="abstract member ToXml : unit -&gt; System.Security.SecurityElement&#xA;override this.ToXml : unit -&gt; System.Security.SecurityElement" Usage="claimsPrincipalPermission.ToXml " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.ToXml</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die XML-codierte Form der aktuellen Berechtigung und ihren Zustand zurück.</summary>
        <returns>Die XML-codierte Form der aktuellen Berechtigung und ihr Zustand.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Prinzipal kann aus seinem XML-codierten Formular rekonstruiert werden <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.FromXml%2A> , indem die-Methode aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="claimsPrincipalPermission.Union target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Union(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Eine Berechtigung, die mit der aktuellen Berechtigung kombiniert werden soll. Das Objekt muss vom Typ <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> sein.</param>
        <summary>Gibt eine neue Berechtigung zurück, die die Union der aktuellen und der angegebenen Berechtigung ist. <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />-Objekt, das über alle Ressource/Aktion-Paare verfügt, die in der aktuellen Instanz und in der Zielinstanz vorhanden sind.</summary>
        <returns>Eine neue <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />, die die Union der aktuellen und der angegeben Berechtigung darstellt, oder <see langword="null" />, wenn <paramref name="target" /> gleich <paramref name="null" /> oder keine Instanz von <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Berechtigung, die zurückgegeben wird, verfügt über alle Ressourcen Aktions Paare, die in der aktuellen Berechtigung und alle Ressourcen Aktions Paare vorhanden sind, die die angegebene Berechtigung enthalten. Damit eine <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> mit der neuen Berechtigung erfolgreich ist, muss der aktuelle Prinzipal für alle Ressourcen Aktions Paare autorisiert werden, die in der aktuellen Berechtigung vorhanden waren, sowie für alle Ressourcen Aktions Paare, die in der angegebenen Berechtigung vorhanden waren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
