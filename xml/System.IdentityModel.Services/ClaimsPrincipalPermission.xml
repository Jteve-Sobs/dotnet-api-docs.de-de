<Type Name="ClaimsPrincipalPermission" FullName="System.IdentityModel.Services.ClaimsPrincipalPermission">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b4460faddc7895df1ede2cd7373bfe845ede8eaf" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83951294" /></Metadata><TypeSignature Language="C#" Value="public sealed class ClaimsPrincipalPermission : System.Security.IPermission, System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit ClaimsPrincipalPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClaimsPrincipalPermission&#xA;Implements IPermission, IUnrestrictedPermission" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClaimsPrincipalPermission sealed : System::Security::IPermission, System::Security::Permissions::IUnrestrictedPermission" />
  <TypeSignature Language="F#" Value="type ClaimsPrincipalPermission = class&#xA;    interface IPermission&#xA;    interface ISecurityEncodable&#xA;    interface IUnrestrictedPermission" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel.Services</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.ISecurityEncodable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.Permissions.IUnrestrictedPermission</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Berechtigung dar, die eine <see cref="T:System.Security.Claims.ClaimsAuthorizationManager" />-Implementierung verwendet, mit der bestimmt wird, ob dem aktiven Prinzipal der Zugriff auf eine Ressource gewährt werden sollte. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission>-Klasse bietet die Möglichkeit, imperative Zugriffs Überprüfungen mithilfe der <xref:System.Security.Claims.ClaimsAuthorizationManager> auszuführen, die für eine Anwendung konfiguriert ist. Wenn Sie die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A>-Methode oder die statische <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A>-Methode aufrufen, können Sie den Schutz von Ressourcen innerhalb des Ausführungs Pfads Ihres Codes entsprechend der Autorisierungs Richtlinie, die für Ihren anspruchsauthentifizierungs-Manager definiert ist, bereitstellen. Deklarative Zugriffs Überprüfungen können mithilfe der <xref:System.IdentityModel.Services.ClaimsPrincipalPermissionAttribute>-Klasse ausgeführt werden.  
  
> [!IMPORTANT]
>  Die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission>-Klasse verwendet den anspruchsautorisierungs-Manager, der durch die <xref:System.IdentityModel.Configuration.IdentityConfiguration> konfiguriert ist, die unter der <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType>-Eigenschaft festgelegt Dies gilt in allen Fällen, auch in Szenarien, in denen der WS-Verbund nicht verwendet wird. beispielsweise aktive (WCF) Webanwendungen und Konsolen Anwendungen. Sie können den Anspruchs Autorisierungs-Manager entweder in der Konfiguration oder Programm gesteuert angeben. Wenn Sie den anspruchsautorisierungs-Manager in einer Konfigurationsdatei angeben möchten, legen Sie das [&lt;ClaimsAuthorizationManager-&gt;](/dotnet/framework/configure-apps/file-schema/windows-identity-foundation/claimsauthorizationmanager) -Element unter einem [&lt;identityconfiguration-&gt;](/dotnet/framework/configure-apps/file-schema/windows-identity-foundation/identityconfiguration) Element fest, und stellen Sie sicher, dass auf diese Identitäts Konfiguration durch das&lt;Element&gt;[federationconfiguration](/dotnet/framework/configure-apps/file-schema/windows-identity-foundation/federationconfiguration) verwiesen wird, das von der Laufzeit geladen wird (z. b. durch Festlegen des `identityConfigurationName` Um den Anspruchs Autorisierungs-Manager Programm gesteuert festzulegen, stellen Sie einen Handler für das <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfigurationCreated?displayProperty=nameWithType>-Ereignis bereit.  
  
 Auf einer Ebene ähnelt die von <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> bereitgestellte Funktionalität den rollenbasierten Zugriffs Überprüfungen (Role-Based Access Checks, RBAC), die durch die <xref:System.Security.Permissions.PrincipalPermission>-Klasse bereitgestellt werden. die <xref:System.Security.Claims.ClaimsAuthorizationManager>-Klasse führt jedoch anhand der Ansprüche, die vom aktiven Prinzipal vorgelegt werden, Prüfungen durch. Dies ermöglicht eine weitaus höhere Granularität als durch die reine RBAC verfügbar ist, bei der viele Berechtigungen in der Regel unter einer einzigen Rolle gesammelt werden. Vielleicht noch wichtiger ist, dass die Anspruchs basierte Autorisierung eine bessere Trennung von Geschäftslogik und Autorisierungs Richtlinien ermöglicht, da die Berechtigung für eine bestimmte Aktion für eine Ressource im Code angefordert werden kann, und die Back-End-Richtlinie kann verwendet werden, um zu konfigurieren, welche Ansprüche die Entität besitzen muss, um die Anforderung zu erfüllen. Wie bei der rollenbasierten Zugriffs Steuerung führt <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> eine benutzerbasierte Zugriffs Überprüfung durch, d. h. im Unterschied zur Code Zugriffssicherheit, die von Klassen implementiert wird, die von der <xref:System.Security.CodeAccessPermission>-Klasse abgeleitet sind, und mithilfe eines Stackwalk sicherzustellen, dass allen Aufrufern des Codes eine Berechtigung erteilt wurde, <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> die Überprüfung nur für den aktuellen  
  
 Die statische <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A>-Methode überprüft den Zugriff für eine angegebene Aktion auf einer angegebenen Ressource. Die Ressource und die Aktion sind beide Zeichen folgen und sind in der Regel URIs. Sie können auch eine Instanz von <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> mit einer Aktion und einer Ressource initialisieren und die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A>-Methode aufzurufen. Obwohl der Konstruktor nur eine einzelne Ressource und eine Aktion annimmt, können <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> Objekte mithilfe der Methoden <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Union%2A> und <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect%2A> kombiniert werden. Eine Berechtigung, die mithilfe dieser Methoden erstellt wurde, kann mehrere Ressourcen Aktions Paare enthalten.  
  
 Beide Methoden bestimmen den Zugriff, indem Sie die <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType>-Methode des konfigurierten Anspruchs Autorisierungs-Managers mit einer <xref:System.Security.Claims.AuthorizationContext> aus dem aktiven Prinzipal (<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>), der Ressource und der Aktion aufrufen. Sie lösen eine <xref:System.Security.SecurityException> aus, wenn der aktuelle Prinzipal nicht zum Ausführen der Aktion für die Ressource autorisiert ist. Andernfalls wird die Ausführung fortgesetzt.  
  
 Im Fall einer <xref:System.IdentityModel.Services.ClaimsPrincipalPermission>, die mehrere Ressourcen Aktions Paare enthält, wird die <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType>-Methode für jedes der in der Berechtigung enthaltenen Ressourcen Aktions Paare aufgerufen.  Damit der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> Vorgang erfolgreich ausgeführt werden kann, muss der aktive Prinzipal für alle in der Berechtigung enthaltenen Ressourcen Aktions Paare autorisiert werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine Ressource mit der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A>-Methode, der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A>-Methode oder einer <xref:System.IdentityModel.Services.ClaimsPrincipalPermissionAttribute>-Deklaration geschützt wird. In jedem Fall wird der konfigurierte <xref:System.Security.Claims.ClaimsAuthorizationManager> aufgerufen, um den aktuellen Prinzipal anhand der angegebenen Ressource und Aktion auszuwerten. Wenn der aktuelle Prinzipal für die angegebene Aktion für die angegebene Ressource nicht autorisiert ist, wird ein <xref:System.Security.SecurityException> ausgelöst. Andernfalls wird die Ausführung fortgesetzt.  
  
 [!code-csharp[WifCppWithCam#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcppwithcam/cs/wifcppwithcam/program.cs#1)]  
  
 Der folgende XML-Code zeigt die Mindestanforderungen für die Verwendung eines benutzerdefinierten Anspruchs Autorisierungs-Managers mit der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission>-Klasse. Sie müssen mindestens die `system.identityModel`-und `system.identityModel.services` Abschnitte im `<configSection>`-Element deklarieren und dann den Autorisierungs-Manager in einem [&lt;ClaimsAuthorizationManager-&gt;](/dotnet/framework/configure-apps/file-schema/windows-identity-foundation/claimsauthorizationmanager) Element unter der Standard Identitäts Konfiguration angeben. Dadurch wird sichergestellt, dass auf den Autorisierungs-Manager von der Standard Verbund Konfiguration verwiesen wird. Alternativ können Sie den Namen der Identitäts Konfiguration angeben, unter der der Autorisierungs-Manager im `identityConfigurationName`-Attribut des [&lt;federationconfiguration&gt;](/dotnet/framework/configure-apps/file-schema/windows-identity-foundation/federationconfiguration) -Elements angegeben ist.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
  <configSections>  
    <!-- WIF configuration sections -->  
    <section name="system.identityModel" type="System.IdentityModel.Configuration.SystemIdentityModelSection, System.IdentityModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>  
    <section name="system.identityModel.services" type="System.IdentityModel.Services.Configuration.SystemIdentityModelServicesSection, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>  
  </configSections>  
  
  <startup>  
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
  </startup>  
  
  <system.identityModel>  
    <identityConfiguration>  
      <claimsAuthorizationManager type ="MyClaimsAuthorizationManager.MyClaimsAuthorizationManager, MyClaimsAuthorizationManager"/>  
    </identityConfiguration>  
  </system.identityModel>  
  
</configuration>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Services.ClaimsPrincipalPermissionAttribute" />
    <altmember cref="P:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration" />
    <altmember cref="T:System.Security.Claims.ClaimsAuthorizationManager" />
    <related type="Article" href="/dotnet/framework/configure-apps/file-schema/windows-identity-foundation/federationconfiguration">&lt;federationconfiguration&gt;</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ClaimsPrincipalPermission (string resource, string action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string resource, string action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resource As String, action As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ClaimsPrincipalPermission(System::String ^ resource, System::String ^ action);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Services.ClaimsPrincipalPermission : string * string -&gt; System.IdentityModel.Services.ClaimsPrincipalPermission" Usage="new System.IdentityModel.Services.ClaimsPrincipalPermission (resource, action)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resource" Type="System.String" />
        <Parameter Name="action" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resource">Die Ressource, auf der der Prinzipal autorisiert werden soll.</param>
        <param name="action">Die Aktion, für die der Prinzipal autorisiert werden soll.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> Objekt wird mit dem angegebenen Ressourcen Aktions paar initialisiert. Sie können die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A>-Methode aufrufen, um eine Zugriffs Überprüfung durchzuführen.  
  
 Obwohl der Konstruktor nur eine einzelne Ressource und eine Aktion annimmt, können <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> Objekte mithilfe der Methoden <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Union%2A> und <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect%2A> kombiniert werden. Die über diese Methoden erstellte Berechtigung kann mehrere Ressourcen Aktions Paare enthalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="resource" /> ist <see langword="null" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public static void CheckAccess (string resource, string action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckAccess(string resource, string action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CheckAccess (resource As String, action As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CheckAccess(System::String ^ resource, System::String ^ action);" />
      <MemberSignature Language="F#" Value="static member CheckAccess : string * string -&gt; unit" Usage="System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess (resource, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2103:ReviewImperativeSecurity", Justification="It is expected that the runtime’s behavior would rely on changing data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resource" Type="System.String" />
        <Parameter Name="action" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resource">Die Ressource, auf der der Prinzipal autorisiert werden soll.</param>
        <param name="action">Die Aktion, für die der Prinzipal autorisiert werden soll.</param>
        <summary>Überprüft, ob der aktuelle Prinzipal berechtigt ist, um die angegebene Aktion für die angegebene Ressource auszuführen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Prinzipal muss für die angegebene Aktion für die angegebene Ressource autorisiert werden, oder die <xref:System.Security.SecurityException> Ausnahme wird ausgelöst.  
  
 Die <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType>-Methode des konfigurierten Anspruchs Autorisierungs-Managers wird mit einem <xref:System.Security.Claims.AuthorizationContext> aufgerufen, der aus dem aktiven Prinzipal (<xref:System.Threading.Thread.CurrentPrincipal%2A>), der Ressource und der Aktion besteht.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine Ressource mit der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A>-Methode geschützt wird. Der konfigurierte anspruchsautorisierungs-Manager wird aufgerufen, um den aktuellen Prinzipal anhand der angegebenen Ressource und Aktion auszuwerten. Wenn der aktuelle Prinzipal für die angegebene Aktion für die angegebene Ressource nicht autorisiert ist, wird ein <xref:System.Security.SecurityException> ausgelöst. Andernfalls wird die Ausführung fortgesetzt.  
  
 [!code-csharp[WifCppWithCam#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifcppwithcam/cs/wifcppwithcam/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Prinzipal ist nicht von <see cref="T:System.Security.Claims.ClaimsPrincipal" /> zuweisbar.  
  
Oder 
Es ist kein <see cref="T:System.Security.Claims.ClaimsAuthorizationManager" /> konfiguriert.</exception>
        <exception cref="T:System.Security.SecurityException">Die Autorisierungsprüfung ist fehlgeschlagen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission&#xA;override this.Copy : unit -&gt; System.Security.IPermission" Usage="claimsPrincipalPermission.Copy " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Copy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2103:ReviewImperativeSecurity", Justification="It is expected that the runtime’s behavior would rely on changing data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Kopie der aktuellen <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />-Instanz zurück.</summary>
        <returns>Eine <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />, die aus der aktuellen Instanz kopiert wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit&#xA;override this.Demand : unit -&gt; unit" Usage="claimsPrincipalPermission.Demand " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überprüft, ob der aktuelle Prinzipal für die Ressourcen-Aktionspaare autorisiert ist, die der aktuellen Instanz zugeordnet sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der aktuelle Prinzipal muss für alle der Instanz zugeordneten Ressourcen Aktions Paare autorisiert werden, oder die <xref:System.Security.SecurityException> Ausnahme wird ausgelöst.  
  
 Obwohl der Konstruktor nur eine einzelne Ressource und eine Aktion annimmt, können <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> Objekte mithilfe der Methoden <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Union%2A> und <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect%2A> kombiniert werden. Die über diese Methoden erstellte Berechtigung kann mehrere Ressourcen Aktions Paare enthalten.  
  
 Die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A>-Methode ruft die <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType>-Methode des konfigurierten Anspruchs Autorisierungs-Managers mit einem <xref:System.Security.Claims.AuthorizationContext> auf, der aus dem aktiven Prinzipal (<xref:System.Threading.Thread.CurrentPrincipal%2A>), der Ressource und der Aktion für jedes der in der Berechtigung enthaltenen Ressourcen Aktions Paare besteht. Damit der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> erfolgreich ist, muss der aktive Prinzipal für alle in der Berechtigung enthaltenen Ressourcen Aktions Paare autorisiert werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine Ressource mit der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A>-Methode geschützt wird. Der konfigurierte anspruchsautorisierungs-Manager wird aufgerufen, um den aktuellen Prinzipal anhand der angegebenen Ressource und Aktion auszuwerten. Wenn der aktuelle Prinzipal für die angegebene Aktion für die angegebene Ressource nicht autorisiert ist, wird ein <xref:System.Security.SecurityException> ausgelöst. Andernfalls wird die Ausführung fortgesetzt.  
  
 [!code-csharp[WifCppWithCam#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcppwithcam/cs/wifcppwithcam/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Prinzipal ist nicht von <see cref="T:System.Security.Claims.ClaimsPrincipal" /> zuweisbar.  
  
Oder 
Es ist kein <see cref="T:System.Security.Claims.ClaimsAuthorizationManager" /> konfiguriert.</exception>
        <exception cref="T:System.Security.SecurityException">Die Autorisierungsprüfung ist fehlgeschlagen.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public void FromXml (System.Security.SecurityElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FromXml (element As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void FromXml(System::Security::SecurityElement ^ element);" />
      <MemberSignature Language="F#" Value="abstract member FromXml : System.Security.SecurityElement -&gt; unit&#xA;override this.FromXml : System.Security.SecurityElement -&gt; unit" Usage="claimsPrincipalPermission.FromXml element" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.FromXml(System.Security.SecurityElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="element">Die XML-Codierung zur Wiederherstellung der Berechtigung.</param>
        <summary>Erstellt die aktuelle Berechtigung und ihren Zustand aus der angegebenen XML-Codierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rekonstruiert eine Berechtigung aus der XML-Codierung, die durch einen aufzurufenden <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.ToXml%2A> Methode erstellt wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" /> ist <see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">Die Codierung enthält nicht erkannte Elemente oder Attribute oder nicht ordnungsgemäß gebildetes XML.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="claimsPrincipalPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Intersect(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Eine Berechtigung, deren Schnittmenge mit der aktuellen Berechtigung gebildet wird. Muss eine Instanz von <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> sein.</param>
        <summary>Gibt eine neue Berechtigung zurück, die den Kreuzungspunkt der aktuellen und der angegebenen Berechtigung ist.</summary>
        <returns>Eine neue <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />, die die Schnittmenge der aktuellen und der angegeben Berechtigung darstellt, oder <see langword="null" />, wenn <paramref name="target" /> gleich <paramref name="null" /> oder keine Instanz von <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene Berechtigung verfügt nur über die Resource-Action-Paare, die sowohl in der aktuellen Berechtigung als auch in der angegebenen Berechtigung vorhanden waren. Ressourcen-Aktions Paare, die nur in einer oder den anderen Berechtigungen vorhanden waren, sind nicht eingeschlossen. Damit ein <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> mit der neuen Berechtigung erfolgreich ist, muss der aktuelle Prinzipal nur für die Ressourcen Aktions Paare autorisiert werden, die der aktuellen Berechtigung und der angegebenen Berechtigung gemeinsam waren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool&#xA;override this.IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="claimsPrincipalPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Die Berechtigung, für die geprüft werden soll, ob sie eine Teilmenge einer anderen Berechtigung ist. Muss eine Instanz von <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> sein.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Berechtigung eine Teilmenge der angegebenen Berechtigung ist.</summary>
        <returns><see langword="true" />, wenn die aktuelle Berechtigung eine Teilmenge der angegebenen Berechtigung darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle Berechtigung ist eine Teilmenge der angegebenen Berechtigung, wenn alle in der aktuellen Berechtigung enthaltenen Ressourcen Aktions Paare auch in der angegebenen Berechtigung vorhanden sind. Wenn `target` `null` ist oder keine Instanz von <xref:System.IdentityModel.Services.ClaimsPrincipalPermission>ist, gibt der <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.IsSubsetOf%2A> `false`zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnrestricted">
      <MemberSignature Language="C#" Value="public bool IsUnrestricted ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsUnrestricted() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.IsUnrestricted" />
      <MemberSignature Language="VB.NET" Value="Public Function IsUnrestricted () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsUnrestricted();" />
      <MemberSignature Language="F#" Value="abstract member IsUnrestricted : unit -&gt; bool&#xA;override this.IsUnrestricted : unit -&gt; bool" Usage="claimsPrincipalPermission.IsUnrestricted " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.Permissions.IUnrestrictedPermission.IsUnrestricted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob die Berechtigung uneingeschränkt ist.</summary>
        <returns><see langword="true" />, wenn die Berechtigung uneingeschränkt ist, andernfalls <see langword="false" />. Gibt immer <see langword="true" /> zurück, was angibt, dass die Berechtigung uneingeschränkt ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="abstract member ToXml : unit -&gt; System.Security.SecurityElement&#xA;override this.ToXml : unit -&gt; System.Security.SecurityElement" Usage="claimsPrincipalPermission.ToXml " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.ToXml</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die XML-codierte Form der aktuellen Berechtigung und ihren Zustand zurück.</summary>
        <returns>Die XML-codierte Form der aktuellen Berechtigung und ihr Zustand.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Prinzipal kann aus seinem XML-codierten Formular rekonstruiert werden, indem die <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.FromXml%2A>-Methode aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="claimsPrincipalPermission.Union target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Union(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Eine Berechtigung, die mit der aktuellen Berechtigung kombiniert werden soll. Das Objekt muss vom Typ <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> sein.</param>
        <summary>Gibt eine neue Berechtigung zurück, die die Union der aktuellen und der angegebenen Berechtigung ist. <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />-Objekt, das über alle Ressource/Aktion-Paare verfügt, die in der aktuellen Instanz und in der Zielinstanz vorhanden sind.</summary>
        <returns>Eine neue <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />, die die Union der aktuellen und der angegeben Berechtigung darstellt, oder <see langword="null" />, wenn <paramref name="target" /> gleich <paramref name="null" /> oder keine Instanz von <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Berechtigung, die zurückgegeben wird, verfügt über alle Ressourcen Aktions Paare, die in der aktuellen Berechtigung und alle Ressourcen Aktions Paare vorhanden sind, die die angegebene Berechtigung enthalten. Damit ein <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> mit der neuen Berechtigung erfolgreich ist, muss der aktuelle Prinzipal für alle Ressourcen Aktions Paare autorisiert werden, die in der aktuellen Berechtigung vorhanden waren, sowie für alle Ressourcen Aktions Paare, die in der angegebenen Berechtigung vorhanden waren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
