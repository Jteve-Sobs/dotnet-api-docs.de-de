<Type Name="ConfigurationManager" FullName="System.Configuration.ConfigurationManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="196650deb8e92955e7743171b4d6061c0077e7c9" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82395048" /></Metadata><TypeSignature Language="C#" Value="public static class ConfigurationManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ConfigurationManager extends System.Object" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ConfigurationManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ConfigurationManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ConfigurationManager abstract sealed" />
  <TypeSignature Language="F#" Value="type ConfigurationManager = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed ConfigurationManager extends System.Object" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>System.Configuration</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Zugriff auf Konfigurationsdateien für Clientanwendungen bereit. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Configuration.ConfigurationManager>-Klasse ermöglicht Ihnen den Zugriff auf Computer-, Anwendungs-und Benutzer Konfigurationsinformationen. Diese Klasse ersetzt die <xref:System.Configuration.ConfigurationSettings>-Klasse, die veraltet ist. Verwenden Sie für Webanwendungen die <xref:System.Web.Configuration.WebConfigurationManager>-Klasse.  
  
 Um die <xref:System.Configuration.ConfigurationManager>-Klasse verwenden zu können, muss das Projekt auf die `System.Configuration` Assembly verweisen. Standardmäßig verweisen einige Projektvorlagen, z. b. Konsolenanwendung, nicht auf diese Assembly, sodass Sie Sie manuell referenzieren müssen.  
  
> [!NOTE]
>  Der Name und Speicherort der Anwendungs Konfigurationsdatei sind vom Host der Anwendung abhängig. Weitere Informationen finden Sie unter [Konfigurieren von apps mithilfe von Konfigurationsdateien](~/docs/framework/configure-apps/index.md).  
  
 Sie können die integrierten <xref:System.Configuration> Typen verwenden oder von Ihnen ableiten, um Konfigurationsinformationen zu verarbeiten. Mit diesen Typen können Sie direkt mit Konfigurationsinformationen arbeiten und Konfigurationsdateien so erweitern, dass Sie benutzerdefinierte Informationen enthalten.  
  
 Die <xref:System.Configuration.ConfigurationManager>-Klasse enthält Member, mit denen Sie die folgenden Aufgaben ausführen können:  
  
-   Liest einen Abschnitt aus einer Konfigurationsdatei. Um auf Konfigurationsinformationen zuzugreifen, müssen Sie die <xref:System.Configuration.ConfigurationManager.GetSection%2A>-Methode aufrufen. Verwenden Sie für einige Abschnitte wie `appSettings` und `connectionStrings`die Klassen <xref:System.Configuration.ConfigurationManager.AppSettings%2A> und <xref:System.Configuration.ConfigurationManager.ConnectionStrings%2A>. Diese Member führen schreibgeschützte Vorgänge aus, verwenden eine einzelne zwischengespeicherte Instanz der Konfiguration und sind multithreadfähig.  
  
-   Lesen und Schreiben von Konfigurationsdateien als Ganzes. Die Anwendung kann Konfigurationseinstellungen auf jeder Ebene, für sich selbst oder für andere Anwendungen oder Computer lokal oder Remote lesen und schreiben. Verwenden Sie eine der Methoden, die von der <xref:System.Configuration.ConfigurationManager>-Klasse bereitgestellt werden, um eine Konfigurationsdatei wie SampleApp. exe. config zu öffnen. Diese Methoden geben ein <xref:System.Configuration.Configuration> Objekt zurück, das wiederum Methoden und Eigenschaften verfügbar macht, die Sie verwenden können, um mit den zugeordneten Konfigurationsdateien zu arbeiten. Mit den-Methoden werden Lese-oder Schreibvorgänge durchgeführt und die Konfigurationsdaten jedes Mal erstellt, wenn eine Datei geschrieben wird.  
  
-   Unterstützung von Konfigurationsaufgaben. Die folgenden Typen werden verwendet, um verschiedene Konfigurationsaufgaben zu unterstützen:  
  
    -   <xref:System.Configuration.SectionInformation>  
  
    -   <xref:System.Configuration.PropertyInformation>  
  
    -   <xref:System.Configuration.PropertyInformationCollection>  
  
    -   <xref:System.Configuration.ElementInformation>  
  
    -   <xref:System.Configuration.ContextInformation>  
  
    -   <xref:System.Configuration.ConfigurationSectionGroup>  
  
    -   <xref:System.Configuration.ConfigurationSectionGroupCollection>  
  
     Zusätzlich zum Arbeiten mit vorhandenen Konfigurationsinformationen können Sie benutzerdefinierte Konfigurationselemente erstellen und bearbeiten, indem Sie die integrierten Konfigurationstypen, z. b. die Klassen <xref:System.Configuration.ConfigurationElement>, <xref:System.Configuration.ConfigurationElementCollection>, <xref:System.Configuration.ConfigurationProperty>und <xref:System.Configuration.ConfigurationSection>, erweitern. Ein Beispiel für die programmgesteuerte Erweiterung eines integrierten Konfigurations Typs finden Sie unter <xref:System.Configuration.ConfigurationSection>. Ein Beispiel für die Erweiterung eines integrierten Konfigurations Typs, der das Attribut basierte Modell verwendet, finden Sie unter <xref:System.Configuration.ConfigurationElement>.  
  
   
  
## Examples  
 Das erste Beispiel zeigt eine einfache Konsolenanwendung, die Anwendungseinstellungen liest, eine neue Einstellung hinzufügt und eine vorhandene Einstellung aktualisiert.  
  
```csharp  
using System;  
using System.Configuration;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadAllSettings();  
            ReadSetting("Setting1");  
            ReadSetting("NotValid");  
            AddUpdateAppSettings("NewSetting", "May 7, 2014");  
            AddUpdateAppSettings("Setting1", "May 8, 2014");  
            ReadAllSettings();  
        }  
  
        static void ReadAllSettings()  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
  
                if (appSettings.Count == 0)  
                {  
                    Console.WriteLine("AppSettings is empty.");  
                }  
                else  
                {  
                    foreach (var key in appSettings.AllKeys)  
                    {  
                        Console.WriteLine("Key: {0} Value: {1}", key, appSettings[key]);  
                    }  
                }  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void ReadSetting(string key)  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
                string result = appSettings[key] ?? "Not Found";  
                Console.WriteLine(result);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void AddUpdateAppSettings(string key, string value)  
        {  
            try  
            {  
                var configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);  
                var settings = configFile.AppSettings.Settings;  
                if (settings[key] == null)  
                {  
                    settings.Add(key, value);  
                }  
                else  
                {  
                    settings[key].Value = value;  
                }  
                configFile.Save(ConfigurationSaveMode.Modified);  
                ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error writing app settings");  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Module Module1  
  
    Sub Main()  
        ReadAllSettings()  
        ReadSetting("Setting1")  
        ReadSetting("NotValid")  
        AddUpdateAppSettings("NewSetting", "May 7, 2014")  
        AddUpdateAppSettings("Setting1", "May 8, 2014")  
        ReadAllSettings()  
    End Sub  
  
    Sub ReadAllSettings()  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
  
            If appSettings.Count = 0 Then  
                Console.WriteLine("AppSettings is empty.")  
            Else  
                For Each key As String In appSettings.AllKeys  
                    Console.WriteLine("Key: {0} Value: {1}", key, appSettings(key))  
                Next  
            End If  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub ReadSetting(key As String)  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
            Dim result As String = appSettings(key)  
            If IsNothing(result) Then  
                result = "Not found"  
            End If  
            Console.WriteLine(result)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub AddUpdateAppSettings(key As String, value As String)  
        Try  
            Dim configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None)  
            Dim settings = configFile.AppSettings.Settings  
            If IsNothing(settings(key)) Then  
                settings.Add(key, value)  
            Else  
                settings(key).Value = value  
            End If  
            configFile.Save(ConfigurationSaveMode.Modified)  
            ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error writing app settings")  
        End Try  
    End Sub  
  
End Module  
```  
  
 Im vorherigen Beispiel wird davon ausgegangen, dass das Projekt über eine APP. config-Datei verfügt, wie unten gezeigt.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
  <appSettings>  
    <add key="Setting1" value="May 5, 2014"/>  
    <add key="Setting2" value="May 6, 2014"/>  
  </appSettings>  
</configuration>  
```  
  
 Im folgenden Beispiel wird gezeigt, wie eine Verbindungs Zeichenfolge verwendet wird, um Daten aus einer Datenbank zu lesen.  
  
```csharp  
using System;  
using System.Configuration;  
using System.Data.SqlClient;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadProducts();  
        }  
  
        static void ReadProducts()  
        {  
            var connectionString = ConfigurationManager.ConnectionStrings["WingtipToys"].ConnectionString;  
            string queryString = "SELECT Id, ProductName FROM dbo.Products;";  
            using (var connection = new SqlConnection(connectionString))  
            {  
                var command = new SqlCommand(queryString, connection);  
                connection.Open();  
                using (var reader = command.ExecuteReader())  
                {  
                    while (reader.Read())  
                    {  
                        Console.WriteLine(String.Format("{0}, {1}", reader[0], reader[1]));  
                    }  
                }  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Imports System.Data.SqlClient  
Module Module1  
  
    Sub Main()  
        ReadProducts()  
    End Sub  
  
    Sub ReadProducts()  
        Dim connectionString = ConfigurationManager.ConnectionStrings("WingtipToys").ConnectionString  
        Dim queryString = "SELECT Id, ProductName FROM dbo.Products;"  
        Using connection As New SqlConnection(connectionString)  
            Dim command = New SqlCommand(queryString, connection)  
            connection.Open()  
  
            Using reader As SqlDataReader = command.ExecuteReader()  
                While reader.Read()  
                    Console.WriteLine(String.Format("{0}, {1}", reader(0), reader(1)))  
                End While  
            End Using  
        End Using  
    End Sub  
  
End Module  
```  
  
 Im vorherigen Beispiel wird davon ausgegangen, dass das Projekt über eine APP. config verfügt, wie unten gezeigt.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
    <connectionStrings>  
      <add name="WingtipToys" connectionString="Data Source=(LocalDB)\v11.0;Initial Catalog=WingtipToys;Integrated Security=True;Pooling=False" />  
    </connectionStrings>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Die <see cref="T:System.Configuration.Configuration" />-Klasse ermöglicht den programmgesteuerten Zugriff zum Bearbeiten von Konfigurationsdateien. Sie verwenden eine der geöffneten Methoden, die von <see cref="T:System.Configuration.ConfigurationManager" />bereitgestellt werden. Diese Methoden geben ein <see cref="T:System.Configuration.Configuration" /> Objekt zurück, das wiederum die erforderlichen Methoden und Eigenschaften bereitstellt, um die zugrunde liegenden Konfigurationsdateien zu verarbeiten. Sie können auf diese Dateien zum Lesen oder Schreiben zugreifen.  
  
Um die Konfigurationsdateien zu lesen, verwenden Sie <see cref="M:System.Configuration.Configuration.GetSection(System.String)" /> oder <see cref="M:System.Configuration.Configuration.GetSectionGroup(System.String)" />, um die Konfigurationsinformationen zu lesen. Der Benutzer oder der Prozess, der liest, muss über die folgenden Berechtigungen verfügen: 
-Leseberechtigung für die Konfigurationsdatei auf der aktuellen Konfigurations Hierarchieebene.  
  
: Leseberechtigungen für alle übergeordneten Konfigurationsdateien.  
  
Wenn Ihre Anwendung schreibgeschützten Zugriff auf Ihre eigene Konfiguration benötigt, empfiehlt es sich, die <see cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />-Methode zu verwenden. Diese Methode ermöglicht den Zugriff auf die zwischengespeicherten Konfigurationswerte für die aktuelle Anwendung, die eine bessere Leistung als die <see cref="T:System.Configuration.Configuration" /> Klasse aufweist.  
  
Verwenden Sie eine der <see cref="Overload:System.Configuration.Configuration.Save" /> Methoden, um in die Konfigurationsdateien zu schreiben. Der Benutzer oder der Prozess, der schreibt, muss über die folgenden Berechtigungen verfügen: 
-Schreib Berechtigung für die Konfigurationsdatei und das Verzeichnis auf der aktuellen Konfigurations Hierarchieebene.  
  
: Leseberechtigungen für alle Konfigurationsdateien.</para></block>
    <altmember cref="T:System.Configuration.Configuration" />
    <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
    <related type="Article" href="~/docs/framework/configure-apps/index.md">Konfigurationsdateien</related>
  </Docs>
  <Members>
    <Member MemberName="AppSettings">
      <MemberSignature Language="C#" Value="public static System.Collections.Specialized.NameValueCollection AppSettings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Specialized.NameValueCollection AppSettings" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationManager.AppSettings" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AppSettings As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Specialized::NameValueCollection ^ AppSettings { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AppSettings : System.Collections.Specialized.NameValueCollection" Usage="System.Configuration.ConfigurationManager.AppSettings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Configuration.AppSettingsSection" />-Daten für die Standardkonfiguration der aktuellen Anwendung ab.</summary>
        <value>Ein <see cref="T:System.Collections.Specialized.NameValueCollection" />-Objekt, das den Inhalt des <see cref="T:System.Configuration.AppSettingsSection" />-Objekts für die Standardkonfiguration der aktuellen Anwendung enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Configuration.AppSettingsSection>-Objekt enthält den Inhalt des `appSettings` Abschnitts der Konfigurationsdatei.  
  
   
  
## Examples  
 Das erste Beispiel zeigt eine einfache Konsolenanwendung, die Anwendungseinstellungen liest, eine neue Einstellung hinzufügt und eine vorhandene Einstellung aktualisiert.  
  
```csharp  
using System;  
using System.Configuration;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadAllSettings();  
            ReadSetting("Setting1");  
            ReadSetting("NotValid");  
            AddUpdateAppSettings("NewSetting", "May 7, 2014");  
            AddUpdateAppSettings("Setting1", "May 8, 2014");  
            ReadAllSettings();  
        }  
  
        static void ReadAllSettings()  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
  
                if (appSettings.Count == 0)  
                {  
                    Console.WriteLine("AppSettings is empty.");  
                }  
                else  
                {  
                    foreach (var key in appSettings.AllKeys)  
                    {  
                        Console.WriteLine("Key: {0} Value: {1}", key, appSettings[key]);  
                    }  
                }  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void ReadSetting(string key)  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
                string result = appSettings[key] ?? "Not Found";  
                Console.WriteLine(result);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void AddUpdateAppSettings(string key, string value)  
        {  
            try  
            {  
                var configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);  
                var settings = configFile.AppSettings.Settings;  
                if (settings[key] == null)  
                {  
                    settings.Add(key, value);  
                }  
                else  
                {  
                    settings[key].Value = value;  
                }  
                configFile.Save(ConfigurationSaveMode.Modified);  
                ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error writing app settings");  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Module Module1  
  
    Sub Main()  
        ReadAllSettings()  
        ReadSetting("Setting1")  
        ReadSetting("NotValid")  
        AddUpdateAppSettings("NewSetting", "May 7, 2014")  
        AddUpdateAppSettings("Setting1", "May 8, 2014")  
        ReadAllSettings()  
    End Sub  
  
    Sub ReadAllSettings()  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
  
            If appSettings.Count = 0 Then  
                Console.WriteLine("AppSettings is empty.")  
            Else  
                For Each key As String In appSettings.AllKeys  
                    Console.WriteLine("Key: {0} Value: {1}", key, appSettings(key))  
                Next  
            End If  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub ReadSetting(key As String)  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
            Dim result As String = appSettings(key)  
            If IsNothing(result) Then  
                result = "Not found"  
            End If  
            Console.WriteLine(result)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub AddUpdateAppSettings(key As String, value As String)  
        Try  
            Dim configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None)  
            Dim settings = configFile.AppSettings.Settings  
            If IsNothing(settings(key)) Then  
                settings.Add(key, value)  
            Else  
                settings(key).Value = value  
            End If  
            configFile.Save(ConfigurationSaveMode.Modified)  
            ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error writing app settings")  
        End Try  
    End Sub  
  
End Module  
```  
  
 Im vorherigen Beispiel wird davon ausgegangen, dass das Projekt über eine APP. config-Datei verfügt, wie unten gezeigt.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
  <appSettings>  
    <add key="Setting1" value="May 5, 2014"/>  
    <add key="Setting2" value="May 6, 2014"/>  
  </appSettings>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Ein <see cref="T:System.Collections.Specialized.NameValueCollection" />-Objekt konnte mit den Anwendungseinstellungsdaten nicht abgerufen werden.</exception>
        <altmember cref="T:System.Configuration.AppSettingsSection" />
        <altmember cref="T:System.Collections.Specialized.NameValueCollection" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionStrings">
      <MemberSignature Language="C#" Value="public static System.Configuration.ConnectionStringSettingsCollection ConnectionStrings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Configuration.ConnectionStringSettingsCollection ConnectionStrings" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationManager.ConnectionStrings" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ConnectionStrings As ConnectionStringSettingsCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Configuration::ConnectionStringSettingsCollection ^ ConnectionStrings { System::Configuration::ConnectionStringSettingsCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionStrings : System.Configuration.ConnectionStringSettingsCollection" Usage="System.Configuration.ConfigurationManager.ConnectionStrings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConnectionStringSettingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Configuration.ConnectionStringsSection" />-Daten für die Standardkonfiguration der aktuellen Anwendung ab.</summary>
        <value>Ein <see cref="T:System.Configuration.ConnectionStringSettingsCollection" />-Objekt, das den Inhalt des <see cref="T:System.Configuration.ConnectionStringsSection" />-Objekts für die Standardkonfiguration der aktuellen Anwendung enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Configuration.ConnectionStringsSection>-Objekt enthält den Inhalt des `connectionStrings` Abschnitts der Konfigurationsdatei.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine Verbindungs Zeichenfolge verwendet wird, um Daten aus einer Datenbank zu lesen.  
  
```csharp  
using System;  
using System.Configuration;  
using System.Data.SqlClient;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadProducts();  
        }  
  
        static void ReadProducts()  
        {  
            var connectionString = ConfigurationManager.ConnectionStrings["WingtipToys"].ConnectionString;  
            string queryString = "SELECT Id, ProductName FROM dbo.Products;";  
            using (var connection = new SqlConnection(connectionString))  
            {  
                var command = new SqlCommand(queryString, connection);  
                connection.Open();  
                using (var reader = command.ExecuteReader())  
                {  
                    while (reader.Read())  
                    {  
                        Console.WriteLine(String.Format("{0}, {1}", reader[0], reader[1]));  
                    }  
                }  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Imports System.Data.SqlClient  
Module Module1  
  
    Sub Main()  
        ReadProducts()  
    End Sub  
  
    Sub ReadProducts()  
        Dim connectionString = ConfigurationManager.ConnectionStrings("WingtipToys").ConnectionString  
        Dim queryString = "SELECT Id, ProductName FROM dbo.Products;"  
        Using connection As New SqlConnection(connectionString)  
            Dim command = New SqlCommand(queryString, connection)  
            connection.Open()  
  
            Using reader As SqlDataReader = command.ExecuteReader()  
                While reader.Read()  
                    Console.WriteLine(String.Format("{0}, {1}", reader(0), reader(1)))  
                End While  
            End Using  
        End Using  
    End Sub  
  
End Module  
```  
  
 Im vorherigen Beispiel wird davon ausgegangen, dass das Projekt über eine APP. config verfügt, wie unten gezeigt.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
    <connectionStrings>  
      <add name="WingtipToys" connectionString="Data Source=(LocalDB)\v11.0;Initial Catalog=WingtipToys;Integrated Security=True;Pooling=False" />  
    </connectionStrings>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Es konnte kein <see cref="T:System.Configuration.ConnectionStringSettingsCollection" />-Objekt abgerufen werden.</exception>
        <altmember cref="T:System.Configuration.ConnectionStringsSection" />
        <altmember cref="T:System.Configuration.ConnectionStringSettingsCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public static object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="static member GetSection : string -&gt; obj" Usage="System.Configuration.ConfigurationManager.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Der Konfigurationsabschnittspfad und -name. Knotennamen werden durch Schrägstriche getrennt, z.B. „system.net/mailSettings/smtp“.</param>
        <summary>Ruft einen angegebenen Konfigurationsabschnitt für die Standardkonfiguration der aktuellen Anwendung ab.</summary>
        <returns>Das angegebene <see cref="T:System.Configuration.ConfigurationSection" />-Objekt oder <see langword="null" />, wenn der Abschnitt nicht vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Client Anwendungen ruft diese Methode eine Konfigurationsdatei ab, die durch das Zusammenführen der Anwendungs Konfigurationsdatei, der lokalen Benutzer Konfigurationsdatei und der Roamingkonfigurationsdatei abgerufen wurde.  
  
 Die <xref:System.Configuration.ConfigurationManager.GetSection%2A>-Methode greift auf Lauf Zeit Konfigurationsinformationen zu, die nicht geändert werden können. Um die Konfiguration zu ändern, verwenden Sie die <xref:System.Configuration.Configuration.GetSection%2A>-Methode für die Konfigurationsdatei, die Sie mithilfe einer der folgenden geöffneten Methoden abrufen:  
  
-   <xref:System.Configuration.ConfigurationManager.OpenExeConfiguration%2A>  
  
-   <xref:System.Configuration.ConfigurationManager.OpenMachineConfiguration%2A>  
  
-   <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Configuration.ConfigurationManager.GetSection%2A>-Methode gezeigt. Das Beispiel ist Teil eines größeren Beispiels, das für die <xref:System.Configuration.ConfigurationManager>-Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#7)]
 [!code-vb[System.Configuration.ConfigurationManager#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Eine Konfigurationsdatei konnte nicht geladen werden.</exception>
        <block subset="none" type="overrides"><para>Sie müssen den Rückgabewert in den erwarteten Konfigurationstyp umwandeln. Um mögliche Umwandlungs Ausnahmen zu vermeiden, sollten Sie einen bedingten Umwandlungs Vorgang wie den <see langword="as" /> Operator C# in oder die [TryCast](~/docs/visual-basic/language-reference/operators/trycast-operator.md) -Funktion in Visual Basic verwenden.</para></block>
        <altmember cref="T:System.Configuration.ConfigurationSection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExeConfiguration">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet die angegebene Clientkonfigurationsdatei als <see cref="T:System.Configuration.Configuration" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenExeConfiguration (System.Configuration.ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenExeConfiguration(valuetype System.Configuration.ConfigurationUserLevel userLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenExeConfiguration(System.Configuration.ConfigurationUserLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExeConfiguration (userLevel As ConfigurationUserLevel) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenExeConfiguration(System::Configuration::ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="F#" Value="static member OpenExeConfiguration : System.Configuration.ConfigurationUserLevel -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenExeConfiguration userLevel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userLevel" Type="System.Configuration.ConfigurationUserLevel" />
      </Parameters>
      <Docs>
        <param name="userLevel">Die <see cref="T:System.Configuration.ConfigurationUserLevel" />, für die Sie die Konfiguration öffnen.</param>
        <summary>Öffnet die Konfigurationsdatei für die aktuelle Anwendung als <see cref="T:System.Configuration.Configuration" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.Configuration.Configuration" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Client Anwendungen verwenden eine globale Konfiguration, die für alle Benutzer gilt, separate Konfigurationen, die für einzelne Benutzer gelten, und Konfigurationen, die für Roamingbenutzer gelten. Der `userLevel`-Parameter bestimmt den Speicherort der zu öffnenden Konfigurationsdatei, indem er angibt, ob er über keine Benutzerebene (die Konfigurationsdatei befindet sich im gleichen Verzeichnis wie die Anwendung) oder über eine benutzerspezifische Ebene verfügt (die Konfigurationsdatei befindet sich in einem von der Benutzerebene festgelegten Pfad der Anwendungseinstellungen).  
  
 Geben Sie an, welche Konfiguration Sie erhalten möchten, indem Sie einen der folgenden Werte für `userLevel`übergeben:  
  
-   Um das <xref:System.Configuration.Configuration> Objekt zu erhalten, das für alle Benutzer gilt, legen Sie `userLevel` auf <xref:System.Configuration.ConfigurationUserLevel.None>fest.  
  
-   Um das lokale <xref:System.Configuration.Configuration> Objekt zu erhalten, das für den aktuellen Benutzer gilt, legen Sie `userLevel` auf <xref:System.Configuration.ConfigurationUserLevel.PerUserRoamingAndLocal>fest.  
  
-   Um das Roaming <xref:System.Configuration.Configuration> Objekt zu erhalten, das für den aktuellen Benutzer gilt, legen Sie `userLevel` auf <xref:System.Configuration.ConfigurationUserLevel.PerUserRoaming>fest.  
  
    > [!NOTE]
    >  Um das <xref:System.Configuration.Configuration>-Objekt für eine Ressource zu erhalten, muss der Code über Leseberechtigungen für alle Konfigurationsdateien verfügen, von denen er Einstellungen erbt. Um eine Konfigurationsdatei zu aktualisieren, muss der Code zusätzlich über Schreibberechtigungen für die Konfigurationsdatei und das Verzeichnis verfügen, in dem Sie vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Configuration.ConfigurationManager.OpenExeConfiguration%2A>-Methode veranschaulicht.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#5)]
 [!code-vb[System.Configuration.ConfigurationManager#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Eine Konfigurationsdatei konnte nicht geladen werden.</exception>
        <altmember cref="T:System.Configuration.ConfigurationUserLevel" />
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <Member MemberName="OpenExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenExeConfiguration (string exePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenExeConfiguration(string exePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenExeConfiguration(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExeConfiguration (exePath As String) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenExeConfiguration(System::String ^ exePath);" />
      <MemberSignature Language="F#" Value="static member OpenExeConfiguration : string -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenExeConfiguration exePath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="exePath">Der Pfad der ausführbaren Datei (EXE).</param>
        <summary>Öffnet die angegebene Clientkonfigurationsdatei als <see cref="T:System.Configuration.Configuration" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.Configuration.Configuration" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Client Anwendungen verwenden eine globale Konfiguration, die für alle Benutzer gilt, separate Konfigurationen, die für einzelne Benutzer gelten, und Konfigurationen, die für Roamingbenutzer gelten. Der `userLevel` Wert bestimmt den Speicherort der Konfigurationsdatei, die geöffnet wird. Es zeigt an, ob es über keine Benutzerebene (die Konfigurationsdatei befindet sich im selben Verzeichnis wie die Anwendung) oder eine benutzerspezifische Ebene (die Konfigurationsdatei befindet sich in einem Anwendungs Einstellungs Pfad, der durch den Typ der Benutzerebene festgelegt ist).  
  
 Das Aufrufen dieser Methoden Überladung entspricht dem Aufrufen der <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%28System.Configuration.ExeConfigurationFileMap%2CSystem.Configuration.ConfigurationUserLevel%2CSystem.Boolean%29> Überladung, bei der der Parameter `preLoad` auf `false`festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Configuration.ConfigurationManager.OpenExeConfiguration%2A>-Methode veranschaulicht.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#6)]
 [!code-vb[System.Configuration.ConfigurationManager#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Eine Konfigurationsdatei konnte nicht geladen werden.</exception>
        <altmember cref="T:System.Configuration.ConfigurationUserLevel" />
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <Member MemberName="OpenMachineConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMachineConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMachineConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMachineConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMachineConfiguration () As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMachineConfiguration();" />
      <MemberSignature Language="F#" Value="static member OpenMachineConfiguration : unit -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMachineConfiguration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Öffnet die Computerkonfigurationsdatei auf dem aktuellen Computer als <see cref="T:System.Configuration.Configuration" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.Configuration.Configuration" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Computer Konfigurationseinstellungen gelten für den gesamten Computer und alle Anwendungen, die sich darauf befinden, es sei denn, Sie wurden für die lokale Anwendung überschrieben. Die Computer Konfigurationseinstellungen werden in der Datei Machine. config der aktuellen Version des .NET Framework gelesen. Die Datei Machine. config befindet sich im folgenden Unterverzeichnis:  
  
 *% windir%* \Microsoft.NET\Framework\\*Version*\Config  
  
> [!NOTE]
>  Um das <xref:System.Configuration.Configuration> Objekt für eine Ressource abzurufen, muss der Code über Leseberechtigungen für alle Konfigurationsdateien verfügen, von denen er Einstellungen erbt. Um eine Konfigurationsdatei zu aktualisieren, muss der Code zusätzlich über Schreibberechtigungen für die Konfigurationsdatei und das Verzeichnis verfügen, in dem Sie vorhanden ist. Es ist nicht möglich, auf die Datei "Machine. config" für andere Versionen der .NET Framework zuzugreifen, die auf dem Computer installiert sein könnten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie mit der <xref:System.Configuration.ConfigurationManager.OpenMachineConfiguration%2A>-Methode alle in der Konfigurationsdatei enthaltenen Abschnitte abrufen können.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#4)]
 [!code-vb[System.Configuration.ConfigurationManager#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Eine Konfigurationsdatei konnte nicht geladen werden.</exception>
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenMappedExeConfiguration">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet die angegebene Clientkonfigurationsdatei als <see cref="T:System.Configuration.Configuration" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenMappedExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMappedExeConfiguration (System.Configuration.ExeConfigurationFileMap fileMap, System.Configuration.ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMappedExeConfiguration(class System.Configuration.ExeConfigurationFileMap fileMap, valuetype System.Configuration.ConfigurationUserLevel userLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(System.Configuration.ExeConfigurationFileMap,System.Configuration.ConfigurationUserLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMappedExeConfiguration (fileMap As ExeConfigurationFileMap, userLevel As ConfigurationUserLevel) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMappedExeConfiguration(System::Configuration::ExeConfigurationFileMap ^ fileMap, System::Configuration::ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="F#" Value="static member OpenMappedExeConfiguration : System.Configuration.ExeConfigurationFileMap * System.Configuration.ConfigurationUserLevel -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMappedExeConfiguration (fileMap, userLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileMap" Type="System.Configuration.ExeConfigurationFileMap" />
        <Parameter Name="userLevel" Type="System.Configuration.ConfigurationUserLevel" />
      </Parameters>
      <Docs>
        <param name="fileMap">Ein <see cref="T:System.Configuration.ExeConfigurationFileMap" />-Objekt, das auf die Konfigurationsdatei verweist, die statt der Standard-Anwendungskonfigurationsdatei verwendet werden sollte.</param>
        <param name="userLevel">Das <see cref="T:System.Configuration.ConfigurationUserLevel" />-Objekt, für das Sie die Konfiguration öffnen.</param>
        <summary>Öffnet die angegebene Clientkonfigurationsdatei als <see cref="T:System.Configuration.Configuration" />-Objekt mithilfe der angegebenen Dateizuordnung und Benutzerebene.</summary>
        <returns>Konfigurationsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Configuration.ConfigurationUserLevel>-Objekt bestimmt den Speicherort der Konfigurationsdatei, die geöffnet wird. Gibt an, ob die Datei keine Benutzerebene hat (die Konfigurationsdatei befindet sich im selben Verzeichnis wie die Anwendung) oder über eine benutzerspezifische Ebene (die Konfigurationsdatei befindet sich in einem von `userLevel`festgelegten Anwendungs Einstellungs Pfad).  
  
> [!NOTE]
>  Um das <xref:System.Configuration.Configuration> Objekt für eine Ressource abzurufen, muss der Code über Leseberechtigungen für alle Konfigurationsdateien verfügen, von denen er Einstellungen erbt. Um eine Konfigurationsdatei zu aktualisieren, muss der Code zusätzlich über Schreibberechtigungen für die Konfigurationsdatei und das Verzeichnis verfügen, in dem Sie vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie mit der <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%2A>-Methode alle in der Konfigurationsdatei enthaltenen Abschnitte abrufen können.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#9)]
 [!code-vb[System.Configuration.ConfigurationManager#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Eine Konfigurationsdatei konnte nicht geladen werden.</exception>
        <altmember cref="T:System.Configuration.ConfigurationUserLevel" />
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <Member MemberName="OpenMappedExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMappedExeConfiguration (System.Configuration.ExeConfigurationFileMap fileMap, System.Configuration.ConfigurationUserLevel userLevel, bool preLoad);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMappedExeConfiguration(class System.Configuration.ExeConfigurationFileMap fileMap, valuetype System.Configuration.ConfigurationUserLevel userLevel, bool preLoad) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(System.Configuration.ExeConfigurationFileMap,System.Configuration.ConfigurationUserLevel,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMappedExeConfiguration (fileMap As ExeConfigurationFileMap, userLevel As ConfigurationUserLevel, preLoad As Boolean) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMappedExeConfiguration(System::Configuration::ExeConfigurationFileMap ^ fileMap, System::Configuration::ConfigurationUserLevel userLevel, bool preLoad);" />
      <MemberSignature Language="F#" Value="static member OpenMappedExeConfiguration : System.Configuration.ExeConfigurationFileMap * System.Configuration.ConfigurationUserLevel * bool -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMappedExeConfiguration (fileMap, userLevel, preLoad)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileMap" Type="System.Configuration.ExeConfigurationFileMap" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="userLevel" Type="System.Configuration.ConfigurationUserLevel" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preLoad" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="fileMap">Ein <see cref="T:System.Configuration.ExeConfigurationFileMap" />-Objekt, das auf die Konfigurationsdatei verweist, die statt der Standard-Anwendungskonfigurationsdatei verwendet werden sollte.</param>
        <param name="userLevel">Das <see cref="T:System.Configuration.ConfigurationUserLevel" />-Objekt, für das Sie die Konfiguration öffnen.</param>
        <param name="preLoad"><see langword="true" />, um alle Abschnittsgruppen und Abschnitte vorab zu laden, andernfalls <see langword="false" />.</param>
        <summary>Öffnet die angegebene Clientkonfigurationsdatei als <see cref="T:System.Configuration.Configuration" />-Objekt mithilfe der angegebenen Dateizuordnung, Benutzerebene und Vorladeoption.</summary>
        <returns>Konfigurationsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Configuration.ConfigurationUserLevel>-Objekt bestimmt den Speicherort der Konfigurationsdatei, die geöffnet wird. Gibt an, ob die Datei keine Benutzerebene hat (die Konfigurationsdatei befindet sich im selben Verzeichnis wie die Anwendung) oder über eine benutzerspezifische Ebene (die Konfigurationsdatei befindet sich in einem von `userLevel`festgelegten Anwendungs Einstellungs Pfad).  
  
> [!NOTE]
>  Um das <xref:System.Configuration.Configuration> Objekt für eine Ressource abzurufen, muss der Code über Leseberechtigungen für alle Konfigurationsdateien verfügen, von denen er Einstellungen erbt. Um eine Konfigurationsdatei zu aktualisieren, muss der Code zusätzlich über Schreibberechtigungen für die Konfigurationsdatei und das Verzeichnis verfügen, in dem Sie vorhanden ist.  
  
 Ein Codebeispiel finden Sie in der <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%2A> Überladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Eine Konfigurationsdatei konnte nicht geladen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenMappedMachineConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMappedMachineConfiguration (System.Configuration.ConfigurationFileMap fileMap);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMappedMachineConfiguration(class System.Configuration.ConfigurationFileMap fileMap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMappedMachineConfiguration(System.Configuration.ConfigurationFileMap)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMappedMachineConfiguration (fileMap As ConfigurationFileMap) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMappedMachineConfiguration(System::Configuration::ConfigurationFileMap ^ fileMap);" />
      <MemberSignature Language="F#" Value="static member OpenMappedMachineConfiguration : System.Configuration.ConfigurationFileMap -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMappedMachineConfiguration fileMap" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileMap" Type="System.Configuration.ConfigurationFileMap" />
      </Parameters>
      <Docs>
        <param name="fileMap">Ein <see cref="T:System.Configuration.ExeConfigurationFileMap" />-Objekt, das auf die Konfigurationsdatei verweist, die statt der Standard-Anwendungskonfigurationsdatei verwendet werden sollte.</param>
        <summary>Öffnet die Computerkonfigurationsdatei als <see cref="T:System.Configuration.Configuration" />-Objekt, das die angegebene Dateizuordnung verwendet.</summary>
        <returns>Ein <see cref="T:System.Configuration.Configuration" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Computer Konfigurationseinstellungen gelten für den gesamten Computer und alle Anwendungen, die sich darauf befinden, es sei denn, Sie wurden für die lokale Anwendung überschrieben. Die Computer Konfigurationseinstellungen werden in der Datei Machine. config der aktuellen Version des .NET Framework gelesen. Die Datei Machine. config befindet sich im folgenden Unterverzeichnis:  
  
 *% windir%* \Microsoft.NET\Framework\\*Version*\Config  
  
> [!NOTE]
>  Um das <xref:System.Configuration.Configuration> Objekt für eine Ressource abzurufen, muss der Code über Leseberechtigungen für alle Konfigurationsdateien verfügen, von denen er Einstellungen erbt. Um eine Konfigurationsdatei zu aktualisieren, muss der Code zusätzlich über Schreibberechtigungen für die Konfigurationsdatei und das Verzeichnis verfügen, in dem Sie vorhanden ist. Es ist nicht möglich, auf die Datei "Machine. config" für andere Versionen der .NET Framework zuzugreifen, die auf dem Computer installiert sein könnten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie die <xref:System.Configuration.ConfigurationManager.OpenMappedMachineConfiguration%2A>-Methode verwenden, um alle Abschnitte in der Konfigurationsdatei abzurufen.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#4)]
 [!code-vb[System.Configuration.ConfigurationManager#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Eine Konfigurationsdatei konnte nicht geladen werden.</exception>
        <altmember cref="T:System.Configuration.Configuration" />
        <altmember cref="T:System.Configuration.ConfigurationFileMap" />
      </Docs>
    </Member>
    <Member MemberName="RefreshSection">
      <MemberSignature Language="C#" Value="public static void RefreshSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RefreshSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.RefreshSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RefreshSection (sectionName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RefreshSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="static member RefreshSection : string -&gt; unit" Usage="System.Configuration.ConfigurationManager.RefreshSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Der Konfigurationsabschnittsname oder der Konfigurationspfad und der Abschnittsname des zu aktualisierenden Abschnitts.</param>
        <summary>Aktualisiert den benannten Abschnitt. Dadurch wird er beim nächsten Abrufen erneut vom Datenträger gelesen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode macht den Cache für den angegebenen Konfigurations Abschnitt ungültig, ohne dass sich dies auf andere Abschnitte auswirkt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie die <xref:System.Configuration.ConfigurationManager.RefreshSection%2A>-Methode verwenden, um den Konfigurations Abschnitt für die Anwendungseinstellungen zu aktualisieren.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#7)]
 [!code-vb[System.Configuration.ConfigurationManager#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
