<Type Name="ConfigurationSection" FullName="System.Configuration.ConfigurationSection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d3456e8d3de961d29e0df884e62440e6858a4efd" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51884625" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ConfigurationSection : System.Configuration.ConfigurationElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ConfigurationSection extends System.Configuration.ConfigurationElement" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ConfigurationSection" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ConfigurationSection&#xA;Inherits ConfigurationElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ConfigurationSection abstract : System::Configuration::ConfigurationElement" />
  <TypeSignature Language="F#" Value="type ConfigurationSection = class&#xA;    inherit ConfigurationElement" />
  <AssemblyInfo>
    <AssemblyName>System.Configuration</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.ConfigurationElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Abschnitt innerhalb einer Konfigurationsdatei dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie verwenden die <xref:System.Configuration.ConfigurationSection> Klasse, um einen benutzerdefinierten Abschnitt-Typ zu implementieren. Erweitern Sie die <xref:System.Configuration.ConfigurationSection> Klasse, um die benutzerdefinierte Behandlung und den programmgesteuerten Zugriff auf die benutzerdefinierten Konfigurationsabschnitte bereitzustellen. Informationen dazu, wie benutzerdefinierten Konfigurationsabschnitte zu verwenden, finden Sie unter [Vorgehensweise: Erstellen benutzerdefinierter Configuration Sections Using ConfigurationSection](https://msdn.microsoft.com/library/febaca98-c727-4017-95ed-82e2fb6cf234).  
  
 Ein Abschnitt registriert den Typ der Verarbeitung mit einem Eintrag in der `configSections` Element. Ein Beispiel finden Sie unter den Auszug aus der Konfigurationsdatei im Abschnitt "Beispiel".  
  
> [!NOTE]
>  In früheren Versionen von .NET Framework-Konfigurationsabschnittshandler wurden verwendet, um Änderungen an Konfigurationseinstellungen vornehmen programmgesteuert. Jetzt werden alle standardmäßigen Konfigurationsabschnitte von Klassen, die erweitern dargestellt die <xref:System.Configuration.ConfigurationSection> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen benutzerdefinierten Abschnitt programmgesteuert zu implementieren.  
  
 Ein vollständiges Beispiel, das zeigt, wie implementieren und verwenden Sie einen benutzerdefinierten Abschnitt, der mithilfe von Modells des attributierten implementiert, finden Sie unter <xref:System.Configuration.ConfigurationElement>.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#1)]
 [!code-vb[System.Configuration.ConfigurationSection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#1)]  
  
 Im folgende Beispiel ist ein Auszug aus der Konfigurationsdatei, wie sie mit dem vorherigen Beispiel angewendet wird.  
  
 ```xml
<?xml version="1.0" encoding="utf-8"?>
  <configuration>  
    <configSections>
      <section name="CustomSection" type="Samples.AspNet. CustomSection, CustomConfigurationSection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" allowDefinition="Everywhere" allowExeDefinition="MachineToApplication" restartOnExternalChanges="true" />
    </configSections>  

    <CustomSection fileName="default.txt" maxUsers="1000" maxIdleTime="00:15:00" /> 
 
  </configuration>
```  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Sie können programmgesteuerte oder deklarativen (attributierten) Codierungsmodell verwenden, zum Erstellen von benutzerdefinierten Konfigurationsabschnitte: 
– Programmgesteuertes Modell. Dieses Modell ist es erforderlich, dass für jedes Abschnittsattribut im Sie eine Eigenschaft zum Abrufen erstellen oder legen Sie dessen Wert aus, und fügen sie Sie der internen Eigenschaftensammlung des zugrunde liegenden hinzu <see cref="T:System.Configuration.ConfigurationElement" /> Basisklasse.  
  
-Deklaratives Modell. Diesem einfachere Modell, das Modell das attributierte so genannte können Sie ein Abschnittsattribut im zu definieren, indem Sie mithilfe einer Eigenschaft, und es mit Attributen versehen. Diese Attribute weisen das Konfigurationssystem von ASP.NET über die Eigenschaftstypen und deren Standardwerte fest. Mit diesen Informationen erhalten mithilfe von Reflektion ASP.NET-Konfigurationssystem erstellt den Abschnitt Property-Objekte und führt die erforderliche Initialisierung.  
  
Die <see cref="T:System.Configuration.Configuration" /> Klasse ermöglicht den programmgesteuerten Zugriff für die Bearbeitung von Konfigurationsdateien. Sie können diese Dateien zum Lesen oder Schreiben wie folgt zugreifen: 
– Lesen. Verwenden Sie <see cref="M:System.Configuration.Configuration.GetSection(System.String)" /> oder <see cref="M:System.Configuration.Configuration.GetSectionGroup(System.String)" /> zum Lesen von Konfigurationsinformationen. Beachten Sie, dass der Benutzer oder Prozess, der liest die folgenden Berechtigungen: 
-Read-Berechtigung für die Konfigurationsdatei unter der aktuellen Ebene der Hierarchie.  
  
-Leseberechtigungen Sie für das übergeordnete Element von Konfigurationsdateien.  
  
Wenn Ihre Anwendung schreibgeschützten Zugriff auf die eigene Konfiguration erfordert, sollten Sie mithilfe von der <see cref="Overload:System.Web.Configuration.WebConfigurationManager.GetSection" /> überladene Methoden im Fall von Webanwendungen oder die <see cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" /> Methode im Fall von Client-Anwendungen.  
  
Diese Methoden ermöglichen den Zugriff auf die zwischengespeicherte Konfigurationswerte für die aktuelle Anwendung, die über eine bessere Leistung als verfügt die <see cref="T:System.Configuration.Configuration" /> Klasse.  
  
 <block subset="none" type="note"><para>  
 Wenn Sie eine statische <see langword="GetSection" /> Methode, eine <paramref name="path" /> -Parameter der <paramref name="path" /> Parameter muss mit der Anwendung, in dem der Code ausgeführt wird; andernfalls wird der Parameter ignoriert, und die Konfigurationsinformationen für die derzeit die Ausführung finden Sie unter Anwendung wird zurückgegeben.  
  
</para></block>  
  
– Schreiben. Verwenden Sie eine der der <see cref="Overload:System.Configuration.Configuration.Save" /> Methoden zum Schreiben von Konfigurationsinformationen. Beachten Sie, dass der Benutzer oder Prozess, der schreibt die folgenden Berechtigungen: 
-Schreiben Sie-Berechtigung für die Konfigurationsdatei und das Verzeichnis unter der aktuellen Ebene der Hierarchie.  
  
-Leseberechtigungen Sie für alle Konfigurationsdateien.</para>
    </block>
    <altmember cref="T:System.Configuration.Configuration" />
    <altmember cref="T:System.Configuration.SectionInformation" />
    <altmember cref="T:System.Configuration.ConfigurationElement" />
    <related type="Article" href="https://msdn.microsoft.com/library/5696e8b2-d489-4220-aef2-f2e0ca9099b4">ASP.NET-API – Übersicht</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ConfigurationSection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ConfigurationSection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Configuration.ConfigurationSection" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Configuration.ConfigurationSection.%23ctor%2A> Konstruktors müssen Sie zunächst einen benutzerdefinierten Abschnitt-Typ zu definieren. Ein Beispiel finden Sie die <xref:System.Configuration.ConfigurationSection> Übersicht über die Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung des <xref:System.Configuration.ConfigurationSection.%23ctor%2A>-Konstruktors veranschaulicht. In diesem Beispiel wird davon ausgegangen, dass Sie eine benutzerdefinierten Abschnitt-Klasse, die mit dem Namen erstellt haben `CustomSection`. Ein Beispiel einer solchen Klasse finden Sie unter den <xref:System.Configuration.ConfigurationSection> Übersicht über die Klasse.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#2)]
 [!code-vb[System.Configuration.ConfigurationSection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeserializeSection">
      <MemberSignature Language="C#" Value="protected internal virtual void DeserializeSection (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void DeserializeSection(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.DeserializeSection(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub DeserializeSection (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void DeserializeSection(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member DeserializeSection : System.Xml.XmlReader -&gt; unit&#xA;override this.DeserializeSection : System.Xml.XmlReader -&gt; unit" Usage="configurationSection.DeserializeSection reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Das <see cref="T:System.Xml.XmlReader" />-Objekt, das aus der Konfigurationsdatei liest.</param>
        <summary>Liest XML aus der Konfigurationsdatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Deserialisierung bezeichnet das Lesen von XML-Daten aus einer Konfigurationsdatei, die Transformation in Echtzeit-Daten und deren Speicherung in einem Objekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <paramref name="reader" /> konnte keine Elemente in der Konfigurationsdatei finden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeObject">
      <MemberSignature Language="C#" Value="protected internal virtual object GetRuntimeObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object GetRuntimeObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.GetRuntimeObject" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetRuntimeObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ GetRuntimeObject();" />
      <MemberSignature Language="F#" Value="abstract member GetRuntimeObject : unit -&gt; obj&#xA;override this.GetRuntimeObject : unit -&gt; obj" Usage="configurationSection.GetRuntimeObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein benutzerdefiniertes Objekt zurück, wenn es in einer abgeleiteten Klasse überschrieben wird.</summary>
        <returns>Das Objekt, das den Abschnitt darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Configuration.Configuration.GetSection%2A> Methode zur Laufzeit aufgerufen wird, wird das Konfigurationssystem erstellt zunächst eine geeignete Instanz von der <xref:System.Configuration.ConfigurationSection> Klasse, und klicken Sie dann gibt das Objekt, das er erhält, aus der <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A> Methode.  
  
 In der Standardeinstellung <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A> einfach gibt das Objekt, das die <xref:System.Configuration.ConfigurationSection> aus, die sie aufgerufen wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A>-Methode gezeigt.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#4)]
 [!code-vb[System.Configuration.ConfigurationSection#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Sie können außer Kraft setzen der <see cref="M:System.Configuration.ConfigurationSection.GetRuntimeObject" /> Methode, um zur Laufzeit einen benutzerdefinierten Typ zurückzugeben.  
  
Z. B. zum Einschränken der Common Language Runtime-Änderungen, die Einstellungen in der <see cref="T:System.Configuration.ConfigurationSection" /> -Klasse, die Sie überschreiben können <see cref="M:System.Configuration.ConfigurationSection.GetRuntimeObject" /> und zurückgeben ein benutzerdefiniertes Typs, die Einschränkungen, die auf die Einstellungen geändert werden können, erzwingt, sofern vorhanden.  
  
Wenn das Laufzeitobjekt ausschließlich intern verwendet wird, kann das zurückgegebene Objekt außerhalb der Assembly verwendet werden, der ihn definiert. Eine Möglichkeit zum Erstellen eines Objekts, die von abgeleitet <see cref="T:System.Configuration.ConfigurationSection" /> und kann nur von Code in der Assembly zur Laufzeit zugegriffen werden Zeit zum Erstellen eines internen Common Language Runtime-Objekts mit einer Methode, die zurückgegeben wird Ihre <see cref="T:System.Configuration.ConfigurationSection" /> Implementierung.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsModified">
      <MemberSignature Language="C#" Value="protected internal override bool IsModified ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool IsModified() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.IsModified" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function IsModified () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool IsModified();" />
      <MemberSignature Language="F#" Value="override this.IsModified : unit -&gt; bool" Usage="configurationSection.IsModified " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob dieses Konfigurationselement geändert wurde, seit es zuletzt gespeichert oder geladen wurde, wenn es in einer abgeleiteten Klasse implementiert wurde.</summary>
        <returns>
          <see langword="true" />, wenn das Element geändert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetModified">
      <MemberSignature Language="C#" Value="protected internal override void ResetModified ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void ResetModified() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ResetModified" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub ResetModified ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void ResetModified();" />
      <MemberSignature Language="F#" Value="override this.ResetModified : unit -&gt; unit" Usage="configurationSection.ResetModified " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt bei Implementierung in einer abgeleiteten Klasse den Wert der <see cref="M:System.Configuration.ConfigurationElement.IsModified" />-Methode auf <see langword="false" /> zurück.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionInformation">
      <MemberSignature Language="C#" Value="public System.Configuration.SectionInformation SectionInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SectionInformation SectionInformation" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationSection.SectionInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SectionInformation As SectionInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Configuration::SectionInformation ^ SectionInformation { System::Configuration::SectionInformation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SectionInformation : System.Configuration.SectionInformation" Usage="System.Configuration.ConfigurationSection.SectionInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SectionInformation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Configuration.SectionInformation" />-Objekt ab, das die nicht anpassbaren Informationen und Funktionen des <see cref="T:System.Configuration.ConfigurationSection" />-Objekts enthält.</summary>
        <value>
          <see cref="T:System.Configuration.SectionInformation" /> mit den nicht anpassbaren Informationen und Funktionen des <see cref="T:System.Configuration.ConfigurationSection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Configuration.ConfigurationSection.SectionInformation%2A>-Eigenschaft veranschaulicht.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#3)]
 [!code-vb[System.Configuration.ConfigurationSection#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Configuration.SectionInformation" />
      </Docs>
    </Member>
    <Member MemberName="SerializeSection">
      <MemberSignature Language="C#" Value="protected internal virtual string SerializeSection (System.Configuration.ConfigurationElement parentElement, string name, System.Configuration.ConfigurationSaveMode saveMode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string SerializeSection(class System.Configuration.ConfigurationElement parentElement, string name, valuetype System.Configuration.ConfigurationSaveMode saveMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.SerializeSection(System.Configuration.ConfigurationElement,System.String,System.Configuration.ConfigurationSaveMode)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SerializeSection (parentElement As ConfigurationElement, name As String, saveMode As ConfigurationSaveMode) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ SerializeSection(System::Configuration::ConfigurationElement ^ parentElement, System::String ^ name, System::Configuration::ConfigurationSaveMode saveMode);" />
      <MemberSignature Language="F#" Value="abstract member SerializeSection : System.Configuration.ConfigurationElement * string * System.Configuration.ConfigurationSaveMode -&gt; string&#xA;override this.SerializeSection : System.Configuration.ConfigurationElement * string * System.Configuration.ConfigurationSaveMode -&gt; string" Usage="configurationSection.SerializeSection (parentElement, name, saveMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentElement" Type="System.Configuration.ConfigurationElement" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="saveMode" Type="System.Configuration.ConfigurationSaveMode" />
      </Parameters>
      <Docs>
        <param name="parentElement">Die <see cref="T:System.Configuration.ConfigurationElement" />-Instanz, die als übergeordnetes Element für die Durchführung der Aufhebung der Zusammenführung verwendet werden soll.</param>
        <param name="name">Der Name des zu erstellenden Abschnitts.</param>
        <param name="saveMode">Die <see cref="T:System.Configuration.ConfigurationSaveMode" />-Instanz, die zum Schreiben in eine Zeichenfolge verwendet werden soll.</param>
        <summary>Erstellt eine XML-Zeichenfolge mit einer nicht zusammengeführten Ansicht des <see cref="T:System.Configuration.ConfigurationSection" />-Objekts als einzelnem Abschnitt, der in einer Datei geschrieben werden soll.</summary>
        <returns>Eine XML-Zeichenfolge mit einer nicht zusammengeführten Ansicht des <see cref="T:System.Configuration.ConfigurationSection" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serialisierung bezieht sich auf die Transformation von Echtzeitdaten und in ein Objekt, das XML-Format und deren Speicherung in einer Konfigurationsdatei enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeElementInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeElementInTargetVersion (System.Configuration.ConfigurationElement element, string elementName, System.Runtime.Versioning.FrameworkName targetFramework);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeElementInTargetVersion(class System.Configuration.ConfigurationElement element, string elementName, class System.Runtime.Versioning.FrameworkName targetFramework) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializeElementInTargetVersion(System.Configuration.ConfigurationElement,System.String,System.Runtime.Versioning.FrameworkName)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeElementInTargetVersion (element As ConfigurationElement, elementName As String, targetFramework As FrameworkName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeElementInTargetVersion(System::Configuration::ConfigurationElement ^ element, System::String ^ elementName, System::Runtime::Versioning::FrameworkName ^ targetFramework);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeElementInTargetVersion : System.Configuration.ConfigurationElement * string * System.Runtime.Versioning.FrameworkName -&gt; bool&#xA;override this.ShouldSerializeElementInTargetVersion : System.Configuration.ConfigurationElement * string * System.Runtime.Versioning.FrameworkName -&gt; bool" Usage="configurationSection.ShouldSerializeElementInTargetVersion (element, elementName, targetFramework)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Configuration.ConfigurationElement" />
        <Parameter Name="elementName" Type="System.String" />
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Configuration.ConfigurationElement" />-Objekt, das ein Kandidat für die Serialisierung ist.</param>
        <param name="elementName">Der Name des <see cref="T:System.Configuration.ConfigurationElement" />-Objekts in XML.</param>
        <param name="targetFramework">Die Zielversion von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <summary>Gibt an, ob das angegebene Element serialisiert werden soll, wenn die Konfigurationsobjekthierarchie für die angegebene Zielversion von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] serialisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="element" /> serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Konfigurationsabschnitt, der für erstellt wird die [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] und höhere Versionen müssen explizit überschreiben Sie diese Methode zurückgeben `true`, jedoch nur, wenn das angegebene Element für die angegebene Version der gültig ist die [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Vorhandene Konfigurationsabschnitte, die für frühere Versionen erstellt wurden die [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] müssen nicht geändert werden.  
  
 Der Basistyp enthält eine Standardimplementierung dieser Methode, die immer zurückgibt `true`. Wenn Sie einen Konfigurationsabschnitt implementieren aus, und Sie diese Methode nicht überschreiben, werden standardmäßig alle Konfigurationselemente, die im Abschnitt "Konfiguration" enthalten sind für alle Framework-Versionen serialisiert werden.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76">Festlegen von .NET Framework-Zielversion für Webprojekte</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializePropertyInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializePropertyInTargetVersion (System.Configuration.ConfigurationProperty property, string propertyName, System.Runtime.Versioning.FrameworkName targetFramework, System.Configuration.ConfigurationElement parentConfigurationElement);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializePropertyInTargetVersion(class System.Configuration.ConfigurationProperty property, string propertyName, class System.Runtime.Versioning.FrameworkName targetFramework, class System.Configuration.ConfigurationElement parentConfigurationElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializePropertyInTargetVersion(System.Configuration.ConfigurationProperty,System.String,System.Runtime.Versioning.FrameworkName,System.Configuration.ConfigurationElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializePropertyInTargetVersion (property As ConfigurationProperty, propertyName As String, targetFramework As FrameworkName, parentConfigurationElement As ConfigurationElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializePropertyInTargetVersion(System::Configuration::ConfigurationProperty ^ property, System::String ^ propertyName, System::Runtime::Versioning::FrameworkName ^ targetFramework, System::Configuration::ConfigurationElement ^ parentConfigurationElement);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializePropertyInTargetVersion : System.Configuration.ConfigurationProperty * string * System.Runtime.Versioning.FrameworkName * System.Configuration.ConfigurationElement -&gt; bool&#xA;override this.ShouldSerializePropertyInTargetVersion : System.Configuration.ConfigurationProperty * string * System.Runtime.Versioning.FrameworkName * System.Configuration.ConfigurationElement -&gt; bool" Usage="configurationSection.ShouldSerializePropertyInTargetVersion (property, propertyName, targetFramework, parentConfigurationElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.Configuration.ConfigurationProperty" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" />
        <Parameter Name="parentConfigurationElement" Type="System.Configuration.ConfigurationElement" />
      </Parameters>
      <Docs>
        <param name="property">Das <see cref="T:System.Configuration.ConfigurationProperty" />-Objekt, das ein Kandidat für die Serialisierung ist.</param>
        <param name="propertyName">Der Name des <see cref="T:System.Configuration.ConfigurationProperty" />-Objekts in XML.</param>
        <param name="targetFramework">Die Zielversion von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <param name="parentConfigurationElement">Das übergeordnete Element der Eigenschaft.</param>
        <summary>Gibt an, ob die angegebene Eigenschaft serialisiert werden soll, wenn die Konfigurationsobjekthierarchie für die angegebene Zielversion von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] serialisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="property" /> serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Konfigurationsabschnitt, der für erstellt wird die [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] und höhere Versionen müssen explizit überschreiben Sie diese Methode zurückgeben `true`, jedoch nur, wenn die angegebene Eigenschaft für die angegebene Version der gültig ist die [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Vorhandene Konfigurationsabschnitte, die für frühere Versionen erstellt wurden die [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] müssen nicht geändert werden.  
  
 Der Basistyp enthält eine Standardimplementierung dieser Methode, die immer zurückgibt `true`. Wenn Sie einen Konfigurationsabschnitt implementieren aus, und Sie diese Methode nicht überschreiben, werden standardmäßig alle Konfigurationseigenschaften, die im Abschnitt "Konfiguration" enthalten sind für alle Framework-Versionen serialisiert werden.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76">Festlegen von .NET Framework-Zielversion für Webprojekte</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSectionInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeSectionInTargetVersion (System.Runtime.Versioning.FrameworkName targetFramework);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeSectionInTargetVersion(class System.Runtime.Versioning.FrameworkName targetFramework) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializeSectionInTargetVersion(System.Runtime.Versioning.FrameworkName)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeSectionInTargetVersion (targetFramework As FrameworkName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeSectionInTargetVersion(System::Runtime::Versioning::FrameworkName ^ targetFramework);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeSectionInTargetVersion : System.Runtime.Versioning.FrameworkName -&gt; bool&#xA;override this.ShouldSerializeSectionInTargetVersion : System.Runtime.Versioning.FrameworkName -&gt; bool" Usage="configurationSection.ShouldSerializeSectionInTargetVersion targetFramework" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" />
      </Parameters>
      <Docs>
        <param name="targetFramework">Die Zielversion von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <summary>Gibt an, ob die aktuelle <see cref="T:System.Configuration.ConfigurationSection" />-Instanz serialisiert werden soll, wenn die Konfigurationsobjekthierarchie für die angegebene Zielversion von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] serialisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn der aktuelle Abschnitt serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Konfigurationsabschnitt, der für erstellt wird die [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] und höhere Versionen müssen explizit überschreiben Sie diese Methode zurückgeben `true`, jedoch nur, wenn Sie der Konfigurationsabschnitt für die angegebene Version der gültig ist die [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Vorhandene Konfigurationsabschnitte, die für frühere Versionen erstellt wurden die [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] müssen nicht geändert werden.  
  
 Der Basistyp enthält eine Standardimplementierung dieser Methode, die immer zurückgibt `true`. Wenn Sie einen Konfigurationsabschnitt implementieren aus, und Sie diese Methode nicht überschreiben, wird standardmäßig der Konfigurationsabschnitt für alle Framework-Versionen serialisiert werden.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76">Festlegen von .NET Framework-Zielversion für Webprojekte</related>
      </Docs>
    </Member>
  </Members>
</Type>