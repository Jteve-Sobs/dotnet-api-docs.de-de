<Type Name="ConfigurationSection" FullName="System.Configuration.ConfigurationSection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5b68952bbc0f63d934edd49d4d2f1dad57c1f566" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70684622" /></Metadata><TypeSignature Language="C#" Value="public abstract class ConfigurationSection : System.Configuration.ConfigurationElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ConfigurationSection extends System.Configuration.ConfigurationElement" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ConfigurationSection" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ConfigurationSection&#xA;Inherits ConfigurationElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ConfigurationSection abstract : System::Configuration::ConfigurationElement" />
  <TypeSignature Language="F#" Value="type ConfigurationSection = class&#xA;    inherit ConfigurationElement" />
  <AssemblyInfo>
    <AssemblyName>System.Configuration</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.ConfigurationElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Abschnitt innerhalb einer Konfigurationsdatei dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Configuration.ConfigurationSection> -Klasse, um einen benutzerdefinierten Abschnitts Typ zu implementieren. Erweitern Sie <xref:System.Configuration.ConfigurationSection> die-Klasse, um benutzerdefinierte Handhabung und programmgesteuerten Zugriff auf benutzerdefinierte Konfigurations Abschnitte bereitzustellen. Weitere Informationen zum Verwenden von benutzerdefinierten Konfigurations Abschnitten finden [Sie unter Gewusst wie: Erstellen von benutzerdefinierten Konfigurations Abschnitten mithilfe von ConfigurationSection](https://msdn.microsoft.com/library/febaca98-c727-4017-95ed-82e2fb6cf234).  
  
 Ein-Abschnitt registriert seinen Behandlungstyp mit einem Eintrag `configSections` im-Element. Ein Beispiel finden Sie im Beispiel für eine Konfigurationsdatei im Beispiel Abschnitt.  
  
> [!NOTE]
>  In früheren Versionen der .NET Framework wurden Konfigurations Abschnitts Handler verwendet, um Programm gesteuert Änderungen an Konfigurationseinstellungen vorzunehmen. Nun werden alle Standard Konfigurations Abschnitte durch Klassen dargestellt, die die <xref:System.Configuration.ConfigurationSection> -Klasse erweitern.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein benutzerdefinierter Abschnitt Programm gesteuert implementiert wird.  
  
 Ein umfassendes Beispiel, das zeigt, wie ein benutzerdefinierter Abschnitt implementiert und verwendet wird, der mit dem attributierten Modell implementiert wurde, finden <xref:System.Configuration.ConfigurationElement>Sie unter.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#1)]
 [!code-vb[System.Configuration.ConfigurationSection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#1)]  
  
 Das folgende Beispiel ist ein Auszug aus der Konfigurationsdatei, die für das vorherige Beispiel gilt.  
  
 ```xml
<?xml version="1.0" encoding="utf-8"?>
  <configuration>  
    <configSections>
      <section name="CustomSection" type="Samples.AspNet. CustomSection, CustomConfigurationSection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" allowDefinition="Everywhere" allowExeDefinition="MachineToApplication" restartOnExternalChanges="true" />
    </configSections>  

    <CustomSection fileName="default.txt" maxUsers="1000" maxIdleTime="00:15:00" /> 
 
  </configuration>
```  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Sie können ein Programm gesteuertes oder deklaratives (attributiertes) Codierungs Modell verwenden, um benutzerdefinierte Konfigurations Abschnitte zu erstellen: 
-Programm gesteuertes Modell. Dieses Modell erfordert, dass Sie für jedes Abschnitts Attribut eine Eigenschaft erstellen, um den Wert zu erhalten oder festzulegen, und ihn dem internen Eigenschaften Behälter <see cref="T:System.Configuration.ConfigurationElement" /> der zugrunde liegenden Basisklasse hinzufügen.  
  
-Deklaratives Modell. Mit diesem einfacheren Modell, das auch als attributiertes Modell bezeichnet wird, können Sie mithilfe einer Eigenschaft ein Abschnitts Attribut definieren und es mit Attributen versehen. Diese Attribute weisen das ASP.NET-Konfigurationssystem über die Eigenschafts Typen und deren Standardwerte hin. Mit diesen Informationen, die durch Reflektion abgerufen werden, erstellt das ASP.NET-Konfigurationssystem die Abschnitts Eigenschafts Objekte und führt die erforderliche Initialisierung aus.  
  
Die <see cref="T:System.Configuration.Configuration" /> -Klasse ermöglicht den programmgesteuerten Zugriff zum Bearbeiten von Konfigurationsdateien. Sie können wie folgt auf diese Dateien zum Lesen oder Schreiben zugreifen: 
Lektüre. Sie verwenden <see cref="M:System.Configuration.Configuration.GetSection(System.String)" /> oder <see cref="M:System.Configuration.Configuration.GetSectionGroup(System.String)" /> , um Konfigurationsinformationen zu lesen. Beachten Sie, dass der Benutzer oder der Prozess, der liest, über die folgenden Berechtigungen verfügen muss: 
-Leseberechtigung für die Konfigurationsdatei auf der aktuellen Konfigurations Hierarchieebene.  
  
: Leseberechtigungen für alle übergeordneten Konfigurationsdateien.  
  
Wenn Ihre Anwendung schreibgeschützten Zugriff auf Ihre eigene Konfiguration benötigt, empfiehlt es sich, die <see cref="Overload:System.Web.Configuration.WebConfigurationManager.GetSection" /> überladenen Methoden im Fall von Webanwendungen oder die <see cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" /> -Methode im Fall von Client Anwendungen zu verwenden.  
  
Diese Methoden ermöglichen den Zugriff auf die zwischengespeicherten Konfigurationswerte für die aktuelle Anwendung, die eine bessere Leistung <see cref="T:System.Configuration.Configuration" /> als die-Klasse aufweist.  
  
 <block subset="none" type="note"><para>  
 Wenn Sie eine statische <see langword="GetSection" /> Methode verwenden, die einen <paramref name="path" /> -Parameter annimmt, muss der <paramref name="path" /> -Parameter auf die Anwendung verweisen, in der der Code ausgeführt wird. andernfalls wird der-Parameter ignoriert, und es werden Konfigurationsinformationen für den derzeit laufenden die Anwendung wird zurückgegeben.  
  
</para></block>  
  
Lassungs. Verwenden Sie eine der <see cref="Overload:System.Configuration.Configuration.Save" /> -Methoden, um Konfigurationsinformationen zu schreiben. Beachten Sie, dass der Benutzer oder der Prozess, der schreibt, über die folgenden Berechtigungen verfügen muss: 
-Schreib Berechtigung für die Konfigurationsdatei und das Verzeichnis auf der aktuellen Konfigurations Hierarchieebene.  
  
: Leseberechtigungen für alle Konfigurationsdateien.</para></block>
    <altmember cref="T:System.Configuration.Configuration" />
    <altmember cref="T:System.Configuration.SectionInformation" />
    <altmember cref="T:System.Configuration.ConfigurationElement" />
    <related type="Article" href="https://msdn.microsoft.com/library/5696e8b2-d489-4220-aef2-f2e0ca9099b4">Übersicht über die ASP.net Configuration-API</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ConfigurationSection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ConfigurationSection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Configuration.ConfigurationSection" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den <xref:System.Configuration.ConfigurationSection.%23ctor%2A> -Konstruktor verwenden möchten, müssen Sie zuerst einen benutzerdefinierten Abschnitts Typen definieren. Ein Beispiel finden Sie in <xref:System.Configuration.ConfigurationSection> der Übersicht über die-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung des <xref:System.Configuration.ConfigurationSection.%23ctor%2A>-Konstruktors veranschaulicht. In diesem Beispiel wird davon ausgegangen, dass Sie eine benutzerdefinierte `CustomSection`Abschnitts Klasse namens erstellt haben. Ein Beispiel für eine solche Klasse finden Sie in der <xref:System.Configuration.ConfigurationSection> Übersicht über die-Klasse.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#2)]
 [!code-vb[System.Configuration.ConfigurationSection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeserializeSection">
      <MemberSignature Language="C#" Value="protected internal virtual void DeserializeSection (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void DeserializeSection(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.DeserializeSection(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub DeserializeSection (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void DeserializeSection(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member DeserializeSection : System.Xml.XmlReader -&gt; unit&#xA;override this.DeserializeSection : System.Xml.XmlReader -&gt; unit" Usage="configurationSection.DeserializeSection reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Das <see cref="T:System.Xml.XmlReader" />-Objekt, das aus der Konfigurationsdatei liest.</param>
        <summary>Liest XML aus der Konfigurationsdatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Deserialisierung bezieht sich auf das Lesen von XML-Daten aus einer Konfigurationsdatei, deren Transformation in Echtzeitdaten und deren Speicherung in einem Objekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><paramref name="reader" /> konnte keine Elemente in der Konfigurationsdatei finden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeObject">
      <MemberSignature Language="C#" Value="protected internal virtual object GetRuntimeObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object GetRuntimeObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.GetRuntimeObject" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetRuntimeObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ GetRuntimeObject();" />
      <MemberSignature Language="F#" Value="abstract member GetRuntimeObject : unit -&gt; obj&#xA;override this.GetRuntimeObject : unit -&gt; obj" Usage="configurationSection.GetRuntimeObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein benutzerdefiniertes Objekt zurück, wenn es in einer abgeleiteten Klasse überschrieben wird.</summary>
        <returns>Das Objekt, das den Abschnitt darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Configuration.Configuration.GetSection%2A> -Methode zur Laufzeit aufgerufen wird, erstellt das Konfigurationssystem zuerst eine entsprechende Instanz <xref:System.Configuration.ConfigurationSection> der-Klasse und gibt dann das Objekt zurück, das aus der <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A> -Methode abgerufen wird.  
  
 Standardmäßig <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A> gibt einfach das-Objekt zurück, das <xref:System.Configuration.ConfigurationSection> den darstellt, von dem er aufgerufen wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A>-Methode gezeigt.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#4)]
 [!code-vb[System.Configuration.ConfigurationSection#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Sie können die <see cref="M:System.Configuration.ConfigurationSection.GetRuntimeObject" /> -Methode überschreiben, um zur Laufzeit einen benutzerdefinierten Typ zurückzugeben.  
  
Wenn Sie z. b. die Lauf Zeitänderung der Einstellungen <see cref="T:System.Configuration.ConfigurationSection" /> in der-Klasse einschränken <see cref="M:System.Configuration.ConfigurationSection.GetRuntimeObject" /> möchten, können Sie einen benutzerdefinierten Typ überschreiben und zurückgeben, der Einschränkungen erzwingt, welche Einstellungen ggf. geändert werden können.  
  
Wenn das Laufzeitobjekt nur intern ist, kann das zurückgegebene Objekt nicht außerhalb der Assembly verwendet werden, durch die es definiert wird. Eine Möglichkeit zum Erstellen eines Objekts, das von <see cref="T:System.Configuration.ConfigurationSection" /> abgeleitet wird und auf das nur von Code in der Assembly zur Laufzeit zugegriffen werden kann, ist das Erstellen eines internen Lauf Zeit Objekts, das <see cref="T:System.Configuration.ConfigurationSection" /> über eine-Methode verfügt, die die Implementierung zurückgibt.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsModified">
      <MemberSignature Language="C#" Value="protected internal override bool IsModified ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool IsModified() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.IsModified" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function IsModified () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool IsModified();" />
      <MemberSignature Language="F#" Value="override this.IsModified : unit -&gt; bool" Usage="configurationSection.IsModified " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob dieses Konfigurationselement geändert wurde, seit es zuletzt gespeichert oder geladen wurde, wenn es in einer abgeleiteten Klasse implementiert wurde.</summary>
        <returns><see langword="true" />, wenn das Element geändert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetModified">
      <MemberSignature Language="C#" Value="protected internal override void ResetModified ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void ResetModified() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ResetModified" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub ResetModified ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void ResetModified();" />
      <MemberSignature Language="F#" Value="override this.ResetModified : unit -&gt; unit" Usage="configurationSection.ResetModified " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt bei Implementierung in einer abgeleiteten Klasse den Wert der <see cref="M:System.Configuration.ConfigurationElement.IsModified" />-Methode auf <see langword="false" /> zurück.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionInformation">
      <MemberSignature Language="C#" Value="public System.Configuration.SectionInformation SectionInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SectionInformation SectionInformation" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationSection.SectionInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SectionInformation As SectionInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Configuration::SectionInformation ^ SectionInformation { System::Configuration::SectionInformation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SectionInformation : System.Configuration.SectionInformation" Usage="System.Configuration.ConfigurationSection.SectionInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SectionInformation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Configuration.SectionInformation" />-Objekt ab, das die nicht anpassbaren Informationen und Funktionen des <see cref="T:System.Configuration.ConfigurationSection" />-Objekts enthält.</summary>
        <value><see cref="T:System.Configuration.SectionInformation" /> mit den nicht anpassbaren Informationen und Funktionen des <see cref="T:System.Configuration.ConfigurationSection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Configuration.ConfigurationSection.SectionInformation%2A>-Eigenschaft veranschaulicht.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#3)]
 [!code-vb[System.Configuration.ConfigurationSection#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Configuration.SectionInformation" />
      </Docs>
    </Member>
    <Member MemberName="SerializeSection">
      <MemberSignature Language="C#" Value="protected internal virtual string SerializeSection (System.Configuration.ConfigurationElement parentElement, string name, System.Configuration.ConfigurationSaveMode saveMode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string SerializeSection(class System.Configuration.ConfigurationElement parentElement, string name, valuetype System.Configuration.ConfigurationSaveMode saveMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.SerializeSection(System.Configuration.ConfigurationElement,System.String,System.Configuration.ConfigurationSaveMode)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SerializeSection (parentElement As ConfigurationElement, name As String, saveMode As ConfigurationSaveMode) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ SerializeSection(System::Configuration::ConfigurationElement ^ parentElement, System::String ^ name, System::Configuration::ConfigurationSaveMode saveMode);" />
      <MemberSignature Language="F#" Value="abstract member SerializeSection : System.Configuration.ConfigurationElement * string * System.Configuration.ConfigurationSaveMode -&gt; string&#xA;override this.SerializeSection : System.Configuration.ConfigurationElement * string * System.Configuration.ConfigurationSaveMode -&gt; string" Usage="configurationSection.SerializeSection (parentElement, name, saveMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentElement" Type="System.Configuration.ConfigurationElement" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="saveMode" Type="System.Configuration.ConfigurationSaveMode" />
      </Parameters>
      <Docs>
        <param name="parentElement">Die <see cref="T:System.Configuration.ConfigurationElement" />-Instanz, die als übergeordnetes Element für die Durchführung der Aufhebung der Zusammenführung verwendet werden soll.</param>
        <param name="name">Der Name des zu erstellenden Abschnitts.</param>
        <param name="saveMode">Die <see cref="T:System.Configuration.ConfigurationSaveMode" />-Instanz, die zum Schreiben in eine Zeichenfolge verwendet werden soll.</param>
        <summary>Erstellt eine XML-Zeichenfolge mit einer nicht zusammengeführten Ansicht des <see cref="T:System.Configuration.ConfigurationSection" />-Objekts als einzelnem Abschnitt, der in einer Datei geschrieben werden soll.</summary>
        <returns>Eine XML-Zeichenfolge mit einer nicht zusammengeführten Ansicht des <see cref="T:System.Configuration.ConfigurationSection" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Serialisierung bezieht sich auf die Transformation von Echtzeitdaten, die in einem Objekt enthalten sind, auf das XML-Format und den zugehörigen Speicher in einer Konfigurationsdatei.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeElementInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeElementInTargetVersion (System.Configuration.ConfigurationElement element, string elementName, System.Runtime.Versioning.FrameworkName targetFramework);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeElementInTargetVersion(class System.Configuration.ConfigurationElement element, string elementName, class System.Runtime.Versioning.FrameworkName targetFramework) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializeElementInTargetVersion(System.Configuration.ConfigurationElement,System.String,System.Runtime.Versioning.FrameworkName)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeElementInTargetVersion (element As ConfigurationElement, elementName As String, targetFramework As FrameworkName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeElementInTargetVersion(System::Configuration::ConfigurationElement ^ element, System::String ^ elementName, System::Runtime::Versioning::FrameworkName ^ targetFramework);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeElementInTargetVersion : System.Configuration.ConfigurationElement * string * System.Runtime.Versioning.FrameworkName -&gt; bool&#xA;override this.ShouldSerializeElementInTargetVersion : System.Configuration.ConfigurationElement * string * System.Runtime.Versioning.FrameworkName -&gt; bool" Usage="configurationSection.ShouldSerializeElementInTargetVersion (element, elementName, targetFramework)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Configuration.ConfigurationElement" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="elementName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Configuration.ConfigurationElement" />-Objekt, das ein Kandidat für die Serialisierung ist.</param>
        <param name="elementName">Der Name des <see cref="T:System.Configuration.ConfigurationElement" />-Objekts in XML.</param>
        <param name="targetFramework">Die Zielversion von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <summary>Gibt an, ob das angegebene Element serialisiert werden soll, wenn die Konfigurationsobjekthierarchie für die angegebene Zielversion von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] serialisiert wird.</summary>
        <returns><see langword="true" />, wenn <paramref name="element" /> serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Konfigurations Abschnitt, der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] für und spätere Versionen erstellt wird, muss diese Methode explizit überschreiben und zurückgeben `true`, jedoch nur, wenn das angegebene Element für [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]die angegebene Version von gültig ist. Vorhandene Konfigurations Abschnitte, die für frühere Versionen von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] erstellt wurden, müssen nicht geändert werden.  
  
 Der Basistyp enthält eine Standard Implementierung dieser Methode, die immer zurück `true`gibt. Wenn Sie einen Konfigurations Abschnitt implementieren und diese Methode nicht überschreiben, werden standardmäßig alle Konfigurationselemente, die im Konfigurations Abschnitt enthalten sind, für alle Frameworkversionen serialisiert.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76">.NET Framework Ziel für Webprojekte</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializePropertyInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializePropertyInTargetVersion (System.Configuration.ConfigurationProperty property, string propertyName, System.Runtime.Versioning.FrameworkName targetFramework, System.Configuration.ConfigurationElement parentConfigurationElement);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializePropertyInTargetVersion(class System.Configuration.ConfigurationProperty property, string propertyName, class System.Runtime.Versioning.FrameworkName targetFramework, class System.Configuration.ConfigurationElement parentConfigurationElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializePropertyInTargetVersion(System.Configuration.ConfigurationProperty,System.String,System.Runtime.Versioning.FrameworkName,System.Configuration.ConfigurationElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializePropertyInTargetVersion (property As ConfigurationProperty, propertyName As String, targetFramework As FrameworkName, parentConfigurationElement As ConfigurationElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializePropertyInTargetVersion(System::Configuration::ConfigurationProperty ^ property, System::String ^ propertyName, System::Runtime::Versioning::FrameworkName ^ targetFramework, System::Configuration::ConfigurationElement ^ parentConfigurationElement);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializePropertyInTargetVersion : System.Configuration.ConfigurationProperty * string * System.Runtime.Versioning.FrameworkName * System.Configuration.ConfigurationElement -&gt; bool&#xA;override this.ShouldSerializePropertyInTargetVersion : System.Configuration.ConfigurationProperty * string * System.Runtime.Versioning.FrameworkName * System.Configuration.ConfigurationElement -&gt; bool" Usage="configurationSection.ShouldSerializePropertyInTargetVersion (property, propertyName, targetFramework, parentConfigurationElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.Configuration.ConfigurationProperty" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="propertyName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parentConfigurationElement" Type="System.Configuration.ConfigurationElement" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="property">Das <see cref="T:System.Configuration.ConfigurationProperty" />-Objekt, das ein Kandidat für die Serialisierung ist.</param>
        <param name="propertyName">Der Name des <see cref="T:System.Configuration.ConfigurationProperty" />-Objekts in XML.</param>
        <param name="targetFramework">Die Zielversion von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <param name="parentConfigurationElement">Das übergeordnete Element der Eigenschaft.</param>
        <summary>Gibt an, ob die angegebene Eigenschaft serialisiert werden soll, wenn die Konfigurationsobjekthierarchie für die angegebene Zielversion von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] serialisiert wird.</summary>
        <returns><see langword="true" />, wenn <paramref name="property" /> serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Konfigurations Abschnitt, der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] für und spätere Versionen erstellt wird, muss diese Methode explizit überschreiben und zurückgeben `true`, jedoch nur, wenn die angegebene Eigenschaft für [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]die angegebene Version von gültig ist. Vorhandene Konfigurations Abschnitte, die für frühere Versionen von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] erstellt wurden, müssen nicht geändert werden.  
  
 Der Basistyp enthält eine Standard Implementierung dieser Methode, die immer zurück `true`gibt. Wenn Sie einen Konfigurations Abschnitt implementieren und diese Methode nicht außer Kraft setzen, werden standardmäßig alle im Konfigurations Abschnitt enthaltenen Konfigurations Eigenschaften für alle Frameworkversionen serialisiert.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76">.NET Framework Ziel für Webprojekte</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSectionInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeSectionInTargetVersion (System.Runtime.Versioning.FrameworkName targetFramework);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeSectionInTargetVersion(class System.Runtime.Versioning.FrameworkName targetFramework) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializeSectionInTargetVersion(System.Runtime.Versioning.FrameworkName)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeSectionInTargetVersion (targetFramework As FrameworkName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeSectionInTargetVersion(System::Runtime::Versioning::FrameworkName ^ targetFramework);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeSectionInTargetVersion : System.Runtime.Versioning.FrameworkName -&gt; bool&#xA;override this.ShouldSerializeSectionInTargetVersion : System.Runtime.Versioning.FrameworkName -&gt; bool" Usage="configurationSection.ShouldSerializeSectionInTargetVersion targetFramework" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="targetFramework">Die Zielversion von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <summary>Gibt an, ob die aktuelle <see cref="T:System.Configuration.ConfigurationSection" />-Instanz serialisiert werden soll, wenn die Konfigurationsobjekthierarchie für die angegebene Zielversion von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] serialisiert wird.</summary>
        <returns><see langword="true" />, wenn der aktuelle Abschnitt serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Konfigurations Abschnitt, der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] für und spätere Versionen erstellt wird, muss diese Methode explizit überschreiben und zurückgeben `true`, jedoch nur, wenn der Konfigurations Abschnitt für [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]die angegebene Version von gültig ist. Vorhandene Konfigurations Abschnitte, die für frühere Versionen von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] erstellt wurden, müssen nicht geändert werden.  
  
 Der Basistyp enthält eine Standard Implementierung dieser Methode, die immer zurück `true`gibt. Wenn Sie einen Konfigurations Abschnitt implementieren und diese Methode nicht außer Kraft setzen, wird der Konfigurations Abschnitt standardmäßig für alle Frameworkversionen serialisiert.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76">.NET Framework Ziel für Webprojekte</related>
      </Docs>
    </Member>
  </Members>
</Type>
