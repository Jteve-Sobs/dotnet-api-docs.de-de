<Type Name="X509Certificate2" FullName="System.Security.Cryptography.X509Certificates.X509Certificate2">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="96cca76185ce48985a2bbb73af6d26ead1375f1a" />
    <Meta Name="ms.sourcegitcommit" Value="81d387351cc43c342755705908f4a5eb8af153d3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/04/2018" />
    <Meta Name="ms.locfileid" Value="34568193" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class X509Certificate2 : System.Security.Cryptography.X509Certificates.X509Certificate" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit X509Certificate2 extends System.Security.Cryptography.X509Certificates.X509Certificate" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
  <TypeSignature Language="VB.NET" Value="Public Class X509Certificate2&#xA;Inherits X509Certificate" />
  <TypeSignature Language="C++ CLI" Value="public ref class X509Certificate2 : System::Security::Cryptography::X509Certificates::X509Certificate" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.X509Certificates.X509Certificate</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt ein X.509-Zertifikat dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die x. 509-Struktur, die in der internationalen Organisation für Normung (ISO) Arbeitsgruppen stammt. Diese Struktur kann verwendet werden, um verschiedene Typen von Informationen, einschließlich der Identität, Ansprüche und Inhaber Attribute (Berechtigungen, Alter, Geschlecht, Speicherort, Zugehörigkeit usw.) darstellen. Obwohl die ISO-Spezifikationen für die Struktur selbst umfangreichste sind die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Klasse dient zum Modellieren der Szenarien für die Verwendung der Internet Engineering Task Force (IETF) Public Key-Infrastruktur, x. 509-(PKIX definierten ) Arbeitsgruppe. Die umfangreichste gemäß diesen Spezifikationen RFC 3280 verwenden, ist "[Zertifikat und Certificate Revocation List (CRL) Profile](http://go.microsoft.com/fwlink/?LinkId=45286)."  
  
> [!IMPORTANT]
>  Beginnend mit der [!INCLUDE[net_v46](~/includes/net-v46-md.md)], diesen Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mithilfe des Typs abgeschlossen haben, sollten Sie es entweder direkt oder indirekt freigeben. Aufrufen, um den Typ direkt zu verwerfen, dessen <xref:System.IDisposable.Dispose%2A> Methode in einer `try` / `catch` Block. Um es indirekt freizugeben, verwenden Sie ein Sprachkonstrukt z. B. `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "Verwenden eines Objekts, implementiert IDisposable" in der <xref:System.IDisposable> Thema zur Schnittstelle.  
>   
>  Für apps, die als Ziel der [!INCLUDE[net_v452](~/includes/net-v452-md.md)] und früheren Versionen der <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Klasse implementiert nicht die <xref:System.IDisposable> Schnittstelle, und daher keine `Dispose` Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Objekt zum Verschlüsseln und Entschlüsseln einer Datei.  
  
 [!code-csharp[X509Certificate2#1](~/samples/snippets/csharp/VS_Snippets_CLR/x509certificate2/cs/program.cs#1)]
 [!code-vb[X509Certificate2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/x509certificate2/vb/program.vb#1)]  
  
 Das folgende Beispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein leeres <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt, im Gegensatz zu den anderen Konstruktoren für diese Klasse, die Informationen zum Zertifikat aus einem Bytearray, ein Zeiger oder eine Zertifikatdatei verwenden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikatspeicher des aktuellen Benutzers öffnet Sie wählt nur die aktiven Zertifikate, und ermöglicht es dem Benutzer eine oder mehrere Zertifikate auswählen. Im Beispiel werden dann Zertifikatsinformationen in die Konsole.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray mit Daten aus einem X.509-Zertifikat.</param>
        <summary>Initialisiert mithilfe der Informationen aus einem Bytearray eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt mit Informationen zum Zertifikat aus einem Bytearray. Das Bytearray möglich binär (DER) codiert oder Base64-codierten x. 509-Daten. Das Bytearray kann sich auch auf einer mit PKCS7 (Authenticode) signierten Datei; Zertifikat des Signaturgebers wird verwendet, um das Objekt zu erstellen.  
  
 Bei Erstellung einer <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Zertifikat durch Angabe eines mit PKCS7 signierten Dateispeicher für `rawData`, die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> wird das Zertifikat, das den signierten und nicht für keines der Zertifikate im Speicher erstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  –   The certificate file does not exist (Die Zertifikatsdatei ist nicht vorhanden).  –   The certificate is invalid (Das Zertifikat ist ungültig).  –   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(IntPtr handle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Zeiger auf einen Zertifikatskontext in nicht verwaltetem Code. Die C-Struktur wird als <see langword="PCCERT_CONTEXT" /> bezeichnet.</param>
        <summary>Initialisiert mithilfe eines nicht verwalteten Handles eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt mithilfe eines Handles für den Microsoft Cryptographic API-Zertifikatskontext `PCCERT_CONTEXT`. Beachten Sie, dass der unmittelbare Aufrufer dieses Konstruktors nicht verwalteten Code eine Berechtigung erfordert.  
  
> [!IMPORTANT]
>  Der Konstruktor erstellt eine Kopie der Zertifikatkontext. Gehen Sie nicht, dass die Kontextstruktur, die Sie an den Konstruktor übergeben gültig ist; Möglicherweise wurde er freigegeben. Erhalten Sie eine Kopie des aktuellen `PCCERT_CONTEXT` -Struktur aus den <xref:System.Security.Cryptography.X509Certificates.X509Certificate.Handle%2A> Eigenschaft allerdings wird hierüber gilt nur während der Lebensdauer der <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Objekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  –   The certificate file does not exist (Die Zertifikatsdatei ist nicht vorhanden).  –   The certificate is invalid (Das Zertifikat ist ungültig).  –   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (System.Security.Cryptography.X509Certificates.X509Certificate certificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.X509Certificates.X509Certificate certificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (certificate As X509Certificate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::Security::Cryptography::X509Certificates::X509Certificate ^ certificate);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="certificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="certificate">Ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" />-Objekt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse mit einem <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine neue Instanz der dem <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Klasse unter Verwendung einer <xref:System.Security.Cryptography.X509Certificates.X509Certificate> Objekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  –   The certificate file does not exist (Die Zertifikatsdatei ist nicht vorhanden).  –   The certificate is invalid (Das Zertifikat ist ungültig).  –   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <summary>Initialisiert mithilfe eines Zertifikatsdateinamens eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt mithilfe eines Zertifikatsdateinamens. Binäre Codierung (DER) oder Base64-Codierung unterstützt.  
  
 Bei Erstellung einer <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Zertifikat durch Angabe eines mit PKCS7 signierten Dateispeicher für `fileName`, die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> wird das Zertifikat, das den signierten und nicht für keines der Zertifikate im Speicher erstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  –   The certificate file does not exist (Die Zertifikatsdatei ist nicht vorhanden).  –   The certificate is invalid (Das Zertifikat ist ungültig).  –   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, System.Security.SecureString password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, class System.Security.SecureString password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As SecureString)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::Security::SecureString ^ password);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray, das Daten aus einem X.509-Zertifikat enthält.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse mit einem Bytearray und einem Kennwort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird mit PKCS12 (PFX)-Dateien verwendet, die private Schlüssel des Zertifikats enthalten. Aufrufen dieses Konstruktors mit dem richtigen Kennwort des privaten Schlüssels entschlüsselt und in einem Schlüsselcontainer gespeichert.  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
 Bei Erstellung einer <xref:System.Security.Cryptography.X509Certificates.X509Certificate> Zertifikat durch Angabe eines mit PKCS7 signierten Dateispeicher für `rawData`, die <xref:System.Security.Cryptography.X509Certificates.X509Certificate> wird das Zertifikat, das den signierten und nicht für keines der Zertifikate im Speicher erstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  –   The certificate file does not exist (Die Zertifikatsdatei ist nicht vorhanden).  –   The certificate is invalid (Das Zertifikat ist ungültig).  –   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::String ^ password);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray mit Daten aus einem X.509-Zertifikat.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse mit einem Bytearray und einem Kennwort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt mit einem Bytearray und ein Kennwort, das Zugriff auf die Zertifikatsdaten benötigt wird. Es wird mit PKCS12 (PFX)-Dateien verwendet, die private Schlüssel des Zertifikats enthalten. Aufrufen dieses Konstruktors mit dem richtigen Kennwort des privaten Schlüssels entschlüsselt und in einem Schlüsselcontainer gespeichert.  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
 Bei Erstellung einer <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Zertifikat durch Angabe eines mit PKCS7 signierten Dateispeicher für `rawData`, die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> wird das Zertifikat, das den signierten und nicht für keines der Zertifikate im Speicher erstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  –   The certificate file does not exist (Die Zertifikatsdatei ist nicht vorhanden).  –   The certificate is invalid (Das Zertifikat ist ungültig).  –   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected X509Certificate2 (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; X509Certificate2(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Die Serialisierungsinformationen, die zum Deserialisieren des neuen <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> erforderlich sind.</param>
        <param name="context">Kontextinformationen zur Quelle des Streams, der deserialisiert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse mit den angegebenen Serialisierungs- und Streamkontextinformationen.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, System.Security.SecureString password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, class System.Security.SecureString password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As SecureString)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::Security::SecureString ^ password);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <summary>Initialisiert mithilfe eines Zertifikatsdateinamens und eines Kennworts eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird mit PKCS12 (PFX)-Dateien verwendet, die private Schlüssel des Zertifikats enthalten. Aufrufen dieses Konstruktors mit dem richtigen Kennwort des privaten Schlüssels entschlüsselt und in einem Schlüsselcontainer gespeichert.  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
 Bei Erstellung einer <xref:System.Security.Cryptography.X509Certificates.X509Certificate> Zertifikat durch Angabe eines mit PKCS7 signierten Dateispeicher für `fileName`, die <xref:System.Security.Cryptography.X509Certificates.X509Certificate> wird das Zertifikat, das den signierten und nicht für keines der Zertifikate im Speicher erstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  –   The certificate file does not exist (Die Zertifikatsdatei ist nicht vorhanden).  –   The certificate is invalid (Das Zertifikat ist ungültig).  –   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::String ^ password);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <summary>Initialisiert mithilfe des Zertifikatsdateinamens und eines für den Zugriff auf das Zertifikat verwendeten Kennworts eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt mithilfe eines Zertifikatsdateinamens und eines Kennworts für den Zugriff auf das Zertifikat erforderlich. Es wird mit PKCS12 (PFX)-Dateien verwendet, die private Schlüssel des Zertifikats enthalten. Aufrufen dieses Konstruktors mit dem richtigen Kennwort des privaten Schlüssels entschlüsselt und in einem Schlüsselcontainer gespeichert.  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
 Bei Erstellung einer <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Zertifikat durch Angabe eines mit PKCS7 signierten Dateispeicher für `fileName`, die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> wird das Zertifikat, das den signierten und nicht für keines der Zertifikate im Speicher erstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  –   The certificate file does not exist (Die Zertifikatsdatei ist nicht vorhanden).  –   The certificate is invalid (Das Zertifikat ist ungültig).  –   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray, das Daten aus einem X.509-Zertifikat enthält.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse mit einem Bytearray, einem Kennwort und einem Schlüsselspeicherflag.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird mit PKCS12 (PFX)-Dateien verwendet, die private Schlüssel des Zertifikats enthalten. Aufrufen dieses Konstruktors mit dem richtigen Kennwort des privaten Schlüssels entschlüsselt und speichert ihn an ein Microsoft Cryptographic API Kryptografiedienstanbieter (CSP).  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
 Bei Erstellung einer <xref:System.Security.Cryptography.X509Certificates.X509Certificate> Zertifikat durch Angabe eines mit PKCS7 signierten Dateispeicher für `rawData`, die <xref:System.Security.Cryptography.X509Certificates.X509Certificate> wird das Zertifikat, das den signierten und nicht für keines der Zertifikate im Speicher erstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  –   The certificate file does not exist (Die Zertifikatsdatei ist nicht vorhanden).  –   The certificate is invalid (Das Zertifikat ist ungültig).  –   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray mit Daten aus einem X.509-Zertifikat.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse mit einem Bytearray, einem Kennwort und einem Schlüsselspeicherflag.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Objekts, wobei einen Byte-array, ein Kennwort, das Zugriff auf die Zertifikatdaten und einem Schlüsselspeicherflag benötigt wird. Es wird mit PKCS12 (PFX)-Dateien verwendet, die private Schlüssel des Zertifikats enthalten. Aufrufen dieses Konstruktors mit dem richtigen Kennwort des privaten Schlüssels entschlüsselt und speichert ihn an ein Microsoft Cryptographic API Kryptografiedienstanbieter (CSP).  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
 Bei Erstellung einer <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Zertifikat durch Angabe eines mit PKCS7 signierten Dateispeicher für `rawData`, die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> wird das Zertifikat, das den signierten und nicht für keines der Zertifikate im Speicher erstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  –   The certificate file does not exist (Die Zertifikatsdatei ist nicht vorhanden).  –   The certificate is invalid (Das Zertifikat ist ungültig).  –   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Initialisiert mithilfe eines Zertifikatsdateinamens, eines Kennworts und eines Schlüsselspeicherflags eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Erstellung einer <xref:System.Security.Cryptography.X509Certificates.X509Certificate> Zertifikat durch Angabe eines mit PKCS7 signierten Dateispeicher für `fileName`, die <xref:System.Security.Cryptography.X509Certificates.X509Certificate> wird das Zertifikat, das den signierten und nicht für keines der Zertifikate im Speicher erstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  –   The certificate file does not exist (Die Zertifikatsdatei ist nicht vorhanden).  –   The certificate is invalid (Das Zertifikat ist ungültig).  –   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Initialisiert mithilfe eines Zertifikatsdateinamens, eines für den Zugriff auf das Zertifikat verwendeten Kennworts und eines Schlüsselspeicherflags eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> ein Objekt mithilfe eines Zertifikatsdateinamens benennen, ein Kennwort erforderlich, um das Zertifikat und einem Schlüsselspeicherflag zugreifen.  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
 Bei Erstellung einer <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Zertifikat durch Angabe eines mit PKCS7 signierten Dateispeicher für `fileName`, die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> wird das Zertifikat, das den signierten und nicht für keines der Zertifikate im Speicher erstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  –   The certificate file does not exist (Die Zertifikatsdatei ist nicht vorhanden).  –   The certificate is invalid (Das Zertifikat ist ungültig).  –   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Archived">
      <MemberSignature Language="C#" Value="public bool Archived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archived" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Archived" />
      <MemberSignature Language="VB.NET" Value="Public Property Archived As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archived { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, dass ein X.509-Zertifikat archiviert wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Zertifikat archiviert wird, <see langword="false" />, wenn das Zertifikat nicht archiviert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird nur für ein Zertifikat festgelegt, die einen Speicher zugeordnet ist. Wenn die Eigenschaft wird festgelegt, und das Zertifikat in einen Zertifikatspeicher hinzugefügt wird, wird der Wert beibehalten. Wenn die Eigenschaft für ein Zertifikat aus einem Store abgerufen festgelegt ist, wird der Wert sofort beibehalten.  
  
 In einem x. 509-Speicher archivierte Zertifikate sind nicht enthalten in der zurückgegebenen <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> -Objekt, es sei denn, die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.Archived%2A> -Eigenschaftensatz auf `true`. Physische Archivierung Aktivitäten ausgeführt werden, wenn die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.Archived%2A> Wert ist nicht festgelegt oder nicht festgelegt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikatspeicher des aktuellen Benutzers öffnet Sie wählt nur die aktiven Zertifikate, und ermöglicht es dem Benutzer eine oder mehrere Zertifikate auswählen. Im Beispiel werden dann Zertifikatsinformationen in die Konsole.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Export">
      <MemberSignature Language="C#" Value="public override byte[] Export (System.Security.Cryptography.X509Certificates.X509ContentType contentType, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] Export(valuetype System.Security.Cryptography.X509Certificates.X509ContentType contentType, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Export(System.Security.Cryptography.X509Certificates.X509ContentType,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Export (contentType As X509ContentType, password As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ Export(System::Security::Cryptography::X509Certificates::X509ContentType contentType, System::String ^ password);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("X509ContentType.SerializedCert is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentType" Type="System.Security.Cryptography.X509Certificates.X509ContentType" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="contentType">To be added.</param>
        <param name="password">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509ExtensionCollection Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509ExtensionCollection Extensions" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As X509ExtensionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509ExtensionCollection ^ Extensions { System::Security::Cryptography::X509Certificates::X509ExtensionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509ExtensionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von <see cref="T:System.Security.Cryptography.X509Certificates.X509Extension" />-Objekten ab.</summary>
        <value>Ein <see cref="T:System.Security.Cryptography.X509Certificates.X509ExtensionCollection" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Erweiterungen in das x. 509-v3-Zertifikatformat definiert können zusätzliche Daten im Zertifikat enthalten sein. Eine Anzahl von Erweiterungen werden in ISO definiert, in der x. 509-v3-Definition sowie von PKIX in RFC 3280 verwenden "[Zertifikat und Certificate Revocation List (CRL) Profile](http://go.microsoft.com/fwlink/?LinkId=45286)." Häufig verwendete Erweiterungen enthalten Informationen zur Schlüsselverwendung (<xref:System.Security.Cryptography.X509Certificates.X509KeyUsageExtension>), key Bezeichner (<xref:System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension>), Richtlinien, Sperrinformationen (CRL Distribution Point-Erweiterung) und andere Verwendungen des Zertifikats.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikatspeicher des aktuellen Benutzers öffnet Sie wählt nur die aktiven Zertifikate, und ermöglicht es dem Benutzer eine oder mehrere Zertifikate auswählen. Im Beispiel werden dann Zertifikatsinformationen in die Konsole.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den einem Zertifikat zugeordneten Alias ab oder legt diesen fest.</summary>
        <value>Der angezeigte Name des Zertifikats.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anzeigenamen sind Eigenschaften im x. 509-Zertifikatspeicher, der festgelegt werden können. Sie werden verwendet, damit einen Benutzer Zertifikate Aliase zuordnen, sodass diese leicht identifiziert werden können.  
  
 Ggf. keinen Anzeigenamen für das Zertifikat, eine leere Zeichenfolge ("") zurückgegeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCertContentType">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Typ des in einem Bytearray oder in einer Datei enthaltenen Zertifikats an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCertContentType">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType (byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType(unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCertContentType (rawData As Byte()) As X509ContentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::X509Certificates::X509ContentType GetCertContentType(cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Detection limited to Cert, Pfx, Pkcs12, Pkcs7 and Unknown")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509ContentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray mit Daten aus einem X.509-Zertifikat.</param>
        <summary>Gibt den Typ des in einem Bytearray enthaltenen Zertifikats an.</summary>
        <returns>Ein <see cref="T:System.Security.Cryptography.X509Certificates.X509ContentType" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht, den Typ des Zertifikats in einer Datei zu ermitteln.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikatspeicher des aktuellen Benutzers öffnet Sie wählt nur die aktiven Zertifikate, und ermöglicht es dem Benutzer eine oder mehrere Zertifikate auswählen. Im Beispiel werden dann Zertifikatsinformationen in die Konsole.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rawData" /> hat die Länge 0 (null) oder ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCertContentType">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCertContentType (fileName As String) As X509ContentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::X509Certificates::X509ContentType GetCertContentType(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Detection limited to Cert, Pfx, Pkcs12 and Unknown")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509ContentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <summary>Gibt den Typ des in einer Datei enthaltenen Zertifikats an.</summary>
        <returns>Ein <see cref="T:System.Security.Cryptography.X509Certificates.X509ContentType" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht, den Typ des Zertifikats in einer Datei zu ermitteln.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen des Zertifikats an. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.IO.FileAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetNameInfo">
      <MemberSignature Language="C#" Value="public string GetNameInfo (System.Security.Cryptography.X509Certificates.X509NameType nameType, bool forIssuer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetNameInfo(valuetype System.Security.Cryptography.X509Certificates.X509NameType nameType, bool forIssuer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetNameInfo(System.Security.Cryptography.X509Certificates.X509NameType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNameInfo (nameType As X509NameType, forIssuer As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetNameInfo(System::Security::Cryptography::X509Certificates::X509NameType nameType, bool forIssuer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("always return String.Empty for UpnName, DnsFromAlternativeName and UrlName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nameType" Type="System.Security.Cryptography.X509Certificates.X509NameType" />
        <Parameter Name="forIssuer" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nameType">Der <see cref="T:System.Security.Cryptography.X509Certificates.X509NameType" /> -Wert für den Antragsteller.</param>
        <param name="forIssuer">
          <see langword="true" />, um den Namen des Ausstellers einzufügen, andernfalls <see langword="false" />.</param>
        <summary>Ruft den die Namen des Zertifikatsantragstellers und des Zertifikatausstellers ab.</summary>
        <returns>Der Name des Zertifikats.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte immer verwendet werden, anstatt das Zertifikat analysieren, da der Großteil der Namenswerte an mehreren Orten befinden können. Mit dieser Methode wird sichergestellt, dass der richtige Name zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikatspeicher des aktuellen Benutzers öffnet Sie wählt nur die aktiven Zertifikate, und ermöglicht es dem Benutzer eine oder mehrere Zertifikate auswählen. Im Beispiel werden dann Zertifikatsinformationen in die Konsole.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasPrivateKey">
      <MemberSignature Language="C#" Value="public bool HasPrivateKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasPrivateKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.HasPrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasPrivateKey As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasPrivateKey { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt einen privaten Schlüssel enthält.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt einen privaten Schlüssel enthält, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Zertifikatskontext ist ungültig.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Import">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mit den bereitgestellten Zertifikatsinformationen auf.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray mit Daten aus einem X.509-Zertifikat.</param>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mit Daten aus einem Bytearray auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, ein raw Byte-Array eines x. 509-Zertifikats und Auffüllen der <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt mit den zugehörigen Werten.  
  
 Da diese Methode nur ein Bytearray annimmt, können sie nur für Zertifikatstypen verwendet werden, die nicht über ein Kennwort ein, z. B. ein Base64-codierte oder DER-codiertes x. 509-Zertifikat oder ein Zertifikat PFX/PKCS12 erfordern. Beachten Sie, dass PFX/PKCS12-Zertifikate über mehrere Zertifikate enthalten kann. In diesem Fall wird das erste Zertifikat zugeordneten privaten Schlüssel verwendet, oder, wenn kein privater Schlüssel gefunden wird, wird das erste Zertifikat verwendet.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Dieser Member kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name eines Zertifikats.</param>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mit Informationen aus einer Zertifikatsdatei auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet eine Zertifikatsdatei, z. B. eine Datei mit einer CER-Erweiterung, die ein x. 509-Zertifikat darstellt, und füllt die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Objekt mit dem Zertifikat, das die Datei enthält.  
  
 Diese Methode kann mit mehreren Zertifikatstypen, einschließlich Base64-codierte oder DER-codiertes x. 509-Zertifikate, PFX/PKCS12-Zertifikate und Signaturgeberzertifikate, z. B. Authenticode verwendet werden. Beachten Sie, dass PFX/PKCS12-Zertifikate über mehrere Zertifikate enthalten kann. In diesem Fall wird das erste Zertifikat zugeordneten privaten Schlüssel verwendet, oder, wenn kein privater Schlüssel gefunden wird, wird das erste Zertifikat verwendet.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Dieser Member kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (byte[] rawData, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(unsigned int8[] rawData, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[],System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (rawData As Byte(), password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(cli::array &lt;System::Byte&gt; ^ rawData, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("SecureString is incomplete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray, das Daten aus einem X.509-Zertifikat enthält.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mithilfe der Daten aus einem Bytearray, eines Kennworts und eines Schlüsselspeicherflags auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode Zertifikatstypen wie Base64-codierte oder DER-codiertes x. 509-Zertifikate oder PFX/PKCS12-Zertifikate verwenden. Beachten Sie, dass PFX/PKCS12-Zertifikate über mehrere Zertifikate enthalten kann. In diesem Fall wird das erste Zertifikat zugeordneten privaten Schlüssel verwendet, oder, wenn kein privater Schlüssel gefunden wird, wird das erste Zertifikat verwendet.  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Dieser Member kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (byte[] rawData, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(unsigned int8[] rawData, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (rawData As Byte(), password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(cli::array &lt;System::Byte&gt; ^ rawData, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("missing KeyStorageFlags support")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray mit Daten aus einem X.509-Zertifikat.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mithilfe der Daten aus einem Bytearray, eines Kennworts und von Flags auf, mit denen bestimmt werden kann, wie der private Schlüssel importiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, zum Auffüllen einer <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> mit einem Kennwort für das Zertifikat, das Bytearray dargestellte Objekt. Die <xref:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags> Wert kann verwendet werden, um zu steuern, wo und wie zum Importieren des privaten Schlüssels.  
  
 Diese Methode ein Bytearray annimmt und Zertifikatstypen wie Base64-codierte oder DER-codiertes x. 509-Zertifikate oder PFX/PKCS12-Zertifikate verwendet werden kann. Beachten Sie, dass PFX/PKCS12-Zertifikate über mehrere Zertifikate enthalten kann. In diesem Fall wird das erste Zertifikat zugeordneten privaten Schlüssel verwendet, oder, wenn kein privater Schlüssel gefunden wird, wird das erste Zertifikat verwendet.  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Dieser Member kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (string fileName, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(string fileName, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String,System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (fileName As String, password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(System::String ^ fileName, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("SecureString is incomplete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mit Informationen aus einer Zertifikatsdatei, einem Kennwort und einem Schlüsselspeicherflag auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Sicherheitshinweis** nie hartcodieren ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (string fileName, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(string fileName, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (fileName As String, password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(System::String ^ fileName, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("missing KeyStorageFlags support")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mit Informationen aus einer Zertifikatsdatei, einem Kennwort und einem <see cref="T:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />-Wert auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden Auffüllen einer <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt mit Informationen aus einer Zertifikatsdatei, einem Kennwort und ein <xref:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags> Wert.  
  
> [!IMPORTANT]
>  Nie Hartcodieren Sie ein Kennwort im Quellcode.  Hartcodierte Kennwörter können aus einer Assembly abgerufen werden die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem hex-Editor oder durch das Öffnen der Assembly in einem Text-Editor wie Notepad.exe.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Dieser Member kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="IssuerName">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X500DistinguishedName IssuerName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X500DistinguishedName IssuerName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.IssuerName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IssuerName As X500DistinguishedName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ IssuerName { System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X500DistinguishedName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Distinguished Name des Zertifikatausstellers ab.</summary>
        <value>Ein <see cref="T:System.Security.Cryptography.X509Certificates.X500DistinguishedName" />-Objekt, das den Namen des Zertifikatausstellers enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft enthält den Namen der Zertifizierungsstelle (CA), die das Zertifikat ausgestellt hat. Verwenden Sie zum Abrufen der Name eines Zertifikats die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.GetNameInfo%2A> Methode.  
  
 Der Distinguished Name für das Zertifikat ist eine Textdarstellung des Zertifikatsantragstellers oder des Zertifikatausstellers. Diese Darstellung besteht aus Namensattributen (z. B. "CN = MyName, OU = MyOrgUnit, C = US").  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Zertifikatskontext ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotAfter">
      <MemberSignature Language="C#" Value="public DateTime NotAfter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime NotAfter" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.NotAfter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NotAfter As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime NotAfter { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Datum in Ortszeit ab, ab dem ein Zertifikat nicht mehr gültig ist.</summary>
        <value>Ein <see cref="T:System.DateTime" />-Objekt, das das Ablaufdatum des Zertifikats darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt ein Ablaufdatum auf dem das Zertifikat ungültig wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotBefore">
      <MemberSignature Language="C#" Value="public DateTime NotBefore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime NotBefore" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.NotBefore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NotBefore As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime NotBefore { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Datum in Ortszeit ab, ab dem ein Zertifikat gültig wird.</summary>
        <value>Ein <see cref="T:System.DateTime" />-Objekt, das das Datum darstellt, an dem das Zertifikat gültig wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt das Datum, an dem das Zertifikat gültig wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="PrivateKey">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.AsymmetricAlgorithm PrivateKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.AsymmetricAlgorithm PrivateKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateKey As AsymmetricAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::AsymmetricAlgorithm ^ PrivateKey { System::Security::Cryptography::AsymmetricAlgorithm ^ get(); void set(System::Security::Cryptography::AsymmetricAlgorithm ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.AsymmetricAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />-Objekt ab, das den einem Zertifikat zugeordneten privaten Schlüssel darstellt oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />-Objekt, das einen kryptografischen Dienstanbieter für RSA oder DSA darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft unterstützt derzeit nur RSA "oder" DSA-Schlüssel, sodass Rückgabe entweder ein <xref:System.Security.Cryptography.RSACryptoServiceProvider> oder ein <xref:System.Security.Cryptography.DSACryptoServiceProvider> Objekt. Wenn kein privater Schlüssel mit dem Zertifikat verknüpft ist, gibt es `null`.  
  
> [!WARNING]
>  Wenn Sie diese Eigenschaft, um festlegen `null` oder auf einen anderen Schlüssel ohne ihn löschen, wird eine Datei für den private Schlüssel auf dem Datenträger zurückgelassen.  
  
 Um den zugeordneten privaten Schlüssel für diese Eigenschaft ordnungsgemäß zu löschen, legen Sie `PersistKeyInCsp` auf `false`, und rufen Sie anschließend die <xref:System.Security.Cryptography.AsymmetricAlgorithm.Clear%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikatspeicher des aktuellen Benutzers öffnet Sie wählt nur die aktiven Zertifikate, und ermöglicht es dem Benutzer eine oder mehrere Zertifikate auswählen. Im Beispiel werden dann Zertifikatsinformationen in die Konsole.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüsselwert ist kein RSA- oder DSA-Schlüssel, oder der Schlüssel kann nicht gelesen werden.</exception>
        <exception cref="T:System.ArgumentNullException">Der Wert, der für diese Eigenschaft festgelegt wird, ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Der Schlüsselalgorithmus für diesen privaten Schlüssel wird nicht unterstützt.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Die X.509-Schlüssel stimmen nicht überein.</exception>
        <exception cref="T:System.ArgumentException">Der Schlüssel des Kryptografiedienstanbieters ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.PublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.PublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PublicKey As PublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::PublicKey ^ PublicKey { System::Security::Cryptography::X509Certificates::PublicKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.PublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" />-Objekt ab, das einem Zertifikat zugeordnet ist.</summary>
        <value>Ein <see cref="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt eine <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey%2A> Objekt, das die Objekt-ID enthält (<xref:System.Security.Cryptography.Oid>), die der Algorithmus für öffentliche Schlüssel, die ASN. 1-codierten Parameter und den ASN. 1-codierten Schlüsselwert darstellt.  
  
 Sie erhalten den Schlüssel als auch ein <xref:System.Security.Cryptography.AsymmetricAlgorithm> Objekt durch Verweisen auf die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey%2A> Eigenschaft. Diese Eigenschaft unterstützt nur RSA "oder" DSA-Schlüssel, sodass entweder zurückgegeben ein <xref:System.Security.Cryptography.RSACryptoServiceProvider> oder ein <xref:System.Security.Cryptography.DSACryptoServiceProvider> Objekt, das den öffentlichen Schlüssel darstellt.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüsselwert ist kein RSA- oder DSA-Schlüssel, oder der Schlüssel kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="RawData">
      <MemberSignature Language="C#" Value="public byte[] RawData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] RawData" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.RawData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawData As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ RawData { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Rohdaten eines Zertifikats ab.</summary>
        <value>Die Rohdaten des Zertifikats als Bytearray.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Zustand eines <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekts zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um den Status des Zertifikats zurückzusetzen. Es gibt auch alle dem Zertifikat zugeordneten Ressourcen frei.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Dieser Member kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SerialNumber">
      <MemberSignature Language="C#" Value="public string SerialNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SerialNumber" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.SerialNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerialNumber As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SerialNumber { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Seriennummer eines Zertifikats als hexadezimale Big-Endian-Zeichenfolge ab.</summary>
        <value>Die Seriennummer des Zertifikats als hexadezimale Zeichenfolge big-Endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Seriennummer des Zertifikats ist Teil des ursprünglichen x. 509-Protokolls. Die Seriennummer ist eine eindeutige Nummer, die ausgegeben wird, durch den Aussteller des Zertifikats, der auch die Zertifizierungsstelle (Certificate Authority, CA) bezeichnet wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Oid SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Oid SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SignatureAlgorithm As Oid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Oid ^ SignatureAlgorithm { System::Security::Cryptography::Oid ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Oid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zum Erstellen der Signatur eines Zertifikats verwendeten Algorithmus ab.</summary>
        <value>Gibt den Objektbezeichner (<see cref="T:System.Security.Cryptography.Oid" />) des Signaturalgorithmus zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Objekt-ID (<xref:System.Security.Cryptography.Oid>) identifiziert den Typ des Signaturalgorithmus, die durch das Zertifikat verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikatspeicher des aktuellen Benutzers öffnet Sie wählt nur die aktiven Zertifikate, und ermöglicht es dem Benutzer eine oder mehrere Zertifikate auswählen. Im Beispiel werden dann Zertifikatsinformationen in die Konsole.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubjectName">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X500DistinguishedName SubjectName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X500DistinguishedName SubjectName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.SubjectName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubjectName As X500DistinguishedName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ SubjectName { System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X500DistinguishedName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Distinguished Name für den Antragsteller aus einem Zertifikat ab.</summary>
        <value>Ein <see cref="T:System.Security.Cryptography.X509Certificates.X500DistinguishedName" />-Objekt, das den Namen des Zertifikatsantragstellers darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definierter Antragstellername ist der Name des Benutzers des Zertifikats. Der distinguished Name für das Zertifikat ist eine Textdarstellung des Antragstellers oder des Ausstellers des Zertifikats. Diese Darstellung besteht aus Namensattributen, z. B. "CN = MyName, OU = MyOrgUnit, C = US".  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Zertifikatskontext ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Thumbprint">
      <MemberSignature Language="C#" Value="public string Thumbprint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Thumbprint" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Thumbprint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thumbprint As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Thumbprint { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Fingerabdruck eines Zertifikats ab.</summary>
        <value>Der Fingerabdruck des Zertifikats.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Fingerabdruck wird dynamisch generiert mithilfe des SHA1-Algorithmus und nicht physisch im Zertifikat vorhanden sein. Da der Fingerabdruck einen eindeutigen Wert für das Zertifikat ist, wird es häufig verwendet ein bestimmtes Zertifikat in keinem Zertifikatspeicher gefunden.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeigt ein X.509-Zertifikat in Textformat an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zeigt ein X.509-Zertifikat in Textformat an.</summary>
        <returns>Die Zertifikatsinformationen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wie bei allen `ToString` Methoden, die Ausgabe möglicherweise nicht verschiedenen Versionen von .NET Framework, damit die Methodenergebnisse für den Inhalt nicht analysiert werden soll. Verwenden Sie die Eigenschaften auf der <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Objekt, das genaue Informationen über den Inhalt zu erhalten, oder verwenden Sie die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString%2A> Methode, um Informationen über das Zertifikat abzurufen.  
  
 Diese Methode zeigt das Zertifikat im Textformat.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString (bool verbose);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString(bool verbose) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString (verbose As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString(bool verbose);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="verbose" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="verbose">
          <see langword="true" />, um den öffentlichen Schlüssel, den privaten Schlüssel, Erweiterungen usw. anzuzeigen, <see langword="false" />, um Informationen anzuzeigen, die denen der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse ähneln, z. B. Fingerabdruck, Seriennummer, Name von Antragsteller und Aussteller usw.</param>
        <summary>Zeigt ein X.509-Zertifikat in Textformat an.</summary>
        <returns>Die Zertifikatsinformationen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wie bei allen `ToString` Methoden, die Ausgabe möglicherweise nicht verschiedenen Versionen von .NET Framework, damit die Methodenergebnisse für den Inhalt nicht analysiert werden soll. Verwenden Sie die Eigenschaften auf der <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Objekt um genaue Informationen zu erhalten.  
  
 Diese Methode zeigt das Zertifikat im Textformat. Wenn die `verbose` Parametersatz auf `true`, die Textanzeige enthält, der öffentliche Schlüssel, den privaten Schlüssel und die Erweiterungen. Wenn `verbose` festgelegt ist, um `false`, Text angezeigt werden, die aus dem x. 509-Zertifikat, einschließlich der Fingerabdruck, Seriennummer, Betreff und Aussteller Namen und Informationen zum Gültigkeitsdatum verfügbaren Felder.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Verify">
      <MemberSignature Language="C#" Value="public bool Verify ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Verify() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Verify" />
      <MemberSignature Language="VB.NET" Value="Public Function Verify () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Verify();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("by default this depends on the incomplete X509Chain")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt mithilfe von Basisvalidierungsrichtlinien eine Validierung von X.509-Ketten aus.</summary>
        <returns>
          <see langword="true" />, wenn die Validierung erfolgreich ist; <see langword="false" /> im Falle eines Validierungsfehlers.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine einfache Kette für das Zertifikat und, verkettet den Basis-Richtlinie gilt. Wenn Sie weitere Informationen zu einem Fehler benötigen, überprüfen Sie das Zertifikat direkt mit der <xref:System.Security.Cryptography.X509Certificates.X509Chain> Objekt.  
  
 Beachten Sie, dass chaining Engine standardmäßig überschrieben werden kann, mithilfe der <xref:System.Security.Cryptography.CryptoConfig> Klasse. Unter Microsoft Windows Server 2003 das Standardmodul entspricht der Spezifikation, die in RFC3280, beschriebenen "[Zertifikat und Certificate Revocation List (CRL) Profile](http://go.microsoft.com/fwlink/?LinkId=45286)."  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikatspeicher des aktuellen Benutzers öffnet Sie wählt nur die aktiven Zertifikate, und ermöglicht es dem Benutzer eine oder mehrere Zertifikate auswählen. Im Beispiel werden dann Zertifikatsinformationen in die Konsole.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public int Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Version" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Version" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Version As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Version { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die X.509-Formatversion eines Zertifikats ab.</summary>
        <value>Das Format des Zertifikats.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt mehrere Versionen von x. 509-Zertifikaten. Diese Eigenschaft gibt an, welches format Sie das Zertifikat verwendet. Beispielsweise wird "3" für eine Version 3-Zertifikat zurückgegeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine ausführbare Befehlszeilendatei, die eine Zertifikatsdatei als Argument verwendet und verschiedene Zertifikatseigenschaften an die Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
  </Members>
</Type>