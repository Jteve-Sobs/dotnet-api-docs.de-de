<Type Name="X509Certificate2" FullName="System.Security.Cryptography.X509Certificates.X509Certificate2">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6a20fa78951797e973f27dcc4683110f9d721679" /><Meta Name="ms.sourcegitcommit" Value="406d23aba879fbb482c6da0f64c8ef9494f6a944" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/31/2019" /><Meta Name="ms.locfileid" Value="68686267" /></Metadata><TypeSignature Language="C#" Value="public class X509Certificate2 : System.Security.Cryptography.X509Certificates.X509Certificate" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit X509Certificate2 extends System.Security.Cryptography.X509Certificates.X509Certificate" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
  <TypeSignature Language="VB.NET" Value="Public Class X509Certificate2&#xA;Inherits X509Certificate" />
  <TypeSignature Language="C++ CLI" Value="public ref class X509Certificate2 : System::Security::Cryptography::X509Certificates::X509Certificate" />
  <TypeSignature Language="F#" Value="type X509Certificate2 = class&#xA;    inherit X509Certificate" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.X509Certificates.X509Certificate</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein X.509-Zertifikat dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die X. 509-Struktur stammt aus den internationale Organisation für Normung (ISO)-Arbeitsgruppen. Diese Struktur kann verwendet werden, um verschiedene Arten von Informationen darzustellen, einschließlich Identitäts-, Berechtigungs-und Inhaber Attributen (Berechtigungen, Alter, Geschlecht, Speicherort, Zugehörigkeit usw.). Obwohl die ISO-Spezifikationen für die Struktur selbst aufschlussreich sind, <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> ist die-Klasse so konzipiert, dass die Verwendungs Szenarien modelliert werden, die in Spezifikationen der Public Key-Infrastruktur (Internet Engineering Task Force, IETF) definiert sind. X. 509 (PKIX ) Arbeitsgruppe. Die informativsten dieser Spezifikationen sind RFC 3280, "[Zertifikat-und Zertifikat Sperr Listen-Profil (CRL)](https://go.microsoft.com/fwlink/?LinkId=45286)".  
  
> [!IMPORTANT]
>  Ab implementiert dieser Typ die <xref:System.IDisposable> -Schnittstelle. [!INCLUDE[net_v46](~/includes/net-v46-md.md)] Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
>   
>  Für apps, die auf [!INCLUDE[net_v452](~/includes/net-v452-md.md)] und frühere Versionen abzielen, <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> implementiert die-Klasse die <xref:System.IDisposable> -Schnittstelle nicht und verfügt daher `Dispose` nicht über eine-Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt verwendet wird, um eine Datei zu verschlüsseln und zu entschlüsseln.  
  
 [!code-csharp[X509Certificate2#1](~/samples/snippets/csharp/VS_Snippets_CLR/x509certificate2/cs/program.cs#1)]
 [!code-vb[X509Certificate2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/x509certificate2/vb/program.vb#1)]  
  
 Im folgenden Beispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein leeres <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt, im Gegensatz zu den anderen Konstruktoren für diese Klasse, die Zertifikat Informationen aus einem Bytearray, einem Zeiger oder einer Zertifikatsdatei verwenden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikat Speicher des aktuellen Benutzers geöffnet, nur aktive Zertifikate ausgewählt und der Benutzer dann die Auswahl eines oder mehrerer Zertifikate ermöglicht. Im Beispiel werden dann Zertifikat Informationen in die Konsole geschrieben.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : byte[] -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 rawData" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray mit Daten aus einem X.509-Zertifikat.</param>
        <summary>Initialisiert mithilfe der Informationen aus einem Bytearray eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt mithilfe von Zertifikat Informationen aus einem Bytearray. Das Bytearray kann binäre (der) codierte oder Base64-codierte X. 509-Daten sein. Das Bytearray kann auch eine PKCS7 (Authenticode)-signierte Datei sein. Das Signatur Geber Zertifikat wird zum Erstellen des-Objekts verwendet.  
  
 Wenn Sie ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Zertifikat erstellen, indem Sie einen PKCS7-signierten Dateispeicher <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> für `rawData`angeben, wird der für das Zertifikat erstellt, das den Speicher signiert hat, und nicht für eines der Zertifikate im Speicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  
  
–   Die Zertifikatsdatei ist nicht vorhanden.  
  
–   The certificate is invalid (Das Zertifikat ist ungültig).  
  
–   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(IntPtr handle);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : nativeint -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Zeiger auf einen Zertifikatskontext in nicht verwaltetem Code. Die C-Struktur wird als <see langword="PCCERT_CONTEXT" /> bezeichnet.</param>
        <summary>Initialisiert mithilfe eines nicht verwalteten Handles eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt mithilfe eines Handles für den kryptografischen API-Zertifikat `PCCERT_CONTEXT`Kontext von Microsoft. Beachten Sie, dass der unmittelbare Aufrufer dieses Konstruktors die Berechtigung "nicht verwalteter Code" erfordert.  
  
> [!IMPORTANT]
>  Der-Konstruktor erstellt eine Kopie des Zertifikat Kontexts. Gehen Sie nicht davon aus, dass die an den Konstruktor übergebenen Kontext Struktur gültig ist. Möglicherweise wurde sie freigegeben. Sie können eine Kopie der aktuellen `PCCERT_CONTEXT` -Struktur aus der <xref:System.Security.Cryptography.X509Certificates.X509Certificate.Handle%2A> -Eigenschaft erhalten, Sie ist jedoch nur <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> während der Lebensdauer des-Objekts gültig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  
  
–   Die Zertifikatsdatei ist nicht vorhanden.  
  
–   The certificate is invalid (Das Zertifikat ist ungültig).  
  
–   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (System.Security.Cryptography.X509Certificates.X509Certificate certificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.X509Certificates.X509Certificate certificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (certificate As X509Certificate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::Security::Cryptography::X509Certificates::X509Certificate ^ certificate);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 certificate" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="certificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="certificate">Ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" />-Objekt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse mit einem <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine neue Instanz der- <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Klasse unter Verwendung <xref:System.Security.Cryptography.X509Certificates.X509Certificate> eines-Objekts.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  
  
–   Die Zertifikatsdatei ist nicht vorhanden.  
  
–   The certificate is invalid (Das Zertifikat ist ungültig).  
  
–   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : string -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <summary>Initialisiert mithilfe eines Zertifikatsdateinamens eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt unter Verwendung eines Zertifikats Dateinamens. Sie unterstützt die binäre Codierung (der) oder die Base64-Codierung.  
  
 Wenn Sie ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Zertifikat erstellen, indem Sie einen PKCS7-signierten Dateispeicher <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> für `fileName`angeben, wird der für das Zertifikat erstellt, das den Speicher signiert hat, und nicht für eines der Zertifikate im Speicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  
  
–   Die Zertifikatsdatei ist nicht vorhanden.  
  
–   The certificate is invalid (Das Zertifikat ist ungültig).  
  
–   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, System.Security.SecureString password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, class System.Security.SecureString password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As SecureString)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::Security::SecureString ^ password);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : byte[] * System.Security.SecureString -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (rawData, password)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray, das Daten aus einem X.509-Zertifikat enthält.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse mit einem Bytearray und einem Kennwort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird mit PKCS12 (PFX)-Dateien verwendet, die den privaten Schlüssel des Zertifikats enthalten. Wenn Sie diesen Konstruktor mit dem richtigen Kennwort aufrufen, wird der private Schlüssel entschlüsselt und in einem Schlüssel Container gespeichert.  
  
> [!IMPORTANT]
>  Niemals hart codiert ein Kennwort innerhalb Ihres Quellcodes.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem Hexadezimal-Editor oder einfach in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
 Wenn Sie ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate> Zertifikat erstellen, indem Sie einen PKCS7-signierten Dateispeicher <xref:System.Security.Cryptography.X509Certificates.X509Certificate> für `rawData`angeben, wird der für das Zertifikat erstellt, das den Speicher signiert hat, und nicht für eines der Zertifikate im Speicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  
  
–   Die Zertifikatsdatei ist nicht vorhanden.  
  
–   The certificate is invalid (Das Zertifikat ist ungültig).  
  
–   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::String ^ password);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : byte[] * string -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (rawData, password)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray mit Daten aus einem X.509-Zertifikat.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse mit einem Bytearray und einem Kennwort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt mit einem Bytearray und einem Kennwort, das für den Zugriff auf die Zertifikat Daten erforderlich ist. Es wird mit PKCS12 (PFX)-Dateien verwendet, die den privaten Schlüssel des Zertifikats enthalten. Wenn Sie diesen Konstruktor mit dem richtigen Kennwort aufrufen, wird der private Schlüssel entschlüsselt und in einem Schlüssel Container gespeichert.  
  
> [!IMPORTANT]
>  Niemals hart codiert ein Kennwort innerhalb Ihres Quellcodes.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem Hexadezimal-Editor oder einfach in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
 Wenn Sie ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Zertifikat erstellen, indem Sie einen PKCS7-signierten Dateispeicher <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> für `rawData`angeben, wird der für das Zertifikat erstellt, das den Speicher signiert hat, und nicht für eines der Zertifikate im Speicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  
  
–   Die Zertifikatsdatei ist nicht vorhanden.  
  
–   The certificate is invalid (Das Zertifikat ist ungültig).  
  
–   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected X509Certificate2 (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; X509Certificate2(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Die Serialisierungsinformationen, die zum Deserialisieren des neuen <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> erforderlich sind.</param>
        <param name="context">Kontextinformationen zur Quelle des Streams, der deserialisiert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse mit den angegebenen Serialisierungs- und Streamkontextinformationen.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: In allen Fällen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, System.Security.SecureString password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, class System.Security.SecureString password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As SecureString)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::Security::SecureString ^ password);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : string * System.Security.SecureString -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (fileName, password)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <summary>Initialisiert mithilfe eines Zertifikatsdateinamens und eines Kennworts eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird mit PKCS12 (PFX)-Dateien verwendet, die den privaten Schlüssel des Zertifikats enthalten. Wenn Sie diesen Konstruktor mit dem richtigen Kennwort aufrufen, wird der private Schlüssel entschlüsselt und in einem Schlüssel Container gespeichert.  
  
> [!IMPORTANT]
>  Niemals hart codiert ein Kennwort innerhalb Ihres Quellcodes.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem Hexadezimal-Editor oder einfach in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
 Wenn Sie ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate> Zertifikat erstellen, indem Sie einen PKCS7-signierten Dateispeicher <xref:System.Security.Cryptography.X509Certificates.X509Certificate> für `fileName`angeben, wird der für das Zertifikat erstellt, das den Speicher signiert hat, und nicht für eines der Zertifikate im Speicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  
  
–   Die Zertifikatsdatei ist nicht vorhanden.  
  
–   The certificate is invalid (Das Zertifikat ist ungültig).  
  
–   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::String ^ password);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : string * string -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (fileName, password)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <summary>Initialisiert mithilfe des Zertifikatsdateinamens und eines für den Zugriff auf das Zertifikat verwendeten Kennworts eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt unter Verwendung eines Zertifikats Dateinamens und eines für den Zugriff auf das Zertifikat erforderlichen Kennworts. Es wird mit PKCS12 (PFX)-Dateien verwendet, die den privaten Schlüssel des Zertifikats enthalten. Wenn Sie diesen Konstruktor mit dem richtigen Kennwort aufrufen, wird der private Schlüssel entschlüsselt und in einem Schlüssel Container gespeichert.  
  
> [!IMPORTANT]
>  Niemals hart codiert ein Kennwort innerhalb Ihres Quellcodes.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem Hexadezimal-Editor oder einfach in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
 Wenn Sie ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Zertifikat erstellen, indem Sie einen PKCS7-signierten Dateispeicher <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> für `fileName`angeben, wird der für das Zertifikat erstellt, das den Speicher signiert hat, und nicht für eines der Zertifikate im Speicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  
  
–   Die Zertifikatsdatei ist nicht vorhanden.  
  
–   The certificate is invalid (Das Zertifikat ist ungültig).  
  
–   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : byte[] * System.Security.SecureString * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (rawData, password, keyStorageFlags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray, das Daten aus einem X.509-Zertifikat enthält.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse mit einem Bytearray, einem Kennwort und einem Schlüsselspeicherflag.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird mit PKCS12 (PFX)-Dateien verwendet, die den privaten Schlüssel des Zertifikats enthalten. Wenn Sie diesen Konstruktor mit dem richtigen Kennwort aufrufen, wird der private Schlüssel entschlüsselt und in einem Kryptografiedienstanbieter (Cryptographic Service Provider, CSP) von Microsoft Cryptographic implementiert.  
  
> [!IMPORTANT]
>  Niemals hart codiert ein Kennwort innerhalb Ihres Quellcodes.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem Hexadezimal-Editor oder einfach in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
 Wenn Sie ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate> Zertifikat erstellen, indem Sie einen PKCS7-signierten Dateispeicher <xref:System.Security.Cryptography.X509Certificates.X509Certificate> für `rawData`angeben, wird der für das Zertifikat erstellt, das den Speicher signiert hat, und nicht für eines der Zertifikate im Speicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  
  
–   Die Zertifikatsdatei ist nicht vorhanden.  
  
–   The certificate is invalid (Das Zertifikat ist ungültig).  
  
–   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : byte[] * string * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (rawData, password, keyStorageFlags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray mit Daten aus einem X.509-Zertifikat.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse mit einem Bytearray, einem Kennwort und einem Schlüsselspeicherflag.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt mit einem Bytearray, einem Kennwort, das für den Zugriff auf die Zertifikat Daten benötigt wird, und einem Schlüsselspeicherflag. Es wird mit PKCS12 (PFX)-Dateien verwendet, die den privaten Schlüssel des Zertifikats enthalten. Wenn Sie diesen Konstruktor mit dem richtigen Kennwort aufrufen, wird der private Schlüssel entschlüsselt und in einem Kryptografiedienstanbieter (Cryptographic Service Provider, CSP) von Microsoft Cryptographic implementiert.  
  
> [!IMPORTANT]
>  Niemals hart codiert ein Kennwort innerhalb Ihres Quellcodes.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem Hexadezimal-Editor oder einfach in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
 Wenn Sie ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Zertifikat erstellen, indem Sie einen PKCS7-signierten Dateispeicher <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> für `rawData`angeben, wird der für das Zertifikat erstellt, das den Speicher signiert hat, und nicht für eines der Zertifikate im Speicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  
  
–   Die Zertifikatsdatei ist nicht vorhanden.  
  
–   The certificate is invalid (Das Zertifikat ist ungültig).  
  
–   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : string * System.Security.SecureString * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (fileName, password, keyStorageFlags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Initialisiert mithilfe eines Zertifikatsdateinamens, eines Kennworts und eines Schlüsselspeicherflags eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate> Zertifikat erstellen, indem Sie einen PKCS7-signierten Dateispeicher <xref:System.Security.Cryptography.X509Certificates.X509Certificate> für `fileName`angeben, wird der für das Zertifikat erstellt, das den Speicher signiert hat, und nicht für eines der Zertifikate im Speicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  
  
–   Die Zertifikatsdatei ist nicht vorhanden.  
  
–   The certificate is invalid (Das Zertifikat ist ungültig).  
  
–   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : string * string * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (fileName, password, keyStorageFlags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Initialisiert mithilfe eines Zertifikatsdateinamens, eines für den Zugriff auf das Zertifikat verwendeten Kennworts und eines Schlüsselspeicherflags eine neue Instanz der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein neues <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt unter Verwendung eines Zertifikats Dateinamens, eines für den Zugriff auf das Zertifikat erforderlichen Kennworts und eines Schlüsselspeicherflags.  
  
> [!IMPORTANT]
>  Niemals hart codiert ein Kennwort innerhalb Ihres Quellcodes.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem Hexadezimal-Editor oder einfach in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
 Wenn Sie ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Zertifikat erstellen, indem Sie einen PKCS7-signierten Dateispeicher <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> für `fileName`angeben, wird der für das Zertifikat erstellt, das den Speicher signiert hat, und nicht für eines der Zertifikate im Speicher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zertifikatfehler. Beispiel:  
  
–   Die Zertifikatsdatei ist nicht vorhanden.  
  
–   The certificate is invalid (Das Zertifikat ist ungültig).  
  
–   The certificate's password is incorrect (Das Kennwort des Zertifikats ist falsch).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Archived">
      <MemberSignature Language="C#" Value="public bool Archived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archived" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Archived" />
      <MemberSignature Language="VB.NET" Value="Public Property Archived As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archived { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archived : bool with get, set" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.Archived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, dass ein X.509-Zertifikat archiviert wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn das Zertifikat archiviert wird, <see langword="false" />, wenn das Zertifikat nicht archiviert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird nur für ein Zertifikat festgelegt, das einem Speicher zugeordnet ist. Wenn die-Eigenschaft festgelegt ist und das Zertifikat einem Zertifikat Speicher hinzugefügt wird, wird der Wert persistent gespeichert. Wenn die Eigenschaft für ein Zertifikat festgelegt wird, das aus einem Speicher abgerufen wurde, wird der Wert sofort persistent gespeichert.  
  
 In einem X. 509-Speicher sind Archivierte Zertifikate nicht im zurückgegebenen <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> -Objekt enthalten <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.Archived%2A> , es sei denn `true`, die-Eigenschaft ist auf festgelegt. Wenn der <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.Archived%2A> Wert festgelegt oder nicht festgelegt ist, erfolgt keine physische Archivierung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikat Speicher des aktuellen Benutzers geöffnet, nur aktive Zertifikate ausgewählt und der Benutzer dann die Auswahl eines oder mehrerer Zertifikate ermöglicht. Im Beispiel werden dann Zertifikat Informationen in die Konsole geschrieben.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Export">
      <MemberSignature Language="C#" Value="public override byte[] Export (System.Security.Cryptography.X509Certificates.X509ContentType contentType, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] Export(valuetype System.Security.Cryptography.X509Certificates.X509ContentType contentType, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Export(System.Security.Cryptography.X509Certificates.X509ContentType,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Export (contentType As X509ContentType, password As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ Export(System::Security::Cryptography::X509Certificates::X509ContentType contentType, System::String ^ password);" />
      <MemberSignature Language="F#" Value="override this.Export : System.Security.Cryptography.X509Certificates.X509ContentType * string -&gt; byte[]" Usage="x509Certificate2.Export (contentType, password)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("X509ContentType.SerializedCert is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentType" Type="System.Security.Cryptography.X509Certificates.X509ContentType" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="password" Type="System.String" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="contentType">To be added.</param>
        <param name="password">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509ExtensionCollection Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509ExtensionCollection Extensions" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As X509ExtensionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509ExtensionCollection ^ Extensions { System::Security::Cryptography::X509Certificates::X509ExtensionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extensions : System.Security.Cryptography.X509Certificates.X509ExtensionCollection" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.Extensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509ExtensionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von <see cref="T:System.Security.Cryptography.X509Certificates.X509Extension" />-Objekten ab.</summary>
        <value>Ein <see cref="T:System.Security.Cryptography.X509Certificates.X509ExtensionCollection" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit den im X. 509 v3-Zertifikat Format definierten Erweiterungen können zusätzliche Daten in das Zertifikat eingeschlossen werden. Eine Reihe von Erweiterungen werden durch ISO in der X. 509 v3-Definition sowie durch PKIX in RFC 3280, "[Zertifikat-und Zertifikat Sperr Listen Profil (CRL)](https://go.microsoft.com/fwlink/?LinkId=45286)" definiert. Allgemeine Erweiterungen enthalten Informationen zur Schlüssel Verwendung (<xref:System.Security.Cryptography.X509Certificates.X509KeyUsageExtension>), zu Schlüssel Bezeichnerzeichen (<xref:System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension>), Zertifikat Richtlinien, Sperrinformationen (CRL-Verteilungs Punkt Erweiterung) und anderen Verwendungsmöglichkeiten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikat Speicher des aktuellen Benutzers geöffnet, nur aktive Zertifikate ausgewählt und der Benutzer dann die Auswahl eines oder mehrerer Zertifikate ermöglicht. Im Beispiel werden dann Zertifikat Informationen in die Konsole geschrieben.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string with get, set" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.FriendlyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den einem Zertifikat zugeordneten Alias ab oder legt diesen fest.</summary>
        <value>Der angezeigte Name des Zertifikats.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anzeigen Amen sind Eigenschaften im X. 509-Zertifikat Speicher, die festgelegt werden können. Sie werden verwendet, um es Benutzern zu ermöglichen, Aliase mit Zertifikaten zuzuordnen, damit Sie problemlos identifiziert werden können.  
  
 Wenn kein Anzeige Name für das Zertifikat vorhanden ist, wird eine leere Zeichenfolge ("") zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCertContentType">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Typ des in einem Bytearray oder in einer Datei enthaltenen Zertifikats an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCertContentType">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType (byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType(unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCertContentType (rawData As Byte()) As X509ContentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::X509Certificates::X509ContentType GetCertContentType(cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member GetCertContentType : byte[] -&gt; System.Security.Cryptography.X509Certificates.X509ContentType" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType rawData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Detection limited to Cert, Pfx, Pkcs12, Pkcs7 and Unknown")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509ContentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray mit Daten aus einem X.509-Zertifikat.</param>
        <summary>Gibt den Typ des in einem Bytearray enthaltenen Zertifikats an.</summary>
        <returns>Ein <see cref="T:System.Security.Cryptography.X509Certificates.X509ContentType" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht es Ihnen, den Typ des Zertifikats in einer Datei zu ermitteln.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikat Speicher des aktuellen Benutzers geöffnet, nur aktive Zertifikate ausgewählt und der Benutzer dann die Auswahl eines oder mehrerer Zertifikate ermöglicht. Im Beispiel werden dann Zertifikat Informationen in die Konsole geschrieben.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rawData" /> hat die Länge 0 (null) oder ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCertContentType">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCertContentType (fileName As String) As X509ContentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::X509Certificates::X509ContentType GetCertContentType(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member GetCertContentType : string -&gt; System.Security.Cryptography.X509Certificates.X509ContentType" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Detection limited to Cert, Pfx, Pkcs12 and Unknown")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509ContentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <summary>Gibt den Typ des in einer Datei enthaltenen Zertifikats an.</summary>
        <returns>Ein <see cref="T:System.Security.Cryptography.X509Certificates.X509ContentType" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht es Ihnen, den Typ des Zertifikats in einer Datei zu ermitteln.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen des Zertifikats. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumeration:<see cref="F:System.IO.FileAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetNameInfo">
      <MemberSignature Language="C#" Value="public string GetNameInfo (System.Security.Cryptography.X509Certificates.X509NameType nameType, bool forIssuer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetNameInfo(valuetype System.Security.Cryptography.X509Certificates.X509NameType nameType, bool forIssuer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetNameInfo(System.Security.Cryptography.X509Certificates.X509NameType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNameInfo (nameType As X509NameType, forIssuer As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetNameInfo(System::Security::Cryptography::X509Certificates::X509NameType nameType, bool forIssuer);" />
      <MemberSignature Language="F#" Value="member this.GetNameInfo : System.Security.Cryptography.X509Certificates.X509NameType * bool -&gt; string" Usage="x509Certificate2.GetNameInfo (nameType, forIssuer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("always return String.Empty for UpnName, DnsFromAlternativeName and UrlName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nameType" Type="System.Security.Cryptography.X509Certificates.X509NameType" />
        <Parameter Name="forIssuer" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nameType">Der <see cref="T:System.Security.Cryptography.X509Certificates.X509NameType" /> -Wert für den Antragsteller.</param>
        <param name="forIssuer"><see langword="true" />, um den Namen des Ausstellers einzufügen, andernfalls <see langword="false" />.</param>
        <summary>Ruft den die Namen des Zertifikatsantragstellers und des Zertifikatausstellers ab.</summary>
        <returns>Der Name des Zertifikats.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte immer anstelle des Zertifikats verwendet werden, da sich viele der namens Werte an mehreren Speicherorten befinden können. Mit dieser Methode wird sichergestellt, dass der entsprechende Name zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikat Speicher des aktuellen Benutzers geöffnet, nur aktive Zertifikate ausgewählt und der Benutzer dann die Auswahl eines oder mehrerer Zertifikate ermöglicht. Im Beispiel werden dann Zertifikat Informationen in die Konsole geschrieben.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasPrivateKey">
      <MemberSignature Language="C#" Value="public bool HasPrivateKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasPrivateKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.HasPrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasPrivateKey As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasPrivateKey { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasPrivateKey : bool" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.HasPrivateKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt einen privaten Schlüssel enthält.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt einen privaten Schlüssel enthält, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Zertifikatskontext ist ungültig.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Import">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mit den bereitgestellten Zertifikatsinformationen auf.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="override this.Import : byte[] -&gt; unit" Usage="x509Certificate2.Import rawData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray mit Daten aus einem X.509-Zertifikat.</param>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mit Daten aus einem Bytearray auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um ein unformatierte Bytearray für ein X. 509-Zertifikat <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> zu erstellen und das Objekt mit den zugehörigen Werten zu füllen.  
  
 Da diese Methode nur ein Bytearray akzeptiert, kann Sie nur für Zertifikat Typen verwendet werden, für die kein Kennwort erforderlich ist, einschließlich eines Base64-codierten oder der-codierten X. 509-Zertifikats oder eines PFX/PKCS12-Zertifikats. Beachten Sie, dass ein PFX/PKCS12-Zertifikat mehr als ein Zertifikat enthalten kann. In diesem Fall wird das erste Zertifikat verwendet, das einem privaten Schlüssel zugeordnet ist, oder, wenn kein privater Schlüssel gefunden wird, wird das erste Zertifikat verwendet.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für die volle Vertrauenswürdigkeit des unmittelbaren Aufrufers. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für vollständige Vertrauenswürdigkeit für Vererber. Dieser Member kann nicht von teilweise vertrauenswürdigem Code geerbt werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="override this.Import : string -&gt; unit" Usage="x509Certificate2.Import fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name eines Zertifikats.</param>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mit Informationen aus einer Zertifikatsdatei auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet eine Zertifikatsdatei, z. b. eine Datei mit der Erweiterung. CER, die ein X. 509-Zertifikat darstellt und <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> das-Objekt mit dem in der Datei enthaltenen Zertifikat füllt.  
  
 Diese Methode kann mit mehreren Zertifikat Typen verwendet werden, darunter Base64-codierte oder der-codierte X. 509-Zertifikate, PFX/PKCS12-Zertifikate und Signatur Geber Zertifikate wie Authenticode. Beachten Sie, dass ein PFX/PKCS12-Zertifikat mehr als ein Zertifikat enthalten kann. In diesem Fall wird das erste Zertifikat verwendet, das einem privaten Schlüssel zugeordnet ist, oder, wenn kein privater Schlüssel gefunden wird, wird das erste Zertifikat verwendet.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für die volle Vertrauenswürdigkeit des unmittelbaren Aufrufers. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für vollständige Vertrauenswürdigkeit für Vererber. Dieser Member kann nicht von teilweise vertrauenswürdigem Code geerbt werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (byte[] rawData, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(unsigned int8[] rawData, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[],System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (rawData As Byte(), password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(cli::array &lt;System::Byte&gt; ^ rawData, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="override this.Import : byte[] * System.Security.SecureString * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit" Usage="x509Certificate2.Import (rawData, password, keyStorageFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("SecureString is incomplete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray, das Daten aus einem X.509-Zertifikat enthält.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mithilfe der Daten aus einem Bytearray, eines Kennworts und eines Schlüsselspeicherflags auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode für Zertifikat Typen wie z. b. Base64-codierte oder der-codierte X. 509-Zertifikate oder PFX/PKCS12-Zertifikate verwenden. Beachten Sie, dass ein PFX/PKCS12-Zertifikat mehr als ein Zertifikat enthalten kann. In diesem Fall wird das erste Zertifikat verwendet, das einem privaten Schlüssel zugeordnet ist, oder, wenn kein privater Schlüssel gefunden wird, wird das erste Zertifikat verwendet.  
  
> [!IMPORTANT]
>  Niemals hart codiert ein Kennwort innerhalb Ihres Quellcodes.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem Hexadezimal-Editor oder einfach in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für die volle Vertrauenswürdigkeit des unmittelbaren Aufrufers. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für vollständige Vertrauenswürdigkeit für Vererber. Dieser Member kann nicht von teilweise vertrauenswürdigem Code geerbt werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (byte[] rawData, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(unsigned int8[] rawData, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (rawData As Byte(), password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(cli::array &lt;System::Byte&gt; ^ rawData, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="override this.Import : byte[] * string * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit" Usage="x509Certificate2.Import (rawData, password, keyStorageFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("missing KeyStorageFlags support")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawData">Ein Bytearray mit Daten aus einem X.509-Zertifikat.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mithilfe der Daten aus einem Bytearray, eines Kennworts und von Flags auf, mit denen bestimmt werden kann, wie der private Schlüssel importiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> -Objekt mit einem Kennwort für das durch das Bytearray dargestellte Zertifikat aufzufüllen. Der <xref:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags> -Wert kann verwendet werden, um zu steuern, wo und wie der private Schlüssel importiert werden soll.  
  
 Diese Methode akzeptiert ein Bytearray und kann für Zertifikat Typen wie Base64-codierte oder der-codierte X. 509-Zertifikate oder PFX/PKCS12-Zertifikate verwendet werden. Beachten Sie, dass ein PFX/PKCS12-Zertifikat mehr als ein Zertifikat enthalten kann. In diesem Fall wird das erste Zertifikat verwendet, das einem privaten Schlüssel zugeordnet ist, oder, wenn kein privater Schlüssel gefunden wird, wird das erste Zertifikat verwendet.  
  
> [!IMPORTANT]
>  Niemals hart codiert ein Kennwort innerhalb Ihres Quellcodes.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem Hexadezimal-Editor oder einfach in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für die volle Vertrauenswürdigkeit des unmittelbaren Aufrufers. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für vollständige Vertrauenswürdigkeit für Vererber. Dieser Member kann nicht von teilweise vertrauenswürdigem Code geerbt werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (string fileName, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(string fileName, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String,System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (fileName As String, password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(System::String ^ fileName, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="override this.Import : string * System.Security.SecureString * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit" Usage="x509Certificate2.Import (fileName, password, keyStorageFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("SecureString is incomplete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mit Informationen aus einer Zertifikatsdatei, einem Kennwort und einem Schlüsselspeicherflag auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Sicherheitshinweis** Niemals hart codiert ein Kennwort innerhalb Ihres Quellcodes.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem Hexadezimal-Editor oder einfach in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für die volle Vertrauenswürdigkeit des unmittelbaren Aufrufers. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für die volle Vertrauenswürdigkeit des unmittelbaren Aufrufers. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (string fileName, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(string fileName, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (fileName As String, password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(System::String ^ fileName, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="override this.Import : string * string * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit" Usage="x509Certificate2.Import (fileName, password, keyStorageFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("missing KeyStorageFlags support")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Zertifikatsdatei.</param>
        <param name="password">Das für den Zugriff auf die X.509-Zertifikatsdaten erforderliche Kennwort.</param>
        <param name="keyStorageFlags">Eine bitweise Kombination der Enumerationswerte, die steuern wo und wie das Zertifikat importiert wird.</param>
        <summary>Füllt ein <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekt mit Informationen aus einer Zertifikatsdatei, einem Kennwort und einem <see cref="T:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />-Wert auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> Objekt mit Informationen aus einer Zertifikatsdatei, einem Kennwort und einem <xref:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags> -Wert aufzufüllen.  
  
> [!IMPORTANT]
>  Niemals hart codiert ein Kennwort innerhalb Ihres Quellcodes.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), einem Hexadezimal-Editor oder einfach in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für die volle Vertrauenswürdigkeit des unmittelbaren Aufrufers. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für vollständige Vertrauenswürdigkeit für Vererber. Dieser Member kann nicht von teilweise vertrauenswürdigem Code geerbt werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="IssuerName">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X500DistinguishedName IssuerName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X500DistinguishedName IssuerName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.IssuerName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IssuerName As X500DistinguishedName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ IssuerName { System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IssuerName : System.Security.Cryptography.X509Certificates.X500DistinguishedName" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.IssuerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X500DistinguishedName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Distinguished Name des Zertifikatausstellers ab.</summary>
        <value>Ein <see cref="T:System.Security.Cryptography.X509Certificates.X500DistinguishedName" />-Objekt, das den Namen des Zertifikatausstellers enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft enthält den Namen der Zertifizierungsstelle (Certificate Authority, ca), die das Zertifikat ausgestellt hat. Um den Namen eines Zertifikats abzurufen, verwenden Sie die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.GetNameInfo%2A> -Methode.  
  
 Der Distinguished Name für das Zertifikat ist eine Textdarstellung des Zertifikatsantragstellers oder des Zertifikatausstellers. Diese Darstellung besteht aus namens Attributen (z. b. "CN = MyName, ou = MyOrgUnit, C = US").  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Zertifikatskontext ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotAfter">
      <MemberSignature Language="C#" Value="public DateTime NotAfter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime NotAfter" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.NotAfter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NotAfter As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime NotAfter { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.NotAfter : DateTime" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.NotAfter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Datum in Ortszeit ab, ab dem ein Zertifikat nicht mehr gültig ist.</summary>
        <value>Ein <see cref="T:System.DateTime" />-Objekt, das das Ablaufdatum des Zertifikats darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt ein Ablaufdatum an, an dem das Zertifikat ungültig wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotBefore">
      <MemberSignature Language="C#" Value="public DateTime NotBefore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime NotBefore" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.NotBefore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NotBefore As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime NotBefore { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.NotBefore : DateTime" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.NotBefore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Datum in Ortszeit ab, ab dem ein Zertifikat gültig wird.</summary>
        <value>Ein <see cref="T:System.DateTime" />-Objekt, das das Datum darstellt, an dem das Zertifikat gültig wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt das Datum an, an dem das Zertifikat gültig wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="PrivateKey">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.AsymmetricAlgorithm PrivateKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.AsymmetricAlgorithm PrivateKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateKey As AsymmetricAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::AsymmetricAlgorithm ^ PrivateKey { System::Security::Cryptography::AsymmetricAlgorithm ^ get(); void set(System::Security::Cryptography::AsymmetricAlgorithm ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateKey : System.Security.Cryptography.AsymmetricAlgorithm with get, set" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.PrivateKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.AsymmetricAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />-Objekt ab, das den einem Zertifikat zugeordneten privaten Schlüssel darstellt oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />-Objekt, das einen kryptografischen Dienstanbieter für RSA oder DSA darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft unterstützt derzeit nur RSA-oder DSA-Schlüssel, sodass entweder <xref:System.Security.Cryptography.RSA> ein- <xref:System.Security.Cryptography.DSA> Objekt oder ein-Objekt <xref:System.Security.Cryptography.RSACryptoServiceProvider> in .net Core <xref:System.Security.Cryptography.DSACryptoServiceProvider> oder ein-Objekt oder ein-Objekt in .NET Framework zurückgegeben wird. Wenn dem Zertifikat kein privater Schlüssel zugeordnet ist, wird zurück `null`gegeben.  
  
> [!WARNING]
>  Wenn Sie diese Eigenschaft `null` auf oder auf einen anderen Schlüssel festlegen, ohne Sie zuerst zu löschen, wird eine Datei mit einem privaten Schlüssel auf dem Datenträger belassen.  
  
 Legen Sie zum ordnungsgemäßen Löschen des privaten Schlüssels, der dieser `PersistKeyInCsp` Eigenschaft `false`zugeordnet ist, auf fest <xref:System.Security.Cryptography.AsymmetricAlgorithm.Clear%2A> , und klicken Sie dann auf die-Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikat Speicher des aktuellen Benutzers geöffnet, nur aktive Zertifikate ausgewählt und der Benutzer dann die Auswahl eines oder mehrerer Zertifikate ermöglicht. Im Beispiel werden dann Zertifikat Informationen in die Konsole geschrieben.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüsselwert ist kein RSA- oder DSA-Schlüssel, oder der Schlüssel kann nicht gelesen werden.</exception>
        <exception cref="T:System.ArgumentNullException">Der Wert, der für diese Eigenschaft festgelegt wird, ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Der Schlüsselalgorithmus für diesen privaten Schlüssel wird nicht unterstützt.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Die X.509-Schlüssel stimmen nicht überein.</exception>
        <exception cref="T:System.ArgumentException">Der Schlüssel des Kryptografiedienstanbieters ist <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Es wurde versucht, diese Eigenschaft festzulegen.</exception>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.PublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.PublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PublicKey As PublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::PublicKey ^ PublicKey { System::Security::Cryptography::X509Certificates::PublicKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PublicKey : System.Security.Cryptography.X509Certificates.PublicKey" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.PublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" />-Objekt ab, das einem Zertifikat zugeordnet ist.</summary>
        <value>Ein <see cref="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt ein <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey%2A> -Objekt zurück, das den Objekt Bezeichner (<xref:System.Security.Cryptography.Oid>), der den Algorithmus für öffentliche Schlüssel darstellt, die ASN. 1-codierten Parameter und den ASN. 1-codierten Schlüsselwert enthält.  
  
 Sie können den Schlüssel auch als <xref:System.Security.Cryptography.AsymmetricAlgorithm> Objekt abrufen, indem Sie auf die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey%2A> -Eigenschaft verweisen. Diese Eigenschaft unterstützt nur RSA-oder DSA-Schlüssel, sodass entweder <xref:System.Security.Cryptography.RSACryptoServiceProvider> ein- <xref:System.Security.Cryptography.DSACryptoServiceProvider> Objekt oder ein-Objekt zurückgegeben wird, das den öffentlichen Schlüssel darstellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüsselwert ist kein RSA- oder DSA-Schlüssel, oder der Schlüssel kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="RawData">
      <MemberSignature Language="C#" Value="public byte[] RawData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] RawData" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.RawData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawData As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ RawData { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawData : byte[]" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.RawData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Rohdaten eines Zertifikats ab.</summary>
        <value>Die Rohdaten des Zertifikats als Bytearray.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Reset();" />
      <MemberSignature Language="F#" Value="override this.Reset : unit -&gt; unit" Usage="x509Certificate2.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Zustand eines <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Objekts zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um den Status des Zertifikats zurückzusetzen. Außerdem werden alle Ressourcen freigegeben, die dem Zertifikat zugeordnet sind.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für die volle Vertrauenswürdigkeit des unmittelbaren Aufrufers. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für vollständige Vertrauenswürdigkeit für Vererber. Dieser Member kann nicht von teilweise vertrauenswürdigem Code geerbt werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SerialNumber">
      <MemberSignature Language="C#" Value="public string SerialNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SerialNumber" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.SerialNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerialNumber As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SerialNumber { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SerialNumber : string" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.SerialNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Seriennummer eines Zertifikats als hexadezimale Big-Endian-Zeichenfolge ab.</summary>
        <value>Die Seriennummer des Zertifikats als hexadezimale Zeichenfolge im Big-Endian-Format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Seriennummer des Zertifikats ist Teil des ursprünglichen X. 509-Protokolls. Die Seriennummer ist eine eindeutige Nummer des Zertifikat Ausstellers, die auch als Zertifizierungsstelle (ca) bezeichnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Oid SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Oid SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SignatureAlgorithm As Oid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Oid ^ SignatureAlgorithm { System::Security::Cryptography::Oid ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignatureAlgorithm : System.Security.Cryptography.Oid" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.SignatureAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Oid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zum Erstellen der Signatur eines Zertifikats verwendeten Algorithmus ab.</summary>
        <value>Der Objekt Bezeichner des Signatur Algorithmus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Objekt Bezeichner<xref:System.Security.Cryptography.Oid>() identifiziert den Typ des Signatur Algorithmus, der vom Zertifikat verwendet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikat Speicher des aktuellen Benutzers geöffnet, nur aktive Zertifikate ausgewählt und der Benutzer dann die Auswahl eines oder mehrerer Zertifikate ermöglicht. Im Beispiel werden dann Zertifikat Informationen in die Konsole geschrieben.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubjectName">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X500DistinguishedName SubjectName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X500DistinguishedName SubjectName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.SubjectName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubjectName As X500DistinguishedName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ SubjectName { System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SubjectName : System.Security.Cryptography.X509Certificates.X500DistinguishedName" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.SubjectName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X500DistinguishedName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Distinguished Name für den Antragsteller aus einem Zertifikat ab.</summary>
        <value>Ein <see cref="T:System.Security.Cryptography.X509Certificates.X500DistinguishedName" />-Objekt, das den Namen des Zertifikatsantragstellers darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Distinguished Name des Antragstellers ist der Name des Benutzers des Zertifikats. Der Distinguished Name für das Zertifikat ist eine Textdarstellung des Antragstellers oder des Ausstellers des Zertifikats. Diese Darstellung besteht aus namens Attributen, z. b. "CN = MyName, ou = MyOrgUnit, C = US".  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Zertifikatskontext ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Thumbprint">
      <MemberSignature Language="C#" Value="public string Thumbprint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Thumbprint" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Thumbprint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thumbprint As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Thumbprint { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Thumbprint : string" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.Thumbprint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Fingerabdruck eines Zertifikats ab.</summary>
        <value>Der Fingerabdruck des Zertifikats.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Fingerabdruck wird dynamisch mit dem SHA1-Algorithmus generiert und ist nicht physisch im Zertifikat vorhanden. Da der Fingerabdruck ein eindeutiger Wert für das Zertifikat ist, wird er häufig verwendet, um ein bestimmtes Zertifikat in einem Zertifikat Speicher zu finden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeigt ein X.509-Zertifikat in Textformat an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="x509Certificate2.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zeigt ein X.509-Zertifikat in Textformat an.</summary>
        <returns>Die Zertifikatsinformationen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wie bei allen `ToString` Methoden ist die Ausgabe möglicherweise nicht über die Versionen der .NET Framework hinweg konsistent, sodass die Methoden Ergebnisse nicht für den Inhalt analysiert werden sollten. Verwenden Sie die Eigenschaften <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> des-Objekts, um genaue Informationen über den Inhalt zu erhalten, oder verwenden Sie die <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString%2A> -Methode, um Informationen über das Zertifikat abzurufen.  
  
 Diese Methode zeigt das Zertifikat im Textformat an.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString (bool verbose);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString(bool verbose) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString (verbose As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString(bool verbose);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool -&gt; string" Usage="x509Certificate2.ToString verbose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="verbose" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="verbose"><see langword="true" />, um den öffentlichen Schlüssel, den privaten Schlüssel, Erweiterungen usw. anzuzeigen, <see langword="false" />, um Informationen anzuzeigen, die denen der <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />-Klasse ähneln, z. B. Fingerabdruck, Seriennummer, Name von Antragsteller und Aussteller usw.</param>
        <summary>Zeigt ein X.509-Zertifikat in Textformat an.</summary>
        <returns>Die Zertifikatsinformationen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wie bei allen `ToString` Methoden ist die Ausgabe möglicherweise nicht über die Versionen der .NET Framework hinweg konsistent, sodass die Methoden Ergebnisse nicht für den Inhalt analysiert werden sollten. Verwenden Sie die Eigenschaften <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> des-Objekts, um genaue Informationen zu erhalten.  
  
 Diese Methode zeigt das Zertifikat im Textformat an. Wenn der `verbose` -Parameter auf `true`festgelegt ist, enthält die Textanzeige den öffentlichen Schlüssel, den privaten Schlüssel und die Erweiterungen. Wenn `verbose` auf`false`festgelegt ist, enthält die Textanzeige die Felder, die aus dem X. 509-Zertifikat verfügbar sind, einschließlich Fingerabdruck, Seriennummer, Antragsteller-und Aussteller Namen sowie Informationen zum Gültigkeitsdatum.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Verify">
      <MemberSignature Language="C#" Value="public bool Verify ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Verify() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Verify" />
      <MemberSignature Language="VB.NET" Value="Public Function Verify () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Verify();" />
      <MemberSignature Language="F#" Value="member this.Verify : unit -&gt; bool" Usage="x509Certificate2.Verify " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("by default this depends on the incomplete X509Chain")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt mithilfe von Basisvalidierungsrichtlinien eine Validierung von X.509-Ketten aus.</summary>
        <returns><see langword="true" />, wenn die Validierung erfolgreich ist; <see langword="false" /> im Falle eines Validierungsfehlers.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine einfache Kette für das Zertifikat und wendet die Basis Richtlinie auf diese Kette an. Wenn Sie weitere Informationen zu einem Fehler benötigen, überprüfen Sie das Zertifikat direkt <xref:System.Security.Cryptography.X509Certificates.X509Chain> mithilfe des-Objekts.  
  
 Beachten Sie, dass die standardverkettungs-Engine mithilfe <xref:System.Security.Cryptography.CryptoConfig> der-Klasse überschrieben werden kann. Unter Microsoft Windows Server 2003 entspricht die Standard-Engine der Spezifikation, die in RFC3280, "[Zertifikat-und Zertifikat Sperr Listen-Profil (CRL)](https://go.microsoft.com/fwlink/?LinkId=45286)" beschrieben ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Zertifikat Speicher des aktuellen Benutzers geöffnet, nur aktive Zertifikate ausgewählt und der Benutzer dann die Auswahl eines oder mehrerer Zertifikate ermöglicht. Im Beispiel werden dann Zertifikat Informationen in die Konsole geschrieben.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public int Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Version" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Version" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Version As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Version { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : int" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die X.509-Formatversion eines Zertifikats ab.</summary>
        <value>Das Format des Zertifikats.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt mehrere Versionen von X. 509-Zertifikaten. Diese Eigenschaft identifiziert das Format, das vom Zertifikat verwendet wird. Beispielsweise wird "3" für ein Zertifikat der Version 3 zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ausführbare Befehlszeilen Datei erstellt, die eine Zertifikat Datei als Argument annimmt und verschiedene Zertifikat Eigenschaften auf der Konsole ausgibt.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Zertifikat kann nicht gelesen werden.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
