<Type Name="EventProvider" FullName="System.Diagnostics.Eventing.EventProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="444c8c7687180dcc9bbce821804e821244aedd0e" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52207604" /></Metadata><TypeSignature Language="C#" Value="public class EventProvider : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventProvider extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Eventing.EventProvider" />
  <TypeSignature Language="VB.NET" Value="Public Class EventProvider&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventProvider : IDisposable" />
  <TypeSignature Language="F#" Value="type EventProvider = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Verwenden Sie diese Klasse zum Schreiben von Ereignissen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zur Verarbeitung von Ereignissen, die geschrieben wird, mit der <xref:System.Diagnostics.Eventing.EventProvider.WriteEvent%2A> und <xref:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent%2A> Methoden, die Ereignisse müssen definiert werden in einem Manifest; mit geschriebene Ereignisse der <xref:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent%2A> Methode erfordern kein Manifest.  
  
 Ereignisse können die folgenden verwaltete Datentypen enthalten:  
  
-   bool  
  
-   Boolesch  
  
-   byte  
  
-   char  
  
-   decimal  
  
-   double  
  
-   float  
  
-   GUID  
  
-   int  
  
-   IntPtr  
  
-   long  
  
-   sbyte  
  
-   short  
  
-   Zeichenfolge  
  
-   uint  
  
-   UInt64  
  
 Wenn ein Ereignis in Ihrem Manifest verwendet die `Boolean` in-Typ, Sie können nicht geschrieben werden Daten mithilfe einer `Boolean` -Datentyp in verwaltetem Code. Die `Boolean` in-Typ erwartet, dass einen 4-Byte-Wert, und ein `Boolean` Datentyp in verwaltetem Code ist 1 Byte. Sie müssen stattdessen eine `int` -Datentyp, um den Wert zu schreiben. Wenn Sie sich anmelden möchten eine `Boolean` Wert, der UInt8-Typ im Manifest verwenden.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventProvider (Guid providerGuid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Guid providerGuid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.#ctor(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (providerGuid As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventProvider(Guid providerGuid);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Eventing.EventProvider : Guid -&gt; System.Diagnostics.Eventing.EventProvider" Usage="new System.Diagnostics.Eventing.EventProvider providerGuid" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="providerGuid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="providerGuid">GUID, die den Anbieter eindeutig identifiziert.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.Eventing.EventProvider" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Registriert den Anbieter. Rufen Sie zum Entfernen der Registrierungs nach Abschluss der <xref:System.Diagnostics.Eventing.EventProvider.Close%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um den Vorgang abzuschließen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Klassen im <see cref="N:System.Diagnostics.Eventing" />-Namespace können nur unter Windows Vista verwendet werden.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="providerGuid" />-Parameter darf nicht NULL sein.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ein vom ETW-Subsystem zurückgegebener Fehler.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="eventProvider.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt die Registrierung des Anbieters aus dem ETW-Subsystem und gibt alle nicht verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten diese Methode, wenn Sie abgeschlossen werden, anstatt abzuwarten, bis das System zum Verwerfen der Ressourcen aufrufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Ein vom ETW-Subsystem zurückgegebener Fehler.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateActivityId">
      <MemberSignature Language="C#" Value="public static Guid CreateActivityId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid CreateActivityId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.CreateActivityId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateActivityId () As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid CreateActivityId();" />
      <MemberSignature Language="F#" Value="static member CreateActivityId : unit -&gt; Guid" Usage="System.Diagnostics.Eventing.EventProvider.CreateActivityId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen eindeutigen Aktivitätsbezeichner für den Anbieter.</summary>
        <returns>Eine eindeutige GUID, die Sie beim Aufruf der <see cref="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" />-Methode verwenden, um den Aktivitätsbezeichner für den Anbieter festzulegen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine statische Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="eventProvider.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die von diesem <see cref="T:System.Diagnostics.Eventing.EventProvider" />-Objekt verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="eventProvider.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Dieser Parameter wird von dieser Methode ignoriert, da keine nicht verwalteten Ressourcen vorhanden sind.</param>
        <summary>Gibt die von diesem <see cref="T:System.Diagnostics.Eventing.EventProvider" />-Objekt verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~EventProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!EventProvider ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="eventProvider.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt Ressourcen frei und führt eine interne Bereinigung durch, bevor die Instanz durch die Garbage Collection wieder freigegeben wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteEventError">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Eventing.EventProvider.WriteEventErrorCode GetLastWriteEventError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Diagnostics.Eventing.EventProvider/WriteEventErrorCode GetLastWriteEventError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteEventError () As EventProvider.WriteEventErrorCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Eventing::EventProvider::WriteEventErrorCode GetLastWriteEventError();" />
      <MemberSignature Language="F#" Value="static member GetLastWriteEventError : unit -&gt; System.Diagnostics.Eventing.EventProvider.WriteEventErrorCode" Usage="System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Eventing.EventProvider+WriteEventErrorCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den letzten Fehler ab, der einem Ereignis zugeordnet ist, das nicht geschrieben werden konnte.</summary>
        <returns>Verwenden Sie den Wert, um die Fehlerursache beim Schreiben eines Ereignisses zu bestimmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Eventing.EventProvider.WriteEvent%2A>, <xref:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent%2A>, und <xref:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent%2A> Methoden legen Sie diesen Wert, wenn sie das Ereignis zu schreiben.  
  
 Dies ist eine statische Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsEnabled">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob der Anbieter durch eine Sitzung aktiviert wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled();" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : unit -&gt; bool" Usage="eventProvider.IsEnabled " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob der Anbieter durch eine Sitzung aktiviert wurde, unabhängig vom Ebenen- und Schlüsselwortwert, die zum Aktivieren des Anbieters verwendet werden.</summary>
        <returns>Ist <see langword="true" />, wenn der Anbieter für eine beliebige Sitzung aktiviert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel ist ein Anbieter nicht diese Methode, um zu bestimmen, ob der Anbieter durch eine Sitzung aktiviert wurde. der Anbieter wird lediglich das Ereignis schreibt und ETW bestimmt, ob das Ereignis für die Sitzung angemeldet ist. Ein Anbieter sollten diese Funktion aufrufen, wenn der Anbieter zum Ausführen zusätzlichen Schritte, um das Ereignis zu generieren muss. In diesem Fall kann das Aufrufen dieser Funktion zunächst Ressourcen und Zeit sparen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled (byte level, long keywords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled(unsigned int8 level, int64 keywords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.IsEnabled(System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled (level As Byte, keywords As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled(System::Byte level, long keywords);" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : byte * int64 -&gt; bool" Usage="eventProvider.IsEnabled (level, keywords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Byte" />
        <Parameter Name="keywords" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="level">Die Detailebene im Ereignis.</param>
        <param name="keywords">Bitmaske, die die Ereigniskategorie angibt. Bei dieser Maske sollte es sich um die Schlüsselwortmaske handeln, die im Manifest für das Ereignis definiert ist.</param>
        <summary>Bestimmt, ob eine Sitzung das angegebene Ereignis vom Anbieter anfordert.</summary>
        <returns>Ist <see langword="true" />, wenn eine Sitzung das angegebene Ereignis anfordert, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel ist ein Anbieter nicht diese Methode, um zu bestimmen, ob eine Sitzung das angegebene Ereignis angefordert hat. der Anbieter wird lediglich das Ereignis schreibt und ETW bestimmt, ob das Ereignis zu einer Sitzung angemeldet ist. Ein Anbieter sollten diese Funktion aufrufen, wenn der Anbieter zum Ausführen zusätzlichen Schritte, um das Ereignis zu generieren muss. Das Aufrufen dieser Funktion zuerst, um zu bestimmen, ob eine Sitzung das Ereignis oder nicht angefordert hat, kann in diesem Fall die Ressourcen und Zeit sparen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetActivityId">
      <MemberSignature Language="C#" Value="public static void SetActivityId (ref Guid id);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetActivityId(valuetype System.Guid&amp; id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetActivityId (ByRef id As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetActivityId(Guid % id);" />
      <MemberSignature Language="F#" Value="static member SetActivityId :  -&gt; unit" Usage="System.Diagnostics.Eventing.EventProvider.SetActivityId id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.Guid" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="id">Ein eindeutiger Aktivitätsbezeichner, der von der <see cref="M:System.Diagnostics.Eventing.EventProvider.CreateActivityId" />-Methode zurückgegeben wird.</param>
        <summary>Legt den aktuellen Aktivitätsbezeichner fest, der von den <see cref="Overload:System.Diagnostics.Eventing.EventProvider.WriteEvent" />-Methoden verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bezeichner wird in den Kontext des Threads gespeichert.  
  
 Beachten Sie, dass in .NET Framework Version 3.5, mussten Sie legen Sie die `id` Parameter dieser Methode und die <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> Eigenschaftswert angibt, der den gleichen Bezeichnerwert. In Version 4.0 des Frameworks die <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> Methode den Korrelationsbezeichner für die Aktivität automatisch für Sie festgelegt.  
  
 Dies ist eine statische Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt ein Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methoden, wenn Sie ein Manifest verwenden, um die Ereignisse zu definieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, params object[] eventPayload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, object[] eventPayload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteEvent (ByRef eventDescriptor As EventDescriptor, ParamArray eventPayload As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, ... cli::array &lt;System::Object ^&gt; ^ eventPayload);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * obj[] -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, eventPayload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="eventPayload" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Eine Instanz von <see cref="T:System.Diagnostics.Eventing.EventDescriptor" />, die das zu schreibende Ereignis identifiziert.</param>
        <param name="eventPayload">Ein Array von Objekten, die die zu schreibenden Ereignisdaten enthalten. Die Objekte müssen in der im Manifest angegebenen Reihenfolge angeordnet sein. Das Array ist auf 32 Objekte beschränkt, von denen nur acht Objekte Zeichenfolgen sein dürfen. Die maximale Datengröße für das Ereignis ist auf 64 KB abzüglich der Größe der Ereignisheader beschränkt. Die Ereignisgröße ist geringer, wenn die Puffergröße der Sitzung geringer ist und die Sitzung erweiterte Datenelemente für das Ereignis enthält.  
  
Dieser Parameter kann NULL sein.</param>
        <summary>Schreibt ein Ereignis. Die Ereignisdaten werden als Objektarray angegeben.</summary>
        <returns>Ist <see langword="true" />, wenn das Ereignis geschrieben wird, andernfalls <see langword="false" />. Wenn der Wert false ist, rufen Sie die <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />-Methode auf, um die Ursache des Fehlers zu ermitteln.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie beim Aufrufen der <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> Methode an einen Aktivitätsbezeichner für das Ereignis, das diese Methode ruft die ID aus den Kontext des Threads ab und schließt Sie es mit dem Ereignis.  
  
 Wenn der Objekttyp nicht unterstützt wird, schreibt die Methode den Wert der des-Objekts <xref:System.Object.ToString%2A?displayProperty=nameWithType> -Methode in der Nutzlast. Eine Liste der unterstützten Objekte des Typs, finden Sie unter den Hinweisen zu den <xref:System.Diagnostics.Eventing.EventProvider> Klasse.  
  
   
  
## Examples  
  
```csharp  
private static Guid providerId = new Guid("{FB33FDA8-45FB-4df0-8A55-EEB4BA88E7E7}");  
  
enum Keyword  
{  
    Read = 0x1,  
    Write = 0x2,  
    Local = 0x4,  
    Remote = 0x8  
}  
  
enum Level  
{  
    Critical = 1,  
    Error,  
    Warning,  
    Information,  
    Verbose  
}  
  
    EventProvider provider = new EventProvider(providerId);  
    EventDescriptor readEvent;  
    string path = @"<PATHGOESHERE>";  
    UInt64 bytesRead = <ASSIGNVALUE>;  
  
    if (provider.IsEnabled(Level.Information, (long)Keyword.Read))  
    {  
        unchecked  
        {  
            readEvent = new EventDescriptor(0x1, 0x0, 0x10, 0x4, 0x0, 0x0, (long)0x8000000000000005);  
        }  
  
        if (!provider.WriteEvent(ref readEvent, new object[] { path, bytesRead }))  
            Console.WriteLine(EventProvider.GetLastWriteEventError());  
    }  
  
    provider.Close();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="eventPayload" />-Parameter enthält zu viele Objekte oder Zeichenfolgen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteEvent (ByRef eventDescriptor As EventDescriptor, data As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, System::String ^ data);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * string -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Eine Instanz von <see cref="T:System.Diagnostics.Eventing.EventDescriptor" />, die das zu schreibende Ereignis identifiziert.</param>
        <param name="data">Die als Ereignisdaten zu schreibende Zeichenfolge.</param>
        <summary>Schreibt ein Ereignis. Die Ereignisdaten werden als Zeichenfolge angegeben.</summary>
        <returns>Ist <see langword="true" />, wenn das Ereignis geschrieben wird, andernfalls <see langword="false" />. Wenn der Wert false ist, rufen Sie die <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />-Methode auf, um die Ursache des Fehlers zu ermitteln.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie beim Aufrufen der <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> Methode an einen Aktivitätsbezeichner für das Ereignis, das diese Methode ruft die ID aus den Kontext des Threads ab und schließt Sie es mit dem Ereignis.  
  
 Die maximale Zeichenfolgenlänge ist auf 64 KB abzüglich der Größe der Ereignisheader beschränkt. Die Ereignisgröße ist geringer, wenn die Puffergröße der Sitzung geringer ist und die Sitzung erweiterte Datenelemente für das Ereignis enthält.  
  
   
  
## Examples  
  
```csharp  
private static Guid providerId = new Guid("{FB33FDA8-45FB-4df0-8A55-EEB4BA88E7E7}");  
  
EventProvider provider = new EventProvider(providerId);  
EventDescriptor writeEvent;  
  
if (provider.IsEnabled())  
{  
     unchecked  
     {  
          writeEvent = new EventDescriptor(0x2, 0x0, 0x10, 0x3, 0x0, 0x0, (long)0x8000000000000006);  
     }  
  
     if (!provider.WriteEvent(ref writeEvent, "Write event."))  
          Console.WriteLine(EventProvider.GetLastWriteEventError());  
}  
  
provider.Close();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wenn <paramref name="data" /> gleich <see langword="null" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, int dataCount, IntPtr data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, int32 dataCount, native int data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Function WriteEvent (ByRef eventDescriptor As EventDescriptor, dataCount As Integer, data As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, int dataCount, IntPtr data);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * int * nativeint -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, dataCount, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="dataCount" Type="System.Int32" />
        <Parameter Name="data" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Eine Instanz von <see cref="T:System.Diagnostics.Eventing.EventDescriptor" />, die das zu schreibende Ereignis identifiziert.</param>
        <param name="dataCount">Die Größe der Ereignisdaten, auf die der <paramref name="data" />-Parameter zeigt. Die maximale Ereignisdatengröße ist auf 64 KB abzüglich der Größe der Ereignisheader beschränkt. Die Ereignisgröße ist geringer, wenn die Puffergröße der Sitzung geringer ist und die Sitzung erweiterte Datenelemente für das Ereignis enthält.</param>
        <param name="data">Der Zeiger auf die zu schreibenden Ereignisdaten.</param>
        <summary>Schreibt ein Ereignis. Die Ereignisdaten werden als Speicherblock angegeben.</summary>
        <returns>Ist <see langword="true" />, wenn das Ereignis geschrieben wird, andernfalls <see langword="false" />. Wenn der Wert false ist, rufen Sie die <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />-Methode auf, um die Ursache des Fehlers zu ermitteln.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie beim Aufrufen der <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> Methode an einen Aktivitätsbezeichner für das Ereignis, das diese Methode ruft die ID aus den Kontext des Threads ab und schließt Sie es mit dem Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteMessageEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt ein Ereignis, das als Daten eine Zeichenfolge enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methoden erfordern kein Manifest, um das Ereignis zu nutzen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteMessageEvent">
      <MemberSignature Language="C#" Value="public bool WriteMessageEvent (string eventMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteMessageEvent(string eventMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteMessageEvent (eventMessage As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteMessageEvent(System::String ^ eventMessage);" />
      <MemberSignature Language="F#" Value="member this.WriteMessageEvent : string -&gt; bool" Usage="eventProvider.WriteMessageEvent eventMessage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventMessage">Als Ereignisdaten zu schreibende Zeichenfolge.</param>
        <summary>Schreibt ein Ereignis, das als Daten eine Zeichenfolge enthält.</summary>
        <returns>Ist <see langword="true" />, wenn das Ereignis geschrieben wird, andernfalls <see langword="false" />. Wenn der Wert false ist, rufen Sie die <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />-Methode auf, um die Ursache des Fehlers zu ermitteln.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die maximale Zeichenfolgenlänge ist auf 64 KB abzüglich der Größe der Ereignisheader beschränkt. Die Ereignisgröße ist geringer, wenn die Puffergröße der Sitzung geringer ist und die Sitzung erweiterte Datenelemente für das Ereignis enthält.  
  
   
  
## Examples  
  
```csharp  
if (!provider.WriteMessageEvent("Event string."))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wenn <paramref name="eventMessage" /> gleich <see langword="null" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteMessageEvent">
      <MemberSignature Language="C#" Value="public bool WriteMessageEvent (string eventMessage, byte eventLevel, long eventKeywords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteMessageEvent(string eventMessage, unsigned int8 eventLevel, int64 eventKeywords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent(System.String,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteMessageEvent (eventMessage As String, eventLevel As Byte, eventKeywords As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteMessageEvent(System::String ^ eventMessage, System::Byte eventLevel, long eventKeywords);" />
      <MemberSignature Language="F#" Value="member this.WriteMessageEvent : string * byte * int64 -&gt; bool" Usage="eventProvider.WriteMessageEvent (eventMessage, eventLevel, eventKeywords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventMessage" Type="System.String" />
        <Parameter Name="eventLevel" Type="System.Byte" />
        <Parameter Name="eventKeywords" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="eventMessage">Als Ereignisdaten zu schreibende Zeichenfolge.</param>
        <param name="eventLevel">Die Detailebene im Ereignis. Wenn der Anbieter das Ereignis mit einem Manifest definiert, legen Sie diesen Wert auf die im Manifest definierte Ebene fest.</param>
        <param name="eventKeywords">Bitmaske, die die Ereigniskategorie angibt. Wenn der Anbieter das Ereignis mit einem Manifest definiert, legen Sie diesen Wert auf die im Manifest definierte Schlüsselwortmaske fest.</param>
        <summary>Schreibt ein Ereignis, das als Daten eine Zeichenfolge enthält, wenn der Ebenen- und Schlüsselwortwert mit den von der Sitzung angeforderten Ereignissen übereinstimmen.</summary>
        <returns>Ist <see langword="true" />, wenn das Ereignis geschrieben wird, andernfalls <see langword="false" />. Wenn der Wert false ist, rufen Sie die <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />-Methode auf, um die Ursache des Fehlers zu ermitteln.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die maximale Zeichenfolgenlänge ist auf 64 KB abzüglich der Größe der Ereignisheader beschränkt. Die Ereignisgröße ist geringer, wenn die Puffergröße der Sitzung geringer ist und die Sitzung erweiterte Datenelemente für das Ereignis enthält.  
  
   
  
## Examples  
  
```csharp  
// Calling this method with level and keyword set to zero is the same  
// as calling WriteMessageEvent(string); the event is always written.  
if (!provider.WriteMessageEvent("Event string.", 0, 0))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
  
// Event is written if the level value of the session is less than or equal to 3, and bit 1 of the session  
// keyword bit-mask is set.  
if (!provider.WriteMessageEvent("Event string.", 3, 2))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wenn <paramref name="eventMessage" /> gleich <see langword="null" /> ist.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteTransferEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verknüpft Ereignisse, wenn Ereignisse in einem End-to-End-Szenario nachverfolgt werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteTransferEvent">
      <MemberSignature Language="C#" Value="public bool WriteTransferEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, Guid relatedActivityId, params object[] eventPayload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteTransferEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, valuetype System.Guid relatedActivityId, object[] eventPayload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Guid,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteTransferEvent (ByRef eventDescriptor As EventDescriptor, relatedActivityId As Guid, ParamArray eventPayload As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteTransferEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, Guid relatedActivityId, ... cli::array &lt;System::Object ^&gt; ^ eventPayload);" />
      <MemberSignature Language="F#" Value="member this.WriteTransferEvent :  * Guid * obj[] -&gt; bool" Usage="eventProvider.WriteTransferEvent (eventDescriptor, relatedActivityId, eventPayload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="relatedActivityId" Type="System.Guid" />
        <Parameter Name="eventPayload" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Eine Instanz von <see cref="T:System.Diagnostics.Eventing.EventDescriptor" />, die das zu schreibende Ereignis identifiziert.</param>
        <param name="relatedActivityId">Aktivitätsbezeichner aus der vorherigen Komponente. Verwenden Sie diesen Parameter, um die Ereignisse der Komponente mit den Ereignissen der vorherigen Komponente zu verknüpfen.</param>
        <param name="eventPayload">Ein Array von Objekten, die die zu schreibenden Ereignisdaten enthalten. Die Daten müssen in der im Manifest angegebenen Reihenfolge angeordnet sein. Das Array ist auf 32 Objekte beschränkt, von denen nur acht Objekte Zeichenfolgen sein dürfen. Die maximale Datengröße für das Ereignis ist auf 64 KB abzüglich der Größe der Ereignisheader beschränkt. Die Ereignisgröße ist geringer, wenn die Puffergröße der Sitzung geringer ist und die Sitzung erweiterte Datenelemente für das Ereignis enthält.</param>
        <summary>Verknüpft Ereignisse, wenn Ereignisse in einem End-to-End-Szenario nachverfolgt werden. Die Ereignisdaten werden als Objektarray angegeben.</summary>
        <returns>Ist <see langword="true" />, wenn das Ereignis geschrieben wird, andernfalls <see langword="false" />. Wenn der Wert false ist, rufen Sie die <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />-Methode auf, um die Ursache des Fehlers zu ermitteln.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verwendet die Aktivitäts-ID, die in den Kontext des Threads festgelegt, um diese Komponente zu identifizieren. Rufen Sie zum Festlegen der Aktivitäts-ID der <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> Methode.  
  
 Bei Verwendung der <xref:System.Diagnostics.Trace> -Klasse, verwenden Sie nicht die <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> Methode zum Angeben der Aktivitäts-ID. Stattdessen greifen auf die <xref:System.Diagnostics.Trace.CorrelationManager%2A> -Eigenschaft zum Abrufen der <xref:System.Diagnostics.CorrelationManager> Objekt. Legen Sie dann die <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> Eigenschaft, um die Aktivitäts-ID. Sie müssen außerdem festlegen der `relatedActivityId` auf eine <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> Wert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wenn <paramref name="eventPayload" /> zu viele Objekte oder Zeichenfolgen enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTransferEvent">
      <MemberSignature Language="C#" Value="protected bool WriteTransferEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool WriteTransferEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, valuetype System.Guid relatedActivityId, int32 dataCount, native int data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Guid,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Function WriteTransferEvent (ByRef eventDescriptor As EventDescriptor, relatedActivityId As Guid, dataCount As Integer, data As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool WriteTransferEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);" />
      <MemberSignature Language="F#" Value="member this.WriteTransferEvent :  * Guid * int * nativeint -&gt; bool" Usage="eventProvider.WriteTransferEvent (eventDescriptor, relatedActivityId, dataCount, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="relatedActivityId" Type="System.Guid" />
        <Parameter Name="dataCount" Type="System.Int32" />
        <Parameter Name="data" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Eine Instanz von <see cref="T:System.Diagnostics.Eventing.EventDescriptor" />, die das zu schreibende Ereignis identifiziert.</param>
        <param name="relatedActivityId">Aktivitätsbezeichner aus der vorherigen Komponente. Verwenden Sie diesen Parameter, um die Ereignisse der Komponente mit den Ereignissen der vorherigen Komponente zu verknüpfen.</param>
        <param name="dataCount">Die Größe der Ereignisdaten, auf die der <paramref name="data" />-Parameter zeigt. Die maximale Ereignisdatengröße ist auf 64 KB abzüglich der Größe der Ereignisheader beschränkt. Die Ereignisgröße ist geringer, wenn die Puffergröße der Sitzung geringer ist und die Sitzung erweiterte Datenelemente für das Ereignis enthält.</param>
        <param name="data">Der Zeiger auf die zu schreibenden Ereignisdaten.</param>
        <summary>Verknüpft Ereignisse, wenn Ereignisse in einem End-to-End-Szenario nachverfolgt werden. Die Ereignisdaten werden als Speicherblock angegeben.</summary>
        <returns>Ist <see langword="true" />, wenn das Ereignis geschrieben wird, andernfalls <see langword="false" />. Wenn der Wert false ist, rufen Sie die <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />-Methode auf, um die Ursache des Fehlers zu ermitteln.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verwendet die Aktivitäts-ID, die in den Kontext des Threads festgelegt, um diese Komponente zu identifizieren. Rufen Sie zum Festlegen der Aktivitäts-ID der <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>