<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata><Meta Name="ms.openlocfilehash" Value="05adb251a801722ef316092a68b4bda8ac4f1500" /><Meta Name="ms.sourcegitcommit" Value="67e8bb367eab32b26025454e7769040cfb1d71c4" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/09/2019" /><Meta Name="ms.locfileid" Value="57701383" /></Metadata><TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Assembly dar, die ein wiederverwendbarer, in verschiedenen Versionen einsetzbarer und selbstbeschreibender Baustein einer Anwendung der Common Language Runtime (CLR) ist.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Reflection.Assembly> Klasse, um das Laden von Assemblys, um die Metadaten und die zugehörigen Teile der Assemblys, die zum Ermitteln der Typen in Assemblys enthalten, und klicken Sie zum Erstellen von Instanzen dieser Typen zu untersuchen.  
  
 Ein Array von abzurufenden <xref:System.Reflection.Assembly> Objekte, die die Assemblys derzeit darstellen geladen in eine Anwendungsdomäne (z. B. die Standardanwendungsdomäne eines einfachen Projekts), verwenden die <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> Methode.  
  
 Assemblys dynamisch geladen werden die <xref:System.Reflection.Assembly> Klasse stellt die folgenden statischen Methoden (`Shared` -Methoden in Visual Basic). Assemblys werden geladen, in die Anwendungsdomäne, in der Load-Vorgang auftritt.  
  
-   Die empfohlene Methode zum Laden von Assemblys ist die Verwendung der <xref:System.AppDomain.Load%2A> -Methode, die Identifizierung der Assembly anhand des Anzeigenamens geladen werden (z. B. "System.Windows.Forms, Version = 2.0.0.0, Kultur = Neutral, PublicKeyToken = b77a5c561934e089"). Die Suche nach der Assembly folgt den Regeln, die in beschriebenen [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).  
  
-   Die <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> und <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> Methoden können Sie zum Laden einer Assembly für die Reflektion, aber nicht für die Ausführung. Beispielsweise kann eine Assembly, die eine 64-Bit-Plattform konzipiert ist Code untersucht werden, die auf einer 32-Bit-Plattform ausgeführt wird.  
  
-   Die <xref:System.Reflection.Assembly.LoadFile%2A> und <xref:System.Reflection.Assembly.LoadFrom%2A> Methoden werden bereitgestellt, für die seltenen Szenarien, in denen eine Assembly muss identifiziert werden, anhand des Pfads.  
  
 Zum Abrufen einer <xref:System.Reflection.Assembly> Objekt für die derzeit ausgeführte Assembly verwenden die <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> Methode.  
  
 Viele Elemente der der <xref:System.Reflection.Assembly> -Klasse stellen Informationen zu einer Assembly bereit. Beispiel:  
  
-   Die <xref:System.Reflection.Assembly.GetName%2A> Methode gibt ein <xref:System.Reflection.AssemblyName> Objekt, das Zugriff auf die Teile des Assemblyanzeigenamens bereitstellt.  
  
-   Die <xref:System.Reflection.Assembly.GetCustomAttributes%2A> Methode listet die Attribute, die auf die Assembly angewendet.  
  
-   Die <xref:System.Reflection.Assembly.GetFiles%2A> -Methode bietet Zugriff auf die Dateien in das Assemblymanifest.  
  
-   Die <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> Methode enthält die Namen der Ressourcen in das Assemblymanifest.  
  
 Die <xref:System.Reflection.Assembly.GetTypes%2A> Methode listet alle Typen in der Assembly. Die <xref:System.Reflection.Assembly.GetExportedTypes%2A> -Methode listet die Typen, die für Aufrufer außerhalb der Assembly sichtbar sind. Die <xref:System.Reflection.Assembly.GetType%2A> Methode kann verwendet werden, um für einen bestimmten Typ in der Assembly zu suchen. Die <xref:System.Reflection.Assembly.CreateInstance%2A> Methode gesucht, und Erstellen von Instanzen von Typen in der Assembly verwendet werden kann.  
  
 Weitere Informationen zu Assemblys finden Sie im Abschnitt "Domänen und Assemblys Anwendung" in der [Anwendungsdomänen](~/docs/framework/app-domains/application-domains.md) Thema.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die aktuell ausgeführte Assembly abrufen, erstellen Sie eine Instanz eines Typs, die in dieser Assembly enthalten sind und eine der Methoden des Typs mit später Bindung aufgerufen. Zu diesem Zweck das Codebeispiel definiert eine Klasse namens `Example`, mit einer Methode namens `SampleMethod`. Der Konstruktor der Klasse akzeptiert eine ganze Zahl, die zum Berechnen der Rückgabewert der Methode verwendet wird.  
  
 Im Codebeispiel wird außerdem veranschaulicht die Verwendung von der <xref:System.Reflection.Assembly.GetName%2A> Methode zum Abrufen einer <xref:System.Reflection.AssemblyName> -Objekt, das zum Analysieren der vollständige Name der Assembly verwendet werden kann. Das Beispiel zeigt die Versionsnummer der Assembly, die <xref:System.Reflection.Assembly.CodeBase%2A> -Eigenschaft, und die <xref:System.Reflection.Assembly.EntryPoint%2A> Eigenschaft.  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Diese Klasse kann nicht von teilweise vertrauenswürdigem Code nicht geerbt werden.</permission>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md">Anwendungsdomänen</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Assembly" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird von abgeleiteten Klassen aufgerufen, während der Erstellung der <xref:System.Reflection.Assembly> Objekte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den ursprünglich angegebenen Speicherort der Assembly ab, z. B. in einem <see cref="T:System.Reflection.AssemblyName" />-Objekt.</summary>
        <value>Der Speicherort der Assembly, der ursprünglich angegeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie zum Abrufen des absoluten Pfads der geladenen Datei Manifest enthält die <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> Eigenschaft stattdessen.  
  
 Wenn die Assembly als ein Bytearray geladen wurde, verwenden Sie eine Überladung von der <xref:System.Reflection.Assembly.Load%2A> Methode, die ein Array von Bytes verwendet, diese Eigenschaft gibt den Speicherort der Aufrufer der Methode nicht den Speicherort der geladenen Assembly zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Reflection.Assembly.CodeBase%2A> Eigenschaft.  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf den Pfad. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht einen Typ aus dieser Assembly und erstellt mithilfe der Systemaktivierung eine Instanz dieses Typs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Der <see cref="P:System.Type.FullName" /> des zu suchenden Typs.</param>
        <summary>Sucht den angegebenen Typ aus dieser Assembly unter Berücksichtigung der Groß- und Kleinschreibung und erstellt mithilfe der Systemaktivierung eine Instanz dieses Typs.</summary>
        <returns>Eine Instanz des angegebenen Typs, der mit dem Standardkonstruktor erstellt wurde; oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wird. Der Typ wird mit dem Standardbinder aufgelöst, ohne Kultur- oder Aktivierungsattribute anzugeben, und mit <see cref="T:System.Reflection.BindingFlags" /> auf <see langword="Public" /> oder <see langword="Instance" /> festgelegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Laufzeit nicht gefunden wird `typeName` in die <xref:System.Reflection.Assembly> -Instanz, es gibt `null` anstatt eine Ausnahme auszulösen. Dies kann mehrere Ursachen haben:  
  
-   Sie noch nicht den vollqualifizierten Namen des Typs angegeben.  
  
-   Sie haben den vollqualifizierten Typnamen angegeben, aber entspricht nicht der Fall die Groß-/Kleinschreibung des Typs <xref:System.Type.FullName%2A?displayProperty=nameWithType> Eigenschaft. Einen Vergleich Groß-/Kleinschreibung `typeName` aufrufen, durch den vollständigen Namen des Typs, der <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> überladen, und geben Sie `true` für die `ignoreCase` Argument.  
  
-   Der Typ ist nicht vorhanden, in der aktuellen <xref:System.Reflection.Assembly> Instanz.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `Person` -Klasse und ruft die <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> Methode instanziiert.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> ist eine leere Zeichenfolge ("") oder eine Zeichenfolge, die mit einem Null-Zeichen beginnt.  
  
- oder - 
Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="typeName" /> erfordert eine abhängige Assembly, die nicht gefunden wurde.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="typeName" /> erfordert eine abhängige Assembly, die gefunden wurde, aber nicht geladen werden konnte.  
  
- oder - 
Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen, und <paramref name="typeName" /> erfordert eine abhängige Assembly, die nicht vorab geladen wurde.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="typeName" /> erfordert eine abhängige Assembly, die Datei ist jedoch keine gültige Assembly.  
  
- oder - 
 <paramref name="typeName" /> erfordert eine abhängige Assembly, die für eine Version der Laufzeit kompiliert wurde, die höher als die derzeit geladene Version ist.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Der <see cref="P:System.Type.FullName" /> des zu suchenden Typs.</param>
        <param name="ignoreCase"><see langword="true" />, um die Groß- und Kleinschreibung des Typnamens zu ignorieren, andernfalls <see langword="false" />.</param>
        <summary>Sucht den angegebenen Typ aus dieser Assembly, unter wahlweiser Berücksichtigung der Groß- und Kleinschreibung, und erstellt mithilfe der Systemaktivierung eine Instanz dieses Typs.</summary>
        <returns>Eine Instanz des angegebenen Typs, der mit dem Standardkonstruktor erstellt wurde; oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wird. Der Typ wird mit dem Standardbinder aufgelöst, ohne Kultur- oder Aktivierungsattribute anzugeben, und mit <see cref="T:System.Reflection.BindingFlags" /> auf <see langword="Public" /> oder <see langword="Instance" /> festgelegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Laufzeit nicht gefunden wird `typeName` in die <xref:System.Reflection.Assembly> -Instanz, es gibt `null` anstatt eine Ausnahme auszulösen. Dies kann mehrere Ursachen haben:  
  
-   Sie noch nicht den vollqualifizierten Namen des Typs angegeben.  
  
-   Der Typ ist nicht vorhanden, in der aktuellen <xref:System.Reflection.Assembly> Instanz.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `Person` Klasse. Es ruft dann die <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> Methode instanziieren, aber da die Groß-/Kleinschreibung von der `typeName` Argument stimmt nicht überein, der des Typs des <xref:System.Type.FullName%2A> -Eigenschaft gibt die Methode zurück `null`. Wenn das Beispiel übergibt die gleiche Zeichenfolge, die die <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> methodenüberladung, und gibt an, dass der Vergleich Groß-/Kleinschreibung, sollten die `Person` Klasse gefunden wird, und ein `Person` Objekt erfolgreich instanziiert wird.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> ist eine leere Zeichenfolge ("") oder eine Zeichenfolge, die mit einem Null-Zeichen beginnt.  
  
- oder - 
Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="typeName" /> erfordert eine abhängige Assembly, die nicht gefunden wurde.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="typeName" /> erfordert eine abhängige Assembly, die gefunden wurde, aber nicht geladen werden konnte.  
  
- oder - 
Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen, und <paramref name="typeName" /> erfordert eine abhängige Assembly, die nicht vorab geladen wurde.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="typeName" /> erfordert eine abhängige Assembly, die Datei ist jedoch keine gültige Assembly.  
  
- oder - 
 <paramref name="typeName" /> erfordert eine abhängige Assembly, die für eine Version der Laufzeit kompiliert wurde, die höher als die derzeit geladene Version ist.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">Der <see cref="P:System.Type.FullName" /> des zu suchenden Typs.</param>
        <param name="ignoreCase"><see langword="true" />, um die Groß- und Kleinschreibung des Typnamens zu ignorieren, andernfalls <see langword="false" />.</param>
        <param name="bindingAttr">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt. Der Wert ist eine Kombination von Bitflags aus <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Ein Array, das die an den Konstruktor zu übergebenden Argumente enthält. Dieses Array von Argumenten muss bezüglich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor gewünscht ist, muss <paramref name="args" /> ein leeres Array oder <see langword="null" /> sein.</param>
        <param name="culture">Eine Instanz von <see langword="CultureInfo" /> für die Steuerung der Umwandlung von Typen. Wenn dies <see langword="null" /> ist, wird die <see langword="CultureInfo" /> des aktuellen Threads verwendet. (Dies ist z. B. erforderlich, um einen <see langword="String" />, der 1000 darstellt, in einen <see langword="Double" />-Wert zu konvertieren, da 1000 in verschiedenen Kulturen unterschiedlich dargestellt wird.)</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Sucht den angegebenen Typ aus dieser Assembly und erstellt mithilfe der Systemaktivierung eine Instanz dieses Typs. Hierbei ist die Berücksichtigung der Groß- und Kleinschreibung optional und Kultur, Argumente, Bindungs- und Aktivierungsattribute sind angegeben.</summary>
        <returns>Eine Instanz des angegebenen Typs oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wird. Die angegebenen Argumente werden verwendet, um den Typ aufzulösen und den Konstruktor zu binden, der verwendet wird, um die Instanz zu erstellen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> ist eine leere Zeichenfolge ("") oder eine Zeichenfolge, die mit einem Null-Zeichen beginnt.  
  
- oder - 
Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.NotSupportedException">Ein nicht leeres Array von Aktivierungsattributen wird an einen Typ übergeben, der nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="typeName" /> erfordert eine abhängige Assembly, die nicht gefunden wurde.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="typeName" /> erfordert eine abhängige Assembly, die gefunden wurde, aber nicht geladen werden konnte.  
  
- oder - 
Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen, und <paramref name="typeName" /> erfordert eine abhängige Assembly, die nicht vorab geladen wurde.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="typeName" /> erfordert eine abhängige Assembly, die Datei ist jedoch keine gültige Assembly.  
  
- oder - 
 <paramref name="typeName" /> erfordert eine abhängige Assembly, die für eine Version der Laufzeit kompiliert wurde, die höher als die derzeit geladene Version ist.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Um eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename einer Assembly.</param>
        <param name="typeName">Der vollständige Name eines Typs.</param>
        <summary>Erstellt den Namen eines Typs, der durch den Anzeigenamen der zugehörigen Assembly gekennzeichnet wird.</summary>
        <returns>Der vollständige Name des Typs, der durch den Anzeigenamen der Assembly gekennzeichnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Format der zurückgegebenen Zeichenfolge lautet:  
  
 \<FullTypeName>, \<AssemblyDisplayName>  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> eine Beschreibung der das Format des Anzeigenamens einer Assembly.  
  
 Um Änderungen in der common Language Runtime-Versionen zu unterstützen, verwenden Sie diese Methode statt der qualifizierte Name selbst zu erstellen.  Weitere Informationen zu den qualifizierten Assemblynamen, finden Sie unter <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Sammlung ab, die die benutzerdefinierten Attribute dieser Assembly enthält.</summary>
        <value>Eine Sammlung, die die benutzerdefinierten Attribute dieser Assembly enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung der Typen ab, die in dieser Assembly definiert sind.</summary>
        <value>Eine Sammlung der Typen, die in dieser Assembly definiert sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Assembly.DefinedTypes%2A> Eigenschaft ist vergleichbar mit der <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> -Methode, außer dass die <xref:System.Reflection.Assembly.DefinedTypes%2A> Eigenschaft gibt eine Auflistung von <xref:System.Reflection.TypeInfo> Objekte, und die <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> Methode gibt ein Array von <xref:System.Type> Objekte.  
  
 Das zurückgegebene Array enthält geschachtelte Typen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Einstiegspunkt dieser Assembly ab.</summary>
        <value>Ein Objekt, das den Einstiegspunkt dieser Assembly darstellt. Wenn kein Einstiegspunkt gefunden wird, z. B. weil die Assembly eine DLL ist, wird <see langword="null" /> zurückgegeben.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob diese Assembly und das angegebene Objekt gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="o" /> gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Assembly.Equals%2A> Methode führt eine Überprüfen auf Verweisgleichheit, um zu bestimmen, ob die aktuelle Instanz und `o` gleich sind.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den URI einschließlich Escapezeichen ab, der die CodeBase darstellt.</summary>
        <value>Ein URI mit Escapezeichen.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf den Pfad. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Beweis für diese Assembly ab.</summary>
        <value>Der Beweis für diese Assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den Beweis bilden die Informationen, die der Sicherheitsrichtlinie als Eingaben für Entscheidungen dienen, z. B., welche Berechtigungen einem Code erteilt werden können.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung der in dieser Assembly definierten öffentlichen Typen ab, die außerhalb der Assembly sichtbar sind.</summary>
        <value>Eine Sammlung der in dieser Assembly definierten öffentlichen Typen, die außerhalb der Assembly sichtbar sind.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Anzeigenamen der Assembly ab.</summary>
        <value>Der Anzeigename der Assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter <xref:System.Reflection.AssemblyName> eine Beschreibung der das Format des Anzeigenamens einer Assembly.  
  
> [!NOTE]
>  Schreiben eigenen Code zum Analysieren von Anzeigenamen wird nicht empfohlen. Übergeben Sie stattdessen den Namen, der die <xref:System.Reflection.AssemblyName.%23ctor%2A> -Konstruktor, der analysiert, und füllt die entsprechenden Felder des neuen <xref:System.Reflection.AssemblyName>.  
  
 In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt wird, und kann als Teil der Assembly-Zeichenfolgen angegeben werden. Es ist jedoch nicht enthalten in der Zeichenfolge, die vom der <xref:System.Reflection.Assembly.FullName%2A> Eigenschaft aus Kompatibilitätsgründen. Siehe <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel ruft den Anzeigenamen des aktuell ausgeführten Assembly und den Anzeigenamen der Assembly, enthält die <xref:System.Int32> Typ (`int` in c# `Integer` in Visual Basic).  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Ein Objekt, das einen Typ in der Assembly darstellt, die zurückgegeben wird.</param>
        <summary>Ruft die derzeit geladene Assembly ab, in der der angegebene Typ definiert ist.</summary>
        <returns>Die Assembly, in der der angegebene Typ definiert ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode entspricht dem Abrufen des Werts, der die <xref:System.Type.Assembly?displayProperty=nameWithType> Eigenschaft. Allerdings die <xref:System.Type.Assembly?displayProperty=nameWithType> Eigenschaft wird in der Regel eine bessere Leistung bietet.  
  
 Um diese Methode aufrufen, benötigen Sie eine <xref:System.Type> -Objekt, das bedeutet, dass die Assembly, die in der die Klasse definiert ist bereits geladen werden muss.  
  
   
  
## Examples  
 Das folgende Beispiel ruft die Assembly mit der <xref:System.Int32> geben, und zeigt den Namen und Speicherort.  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die <see cref="T:System.Reflection.Assembly" /> der Methode zurück, die die derzeit ausgeführte Methode aufgerufen hat.</summary>
        <returns>Das <see langword="Assembly" />-Objekt der Methode, die die derzeit ausgeführte Methode aufgerufen hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Methode aufgerufen wird, die die <xref:System.Reflection.Assembly.GetCallingAssembly%2A> Methode vom der just-in-Time (JIT)-Compiler Inline erweitert wird, oder wenn seines Aufrufers Inline erweitert wird, die Assembly, die vom <xref:System.Reflection.Assembly.GetCallingAssembly%2A> unerwartet abweichen. Betrachten Sie beispielsweise die folgenden Methoden und Assemblys:  
  
-   Methode `M1` in der Assembly `A1` Aufrufe <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
-   Methode `M2` in der Assembly `A2` Aufrufe `M1`.  
  
-   Methode `M3` in der Assembly `A3` Aufrufe `M2`.  
  
 Wenn `M1` ist nicht inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> gibt `A2`. Wenn `M1` inline erweitert wird, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> gibt `A3`. Auf ähnliche Weise, wenn `M2` ist nicht inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> gibt `A2`. Wenn `M2` inline erweitert wird, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> gibt `A3`.  
  
 Dieser Effekt tritt auch auf, wenn `M1` wird als ein Endeaufruf aus `M2`, oder wenn `M2` wird als ein Endeaufruf aus `M3`. Sie können verhindern, dass den JIT-Compiler von inlineersetzung der Methode, die aufgerufen <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, durch Anwenden der <xref:System.Runtime.CompilerServices.MethodImplAttribute> -Attribut mit der <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> Flag, aber es gibt keine ähnliche Verfahren zum Verhindern von endständigen aufrufen.  
  
   
  
## Examples  
 Im folgende Beispiel ruft die aufrufende Assembly der aktuellen Methode ab.  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die benutzerdefinierten Attribute für diese Assembly ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Dieses Argument wird für Objekte vom Typ <see cref="T:System.Reflection.Assembly" /> ignoriert.</param>
        <summary>Ruft alle benutzerdefinierten Attribute für diese Assembly ab.</summary>
        <returns>Ein Array, das die benutzerdefinierten Attribute für diese Assembly enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die entsprechende <xref:System.Reflection.ICustomAttributeProvider> -Schnittstellenmethode. Aus diesem Grund die `inherit` Parameter muss angegeben werden, obwohl er ignoriert wird.  
  
 Ein Pseudo-Attribut gibt an, die Bits von den Metadaten, der festgelegt werden muss, wenn das Attribut vorhanden ist. Im Gegensatz zu benutzerdefinierten Attributen, die die Metadaten für einen Typ erweitern, und wird zusammen mit dem Typ gespeichert werden, wird ein Pseudo-Attribut ändert die Metadaten für den Typ und anschließend verworfen. Einige der resultierenden Bits kann nicht mit vorhandenen Reflektionsaufruf-APIs zugegriffen werden.  
  
 Die folgende Tabelle fasst zusammen, die unterschiedlichen Pseudoattribute und Accessoren für die Bits, die bei der Reflektion verfügbar sind.  
  
|Pseudo-Attribute|Metadaten-Bits|Reflection-Accessor|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL-name|Keine Accessor für PInvokeMap gewöhnlichen Methode oder globalen Attribute.<br /><br /> Kein Accessor für die DLL-Namen.|  
|GuidAttribute|Als echte benutzerdefinierte Attribut gespeichert.|Zugriff auf als echte benutzerdefinierte Attribut.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Verschiedene Bits.|Kein Accessor.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Packen von Klassen.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Kein Accessor.|  
|FieldOffsetAttribute|Feld Offset.|Kein Accessor.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Keine-Accessor oder Enumerator.|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Der Typ, für den die benutzerdefinierten Attribute zurückzugeben sind.</param>
        <param name="inherit">Dieses Argument wird für Objekte vom Typ <see cref="T:System.Reflection.Assembly" /> ignoriert.</param>
        <summary>Ruft die benutzerdefinierten Attribute für diese Assembly ab, wie durch den Typ angegeben.</summary>
        <returns>Ein Array, das die benutzerdefinierten Attribute für diese Assembly enthält, wie durch <paramref name="attributeType" /> angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die entsprechende <xref:System.Reflection.ICustomAttributeProvider> -Schnittstellenmethode. Aus diesem Grund die `inherit` Parameter muss angegeben werden, obwohl er ignoriert wird.  
  
 Ein Pseudo-Attribut gibt an, die Bits von den Metadaten, der festgelegt werden muss, wenn das Attribut vorhanden ist. Im Gegensatz zu benutzerdefinierten Attributen, die die Metadaten für einen Typ erweitern, und wird zusammen mit dem Typ gespeichert werden, wird ein Pseudo-Attribut ändert die Metadaten für den Typ und anschließend verworfen. Einige der resultierenden Bits kann nicht mit vorhandenen Reflektionsaufruf-APIs zugegriffen werden.  
  
 Die folgende Tabelle fasst zusammen, die unterschiedlichen Pseudoattribute und Accessoren für die Bits, die bei der Reflektion verfügbar sind.  
  
|Pseudo-Attribute|Metadaten-Bits|Reflection-Accessor|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL-name|Keine Accessor für PInvokeMap gewöhnlichen Methode oder globalen Attribute.<br /><br /> Kein Accessor für die DLL-Namen.|  
|GuidAttribute|Als echte benutzerdefinierte Attribut gespeichert.|Zugriff auf als echte benutzerdefinierte Attribut.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Verschiedene Bits.|Kein Accessor.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Packen von Klassen.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Kein Accessor.|  
|FieldOffsetAttribute|Feld Offset.|Kein Accessor.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Keine-Accessor oder Enumerator.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="attributeType" /> ist kein Laufzeittyp.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt Informationen zu den Attributen zurück, die auf den aktuellen <see cref="T:System.Reflection.Assembly" /> angewendet wurden. Diese sind als <see cref="T:System.Reflection.CustomAttributeData" />-Objekte ausgedrückt.</summary>
        <returns>Eine generische Liste von <see cref="T:System.Reflection.CustomAttributeData" />-Objekten, die Daten zu den Attributen darstellen, die auf die aktuelle Assembly angewendet wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die benutzerdefinierten Attribute des Codes in den ReflectionOnly Kontext, in Fällen zu untersuchen, in dem die benutzerdefinierten Attribute selbst im Code definiert werden, die in den ReflectionOnly-Kontext geladen wird. Methoden wie <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> und <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> kann nicht in diesen Fällen verwendet werden, da sie Instanzen der Attribute erstellen. Code in den ReflectionOnly Kontext kann nicht ausgeführt werden. Weitere Informationen und Beispielcode, finden Sie unter den <xref:System.Reflection.CustomAttributeData> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den in der Standardanwendungsdomäne ausführbaren Prozess ab. In anderen Anwendungsdomänen ist dies die erste ausführbare Datei, die von <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> ausgeführt wurde.</summary>
        <returns>Die Assembly, die der in der Standardanwendungsdomäne ausführbare Prozess ist, oder die erste ausführbare Datei, die von <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> ausgeführt wurde. Kann <see langword="null" /> zurückgeben, wenn der Aufruf aus nicht verwaltetem Code erfolgt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Assembly.GetEntryAssembly%2A> Methode zurückgeben `null` bei eine verwaltete Assembly geladen wurde von einer nicht verwalteten Anwendung. Wenn eine nicht verwaltete Anwendung eine Instanz einer COM-Komponente, die in einem Aufruf von c# geschriebene erstellt z. B. die <xref:System.Reflection.Assembly.GetEntryAssembly%2A> Methode aus der C#-Komponente gibt null zurück, da der Einstiegspunkt für den Prozess nicht verwaltetem Code anstatt in eine verwaltete Assembly wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Assembly ab, die den derzeit ausgeführten Code enthält.</summary>
        <returns>Die Assembly, die den derzeit ausgeführten Code enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aus Leistungsgründen sollten Sie diese Methode aufrufen, nur, wenn Sie zur Entwurfszeit noch nicht kennen, Assembly, in der gerade ausgeführt wird. Die empfohlene Methode zum Abrufen einer <xref:System.Reflection.Assembly> -Objekt, das die aktuelle Assembly darstellt, ist die Verwendung der <xref:System.Type.Assembly%2A?displayProperty=nameWithType> Eigenschaft eines Typs finden Sie in der Assembly, wie im folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 Rufen Sie die Assembly mit der Methode, die den derzeit ausgeführten Code aufgerufen mit <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.Assembly%2A?displayProperty=nameWithType> -Eigenschaft zum Abrufen der aktuell ausgeführten Assembly auf Grundlage eines Typs in der Assembly enthalten sind. Er ruft auch die <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> Methode an, dass es gibt eine <xref:System.Reflection.Assembly> Objekt, das die gleiche Assembly darstellt.  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die in dieser Assembly definierten öffentlichen Typen ab, die außerhalb der Assembly sichtbar sind.</summary>
        <returns>Ein Array, das die in dieser Assembly definierten Typen darstellt, die außerhalb der Assembly sichtbar sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die einzigen Typen, die außerhalb einer Assembly sichtbar sind öffentliche Typen und öffentliche Typen, die in anderen öffentlichen Typen geschachtelt.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert eine Reihe von Klassen mit verschiedenen Zugriffsebenen und Aufrufe <xref:System.Reflection.Assembly.GetExportedTypes%2A> um diejenigen anzuzeigen, die außerhalb der Assembly sichtbar sind.  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Assembly ist eine dynamische Assembly.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Eine abhängige Assembly konnte nicht geladen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der angegebenen Datei. Der Pfad zur Datei darf nicht enthalten sein.</param>
        <summary>Ruft einen <see cref="T:System.IO.FileStream" /> für die angegebene Datei in der Dateitabelle des Manifests dieser Assembly ab.</summary>
        <returns>Ein Datenstrom, der die angegebene Datei enthält, oder <see langword="null" />, wenn die Datei nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode funktioniert für sowohl öffentliche und private Ressourcendateien.  
  
 Die `name` sollte den Pfad zu der Datei nicht enthalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="name" />-Parameter ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> ist keine gültige Assembly.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf den Pfad und zum Lesen der angegebenen Datei. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Dateien in der Dateitabelle eines Assemblymanifests ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Dateien in der Dateitabelle eines Assemblymanifests ab.</summary>
        <returns>Ein Array von Streams, die die Dateien enthalten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode funktioniert auf öffentlichen und privaten Ressourcendateien.  
  
 Diese Überladung entspricht dem Aufrufen der <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> Überladung und Angeben von `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Eine Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">Eine Datei war keine gültige Assembly.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><see langword="true" />, wenn Ressourcenmodule eingebunden werden sollen, andernfalls <see langword="false" />.</param>
        <summary>Ruft die Dateien in der Dateitabelle eines Assemblymanifests ab und gibt an, ob Ressourcenmodule eingebunden werden sollen.</summary>
        <returns>Ein Array von Streams, die die Dateien enthalten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode funktioniert auf öffentlichen und privaten Ressourcendateien.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Eine Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">Eine Datei war keine gültige Assembly.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft alle geladenen Module ab, die Bestandteil dieser Assembly sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft alle geladenen Module ab, die Bestandteil dieser Assembly sind.</summary>
        <returns>Ein Array von Modulen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><see langword="true" />, wenn Ressourcenmodule eingebunden werden sollen, andernfalls <see langword="false" />.</param>
        <summary>Ruft alle geladenen Module ab, die Bestandteil dieser Assembly sind, und gibt an, ob Ressourcenmodule eingebunden werden sollen.</summary>
        <returns>Ein Array von Modulen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">Der Ressourcenname unter Berücksichtigung der Groß- und Kleinschreibung.</param>
        <summary>Gibt Informationen darüber zurück, wie die angegebene Ressource beibehalten wurde.</summary>
        <returns>Ein Objekt, das Informationen zur Topologie der Ressource enthält, oder <see langword="null" />, falls die Ressource nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ressourceninformationen wird nur zurückgegeben, wenn die Ressource an den Aufrufer sichtbar ist, oder der Aufrufer verfügt <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="resourceName" />-Parameter ist eine leere Zeichenfolge ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Namen aller Ressourcen in dieser Assembly zurück.</summary>
        <returns>Ein Array, das die Namen sämtlicher Ressourcen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können jeden Ressourcennamen in das Array, das von dieser Methode zurückgegebene wie folgt verwenden:  
  
-   Sie können den Namen der Ressource zu übergeben die <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> Methode, um zusätzliche Informationen über die Ressource abzurufen.  
  
-   Wenn der Name eine binäre RESOURCES-Datei bezeichnet, können Sie die Resources-Dateierweiterung zu entfernen und übergeben es an der <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> Konstruktor zum Instanziieren des Ressourcen-Managers.  
  
-   Können Sie den Namen der Ressource zum Übergeben der <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> Methode zum Abrufen einer <xref:System.IO.Stream> -Objekt, das Sie anschließend an übergeben können die <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> Konstruktor.  
  
-   Können Sie den Namen der Ressource zum Übergeben der <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> Methode zum Abrufen einer <xref:System.IO.Stream> -Objekt, das Sie anschließend an übergeben können die <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> Konstruktor.  
  
 Ressourceninformationen wird nur zurückgegeben, wenn die Ressource an den Aufrufer sichtbar ist, oder der Aufrufer verfügt <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt die angegebene Manifestressource aus dieser Assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der angeforderten Manifestressource unter Berücksichtigung der Groß- und Kleinschreibung.</param>
        <summary>Lädt die angegebene Manifestressource aus dieser Assembly.</summary>
        <returns>Die Manifestressource oder <see langword="null" />, wenn während des Kompilierens keine Ressourcen angegeben wurden oder wenn die Ressource für den Aufrufer nicht sichtbar ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Manifestressource ist eine Ressource (z. B. eine Bilddatei), die in der Assembly zum Zeitpunkt der Kompilierung eingebettet ist. Weitere Informationen zu Ressourcen in einem Dienstmanifest, finden Sie unter [Grundlagen von Microsoft .NET Framework-Ressource](https://go.microsoft.com/fwlink/?LinkId=204554) in der MSDN Library.  
  
 Ressourceninformationen wird nur zurückgegeben, wenn die Ressource an den Aufrufer sichtbar ist, oder der Aufrufer verfügt <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Diese Methode gibt `null` Wenn eine private Ressource in einer anderen Assembly zugegriffen wird und der Aufrufer verfügt nicht über <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag.  
  
 Wenn das Manifest eine Ressourcendatei und listet <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> gibt eine <xref:System.IO.Stream> Objekt, auch wenn zum Zeitpunkt die Ressourcendatei auf dem Datenträger gefunden werden kann. Wenn die Ressourcen-Datei nicht gefunden wird, übergibt das resultierende <xref:System.IO.Stream> -Objekt an die <xref:System.Resources.ResourceReader> Konstruktor veranlasst, dass ein <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="name" />-Parameter ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.  
  
</para>
          </block>  
  
 Eine gefundene Datei konnte nicht geladen werden.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> ist keine gültige Assembly.</exception>
        <exception cref="T:System.NotImplementedException">Die Ressourcenlänge überschreitet <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">Assemblymanifest</related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, dessen Namespace verwendet wird, um den Gültigkeitsbereich des Manifestressourcennamens festzulegen.</param>
        <param name="name">Der Name der angeforderten Manifestressource unter Berücksichtigung der Groß- und Kleinschreibung.</param>
        <summary>Lädt die angegebene Manifestressource, deren Gültigkeitsbereich durch den Namespace des angegebenen Typs festgelegt ist, aus dieser Assembly.</summary>
        <returns>Die Manifestressource oder <see langword="null" />, wenn während des Kompilierens keine Ressourcen angegeben wurden oder wenn die Ressource für den Aufrufer nicht sichtbar ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Angenommen, der vollständige Name für die angegebene `type` "MyNameSpace.MyClasses lautet" und `name` ist "Net", diese Methode sucht nach der Ressource "MyNameSpace.NET" überladen.  
  
 Eine Manifestressource ist eine Ressource (z. B. eine Bilddatei), die in der Assembly zum Zeitpunkt der Kompilierung eingebettet ist. Weitere Informationen zu Ressourcen in einem Dienstmanifest, finden Sie unter [Grundlagen von Microsoft .NET Framework-Ressource](https://go.microsoft.com/fwlink/?LinkId=204554) in der MSDN Library.  
  
 Ressourceninformationen wird nur zurückgegeben, wenn die Ressource an den Aufrufer sichtbar ist, oder der Aufrufer verfügt <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Diese Methode gibt `null` Wenn eine private Ressource in einer anderen Assembly zugegriffen wird und der Aufrufer verfügt nicht über <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag.  
  
 Wenn das Manifest eine Ressourcendatei und listet <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> gibt eine <xref:System.IO.Stream> Objekt, auch wenn zum Zeitpunkt die Ressourcendatei auf dem Datenträger gefunden werden kann. Wenn die Ressourcen-Datei nicht gefunden wird, übergibt das resultierende <xref:System.IO.Stream> -Objekt an die <xref:System.Resources.ResourceReader> Konstruktor veranlasst, dass ein <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="name" />-Parameter ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> ist keine gültige Assembly.</exception>
        <exception cref="T:System.NotImplementedException">Die Ressourcenlänge überschreitet <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">Assemblymanifest</related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Moduls, das angefordert wird.</param>
        <summary>Ruft das angegebene Modul in dieser Assembly ab.</summary>
        <returns>Das angeforderte Modul oder <see langword="null" />, wenn das Modul nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode funktioniert für Dateinamen.  
  
 Klassen in der `Reflection.Emit` Namespace geben den Bereichsnamen für ein dynamisches Modul. Der Bereichsname lassen sich die <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> Eigenschaft. Übergeben Sie die Art des Moduls zu `Assembly.GetModule`. Beispielsweise sollten Sie das Modul, die das Assemblymanifest enthält, übergeben Sie den Bereichsnamen des Moduls an `GetModule`. Andernfalls übergeben Sie den Dateinamen des Moduls an. Assemblys geladen wird, eines der `Load` Methoden, die ein Byte []-Parameter aufweisen, haben nur ein Modul, und das Manifestmodul. Immer diese Module, die mit dem Bereichsnamen zu suchen.  
  
 Ein Typ abgerufen werden kann, von einem bestimmten Modul über <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>. Aufrufen von `Module.GetType` für das Modul mit dem Manifest nicht initiiert eine Suche in der gesamten Assembly. Zum Abrufen eines Typs aus einer Assembly, unabhängig davon, welches Modul ist, rufen Sie <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="name" />-Parameter ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> ist keine gültige Assembly.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft alle Module ab, die Bestandteil dieser Assembly sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft alle Module ab, die Bestandteil dieser Assembly sind.</summary>
        <returns>Ein Array von Modulen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode funktioniert auf öffentlichen und privaten Ressourcendateien.  
  
> [!NOTE]
>  Module müssen mit Dateinamenerweiterungen ausgegeben werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Namen des Moduls im zurückgegebenen Array, das das Assemblymanifest enthält.  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Das zu ladende Modul gibt keine Dateierweiterung an.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><see langword="true" />, wenn Ressourcenmodule eingebunden werden sollen, andernfalls <see langword="false" />.</param>
        <summary>Ruft alle Module ab, die Bestandteil dieser Assembly sind, und gibt an, ob Ressourcenmodule eingebunden werden sollen.</summary>
        <returns>Ein Array von Modulen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode funktioniert auf öffentlichen und privaten Ressourcendateien.  
  
> [!NOTE]
>  Module müssen mit Dateinamenerweiterungen ausgegeben werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Reflection.AssemblyName" /> für diese Assembly ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen <see cref="T:System.Reflection.AssemblyName" /> für diese Assembly ab.</summary>
        <returns>Ein Objekt, das den vollständig analysierten Anzeigenamen für diese Assembly enthält.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf den Pfad der Assembly. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName"><see langword="true" />, um die <see cref="P:System.Reflection.Assembly.CodeBase" /> auf den Speicherort der Assembly festzulegen, nachdem sie verborgen kopiert wurde. <see langword="false" />, um die <see cref="P:System.Reflection.Assembly.CodeBase" /> auf den ursprünglichen Speicherort festzulegen.</param>
        <summary>Ruft einen <see cref="T:System.Reflection.AssemblyName" /> für diese Assembly ab und legt die CodeBase fest, wie in <paramref name="copiedName" /> angegeben.</summary>
        <returns>Ein Objekt, das den vollständig analysierten Anzeigenamen für diese Assembly enthält.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf den Pfad der Assembly. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Das Objekt, das mit Serialisierungsinformationen aufgefüllt werden soll.</param>
        <param name="context">Der Zielkontext der Serialisierung.</param>
        <summary>Ruft Serialisierungsinformationen mit allen Daten ab, die für das erneute Instanziieren dieser Assembly benötigt werden.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die <see cref="T:System.Reflection.AssemblyName" />-Objekte für alle Assemblys ab, auf die diese Assembly verweist.</summary>
        <returns>Ein Array, das die vollständig analysierten Anzeigenamen aller mit Verweisen von dieser Assembly versehenen Assemblys enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> Eigenschaft eine <xref:System.Reflection.AssemblyName> Objekt, das von dieser Methode zurückgegeben wird, ist <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> liegt kein Hashalgorithmus der Assembly, auf die verwiesen wird, oder der Hashalgorithmus der referenzierten Assembly ist nicht gekennzeichnet durch die <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> Enumeration. In früheren Versionen von .NET Framework die <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> zurückgegebene Eigenschaft <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> in dieser Situation.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen der <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> Methode. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Assembly> Klasse.  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Satellitenassembly ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Die angegebene Kultur.</param>
        <summary>Ruft die Satellitenassembly für die angegebene Kultur ab.</summary>
        <returns>Die angegebene Satellitenassembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Satellitenassemblys enthalten lokalisierte Ressourcen, und der Hauptthread der Anwendungsassemblys, die nicht lokalisierbaren, ausführbaren Code und Ressourcen für eine einzelne Kultur, die als Standardkultur bzw. neutrale Kultur dienen enthalten.  
  
 Rufen Sie diese Methode, um die aktuelle Assemblyversion zu verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Satellitenassembly mit einem übereinstimmenden Dateinamen wurde gefunden, aber die <see langword="CultureInfo" /> stimmte nicht mit der Angabe überein.</exception>
        <exception cref="T:System.BadImageFormatException">Die Satellitenassembly ist keine gültige Assembly.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">Die angegebene Kultur.</param>
        <param name="version">Die Version der Satellitenassembly.</param>
        <summary>Ruft die angegebene Version der Satellitenassembly für die angegebene Kultur ab.</summary>
        <returns>Die angegebene Satellitenassembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Satellitenassemblys enthalten lokalisierte Ressourcen, und der Hauptthread der Anwendungsassemblys, die nicht lokalisierbaren, ausführbaren Code und Ressourcen für eine einzelne Kultur, die als Standardkultur bzw. neutrale Kultur dienen enthalten.  
  
 Rufen Sie die <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> -Überladung verwenden, um die aktuelle Assemblyversion zu verwenden.  
  
 Wenn `version` ist `null`, die aktuelle Assemblyversion wird verwendet, wenn die Ressource und die Hauptassemblys angemeldet sind.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Satellitenassembly mit einem übereinstimmenden Dateinamen wurde gefunden, aber die <see langword="CultureInfo" /> oder die Version stimmte nicht mit der den Angaben überein.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Satellitenassembly ist keine gültige Assembly.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft das <see cref="T:System.Type" />-Objekt ab, das den angegebenen Typ darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der vollständige Name des Typs.</param>
        <summary>Ruft das <see cref="T:System.Type" />-Objekt mit dem angegebenen Namen aus der Assemblyinstanz ab.</summary>
        <returns>Ein Objekt, das die angegebene Klasse darstellt, oder <see langword="null" />, wenn die Klasse nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht nur die aktuelle Assemblyinstanz. Die `name` Parameter enthält den Namespace jedoch ausschließlich der Assembly. Um andere Assemblys für einen Typ zu durchsuchen, verwenden die <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> methodenüberladung, die optional einen Anzeigenamen für die Assembly als Teil des Typnamens enthalten können.  
  
> [!NOTE]
>  Wenn der Typ in eine andere Assembly weitergeleitet wurde, wird er weiterhin von dieser Methode zurückgegeben. Informationen zum Weiterleiten von Typen finden Sie unter [Typweiterleitung in der Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine abstrakte `MeansOfTransportation` -Klasse in der `Transportation` Namespace. Ruft die <xref:System.Reflection.Assembly.GetType%28System.String%29> Methode zum Abrufen der <xref:System.Type> Objekt, ruft der <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> -Methode zum Abrufen der ein Array von <xref:System.Reflection.PropertyInfo> Objekte, die die Eigenschaften des Typs darstellen, und zeigt dann die Informationen für des Typs des abstrakten Eigenschaften. Beachten Sie, dass der Aufruf der <xref:System.Reflection.Assembly.GetType%28System.String%29> -Methode verwendet den vollqualifizierten Typnamen (d. h., dessen Namespace zusammen mit dem Typnamen an).  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> erfordert eine abhängige Assembly, die nicht gefunden wurde.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.  
  
</para>
          </block>
          <paramref name="name" /> erfordert eine abhängige Assembly, die gefunden wurde, aber nicht geladen werden konnte.  
  
- oder - 
Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen, und <paramref name="name" /> erfordert eine abhängige Assembly, die nicht vorab geladen wurde.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> erfordert eine abhängige Assembly, die Datei ist jedoch keine gültige Assembly.  
  
- oder - 
 <paramref name="name" /> erfordert eine abhängige Assembly, die für eine Version der Laufzeit kompiliert wurde, die höher als die derzeit geladene Version ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der vollständige Name des Typs.</param>
        <param name="throwOnError"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden wurde. <see langword="false" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Ruft das <see cref="T:System.Type" />-Objekt mit dem angegebenen Namen in der Assemblyinstanz ab und löst optional eine Ausnahme aus, wenn der Typ nicht gefunden wurde.</summary>
        <returns>Ein Objekt, das die angegebene Klasse darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht nur die aktuelle Assemblyinstanz. Die `name` Parameter enthält den Namespace jedoch ausschließlich der Assembly. Um andere Assemblys für einen Typ zu durchsuchen, verwenden die <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> methodenüberladung, die optional einen Anzeigenamen für die Assembly als Teil des Typnamens enthalten können.  
  
> [!NOTE]
>  Wenn der Typ in eine andere Assembly weitergeleitet wurde, wird er weiterhin von dieser Methode zurückgegeben. Informationen zum Weiterleiten von Typen finden Sie unter [Typweiterleitung in der Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Die `throwOnError` Parameter wirkt sich nur auf was geschieht, wenn der Typ nicht gefunden wird. Es hat keine Auswirkungen auf andere Ausnahmen, die ausgelöst werden. Insbesondere, wenn der Typ befindet sich aber nicht geladen werden <xref:System.TypeLoadException> kann ausgelöst werden, auch wenn `throwOnError` ist `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist ungültig.  
  
- oder - 
Die Länge von <paramref name="name" /> überschreitet 1024 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> erfordert eine abhängige Assembly, die nicht gefunden wurde.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="name" /> erfordert eine abhängige Assembly, die gefunden wurde, aber nicht geladen werden konnte.  
  
- oder - 
Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen, und <paramref name="name" /> erfordert eine abhängige Assembly, die nicht vorab geladen wurde.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> erfordert eine abhängige Assembly, die Datei ist jedoch keine gültige Assembly.  
  
- oder - 
 <paramref name="name" /> erfordert eine abhängige Assembly, die für eine Version der Laufzeit kompiliert wurde, die höher als die derzeit geladene Version ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der vollständige Name des Typs.</param>
        <param name="throwOnError"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden wurde. <see langword="false" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="ignoreCase"><see langword="true" />, um die Groß- und Kleinschreibung des Typnamens zu ignorieren, andernfalls <see langword="false" />.</param>
        <summary>Ruft das <see cref="T:System.Type" />-Objekt mit dem angegebenen Namen in der Assemblyinstanz ab, wobei optional die Groß- und Kleinschreibung unberücksichtigt bleiben und optional eine Ausnahme ausgelöst werden kann, wenn der Typ nicht gefunden wurde.</summary>
        <returns>Ein Objekt, das die angegebene Klasse darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht nur die aktuelle Assemblyinstanz. Die `name` Parameter enthält den Namespace jedoch ausschließlich der Assembly. Um andere Assemblys für einen Typ zu durchsuchen, verwenden die <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> methodenüberladung, die optional einen Anzeigenamen für die Assembly als Teil des Typnamens enthalten können.  
  
> [!NOTE]
>  Wenn der Typ in eine andere Assembly weitergeleitet wurde, wird er weiterhin von dieser Methode zurückgegeben. Informationen zum Weiterleiten von Typen finden Sie unter [Typweiterleitung in der Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Die `throwOnError` Parameter wirkt sich nur auf was geschieht, wenn der Typ nicht gefunden wird. Es hat keine Auswirkungen auf andere Ausnahmen, die ausgelöst werden. Insbesondere, wenn der Typ befindet sich aber nicht geladen werden <xref:System.TypeLoadException> kann ausgelöst werden, auch wenn `throwOnError` ist `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist ungültig.  
  
- oder - 
Die Länge von <paramref name="name" /> überschreitet 1024 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> erfordert eine abhängige Assembly, die nicht gefunden wurde.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="name" /> erfordert eine abhängige Assembly, die gefunden wurde, aber nicht geladen werden konnte.  
  
- oder - 
Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen, und <paramref name="name" /> erfordert eine abhängige Assembly, die nicht vorab geladen wurde.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> erfordert eine abhängige Assembly, die Datei ist jedoch keine gültige Assembly.  
  
- oder - 
 <paramref name="name" /> erfordert eine abhängige Assembly, die für eine Version der Laufzeit kompiliert wurde, die höher als die derzeit geladene Version ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die in dieser Assembly definierten Typen ab.</summary>
        <returns>Ein Array, das alle in dieser Assembly definierten Typen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurückgegebene Array enthält geschachtelte Typen.  
  
 Wenn die <xref:System.Reflection.Assembly.GetTypes%2A> Methode ist auf eine Assembly und einen Typ aufgerufen, in der betreffenden Assembly eines Typs in einer Assembly abhängig ist, die nicht geladen wurde (z. B., wenn er von einem Typ in der zweiten Assembly abgeleitet ist), eine <xref:System.Reflection.ReflectionTypeLoadException> ausgelöst. Dies kann beispielsweise auftreten, wenn die erste Assembly mit geladen wurde die <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> oder <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> Methoden und die zweite Assembly wurde nicht geladen. Es kann auch vorkommen, mit Assemblys geladen, mit der <xref:System.Reflection.Assembly.Load%2A> und <xref:System.Reflection.Assembly.LoadFile%2A> Methoden auf, wenn die zweite Assembly gefunden, wenn werden kann die <xref:System.Reflection.Assembly.GetTypes%2A> Methode wird aufgerufen.  
  
> [!NOTE]
>  Wenn ein Typ in eine andere Assembly weitergeleitet wurde, ist es nicht im zurückgegebenen Array enthalten. Informationen zum Weiterleiten von Typen finden Sie unter [Typweiterleitung in der Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Zum Abrufen einer Auflistung von <xref:System.Reflection.TypeInfo> Objekte anstelle eines Arrays von <xref:System.Type> Objekte zu verwenden, die <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Parameter einer Methode für einen Typ in der angegebenen Assembly.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">Die Assembly enthält einen oder mehrere Typen, die nicht geladen werden können. Das von der <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" />-Eigenschaft dieser Ausnahme zurückgegebene Array enthält ein <see cref="T:System.Type" />-Objekt für jeden Typ, der geladen wurde, und <see langword="null" /> für jeden Typ, der nicht geladen werden konnte. Die <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" />-Eigenschaft enthält hingegen eine Ausnahme für jeden Typ, der nicht geladen werden konnte.</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Assembly aus dem globalen Assemblycache geladen wurde.</summary>
        <value><see langword="true" />, wenn die Assembly aus dem globalen Assemblycache geladen wurde, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Hostkontext ab, mit dem die Assembly geladen wurde.</summary>
        <value>Ein <see cref="T:System.Int64" />-Wert, der den Hostkontext angibt, mit dem die Assembly geladen wurde, sofern vorhanden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zeichenfolge ab, die die Version der CLR darstellt, die in der Datei mit dem Manifest gespeichert wurde.</summary>
        <value>Der CLR-Versionsordnername. Dies ist kein vollständiger Pfad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beispielsweise wäre der Wert für die .NET Framework Version 1.1 v1.1.4322. Die Binärdateien für diese Version werden im Pfad WINDIR%\Microsoft.NET\Framework\v1.1.4322 befinden.  
  
 In der Standardeinstellung <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> festgelegt ist, auf die Version der CLR verwendet, um die Assembly zu erstellen. Aber kann es auf einen anderen Wert zum Zeitpunkt der Kompilierung festgelegt wurden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public virtual bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Reflection.Assembly.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob sich diese Assembly in einem entladbaren <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> befindet.</summary>
        <value><see langword="true" /> Wenn diese Assembly sich in einer entladbaren befindet <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Weitere Informationen finden Sie unter <see href="/en-us/dotnet/standard/assembly/unloadability-howto">verwenden, und Debuggen von Assembly Unloadability in .NET Core</see>.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Der Typ des Attributs, das für diese Assembly überprüft werden soll.</param>
        <param name="inherit">Dieses Argument wird für Objekte dieses Typs ignoriert.</param>
        <summary>Gibt an, ob ein angegebenes Attribut für die Assembly übernommen worden ist.</summary>
        <returns><see langword="true" />, wenn das Attribut für die Assembly übernommen wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel gilt die <xref:System.Reflection.AssemblyTitleAttribute> Attribut, um eine Assembly und dann verwendet, <xref:System.Reflection.Assembly.IsDefined%2A> an, ob es angewendet wurde. Außerdem prüft ein Attribut, das nicht angewendet wurde.  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="attributeType" /> verwendet einen ungültigen Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle Assembly dynamisch im aktuellen Prozess mithilfe der Reflektionsausgabe generiert wurde.</summary>
        <value><see langword="true" />, wenn die aktuelle Assembly dynamisch im aktuellen Prozess generiert wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamische Assemblys werden von der abgeleiteten Klasse dargestellt <xref:System.Reflection.Emit.AssemblyBuilder>.  
  
 Es ist nicht dynamisch, wenn eine dynamische Assembly auf dem Datenträger, die gespeicherte Assembly gespeichert wird. Wenn die gespeicherte Assembly in eine andere Anwendungsdomäne oder einen Prozess geladen wird die <xref:System.Reflection.Assembly.IsDynamic%2A> -Eigenschaft gibt `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle Assembly mit voller Vertrauenswürdigkeit geladen wird.</summary>
        <value><see langword="true" />, wenn die aktuelle Assembly mit voller Vertrauenswürdigkeit geladen wird, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt eine Assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Ein Bytearray, das ein COFF-Image mit einer ausgegebenen Assembly ist.</param>
        <summary>Lädt die Assembly mit einem COFF (Common Object File Format)-Image, das eine ausgegebene Assembly enthält. Die Assembly wird in die Anwendungsdomäne des Aufrufers geladen.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Vertrauensebene einer Assembly, die geladen wird, mithilfe dieser Methode ist die Vertrauensebene der aufrufenden Assembly identisch. Um eine Assembly aus einem Bytearray mit der Vertrauensebene der Anwendungsdomäne zu laden, verwenden die <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> -methodenüberladung. Weitere Informationen zur Verwendung von Beweisen Sie mit Überladungen von der <xref:System.Reflection.Assembly.Load%2A> Methode, die Bytearrays akzeptieren, finden Sie unter der <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> -methodenüberladung.  
  
 Reflektieren ausführbaren C++-Dateien kann Auslösen einer <xref:System.BadImageFormatException>. Wahrscheinlichste Ursache ist der C++-Compiler die Umsetzungsadressen entfernen oder die `.reloc` Abschnitt aus der ausführbaren Datei. Beibehalten der `.reloc` für die ausführbare Datei für C++ zu beheben, geben Sie `/fixed:no` beim verknüpfen.  
  
 Beachten Sie, dass die Überladung dieser Methode erstellt immer eine neue <xref:System.Reflection.Assembly> Objekt mit eigenen Zuordnung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> ist keine gültige Assembly.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="rawAssembly" /> wurde mit einer höheren Version kompiliert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Das Objekt, das die zu ladende Assembly beschreibt.</param>
        <summary>Lädt eine Assembly bei Angabe von <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> wird ausgelöst, wenn `assemblyRef` gibt an, der vollständige Assemblyname und die erste Assembly, die den einfachen Namen entspricht, verfügt über eine andere Version, Kultur und Token des öffentlichen Schlüssels. Das Ladeprogramm wird nicht fortgesetzt, Suchen nach anderen Assemblys, die den einfachen Namen entsprechen. Ab .NET Framework 4, da die Ausführung des Codes in remote-Assemblys in der Standardeinstellung deaktiviert ist eine <xref:System.IO.FileLoadException> wird auch ausgelöst, wenn `assemblyRef` gibt eine remote-Assembly. Damit kann codeausführung von Remotestandorten geladen, können Sie die [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) Konfigurationselement.     
  
> [!NOTE]
>  Verwenden Sie keine <xref:System.Reflection.AssemblyName> nur mit der <xref:System.Reflection.AssemblyName.CodeBase%2A> Eigenschaftensatz. Die <xref:System.Reflection.AssemblyName.CodeBase%2A> Eigenschaft stellt keinen Elemente der Assemblyidentität (z. B. Name oder Version), also Laden erfolgt nicht gemäß den Regeln des Load-von-Identität, wie erwartet aus der <xref:System.Reflection.Assembly.Load%2A> Methode. Stattdessen wird die Assembly geladen, mithilfe von Load-from-Regeln. Informationen zu den Nachteilen der LoadFrom-Kontext verwenden, finden Sie unter den <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> methodenüberladung oder [Best Practices für das Laden von Assembly](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 Das Erteilen bestimmter Berechtigungen für eine Assembly beruht auf Beweisen. Die Regeln für das Zusammenführen von Assembly und Sicherheitsinformationen sind wie folgt aus:  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> Methode ohne <xref:System.Security.Policy.Evidence> -Parameter wird die Assembly mit der das Ladeprogramm bereitgestellten Beweisen geladen.  
  
-   Bei Verwendung von einer <xref:System.Reflection.Assembly.Load%2A> -Methode mit einer <xref:System.Security.Policy.Evidence> Parameter Beweise werden zusammengeführt. Beweise, die als Argument an die <xref:System.Reflection.Assembly.Load%2A> Methode ersetzen vom Ladeprogramm bereitgestellte Beweise.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> methodenüberladung mit einem `Byte[]` Parameter, um ein Image common Object File Format (COFF), Beweise zu laden, wird von der aufrufenden Assembly geerbt. Dies gilt für .NET Framework, Version 1.1 Service Pack 1 (SP1) und nachfolgende Versionen.  
  
    > [!NOTE]
    >  In .NET Framework, Version 1.0 und Version 1.1 ohne SP1, bei der Verwendung einer <xref:System.Reflection.Assembly.Load%2A> methodenüberladung mit einem `Byte[]` Parameter zum Laden eines COFF-Image, Beweise kombiniert wird. `Zone`, `Url` und `Site` stammen aus der aufrufenden Assembly und `Hash` und `StrongName` stammen aus der COFF-Assembly.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> -Methode mit einem `Byte[]` Parameter und <xref:System.Security.Policy.Evidence> um ein COFF-Image zu laden, wird nur der angegebene Beweis verwendet. Von der aufrufenden Assembly und Beweise von COFF-Image werden ignoriert.  
  
 Reflektieren ausführbaren C++-Dateien kann Auslösen einer <xref:System.BadImageFormatException>. Wahrscheinlichste Ursache ist der C++-Compiler die Umsetzungsadressen entfernen oder die `.reloc` Abschnitt aus der ausführbaren Datei. Beibehalten der `.reloc` für die ausführbare Datei für C++ zu beheben, geben Sie `/fixed:no` beim verknüpfen.  
  
> [!NOTE]
>  Wenn beide die <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> Eigenschaft und die <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> Eigenschaft festgelegt werden, der erste Versuch zum Laden der Assembly verwendet den Anzeigenamen (einschließlich Version, Kultur und So weiter, vom der <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> Eigenschaft). Wenn die Datei nicht gefunden wird, <xref:System.Reflection.AssemblyName.CodeBase%2A> wird verwendet, um nach der Assembly zu suchen. Wenn die Assembly gefunden wird, mithilfe von <xref:System.Reflection.AssemblyName.CodeBase%2A>, der Anzeigenamen der Assembly abgeglichen wird. Wenn die Übereinstimmung fehlschlägt, eine <xref:System.IO.FileLoadException> ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Reflection.AssemblyName> -Objekt und verwendet es zum Laden der `sysglobal.dll` Assembly. Das Beispiel zeigt anschließend den vollständigen Namen der öffentlichen Typen der Assembly.  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.  
  
</para>
          </block>  
  
 Eine gefundene Datei konnte nicht geladen werden.

- oder -

<paramref name="assemblyRef" /> gibt eine Remoteassembly an, die Funktion zum Ausführen von Code in Remoteassemblys ist jedoch deaktiviert. Weitere Informationen finden Sie unter <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" /> ist keine gültige Assembly. - oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyRef" /> wurde mit einer höheren Version kompiliert.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">So sucht Common Language Runtime nach Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Die Langform des Assemblynamens.</param>
        <summary>Lädt eine Assembly, wenn die Langform des Namens angegeben wurde.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Langform des Namen einer Assembly besteht aus der einfache Name (z. B. "System" für die Assembly "System.dll") zusammen mit der Version, Kultur, öffentliches Schlüsseltoken und optional seine Prozessorarchitektur. Dies entspricht der Assembly <xref:System.Reflection.Assembly.FullName%2A> Eigenschaft. Das folgende Beispiel veranschaulicht die Verwendung eines langen namens zum Laden der Assembly "System.dll" für die .NET Framework 4.  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException> wird ausgelöst, wenn `assemblyString` gibt an, der vollständige Assemblyname und die erste Assembly, die den einfachen Namen entspricht, verfügt über eine andere Version, Kultur und Token des öffentlichen Schlüssels. Das Ladeprogramm wird nicht fortgesetzt, Suchen nach anderen Assemblys, die den einfachen Namen entsprechen.  
  
 Das Erteilen bestimmter Berechtigungen für eine Assembly beruht auf Beweisen. Die Regeln für das Zusammenführen von Assembly und Sicherheitsinformationen sind wie folgt aus:  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> Methode ohne <xref:System.Security.Policy.Evidence> -Parameter wird die Assembly mit der das Ladeprogramm bereitgestellten Beweisen geladen.  
  
-   Bei Verwendung von einer <xref:System.Reflection.Assembly.Load%2A> -Methode mit einer <xref:System.Security.Policy.Evidence> Parameter Beweise werden zusammengeführt. Beweise, die als Argument an die <xref:System.Reflection.Assembly.Load%2A> Methode ersetzen vom Ladeprogramm bereitgestellte Beweise.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> methodenüberladung mit einem `Byte[]` Parameter, um ein Image common Object File Format (COFF), Beweise zu laden, wird von der aufrufenden Assembly geerbt. Dies gilt für .NET Framework, Version 1.1 Service Pack 1 (SP1) und nachfolgende Versionen.  
  
    > [!NOTE]
    >  In .NET Framework, Version 1.0 und Version 1.1 ohne SP1, bei der Verwendung einer <xref:System.Reflection.Assembly.Load%2A> methodenüberladung mit einem `Byte[]` Parameter zum Laden eines COFF-Image, Beweise kombiniert wird. `Zone`, `Url` und `Site` stammen aus der aufrufenden Assembly und `Hash` und `StrongName` stammen aus der COFF-Assembly.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> -Methode mit einem `Byte[]` Parameter und <xref:System.Security.Policy.Evidence> um ein COFF-Image zu laden, wird nur der angegebene Beweis verwendet. Von der aufrufenden Assembly und Beweise von COFF-Image werden ignoriert.  
  
 Reflektieren ausführbaren C++-Dateien kann Auslösen einer <xref:System.BadImageFormatException>. Wahrscheinlichste Ursache ist der C++-Compiler die Umsetzungsadressen entfernen oder die `.reloc` Abschnitt aus der ausführbaren Datei. Beibehalten der `.reloc` für die ausführbare Datei für C++ zu beheben, geben Sie `/fixed:no` beim verknüpfen.  
  
 In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt wird, und kann als Teil der Assembly-Zeichenfolgen angegeben werden. Z. B. "ProcessorArchitecture = Msil". Die empfohlene Methode zum Namen einer Assembly angeben. allerdings ist die Erstellung einer <xref:System.Reflection.AssemblyName> -Objekt und übergeben es an eine geeignete Überladung der der <xref:System.Reflection.Assembly.Load%2A> Methode. Siehe <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel lädt eine Assembly lautet den vollqualifizierten Name angegeben, und listet alle in der angegebenen Assembly enthaltenen Typen. Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyString" /> ist eine Zeichenfolge mit der Länge 0 (null).</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> ist keine gültige Assembly.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyString" /> wurde mit einer höheren Version kompiliert.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">So sucht Common Language Runtime nach Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Ein Bytearray, das ein COFF-Image mit einer ausgegebenen Assembly ist.</param>
        <param name="rawSymbolStore">Ein Bytearray, das die Rohdatenbytes enthält, die die Symbole für die Assembly darstellen.</param>
        <summary>Lädt die Assembly mit einem COFF-Image (Common Object File Format), das eine ausgegebene Assembly und optional Symbole für die Assembly enthält. Die Assembly wird in die Anwendungsdomäne des Aufrufers geladen.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Vertrauensebene einer Assembly, die geladen wird, mithilfe dieser Methode ist die Vertrauensebene der aufrufenden Assembly identisch. Um eine Assembly aus einem Bytearray mit der Vertrauensebene der Anwendungsdomäne zu laden, verwenden die <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> -methodenüberladung. Weitere Informationen zur Verwendung von Beweisen Sie mit Überladungen von der <xref:System.Reflection.Assembly.Load%2A> Methode, die Bytearrays akzeptieren, finden Sie unter der <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> -methodenüberladung.  
  
 Reflektieren ausführbaren C++-Dateien kann Auslösen einer <xref:System.BadImageFormatException>. Wahrscheinlichste Ursache ist der C++-Compiler die Umsetzungsadressen entfernen oder die `.reloc` Abschnitt aus der ausführbaren Datei. Beibehalten der `.reloc` für die ausführbare Datei für C++ zu beheben, geben Sie `/fixed:no` beim verknüpfen.  
  
 Beachten Sie, dass die Überladung dieser Methode erstellt immer eine neue <xref:System.Reflection.Assembly> Objekt mit eigenen Zuordnung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> ist keine gültige Assembly.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="rawAssembly" /> wurde mit einer höheren Version kompiliert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Das Objekt, das die zu ladende Assembly beschreibt.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <summary>Lädt eine Assembly bei Angabe von <see cref="T:System.Reflection.AssemblyName" />. Die Assembly wird mithilfe des bereitgestellten Beweises in die Domäne des Aufrufers geladen.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> wird ausgelöst, wenn `assemblyRef` gibt an, der vollständige Assemblyname und die erste Assembly, die den einfachen Namen entspricht, verfügt über eine andere Version, Kultur und Token des öffentlichen Schlüssels. Das Ladeprogramm wird nicht fortgesetzt, Suchen nach anderen Assemblys, die den einfachen Namen entsprechen.  Ab .NET Framework 4, da die Ausführung des Codes in remote-Assemblys in der Standardeinstellung deaktiviert ist eine <xref:System.IO.FileLoadException> wird auch ausgelöst, wenn `assemblyRef` gibt eine remote-Assembly. Damit kann codeausführung von Remotestandorten geladen, können Sie die [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) Konfigurationselement.   
  
> [!NOTE]
>  Verwenden Sie keine <xref:System.Reflection.AssemblyName> nur mit der <xref:System.Reflection.AssemblyName.CodeBase%2A> Eigenschaftensatz. Die <xref:System.Reflection.AssemblyName.CodeBase%2A> Eigenschaft stellt keinen Elemente der Assemblyidentität (z. B. Name oder Version), also Laden erfolgt nicht gemäß den Regeln des Load-von-Identität, wie erwartet aus der <xref:System.Reflection.Assembly.Load%2A> Methode. Stattdessen wird die Assembly geladen, mithilfe von Load-from-Regeln. Informationen zu den Nachteilen der LoadFrom-Kontext verwenden, finden Sie unter den <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> methodenüberladung oder [Best Practices für das Laden von Assembly](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 Das Erteilen bestimmter Berechtigungen für eine Assembly beruht auf Beweisen. Die Regeln für das Zusammenführen von Assembly und Sicherheitsinformationen sind wie folgt aus:  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> Methode ohne <xref:System.Security.Policy.Evidence> -Parameter wird die Assembly mit der das Ladeprogramm bereitgestellten Beweisen geladen.  
  
-   Bei Verwendung von einer <xref:System.Reflection.Assembly.Load%2A> -Methode mit einer <xref:System.Security.Policy.Evidence> Parameter Beweise werden zusammengeführt. Beweise, die als Argument an die <xref:System.Reflection.Assembly.Load%2A> Methode ersetzen vom Ladeprogramm bereitgestellte Beweise.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> methodenüberladung mit einem `Byte[]` Parameter, um ein Image common Object File Format (COFF), Beweise zu laden, wird von der aufrufenden Assembly geerbt. Dies gilt für .NET Framework, Version 1.1 Service Pack 1 (SP1) und nachfolgende Versionen.  
  
    > [!NOTE]
    >  In .NET Framework, Version 1.0 und Version 1.1 ohne SP1, bei der Verwendung einer <xref:System.Reflection.Assembly.Load%2A> methodenüberladung mit einem `Byte[]` Parameter zum Laden eines COFF-Image, Beweise kombiniert wird. `Zone`, `Url` und `Site` stammen aus der aufrufenden Assembly und `Hash` und `StrongName` stammen aus der COFF-Assembly.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> -Methode mit einem `Byte[]` Parameter und <xref:System.Security.Policy.Evidence> um ein COFF-Image zu laden, wird nur der angegebene Beweis verwendet. Von der aufrufenden Assembly und Beweise von COFF-Image werden ignoriert.  
  
 Reflektieren ausführbaren C++-Dateien kann Auslösen einer <xref:System.BadImageFormatException>. Wahrscheinlichste Ursache ist der C++-Compiler die Umsetzungsadressen entfernen oder die `.reloc` Abschnitt aus der ausführbaren Datei. Beibehalten der `.reloc` für die ausführbare Datei für C++ zu beheben, geben Sie `/fixed:no` beim verknüpfen.  
  
> [!NOTE]
>  Wenn beide die <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> Eigenschaft und die <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> Eigenschaft festgelegt werden, der erste Versuch zum Laden der Assembly verwendet den Anzeigenamen (einschließlich Version, Kultur und So weiter, vom der <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> Eigenschaft). Wenn die Datei nicht gefunden wird, <xref:System.Reflection.AssemblyName.CodeBase%2A> wird verwendet, um nach der Assembly zu suchen. Wenn die Assembly gefunden wird, mithilfe von <xref:System.Reflection.AssemblyName.CodeBase%2A>, der Anzeigenamen der Assembly abgeglichen wird. Wenn die Übereinstimmung fehlschlägt, eine <xref:System.IO.FileLoadException> ausgelöst.  
  
 Aufrufen der <xref:System.Reflection.Assembly.Load%2A> Methode, die mehr als einmal in der gleichen Assembly, aber einen anderen Beweis angegeben, die common Language Runtime keine ausgelöst wird, eine <xref:System.IO.FileLoadException> , da die Gleichheit und Integrität der anderen Beweis-Spezifikationen nicht möglich bestimmt. Der Beweis, der zuerst erfolgreich ist, ist der Beweis, der verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" /> ist keine gültige Assembly.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyRef" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.

- oder -

<paramref name="assemblyRef" /> gibt eine Remoteassembly an, die Funktion zum Ausführen von Code in Remoteassemblys ist jedoch deaktiviert. Weitere Informationen finden Sie unter <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">So sucht Common Language Runtime nach Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Der Anzeigename der Assembly.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <summary>Lädt eine Assembly bei Angabe des Anzeigenamens, wobei die Assembly unter Verwendung der bereitgestellten Beweise in die Domäne des Aufrufers geladen wird.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> wird ausgelöst, wenn `assemblyString` gibt an, der vollständige Assemblyname und die erste Assembly, die den einfachen Namen entspricht, verfügt über eine andere Version, Kultur und Token des öffentlichen Schlüssels. Das Ladeprogramm wird nicht fortgesetzt, Suchen nach anderen Assemblys, die den einfachen Namen entsprechen.  
  
 Das Erteilen bestimmter Berechtigungen für eine Assembly beruht auf Beweisen. Die Regeln für das Zusammenführen von Assembly und Sicherheitsinformationen sind wie folgt aus:  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> Methode ohne <xref:System.Security.Policy.Evidence> -Parameter wird die Assembly mit der das Ladeprogramm bereitgestellten Beweisen geladen.  
  
-   Bei Verwendung von einer <xref:System.Reflection.Assembly.Load%2A> -Methode mit einer <xref:System.Security.Policy.Evidence> Parameter Beweise werden zusammengeführt. Beweise, die als Argument an die <xref:System.Reflection.Assembly.Load%2A> Methode ersetzen vom Ladeprogramm bereitgestellte Beweise.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> methodenüberladung mit einem `Byte[]` Parameter, um ein Image common Object File Format (COFF), Beweise zu laden, wird von der aufrufenden Assembly geerbt. Dies gilt für .NET Framework, Version 1.1 Service Pack 1 (SP1) und nachfolgende Versionen.  
  
    > [!NOTE]
    >  In .NET Framework, Version 1.0 und Version 1.1 ohne SP1, bei der Verwendung einer <xref:System.Reflection.Assembly.Load%2A> methodenüberladung mit einem `Byte[]` Parameter zum Laden eines COFF-Image, Beweise kombiniert wird. `Zone`, `Url` und `Site` stammen aus der aufrufenden Assembly und `Hash` und `StrongName` stammen aus der COFF-Assembly.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> -Methode mit einem `Byte[]` Parameter und <xref:System.Security.Policy.Evidence> um ein COFF-Image zu laden, wird nur der angegebene Beweis verwendet. Von der aufrufenden Assembly und Beweise von COFF-Image werden ignoriert.  
  
 Reflektieren ausführbaren C++-Dateien kann Auslösen einer <xref:System.BadImageFormatException>. Wahrscheinlichste Ursache ist der C++-Compiler die Umsetzungsadressen entfernen oder die `.reloc` Abschnitt aus der ausführbaren Datei. Beibehalten der `.reloc` für die ausführbare Datei für C++ zu beheben, geben Sie `/fixed:no` beim verknüpfen.  
  
 Wenn Sie diese Methode mehrmals für dieselbe Assembly jedoch einen anderen Beweis angegebenen aufrufen, die common Language Runtime löst keine <xref:System.IO.FileLoadException> , da die Gleichheit und Integrität der anderen Beweis-Spezifikationen nicht bestimmt werden können. Der Beweis, der zuerst erfolgreich ist, ist der Beweis, der verwendet wird.  
  
 In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt wird, und kann als Teil der Assembly-Zeichenfolgen angegeben werden. Z. B. "ProcessorArchitecture = Msil". Die empfohlene Methode zum Namen einer Assembly angeben. allerdings ist die Erstellung einer <xref:System.Reflection.AssemblyName> -Objekt und übergeben es an eine geeignete Überladung der der <xref:System.Reflection.Assembly.Load%2A> Methode. Siehe <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> ist keine gültige Assembly.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyString" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.  
  
- oder - 
Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">So sucht Common Language Runtime nach Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Ein Bytearray, das ein COFF-Image mit einer ausgegebenen Assembly ist.</param>
        <param name="rawSymbolStore">Ein Bytearray, das die Rohdatenbytes enthält, die die Symbole für die Assembly darstellen.</param>
        <param name="securityEvidence">Beweis für das Laden der Assembly.</param>
        <summary>Lädt die Assembly mit einem COFF-Image (Common Object File Format), das eine ausgegebene Assembly und optional Symbole sowie einen Beweis für die Assembly enthält. Die Assembly wird in die Anwendungsdomäne des Aufrufers geladen.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly wird mithilfe des bereitgestellten Beweises in die Domäne des Aufrufers geladen. Die Rohdatenbytes, die die Symbole für die Assembly darstellen, werden ebenfalls geladen.  
  
 Das Erteilen bestimmter Berechtigungen für eine Assembly beruht auf Beweisen. Die Regeln für das Zusammenführen von Assembly und Sicherheitsinformationen sind wie folgt aus:  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> Methode ohne <xref:System.Security.Policy.Evidence> -Parameter wird die Assembly mit der das Ladeprogramm bereitgestellten Beweisen geladen.  
  
-   Bei Verwendung von einer <xref:System.Reflection.Assembly.Load%2A> -Methode mit einer <xref:System.Security.Policy.Evidence> Parameter Beweise werden zusammengeführt. Beweise, die als Argument an die <xref:System.Reflection.Assembly.Load%2A> Methode ersetzen vom Ladeprogramm bereitgestellte Beweise.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> methodenüberladung mit einem `Byte[]` Parameter für das ein COFF-Image, Beweise zu laden, wird von der aufrufenden Assembly geerbt. Dies gilt für .NET Framework, Version 1.1 Service Pack 1 (SP1) und nachfolgende Versionen.  
  
    > [!NOTE]
    >  In .NET Framework, Version 1.0 und Version 1.1 ohne SP1, bei der Verwendung einer <xref:System.Reflection.Assembly.Load%2A> methodenüberladung mit einem `Byte[]` Parameter zum Laden eines COFF-Image, Beweise kombiniert wird. `Zone`, `Url` und `Site` stammen aus der aufrufenden Assembly und `Hash` und `StrongName` stammen aus der COFF-Assembly.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.Load%2A> -Methode mit einem `Byte[]` Parameter und <xref:System.Security.Policy.Evidence> um ein COFF-Image zu laden, wird nur der angegebene Beweis verwendet. Von der aufrufenden Assembly und Beweise von COFF-Image werden ignoriert.  
  
 Reflektieren ausführbaren C++-Dateien kann Auslösen einer <xref:System.BadImageFormatException>. Wahrscheinlichste Ursache ist der C++-Compiler die Umsetzungsadressen entfernen oder die `.reloc` Abschnitt aus der ausführbaren Datei. Beibehalten der `.reloc` für die ausführbare Datei für C++ zu beheben, geben Sie `/fixed:no` beim verknüpfen.  
  
 Aufrufen der [\], Byte\<xref:System.Reflection.Assembly.Load%2A >-Methode mehr als einmal in der gleichen Assembly, aber einen anderen Beweis angegeben, die common Language Runtime keine ausgelöst wird, eine <xref:System.IO.FileLoadException> da die Gleichheit und Integrität der anderen Beweis-Spezifikationen werden nicht bestimmt. Der Beweis, der zuerst erfolgreich ist, ist der Beweis, der verwendet wird.  
  
 Beachten Sie, dass die Überladung dieser Methode erstellt immer eine neue <xref:System.Reflection.Assembly> Objekt mit eigenen Zuordnung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> ist keine gültige Assembly.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="rawAssembly" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="securityEvidence" /> ist nicht <see langword="null" />.  Die CAS-Legacyrichtlinie ist standardmäßig in [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] nicht aktiviert. Wenn sie nicht aktiviert ist, muss <paramref name="securityEvidence" /> <see langword="null" /> sein.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit, Beweise angeben. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Ein Bytearray, das ein COFF-Image mit einer ausgegebenen Assembly ist.</param>
        <param name="rawSymbolStore">Ein Bytearray, das die Rohdatenbytes enthält, die die Symbole für die Assembly darstellen.</param>
        <param name="securityContextSource">Die Quelle des Sicherheitskontexts.</param>
        <summary>Lädt die Assembly mit einem COFF-Image (Common Object File Format), das eine ausgegebene Assembly und optional Symbole enthält und die Quelle für den Sicherheitskontext angibt. Die Assembly wird in die Anwendungsdomäne des Aufrufers geladen.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly wird geladen, in die Anwendungsdomäne des Aufrufers mithilfe der angegebenen Quelle für den Sicherheitskontext. Wenn `rawSymbolStore` angegeben wurde, das die Rohdatenbytes, die die Symbole für die Assembly darstellen, werden ebenfalls geladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> ist keine gültige Assembly.  
  
- oder - 
 <paramref name="rawAssembly" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="securityContextSource" />-Wert ist keiner der Enumerationswerte.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt den Inhalt einer Assemblydatei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der voll gekennzeichnete Pfad der zu ladenden Datei.</param>
        <summary>Lädt den Inhalt einer Assemblydatei mit dem angegebenen Pfad.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Reflection.Assembly.LoadFile%2A> Methode zum Laden und Überprüfen von Assemblys, die die gleiche Identität haben, aber unter verschiedenen Pfaden befinden. <xref:System.Reflection.Assembly.LoadFile%2A> Dateien wird nicht in den LoadFrom-Kontext geladen, und löst nicht die Abhängigkeiten, die mit den Ladepfad, als die <xref:System.Reflection.Assembly.LoadFrom%2A> Methode. <xref:System.Reflection.Assembly.LoadFile%2A> eignet sich für dieses Szenario beschränkt da <xref:System.Reflection.Assembly.LoadFrom%2A> nicht zum Laden von Assemblys verwendet werden, die über die gleiche Identität, aber unterschiedliche Pfade verfügen; es wird nur beim ersten Laden diese Assembly.  

Ab .NET Framework 4, wenn `path` gibt eine Assembly in einem Remotestandort befindet, beim Laden von Assemblys ist standardmäßig deaktiviert und die `LoadFile` -Methode löst eine <xref:System.IO.FileLoadException>. Damit kann codeausführung von Remotestandorten geladen, können Sie die [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) Konfigurationselement.    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das <paramref name="path" />-Argument ist kein absoluter Pfad.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.

- oder -

Das Ausführen von Code in Remoteassemblys ist deaktiviert. Weitere Informationen finden Sie unter <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Der <paramref name="path" />-Parameter ist eine leere Zeichenfolge ("") oder nicht vorhanden.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="path" /> ist keine gültige Assembly.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="path" /> wurde mit einer höheren Version kompiliert.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">Der vollqualifizierte Pfad der Assemblydatei.</param>
        <param name="securityEvidence">Beweis für das Laden der Assembly.</param>
        <summary>Lädt eine Assembly bei Angabe des Pfads, wobei die Assembly unter Verwendung der bereitgestellten Beweise in die Domäne des Aufrufers geladen wird.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Reflection.Assembly.LoadFile%2A> Methode zum Laden und Überprüfen von Assemblys, die die gleiche Identität haben, aber unter verschiedenen Pfaden befinden. <xref:System.Reflection.Assembly.LoadFile%2A> Lädt die Dateien in nicht die <xref:System.Reflection.Assembly.LoadFrom%2A> Kontext und nicht mit den Ladepfad, als Abhängigkeiten aufgelöst der <xref:System.Reflection.Assembly.LoadFrom%2A> Methode. <xref:System.Reflection.Assembly.LoadFile%2A> eignet sich für dieses Szenario beschränkt da <xref:System.Reflection.Assembly.LoadFrom%2A> nicht zum Laden von Assemblys verwendet werden, die über die gleiche Identität, aber unterschiedliche Pfade verfügen; es wird nur beim ersten Laden diese Assembly.  

Ab .NET Framework 4, wenn `path` gibt eine Assembly in einem Remotestandort befindet, beim Laden von Assemblys ist standardmäßig deaktiviert und die `LoadFile` -Methode löst eine <xref:System.IO.FileLoadException>. Damit kann codeausführung von Remotestandorten geladen, können Sie die [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) Konfigurationselement.    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das <paramref name="path" />-Argument ist kein absoluter Pfad.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Der <paramref name="path" />-Parameter ist eine leere Zeichenfolge ("") oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.

- oder -

Das Ausführen von Code in Remoteassemblys ist deaktiviert. Weitere Informationen finden Sie unter <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="path" /> ist keine gültige Assembly.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="path" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="securityEvidence" /> ist nicht <see langword="null" />. Die CAS-Legacyrichtlinie ist standardmäßig in [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] nicht aktiviert. Wenn sie nicht aktiviert ist, muss <paramref name="securityEvidence" /> <see langword="null" /> sein.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt eine Assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

Ab .NET Framework 4 ist die Möglichkeit zum Ausführen von Code in Assemblys geladen werden, von Remotestandorten standardmäßig, und der Aufruf von deaktiviert die `LoadFrom` -Methode löst eine <xref:System.IO.FileLoadException>. Zum Laden der Assembly und deren Code ausführen, müssen Sie entweder:

- Erstellen Sie explizit einen Sandkasten für die Assembly an. (Weitere Informationen finden Sie unter [Gewusst wie: Ausführen von teilweise vertrauenswürdigem Code in einer Sandbox](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)

- Führen Sie die Assembly Code mit voller Vertrauenswürdigkeit mit den `enabled` Attribut der [ `<loadFromRemoteSources>` Konfigurationselement](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) zu `true`. Weitere Informationen finden Sie unter den [ `<loadFromRemoteSources>` Konfigurationselement](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) Artikel.

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name oder Pfad der Datei, die das Manifest der Assembly enthält.</param>
        <summary>Lädt eine Assembly bei Angabe des Anzeigenamens oder Pfads.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `assemblyFile` Parameter muss zu einem URI ohne Escapezeichen verweisen. Diese Methode gibt für alle ungültigen Zeichen im URI-Escape-Zeichen.  
  
> [!NOTE]
>  Dateiübertragungsprotokoll (FTP) wird nicht unterstützt. Wenn der URI für angegeben `assemblyFile` ist eine FTP-Adresse, die Assembly wurde nicht geladen. Es werden keine Ausnahmen ausgelöst.  
  
 `assemblyFile` kann absolut oder relativ zum aktuellen Verzeichnis sein und die Assembly in die Domäne des Aufrufers geladen wird.  
  
 Assemblys in einem von drei Kontexten geladen werden, oder Sie können ohne Kontext geladen werden:  
  
-   Der Load-Kontext enthält Assemblys, die Überprüfung gefundene: im GAC, in einer Hostassembly zu speichern, wenn die Runtime gehostet wird, oder in der <xref:System.AppDomainSetup.ApplicationBase%2A> und <xref:System.AppDomainSetup.PrivateBinPath%2A> der Anwendungsdomäne. Die meisten Überladungen der Methode <xref:System.Reflection.Assembly.Load%2A> laden Assemblys in diesen Kontext.  
  
-   Der LoadFrom-Kontext enthält Assemblys, die für die der Benutzer einen Pfad, der nicht in den Verzeichnissen, die Überprüfung durch Durchsuchen enthalten bereitgestellt. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> und <xref:System.AppDomain.ExecuteAssembly%2A> sind Beispiel für Methoden, die anhand des Pfads laden. 

    Ab .NET Framework 4, wenn der URI des `assemblyFile` gibt Sie an einem Remotestandort befindet, beim Laden von Assemblys ist standardmäßig deaktiviert und die `LoadFrom` -Methode löst eine <xref:System.IO.FileLoadException>. Damit kann codeausführung von Remotestandorten geladen, können Sie die [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) Konfigurationselement.    
  
-   Der ReflectionOnly-Kontext enthält Assemblys, die geladen und die <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> und <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> Methoden; Code in diesen Kontexten können nicht ausgeführt werden.  
  
-   Wenn der Benutzer generiert, oder die Assembly gefunden, ist es nicht in jedem Kontext. Dies gilt für Assemblys geladen, mit Überladungen von der <xref:System.Reflection.Assembly.Load%2A> -Methode, die ein Bytearray mit einer Assembly angeben, um flüchtige dynamische Assemblys mit Reflektion erstellt ausgeben und nicht auf dem Datenträger gespeichert.  
  
 LoadFrom-Kontext ermöglicht es einer Assembly aus einem Pfad, der bei der Suche nicht enthalten sein, und ermöglicht dennoch Abhängigkeiten unter diesem Pfad gefunden und geladen, da die Pfadinformationen vom Kontext verwaltet wird.  
  
 Die <xref:System.Reflection.Assembly.LoadFrom%2A> Methode hat folgende Nachteile. Verwenden Sie stattdessen <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Wenn eine Assembly mit der gleichen Identität bereits geladen wurde, gibt <xref:System.Reflection.Assembly.LoadFrom%2A> die geladene Assembly zurück, auch wenn ein anderer Pfad angegeben wurde.  
  
-   Wenn eine Assembly geladen wurde mit <xref:System.Reflection.Assembly.LoadFrom%2A>, und später eine Assembly im Load-Kontext versucht, dieselbe Assembly anhand des Anzeigenamens zu laden, schlägt der Ladeversuch fehl. Dies kann auftreten, wenn eine Assembly deserialisiert wird.  
  
-   Wenn eine Assembly geladen wurde mit <xref:System.Reflection.Assembly.LoadFrom%2A>, und der Suchpfad einer Assembly mit derselben Identität, aber einen anderen Speicherort ein <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, oder anderes unerwartetes Verhalten auftreten kann.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> fordert <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> oder <xref:System.Net.WebPermission> im angegebenen Pfad.  
  
-   Wenn für ein natives Image vorhanden ist `assemblyFile`, er wird nicht verwendet. Die Assembly nicht domänenneutral geladen.  
  
-   In .NET Framework, Version 1.0 und 1.1 ist die Richtlinie nicht angewendet.  
  
   
  
## Examples  
 Das folgende Beispiel lädt eine Assembly bei Angabe des Anzeigenamens oder Pfads.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> wurde nicht gefunden, oder das Modul, das Sie laden möchten, gibt keine Dateierweiterung an.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.

- oder -

Das Ausführen von Code in Remoteassemblys ist deaktiviert. Weitere Informationen finden Sie unter <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> ist keine gültige Assembly, z. B. eine 32-Bit-Assembly in einem 64-Bit-Prozess. Weitere Informationen finden Sie im Thema zu Ausnahmen.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.Security.SecurityException">Eine Codebasis, die nicht mit "file://" beginnt, wurde ohne die erforderliche <see cref="T:System.Net.WebPermission" /> angegeben.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="assemblyFile" />-Parameter ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Assemblyname überschreitet die im System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen von eines URIS, der mit "file://" beginnt. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name oder Pfad der Datei, die das Manifest der Assembly enthält.</param>
        <param name="securityEvidence">Beweis für das Laden der Assembly.</param>
        <summary>Lädt eine Assembly bei Angabe des Dateinamens oder Pfads und liefert den Sicherheitsbeweis.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `assemblyFile` Parameter muss zu einem URI ohne Escapezeichen verweisen. Diese Methode gibt für alle ungültigen Zeichen im URI-Escape-Zeichen.  
  
> [!NOTE]
>  Dateiübertragungsprotokoll (FTP) wird nicht unterstützt. Wenn der URI für angegeben `assemblyFile` ist eine FTP-Adresse, die Assembly wurde nicht geladen. Es werden keine Ausnahmen ausgelöst.  
  
 `assemblyFile` kann absolut oder relativ zum aktuellen Verzeichnis sein und die Assembly in die Domäne des Aufrufers geladen wird.  
  
 Assemblys in einem von drei Kontexten geladen werden, oder Sie können ohne Kontext geladen werden:  
  
-   Der Load-Kontext enthält Assemblys, die Überprüfung gefundene: im GAC, in einer Hostassembly zu speichern, wenn die Runtime gehostet wird, oder in der <xref:System.AppDomainSetup.ApplicationBase%2A> und <xref:System.AppDomainSetup.PrivateBinPath%2A> der Anwendungsdomäne. Die meisten Überladungen der Methode <xref:System.Reflection.Assembly.Load%2A> laden Assemblys in diesen Kontext.  
  
-   Der LoadFrom-Kontext enthält Assemblys, die für die der Benutzer einen Pfad, der nicht in den Verzeichnissen, die Überprüfung durch Durchsuchen enthalten bereitgestellt. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> und <xref:System.AppDomain.ExecuteAssembly%2A> sind Beispiel für Methoden, die anhand des Pfads laden.

    Ab .NET Framework 4, wenn der URI des `assemblyFile` gibt Sie an einem Remotestandort befindet, beim Laden von Assemblys ist standardmäßig deaktiviert und die `LoadFrom` -Methode löst eine <xref:System.IO.FileLoadException>. Damit kann codeausführung von Remotestandorten geladen, können Sie die [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) Konfigurationselement.    
  
-   Der ReflectionOnly-Kontext enthält Assemblys, die geladen und die <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> und <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> Methoden; Code in diesen Kontexten können nicht ausgeführt werden.  
  
-   Wenn der Benutzer generiert, oder die Assembly gefunden, ist es nicht in jedem Kontext. Dies gilt für Assemblys geladen, mit Überladungen von der <xref:System.Reflection.Assembly.Load%2A> -Methode, die ein Bytearray mit einer Assembly angeben, um flüchtige dynamische Assemblys mit Reflektion erstellt ausgeben und nicht auf dem Datenträger gespeichert.  
  
 LoadFrom-Kontext ermöglicht es einer Assembly aus einem Pfad, der bei der Suche nicht enthalten sein, und ermöglicht dennoch Abhängigkeiten unter diesem Pfad gefunden und geladen, da die Pfadinformationen vom Kontext verwaltet wird.  
  
 Die <xref:System.Reflection.Assembly.LoadFrom%2A> Methode hat folgende Nachteile. Verwenden Sie stattdessen <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Wenn eine Assembly mit der gleichen Identität bereits geladen wurde, gibt <xref:System.Reflection.Assembly.LoadFrom%2A> die geladene Assembly zurück, auch wenn ein anderer Pfad angegeben wurde.  
  
-   Wenn eine Assembly geladen wurde mit <xref:System.Reflection.Assembly.LoadFrom%2A>, und später eine Assembly im Load-Kontext versucht, dieselbe Assembly anhand des Anzeigenamens zu laden, schlägt der Ladeversuch fehl. Dies kann auftreten, wenn eine Assembly deserialisiert ist.  
  
-   Wenn eine Assembly geladen wurde mit <xref:System.Reflection.Assembly.LoadFrom%2A>, und der Suchpfad einer Assembly mit derselben Identität, aber einen anderen Speicherort ein <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, oder anderes unerwartetes Verhalten auftreten kann.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> fordert <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> oder <xref:System.Net.WebPermission> im angegebenen Pfad.  
  
-   Wenn für ein natives Image vorhanden ist `assemblyFile`, er wird nicht verwendet. Die Assembly nicht domänenneutral geladen.  
  
-   In .NET Framework, Version 1.0 und 1.1 ist die Richtlinie nicht angewendet.  
  
 Das Erteilen bestimmter Berechtigungen für eine Assembly beruht auf Beweisen. Die Regeln für das Zusammenführen von Assembly und Sicherheitsinformationen sind wie folgt aus:  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.LoadFrom%2A> Methode ohne <xref:System.Security.Policy.Evidence> -Parameter wird die Assembly mit der das Ladeprogramm bereitgestellten Beweisen geladen.  
  
-   Bei Verwendung von einer <xref:System.Reflection.Assembly.LoadFrom%2A> -Methode mit einer <xref:System.Security.Policy.Evidence> Parameter Beweise werden zusammengeführt. Beweise, die als Argument an die <xref:System.Reflection.Assembly.LoadFrom%2A> Methode ersetzen vom Ladeprogramm bereitgestellte Beweise.  
  
-   Wenn Sie diese Methode mehrmals für dieselbe Assembly jedoch einen anderen Beweis angegebenen aufrufen, die common Language Runtime löst keine <xref:System.IO.FileLoadException> , da die Gleichheit und Integrität der anderen Beweis-Spezifikationen nicht bestimmt werden können. Der Beweis, der zuerst erfolgreich ist, ist der Beweis, der verwendet wird.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.LoadFrom%2A> -Methode mit einer `Byte[]` Parameter, um ein Image common Object File Format (COFF), Beweise laden kombiniert wird. `Zone`, `Url` und `Site` stammen aus der aufrufenden Assembly und `Hash` und `StrongName` stammen aus der COFF-Assembly.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.LoadFrom%2A> -Methode mit einem `Byte[]` Parameter und <xref:System.Security.Policy.Evidence> um ein COFF-Image zu laden, wird nur der angegebene Beweis verwendet. Von der aufrufenden Assembly und Beweise von COFF-Image werden ignoriert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> wurde nicht gefunden, oder das Modul, das Sie laden möchten, gibt keine Dateierweiterung an.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.  
  
- oder - 
<paramref name="securityEvidence" /> ist nicht mehrdeutig und wird als ungültig bestimmt.

- oder -

Das Ausführen von Code in Remoteassemblys ist deaktiviert. Weitere Informationen finden Sie unter <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> ist keine gültige Assembly, z. B. eine 32-Bit-Assembly in einem 64-Bit-Prozess. Weitere Informationen finden Sie im Thema zu Ausnahmen.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.Security.SecurityException">Eine Codebasis, die nicht mit "file://" beginnt, wurde ohne die erforderliche <see cref="T:System.Net.WebPermission" /> angegeben.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="assemblyFile" />-Parameter ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Assemblyname überschreitet die im System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen von eines URIS, der mit "file://" beginnt. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name oder Pfad der Datei, die das Manifest der Assembly enthält.</param>
        <param name="hashValue">Der Wert des errechneten Hashcodes.</param>
        <param name="hashAlgorithm">Der Hashalgorithmus für das Hashing von Dateien und das Generieren des starken Namens.</param>
        <summary>Lädt eine Assembly bei Angabe des Dateinamens bzw. -pfads, des Hashwerts und des Hashalgorithmus.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `assemblyFile` Parameter muss zu einem URI ohne Escapezeichen verweisen. Diese Methode gibt für alle ungültigen Zeichen im URI-Escape-Zeichen.  
  
> [!NOTE]
>  Dateiübertragungsprotokoll (FTP) wird nicht unterstützt. Wenn der URI für angegeben `assemblyFile` ist eine FTP-Adresse, die Assembly wurde nicht geladen. Es werden keine Ausnahmen ausgelöst.  
  
 `assemblyFile` kann absolut oder relativ zum aktuellen Verzeichnis sein und die Assembly in die Domäne des Aufrufers geladen wird.  
  
 Assemblys in einem von drei Kontexten geladen werden, oder Sie können ohne Kontext geladen werden:  
  
-   Der Load-Kontext enthält Assemblys, die Überprüfung gefundene: im globalen Assemblycache, in einer Hostassembly zu speichern, wenn die Runtime gehostet wird, oder in der <xref:System.AppDomainSetup.ApplicationBase%2A> und <xref:System.AppDomainSetup.PrivateBinPath%2A> der Anwendungsdomäne. Die meisten Überladungen der Methode <xref:System.Reflection.Assembly.Load%2A> laden Assemblys in diesen Kontext.  
  
-   Der LoadFrom-Kontext enthält Assemblys, die für die der Benutzer einen Pfad bereitgestellt, der bei der Suche nicht enthalten ist. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> und <xref:System.AppDomain.ExecuteAssembly%2A> sind Beispiel für Methoden, die anhand des Pfads laden.  

    Ab .NET Framework 4, wenn der URI des `assemblyFile` gibt Sie an einem Remotestandort befindet, beim Laden von Assemblys ist standardmäßig deaktiviert und die `LoadFrom` -Methode löst eine <xref:System.IO.FileLoadException>. Damit kann codeausführung von Remotestandorten geladen, können Sie die [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) Konfigurationselement.    
  
-   Der ReflectionOnly-Kontext enthält Assemblys, die geladen und die <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> und <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> Methoden; Code in diesen Kontexten können nicht ausgeführt werden.  
  
-   Wenn der Benutzer generiert, oder die Assembly gefunden, ist es nicht in jedem Kontext. Dies gilt für Assemblys geladen, mit Überladungen von der <xref:System.Reflection.Assembly.Load%2A> -Methode, die ein Bytearray mit einer Assembly angeben, um flüchtige dynamische Assemblys mit Reflektion erstellt ausgeben und nicht auf dem Datenträger gespeichert.  
  
 Der LoadFrom-Kontext ermöglicht es einer Assembly aus einem Pfad geladen werden, die bei der Suche nicht enthalten ist, und ermöglicht dennoch Abhängigkeiten unter diesem Pfad gefunden und geladen, da die Pfadinformationen vom Kontext verwaltet wird.  
  
 Die <xref:System.Reflection.Assembly.LoadFrom%2A> Methode hat folgende Nachteile. Verwenden Sie stattdessen <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Wenn eine Assembly mit der gleichen Identität bereits geladen wurde, gibt <xref:System.Reflection.Assembly.LoadFrom%2A> die geladene Assembly zurück, auch wenn ein anderer Pfad angegeben wurde.  
  
-   Wenn eine Assembly geladen wurde mit <xref:System.Reflection.Assembly.LoadFrom%2A>, und später eine Assembly im Load-Kontext versucht, dieselbe Assembly anhand des Anzeigenamens zu laden, schlägt der Ladeversuch fehl. Dies kann auftreten, wenn eine Assembly deserialisiert ist.  
  
-   Wenn eine Assembly geladen wurde mit <xref:System.Reflection.Assembly.LoadFrom%2A>, und der Suchpfad einer Assembly mit derselben Identität, aber einen anderen Speicherort ein <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, oder anderes unerwartetes Verhalten auftreten kann.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> fordert <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> oder <xref:System.Net.WebPermission> im angegebenen Pfad.  
  
-   Wenn für ein natives Image vorhanden ist `assemblyFile`, er wird nicht verwendet. Die Assembly kann nicht als domänenneutral geladen werden.  
  
 Die Assembly wird mit der das Ladeprogramm bereitgestellten Beweisen geladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> wurde nicht gefunden, oder das Modul, das Sie laden möchten, gibt keine Dateinamenerweiterung an.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.

- oder -

Das Ausführen von Code in Remoteassemblys ist deaktiviert. Weitere Informationen finden Sie unter <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> ist keine gültige Assembly, z. B. eine 32-Bit-Assembly in einem 64-Bit-Prozess. Weitere Informationen finden Sie im Thema zu Ausnahmen.  
  
- oder - 
 <paramref name="assemblyFile" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.Security.SecurityException">Eine Codebasis, die nicht mit "file://" beginnt, wurde ohne die erforderliche <see cref="T:System.Net.WebPermission" /> angegeben.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="assemblyFile" />-Parameter ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Assemblyname überschreitet die im System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen von eines URIS, der mit "file://" beginnt. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name oder Pfad der Datei, die das Manifest der Assembly enthält.</param>
        <param name="securityEvidence">Beweis für das Laden der Assembly.</param>
        <param name="hashValue">Der Wert des errechneten Hashcodes.</param>
        <param name="hashAlgorithm">Der Hashalgorithmus für das Hashing von Dateien und das Generieren des starken Namens.</param>
        <summary>Lädt eine Assembly bei Angabe des Dateinamens bzw. -pfads, des Hashwerts, der Sicherheitsbeweise und des Hashalgorithmus.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `assemblyFile` Parameter muss zu einem URI ohne Escapezeichen verweisen. Diese Methode gibt für alle ungültigen Zeichen im URI-Escape-Zeichen.  
  
> [!NOTE]
>  Dateiübertragungsprotokoll (FTP) wird nicht unterstützt. Wenn der URI für angegeben `assemblyFile` ist eine FTP-Adresse, die Assembly wurde nicht geladen. Es werden keine Ausnahmen ausgelöst.  
  
 `assemblyFile` kann absolut oder relativ zum aktuellen Verzeichnis sein und die Assembly in die Domäne des Aufrufers geladen wird.  
  
 Assemblys in einem von drei Kontexten geladen werden, oder Sie können ohne Kontext geladen werden:  
  
-   Der Load-Kontext enthält Assemblys, die Überprüfung gefundene: im GAC, in einer Hostassembly zu speichern, wenn die Runtime gehostet wird, oder in der <xref:System.AppDomainSetup.ApplicationBase%2A> und <xref:System.AppDomainSetup.PrivateBinPath%2A> der Anwendungsdomäne. Die meisten Überladungen der Methode <xref:System.Reflection.Assembly.Load%2A> laden Assemblys in diesen Kontext.  
  
-   Der LoadFrom-Kontext enthält Assemblys, die für die der Benutzer einen Pfad, der nicht in den Verzeichnissen, die Überprüfung durch Durchsuchen enthalten bereitgestellt. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> und <xref:System.AppDomain.ExecuteAssembly%2A> sind Beispiel für Methoden, die anhand des Pfads laden.  

    Ab .NET Framework 4, wenn der URI des `assemblyFile` gibt Sie an einem Remotestandort befindet, beim Laden von Assemblys ist standardmäßig deaktiviert und die `LoadFrom` -Methode löst eine <xref:System.IO.FileLoadException>. Damit kann codeausführung von Remotestandorten geladen, können Sie die [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) Konfigurationselement.    
  
-   Der ReflectionOnly-Kontext enthält Assemblys, die geladen und die <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> und <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> Methoden; Code in diesen Kontexten können nicht ausgeführt werden.  
  
-   Wenn der Benutzer generiert, oder die Assembly gefunden, ist es nicht in jedem Kontext. Dies gilt für Assemblys geladen, mit Überladungen von der <xref:System.Reflection.Assembly.Load%2A> -Methode, die ein Bytearray mit einer Assembly angeben, um flüchtige dynamische Assemblys mit Reflektion erstellt ausgeben und nicht auf dem Datenträger gespeichert.  
  
 LoadFrom-Kontext ermöglicht es einer Assembly aus einem Pfad, der bei der Suche nicht enthalten sein, und ermöglicht dennoch Abhängigkeiten unter diesem Pfad gefunden und geladen, da die Pfadinformationen vom Kontext verwaltet wird.  
  
 Die <xref:System.Reflection.Assembly.LoadFrom%2A> Methode hat folgende Nachteile. Verwenden Sie stattdessen <xref:System.Reflection.Assembly.Load%2A>.  
  
-   Wenn eine Assembly mit der gleichen Identität bereits geladen wurde, gibt <xref:System.Reflection.Assembly.LoadFrom%2A> die geladene Assembly zurück, auch wenn ein anderer Pfad angegeben wurde.  
  
-   Wenn eine Assembly geladen wurde mit <xref:System.Reflection.Assembly.LoadFrom%2A>, und später eine Assembly im Load-Kontext versucht, dieselbe Assembly anhand des Anzeigenamens zu laden, schlägt der Ladeversuch fehl. Dies kann auftreten, wenn eine Assembly deserialisiert ist.  
  
-   Wenn eine Assembly geladen wurde mit <xref:System.Reflection.Assembly.LoadFrom%2A>, und der Suchpfad einer Assembly mit derselben Identität, aber einen anderen Speicherort ein <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, oder anderes unerwartetes Verhalten auftreten kann.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> fordert <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> oder <xref:System.Net.WebPermission> im angegebenen Pfad.  
  
-   Wenn für ein natives Image vorhanden ist `assemblyFile`, er wird nicht verwendet. Die Assembly nicht domänenneutral geladen.  
  
-   In .NET Framework, Version 1.0 und 1.1 ist die Richtlinie nicht angewendet.  
  
 Das Erteilen bestimmter Berechtigungen für eine Assembly beruht auf Beweisen. Die Regeln für das Zusammenführen von Assembly und Sicherheitsinformationen sind wie folgt aus:  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.LoadFrom%2A> Methode ohne <xref:System.Security.Policy.Evidence> -Parameter wird die Assembly mit der das Ladeprogramm bereitgestellten Beweisen geladen.  
  
-   Bei Verwendung von einer <xref:System.Reflection.Assembly.LoadFrom%2A> -Methode mit einer <xref:System.Security.Policy.Evidence> Parameter Beweise werden zusammengeführt. Beweise, die als Argument an die <xref:System.Reflection.Assembly.LoadFrom%2A> Methode ersetzen vom Ladeprogramm bereitgestellte Beweise.  
  
-   Wenn Sie diese Methode mehrmals für dieselbe Assembly jedoch einen anderen Beweis angegebenen aufrufen, die common Language Runtime löst keine <xref:System.IO.FileLoadException> , da die Gleichheit und Integrität der anderen Beweis-Spezifikationen nicht bestimmt werden können. Der Beweis, der zuerst erfolgreich ist, ist der Beweis, der verwendet wird.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.LoadFrom%2A> -Methode mit einer `Byte[]` Parameter, um ein Image common Object File Format (COFF), Beweise laden kombiniert wird. `Zone`, `Url` und `Site` stammen aus der aufrufenden Assembly und `Hash` und `StrongName` stammen aus der COFF-Assembly.  
  
-   Bei Verwendung einer <xref:System.Reflection.Assembly.LoadFrom%2A> -Methode mit einem `Byte[]` Parameter und <xref:System.Security.Policy.Evidence> um ein COFF-Image zu laden, wird nur der angegebene Beweis verwendet. Von der aufrufenden Assembly und Beweise von COFF-Image werden ignoriert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> wurde nicht gefunden, oder das Modul, das Sie laden möchten, gibt keine Dateierweiterung an.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.  
  
- oder - 
<paramref name="securityEvidence" /> ist nicht mehrdeutig und wird als ungültig bestimmt.

- oder -

Das Ausführen von Code in Remoteassemblys ist deaktiviert. Weitere Informationen finden Sie unter <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> ist keine gültige Assembly, z. B. eine 32-Bit-Assembly in einem 64-Bit-Prozess. Weitere Informationen finden Sie im Thema zu Ausnahmen.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.Security.SecurityException">Eine Codebasis, die nicht mit "file://" beginnt, wurde ohne die erforderliche <see cref="T:System.Net.WebPermission" /> angegeben.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="assemblyFile" />-Parameter ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Assemblyname überschreitet die im System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen von eines URIS, der mit "file://" beginnt. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt das Modul, das für diese Assembly intern ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">Der Name des Moduls. Diese Zeichenfolge muss einem Dateinamen im Manifest dieser Assembly entsprechen.</param>
        <param name="rawModule">Ein Bytearray, das ein COFF-Image mit einem ausgegebenen Modul oder eine Ressource ist.</param>
        <summary>Lädt das Modul, das für diese Assembly intern ist, mit einem COFF (Common Object File Format)-Image, das ein ausgegebenes Modul enthält, oder eine Ressourcendatei.</summary>
        <returns>Das geladene Modul.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="moduleName" /> oder <paramref name="rawModule" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="moduleName" /> stimmt mit keinem Dateieintrag im Manifest dieser Assembly überein.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawModule" /> ist kein gültiges Modul.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">Der Name des Moduls. Diese Zeichenfolge muss einem Dateinamen im Manifest dieser Assembly entsprechen.</param>
        <param name="rawModule">Ein Bytearray, das ein COFF-Image mit einem ausgegebenen Modul oder eine Ressource ist.</param>
        <param name="rawSymbolStore">Ein Bytearray, das die Rohdatenbytes enthält, die die Symbole für das Modul darstellen. Muss <see langword="null" /> sein, wenn es sich um eine Ressourcendatei handelt.</param>
        <summary>Lädt das Modul, das für diese Assembly intern ist, mit einem COFF (Common Object File Format)-Image, das ein ausgegebenes Modul enthält, oder eine Ressourcendatei. Die Rohdatenbytes, die die Symbole für das Modul darstellen, werden ebenfalls geladen.</summary>
        <returns>Das geladene Modul.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="moduleName" /> oder <paramref name="rawModule" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="moduleName" /> stimmt mit keinem Dateieintrag im Manifest dieser Assembly überein.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawModule" /> ist kein gültiges Modul.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt eine Assembly mithilfe eines unvollständigen Namens aus dem Anwendungsverzeichnis oder dem globalen Assemblycache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Die Überladungen der <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> Methode sind veraltet und wurden für die Abwärtskompatibilität beibehalten. Die nicht veraltete Alternative ist <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">Der Anzeigename der Assembly.</param>
        <summary>Lädt eine Assembly mithilfe eines unvollständigen Namens aus dem Anwendungsverzeichnis oder dem globalen Assemblycache.</summary>
        <returns>Die geladene Assembly. Wenn <paramref name="partialName" /> nicht gefunden wird, gibt diese Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Die <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> Methode ist veraltet und wurde für die Abwärtskompatibilität beibehalten. Die nicht veraltete Alternative ist <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Anwendungen, die für das Laden von Assemblys mit dieser Methode werden von Upgrades von diesen Assemblys betroffen. Aus diesem Grund verwenden Sie diese Methode nicht. Umgestalten die Anwendung zur Verwendung der <xref:System.Reflection.Assembly.Load%28System.String%29> methodenüberladung oder <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> -methodenüberladung.  
  
 Diese Methode ruft zuerst <xref:System.Reflection.Assembly.Load%2A>. Wenn die Assembly nicht gefunden wird, gibt diese Methode die Assembly aus dem globalen Assemblycache, der dem gleichen einfachen Namen und die höchste Versionsnummer aufweist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="partialName" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="partialName" /> wurde mit einer höheren Version kompiliert.</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">Der Anzeigename der Assembly.</param>
        <param name="securityEvidence">Beweis für das Laden der Assembly.</param>
        <summary>Lädt eine Assembly mithilfe eines unvollständigen Namens aus dem Anwendungsverzeichnis oder dem globalen Assemblycache. Die Assembly wird mithilfe des bereitgestellten Beweises in die Domäne des Aufrufers geladen.</summary>
        <returns>Die geladene Assembly. Wenn <paramref name="partialName" /> nicht gefunden wird, gibt diese Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Die <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> Methode ist veraltet und wurde für die Abwärtskompatibilität beibehalten. Die nicht veraltete Alternative ist <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Den Beweis bilden die Informationen, die der Sicherheitsrichtlinie als Eingaben für Entscheidungen dienen, z. B., welche Berechtigungen einem Code erteilt werden können.  
  
 Anwendungen, die für das Laden von Assemblys mit dieser Methode werden von Upgrades von diesen Assemblys betroffen. Aus diesem Grund verwenden Sie diese Methode nicht. Umgestalten die Anwendung zur Verwendung der <xref:System.Reflection.Assembly.Load%2A> Methode oder der <xref:System.Reflection.Assembly.LoadFrom%2A> Methode.  
  
 Diese Methode ruft zuerst <xref:System.Reflection.Assembly.Load%2A>. Wenn die Assembly nicht gefunden wird, gibt diese Methode die Assembly aus dem globalen Assemblycache, der dem gleichen einfachen Namen und die höchste Versionsnummer aufweist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweissätzen geladen.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="partialName" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="partialName" /> wurde mit einer höheren Version kompiliert.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwalteten Codes und zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vollständigen Pfad oder UNC-Pfad der geladenen Datei ab, die das Manifest enthält.</summary>
        <value>Der Speicherort der geladenen Datei, die das Manifest enthält. Wenn eine Schattenkopie der geladenen Datei erstellt wurde, entspricht der Speicherort dem der Datei nach dem Erstellen der Schattenkopie. Wenn die Assembly aus einem Bytearray geladen wurde, z. B. bei Verwendung der Überladung der <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" />-Methode, ist der zurückgegebene Wert eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Speicherort vor dem Erstellen die Datei Schattenkopien mit der <xref:System.Reflection.Assembly.CodeBase%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Speicherort der geladenen Datei, die das Manifest enthält.  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aktuelle Assembly ist eine dynamische Assembly, dargestellt durch ein <see cref="T:System.Reflection.Emit.AssemblyBuilder" />-Objekt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf den Pfad. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Erstellen von Schattenkopien von Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Modul mit dem Manifest für die aktuelle Assembly ab.</summary>
        <value>Das Modul mit dem Manifest für die Assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Klassenladeprogramm der Common Language Runtime einen Verweis auf ein internes Modul einer Assembly nicht auf normale Weise auflösen kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis gibt dem Rückruf die Gelegenheit, suchen und Laden Sie das Modul selbst und zurückgeben.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Sammlung ab, die die Module in dieser Assembly enthält.</summary>
        <value>Eine Sammlung, die die Module in dieser Assembly enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">Die Assembly, die mit <paramref name="right" /> verglichen werden soll.</param>
        <param name="right">Die Assembly, die mit <paramref name="left" /> verglichen werden soll.</param>
        <summary>Gibt an, ob zwei <see cref="T:System.Reflection.Assembly" />-Objekte gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">Die Assembly, die mit <paramref name="right" /> verglichen werden soll.</param>
        <param name="right">Die Assembly, die mit <paramref name="left" /> verglichen werden soll.</param>
        <summary>Gibt an, ob zwei <see cref="T:System.Reflection.Assembly" />-Objekte ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Berechtigungssatz der aktuellen Assembly ab.</summary>
        <value>Der Berechtigungssatz der aktuellen Assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> -Objekte können vertraulichen Informationen wie z. B. Pfade enthalten. Aus diesem Grund ist volle Vertrauenswürdigkeit erforderlich, um diese Objekte zugreifen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob diese Assembly in den ReflectionOnly-Kontext geladen wurde.</summary>
        <value><see langword="true" />, wenn die Assembly in den ReflectionOnly-Kontext und nicht in den Ausführungskontext geladen wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Assembly in den ReflectionOnly-Kontext geladen wurde, mithilfe der <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> -Methode Code kann nicht ausgeführt werden, in der Assembly. Um Code auszuführen, muss die Assembly in den Ausführungskontext geladen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt eine Assembly in den ReflectionOnly-Kontext, wo sie überprüft, aber nicht ausgeführt werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Ein Bytearray, das ein COFF-Image mit einer ausgegebenen Assembly ist.</param>
        <summary>Lädt die Assembly aus einem COFF (Common Object File Format)-Image, das eine ausgegebene Assembly enthält. Die Assembly wird in den ReflectionOnly-Kontext der Anwendungsdomäne des Aufrufers geladen.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Code kann nicht in den ReflectionOnly-Kontext geladenen Assembly ausgeführt werden. Um Code auszuführen, die Assembly muss geladen werden in den Ausführungskontext auch mithilfe der <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
 Der ReflectionOnly-Kontext unterscheidet sich nicht von anderen Kontexten. In den Kontext geladene Assemblys können durch das Entladen der Anwendungsdomäne entladen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> ist keine gültige Assembly.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="rawAssembly" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="rawAssembly" /> kann nicht geladen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Der Anzeigename der Assembly, wie von der <see cref="P:System.Reflection.AssemblyName.FullName" />-Eigenschaft zurückgegeben.</param>
        <summary>Lädt eine Assembly in den ReflectionOnly-Kontext, wenn ihr Anzeigename angegeben wurde.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abhängigkeiten werden nicht automatisch in den ReflectionOnly-Kontext geladen.  
  
 Code kann nicht in den ReflectionOnly-Kontext geladenen Assembly ausgeführt werden. Um Code auszuführen, die Assembly muss geladen werden in den Ausführungskontext auch mithilfe der <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
 Das Erteilen bestimmter Berechtigungen für eine Assembly beruht auf Beweisen. Die Regeln für das Zusammenführen von Assembly und Sicherheitsinformationen sind wie folgt aus:  
  
> [!NOTE]
>  In C++ kompilierten ausführbaren Dateien Reflektion löst möglicherweise eine <xref:System.IO.FileLoadException>. Dies wird wahrscheinlich von der C++-Compiler die Umsetzungsadressen oder den .reloc-Abschnitt aus der ausführbaren Datei zu beschränken, verursacht werden. Wenn die .reloc-Adresse beibehalten möchten, geben Sie `/fixed:no` beim verknüpfen.  
  
 Der ReflectionOnly-Kontext unterscheidet sich nicht von anderen Kontexten. In den Kontext geladene Assemblys können durch das Entladen der Anwendungsdomäne entladen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyString" /> ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="assemblyString" /> wurde gefunden, kann aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> ist keine gültige Assembly.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyString" /> wurde mit einer höheren Version kompiliert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Pfad der Datei, die das Manifest der Assembly enthält.</param>
        <summary>Lädt eine Assembly in den ReflectionOnly-Kontext, wenn ihr Pfad angegeben wurde.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abhängigkeiten werden nicht automatisch in den ReflectionOnly-Kontext geladen. Wenn Sie um Abhängigkeiten automatisch zu laden, verarbeiten die <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> Ereignis- und Laden Sie die Abhängigkeit in den Ereignishandler.  
  
 Code kann nicht aus einer Assembly ausgeführt werden, die in den ReflectionOnly-Kontext geladen wurde. Um den Code auszuführen, laden Sie die Assembly mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode.  
  
 Die `assemblyFile` Parameter muss zu einem URI ohne Escapezeichen verweisen. Diese Methode gibt für alle ungültigen Zeichen im URI-Escape-Zeichen.  
  
 Der angegebene Pfad für `assemblyFile` ist relativ zum aktuellen Verzeichnis. Die Assembly wird in der Domäne des Aufrufers geladen.  
  
 Der ReflectionOnly-Kontext unterscheidet sich nicht von anderen Kontexten. In den Kontext geladene Assemblys können durch das Entladen der Anwendungsdomäne entladen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> wurde nicht gefunden, oder das Modul, das Sie laden möchten, gibt keine Dateinamenerweiterung an.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="assemblyFile" /> wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder - 
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.Security.SecurityException">Eine Codebasis, die nicht mit "file://" beginnt, wurde ohne die erforderliche <see cref="T:System.Net.WebPermission" /> angegeben.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Assemblyname überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> ist eine leere Zeichenfolge ("").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen von eines URIS, der mit "file://" beginnt. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, welchen Satz von Sicherheitsregeln die Common Language Runtime (CLR) für diese Assembly erzwingt.</summary>
        <value>Der Sicherheitsregelsatz, den die CLR für diese Assembly erzwingt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig werden in Assemblys, die Kompilierung mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] Transparenz ist, auch wenn Sie diese stattdessen explizit machen können. Assemblys, die mit früheren Versionen von .NET Framework kompiliert wurden, müssen Transparenz der Ebene 1.  
  
 Weitere Informationen finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md">Sicherheitstransparenter Code</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Änderungen der Sicherheit in .NET Framework 4</related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Typ der aktuellen Instanz zurück.</summary>
        <returns>Ein Objekt, das den konvertierten <see cref="T:System.Reflection.Assembly" />-Typ darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den vollständigen Namen der Assembly zurück, der auch als Anzeigename bezeichnet wird.</summary>
        <returns>Der vollständige Name der Assembly oder der Klassenname, wenn der vollständige Name der Assembly nicht bestimmt werden kann.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name oder Pfad der Datei, die das Manifest der Assembly enthält.</param>
        <summary>Lädt eine Assembly in den Ladekontext und umgeht einige Sicherheitsüberprüfungen.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine lokale Assembly zu laden, die das Betriebssystem gekennzeichnet wurden, als geladene aus dem Internet (z. B. eine temporäre Datei, die aus dem Internet oder Intranet heruntergeladen wurde). Bevor Sie die [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], solche Assemblys automatisch in einer Sandbox-Anwendungsdomäne geladen wurden. Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], mit voller Vertrauenswürdigkeit geladen werden.  
  
 Als Alternative zur Verwendung dieser Methode können Sie anwenden können die [ &lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) in der Konfigurationsdatei der Anwendung. Dies bewirkt, dass die common Language Runtime wieder in den der Sicherheitsrichtlinie die [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
> [!CAUTION]
>  Wenn Sie eine dieser Lösungen verwenden, müssen Sie sicher sein, dass es sicher ist, laden ist `assemblyFile` mit voller Vertrauenswürdigkeit.  
  
 Eine Erläuterung der Load-Kontexten, einschließlich der LoadFrom-Kontext finden Sie unter den <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> wurde nicht gefunden, oder das Modul, das Sie laden möchten, gibt keine Dateierweiterung an.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine gefundene Datei konnte nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder - 
 <paramref name="assemblyFile" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.Security.SecurityException">Eine Codebasis, die nicht mit "file://" beginnt, wurde ohne die erforderliche <see cref="T:System.Net.WebPermission" /> angegeben.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="assemblyFile" />-Parameter ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Assemblyname überschreitet die im System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
