<Type Name="TypeDelegator" FullName="System.Reflection.TypeDelegator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f755f3ad78d940335f03c81f092541a3f2742a88" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39928076" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TypeDelegator : System.Reflection.TypeInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit TypeDelegator extends System.Reflection.TypeInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.TypeDelegator" />
  <TypeSignature Language="VB.NET" Value="Public Class TypeDelegator&#xA;Inherits TypeInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeDelegator : System::Reflection::TypeInfo" />
  <TypeSignature Language="F#" Value="type TypeDelegator = class&#xA;    inherit TypeInfo" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Type</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="4cc1c-101">Umschließt ein <see cref="T:System.Type" />-Objekt und delegiert alle Methoden an diesen <see langword="Type" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="4cc1c-101">Wraps a <see cref="T:System.Type" /> object and delegates methods to that <see langword="Type" />.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-102">Von diesem Typ abgeleitet sind, und überschreiben Sie nur die Elemente, die Sie zum Bereitstellen von Anpassungen in haben, sowie die Member, die das Programm erforderlich und nicht bereits von implementiert <xref:System.Reflection.TypeDelegator>.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-102">Derive from this type and override only those members you have to provide customization in, plus any members that are required by your program and not already implemented by <xref:System.Reflection.TypeDelegator>.</span></span>  
  
 <span data-ttu-id="4cc1c-103"><xref:System.Reflection.TypeDelegator> leitet sich von <xref:System.Type?displayProperty=nameWithType> und implementiert die meisten Eigenschaften und Methoden der <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-103"><xref:System.Reflection.TypeDelegator> derives from <xref:System.Type?displayProperty=nameWithType> and implements most of the properties and methods of <xref:System.Type>.</span></span> <span data-ttu-id="4cc1c-104">Für jedes Element implementiert wird, <xref:System.Reflection.TypeDelegator> automatisch an den entsprechenden Member von einer internen delegiert <xref:System.Type> -Objekt, das als Argument an den Konstruktor bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-104">For each member it implements, <xref:System.Reflection.TypeDelegator> automatically delegates to the corresponding member of an internal <xref:System.Type> object, which is supplied as an argument to the constructor.</span></span> <span data-ttu-id="4cc1c-105">Diese interne <xref:System.Type> Objekt verfügbar gemacht wird, sowie Klassen, indem die `protected` <xref:System.Reflection.TypeDelegator.typeImpl> Feld.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-105">This internal <xref:System.Type> object is exposed to deriving classes by the `protected`<xref:System.Reflection.TypeDelegator.typeImpl> field.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4cc1c-106">Einige Mitglieder <xref:System.Reflection.TypeDelegator> Implementierungen aufweisen, obwohl die Mitglieder sich selbst einfach von geerbt werden <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-106">Some members of <xref:System.Reflection.TypeDelegator> have implementations even though the members themselves are simply inherited from <xref:System.Type>.</span></span> <span data-ttu-id="4cc1c-107">In diesen Fällen die Implementierung erfolgt durch eine überschriebene `protected` Methode, die einen Namen besitzt, die mit "Impl" endet.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-107">In these cases, the implementation is provided by an overridden `protected` method that has a name that ends in "Impl".</span></span> <span data-ttu-id="4cc1c-108">Z. B. die Implementierung für alle Überladungen der der <xref:System.Reflection.TypeDelegator.GetMethods%2A> Methode wird bereitgestellt von der überschriebenen <xref:System.Reflection.TypeDelegator.GetMethodImpl%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-108">For example, the implementation for all overloads of the <xref:System.Reflection.TypeDelegator.GetMethods%2A> method is supplied by the overridden <xref:System.Reflection.TypeDelegator.GetMethodImpl%2A> method.</span></span> <span data-ttu-id="4cc1c-109">Die Implementierung für geerbte Eigenschaften wie z. B. <xref:System.Type.IsPublic%2A> und <xref:System.Type.IsNestedAssembly%2A> wird bereitgestellt, von der überschriebenen <xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-109">The implementation for inherited properties such as <xref:System.Type.IsPublic%2A> and <xref:System.Type.IsNestedAssembly%2A> is provided by the overridden <xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A> method.</span></span>  
  
 <span data-ttu-id="4cc1c-110">Abgeleitete Klassen kann einen öffentlichen Konstruktor bereitstellen, die akzeptiert eine <xref:System.Type> -Objekt als Parameter und übergibt Sie einfach das Objekt, das <xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29> Konstruktor oder Sie können festlegen, die interne <xref:System.Type> Objekt auf andere Weise.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-110">Deriving classes can provide a public constructor that takes a <xref:System.Type> object as its parameter and simply passes that object to the <xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29> constructor, or can set the internal <xref:System.Type> object in some other way.</span></span>  
  
 <span data-ttu-id="4cc1c-111">Wenn eine abgeleitete Klasse ein Element verwendet, die nicht vom implementiert wird <xref:System.Reflection.TypeDelegator>, er muss diesen Member überschreiben und eine Implementierung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-111">If a deriving class uses a member that is not implemented by <xref:System.Reflection.TypeDelegator>, it must override that member and provide an implementation.</span></span> <span data-ttu-id="4cc1c-112">Die einfachste Implementierung besteht darin, rufen Sie das entsprechende Element im internen <xref:System.Type> Objekt verfügbar gemacht werden, indem die <xref:System.Reflection.TypeDelegator.typeImpl> Feld, aber Sie können keine Implementierung, die Ihre Anwendung erfordert bereit.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-112">The simplest implementation is to call the corresponding member on the internal <xref:System.Type> object exposed by the <xref:System.Reflection.TypeDelegator.typeImpl> field, but you can provide any implementation your application requires.</span></span> <span data-ttu-id="4cc1c-113">Es ist nicht erforderlich, die diese Member zu überschreiben, wenn sie nicht von der Anwendung verwendet werden oder von Library ruft Ihre Anwendung Functions (z. B. durch die <xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType> Konstruktor).</span><span class="sxs-lookup"><span data-stu-id="4cc1c-113">It is not necessary to override these members if they are not used by your application or by library functions your application calls (for example, by the <xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType> constructor).</span></span>  
  
 <span data-ttu-id="4cc1c-114">Die folgenden virtuellen Methoden (`Overridable` -Methoden in Visual Basic) der <xref:System.Type> werden nicht durch implementiert <xref:System.Reflection.TypeDelegator>: <xref:System.Type.MakeGenericType%2A>, <xref:System.Type.GetGenericTypeDefinition%2A>, <xref:System.Type.GetGenericArguments%2A>, <xref:System.Type.GetGenericParameterConstraints%2A>, <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakeByRefType%2A>, <xref:System.Type.MakePointerType%2A> , <xref:System.Type.GetEnumNames%2A>, <xref:System.Type.GetEnumValues%2A>, <xref:System.Type.GetEnumUnderlyingType%2A>, <xref:System.Type.GetTypeCodeImpl%2A>, <xref:System.Type.IsEnumDefined%2A>, <xref:System.Type.IsEquivalentTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-114">The following virtual methods (`Overridable` methods in Visual Basic) of <xref:System.Type> are not implemented by <xref:System.Reflection.TypeDelegator>: <xref:System.Type.MakeGenericType%2A>, <xref:System.Type.GetGenericTypeDefinition%2A>, <xref:System.Type.GetGenericArguments%2A>, <xref:System.Type.GetGenericParameterConstraints%2A>, <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakeByRefType%2A>, <xref:System.Type.MakePointerType%2A>, <xref:System.Type.GetEnumNames%2A>, <xref:System.Type.GetEnumValues%2A>, <xref:System.Type.GetEnumUnderlyingType%2A>, <xref:System.Type.GetTypeCodeImpl%2A>, <xref:System.Type.IsEnumDefined%2A>, <xref:System.Type.IsEquivalentTo%2A>.</span></span>  
  
 <span data-ttu-id="4cc1c-115">Die folgenden virtuellen Eigenschaften (`Overridable` Eigenschaften in Visual Basic) der <xref:System.Type> werden nicht durch implementiert <xref:System.Reflection.TypeDelegator>: <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, <xref:System.Type.ContainsGenericParameters%2A>, <xref:System.Type.DeclaringMethod%2A>, <xref:System.Type.GenericParameterAttributes%2A>, <xref:System.Type.GenericParameterPosition%2A> , <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, <xref:System.Type.IsSecurityTransparent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-115">The following virtual properties (`Overridable` properties in Visual Basic) of <xref:System.Type> are not implemented by <xref:System.Reflection.TypeDelegator>: <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, <xref:System.Type.ContainsGenericParameters%2A>, <xref:System.Type.DeclaringMethod%2A>, <xref:System.Type.GenericParameterAttributes%2A>, <xref:System.Type.GenericParameterPosition%2A>, <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, <xref:System.Type.IsSecurityTransparent%2A>.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-116">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.TypeDelegator" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-116">Initializes a new instance of the <see cref="T:System.Reflection.TypeDelegator" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeDelegator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeDelegator();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-117">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.TypeDelegator" />-Klasse mit Standardeigenschaften.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-117">Initializes a new instance of the <see cref="T:System.Reflection.TypeDelegator" /> class with default properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeDelegator (Type delegatingType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type delegatingType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (delegatingType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TypeDelegator(Type ^ delegatingType);" />
      <MemberSignature Language="F#" Value="new System.Reflection.TypeDelegator : Type -&gt; System.Reflection.TypeDelegator" Usage="new System.Reflection.TypeDelegator delegatingType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="delegatingType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegatingType">
          <span data-ttu-id="4cc1c-118">Die Instanz der <see cref="T:System.Type" />-Klasse, die den Aufruf der Methode eines Objekts kapselt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-118">The instance of the class <see cref="T:System.Type" /> that encapsulates the call to the method of an object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-119">Initialisiert eine neue Instanz der <see cref="T:System.Reflection.TypeDelegator" />-Klasse unter Angabe der kapselnden Instanz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-119">Initializes a new instance of the <see cref="T:System.Reflection.TypeDelegator" /> class specifying the encapsulating instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-120">Dieser Konstruktor wird aufgerufen, von einer Klasse zum Generieren eines Delegaten, der auf Grundlage der `Type` -Objekt für die Klasse, die Definition der Methode.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-120">This constructor is called from a class to generate a delegate based upon the `Type` object for the class defining the method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4cc1c-121">
            <paramref name="delegatingType" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-121">
              <paramref name="delegatingType" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.TypeDelegator.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-122">Ruft die Assembly des implementierten Typs ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-122">Gets the assembly of the implemented type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4cc1c-123">Ein <see cref="T:System.Reflection.Assembly" />-Objekt, das die Assembly des implementierten Typs darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-123">An <see cref="T:System.Reflection.Assembly" /> object representing the assembly of the implemented type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-124">Assemblys sind die Einheiten für die Bereitstellung in der common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-124">Assemblies are the deployment units in the common language runtime.</span></span> <span data-ttu-id="4cc1c-125">Assemblys richten den Namespace für das Auflösen von Anforderungen, und bestimmen, welche Ressourcen extern verfügbar gemacht werden und die von der Assembly zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-125">Assemblies establish the namespace for resolving requests and determine which resources are exposed externally and which are accessible from within the assembly.</span></span> <span data-ttu-id="4cc1c-126">Die common Language Runtime kann bestimmen, und suchen Sie die Assembly für jede ausgeführte Objekt.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-126">The common language runtime can determine and locate the assembly for any running object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Reflection.TypeDelegator.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-127">Ruft den vollqualifizierten Namen der Assembly ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-127">Gets the assembly's fully qualified name.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4cc1c-128">Ein <see langword="String" />, der den vollqualifizierten Namen der Assembly enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-128">A <see langword="String" /> containing the assembly's fully qualified name.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Reflection.TypeDelegator.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-129">Ruft den Basistyp für den aktuellen Typ ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-129">Gets the base type for the current type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4cc1c-130">Der Basistyp für einen Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-130">The base type for a type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-131">Der Basistyp ist der Typ, von dem dieser Typ direkt erbt.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-131">The base type is the type from which this type directly inherits.</span></span> <span data-ttu-id="4cc1c-132">Da die <xref:System.Object> Klassentyp ist die ultimative Basisklasse aller anderen Typen ist dies der einzige Typ, der keinen Basistyp.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-132">Since the <xref:System.Object> class type is the ultimate base class of all the other types, it is the only type that does not have a base type.</span></span> <span data-ttu-id="4cc1c-133">In diesem Fall `null` wird zurückgegeben, als der Basistyp der `Object` Typ.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-133">In this case, `null` is returned as the base type of the `Object` type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.TypeDelegator.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-134">Ruft den vollqualifizierten Namen des implementierten Typs ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-134">Gets the fully qualified name of the implemented type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4cc1c-135">Ein <see langword="String" />, der den vollqualifizierten Namen des Typs enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-135">A <see langword="String" /> containing the type's fully qualified name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-136">Eine Zeichenfolge, enthält der vollqualifizierte Name des aktuellen `TypeDelegator`.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-136">A string containing the fully qualified name of the current `TypeDelegator`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="override this.GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="typeDelegator.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-137">Ruft die der <see langword="TypeDelegator" />-Klasse zugeordneten Attribute ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-137">Gets the attributes assigned to the <see langword="TypeDelegator" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-138">Ein <see langword="TypeAttributes" />-Objekt, das die Attributflags der Implementierung darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-138">A <see langword="TypeAttributes" /> object representing the implementation attribute flags.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-139">Diese Methode kann verwendet werden, um zu bestimmen, ob die `TypeDelegator` ist abstrakt, öffentliche und so weiter.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-139">This method can be used to determine if the `TypeDelegator` is abstract, public, and so on.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="typeDelegator.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-140">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-140">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-141">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-141">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4cc1c-142">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-142">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects using reflection.</span>
          </span>
          <span data-ttu-id="4cc1c-143">Wenn der <c>Binder</c><see langword="null" /> ist, wird der Standardbinder verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-143">If <c>binder</c> is <see langword="null" />, the default binder is used.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="4cc1c-144">Die Aufrufkonventionen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-144">The calling conventions.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4cc1c-145">Ein Array vom Typ <see langword="Type" />, das eine Liste mit Anzahl, Reihenfolge und Typen der Parameter enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-145">An array of type <see langword="Type" /> containing a list of the parameter number, order, and types.</span>
          </span>
          <span data-ttu-id="4cc1c-146">Typen können nicht <see langword="null" /> sein. Verwenden Sie für die Suche nach einer Methode ohne Parameter eine geeignete <see langword="GetMethod" />-Methode oder ein leeres Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-146">Types cannot be <see langword="null" />; use an appropriate <see langword="GetMethod" /> method or an empty array to search for a method without parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4cc1c-147">Ein Array vom Typ <see langword="ParameterModifier" /> mit derselben Länge wie das <c>types</c>-Array, dessen Elemente die Attribute darstellen, die den Parametern der abzurufenden Methode zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-147">An array of type <see langword="ParameterModifier" /> having the same length as the <c>types</c> array, whose elements represent the attributes associated with the parameters of the method to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-148">Ruft den Konstruktor ab, der die <see langword="TypeDelegator" />-Klasse implementiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-148">Gets the constructor that implemented the <see langword="TypeDelegator" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-149">Ein <see langword="ConstructorInfo" />-Objekt für die Methode, die mit den angegebenen Kriterien übereinstimmt, oder <see langword="null" />, wenn keine Übereinstimmung gefunden werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-149">A <see langword="ConstructorInfo" /> object for the method that matches the specified criteria, or <see langword="null" /> if a match cannot be found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-150">Die `callConvention` Parameter gibt die Aufrufkonvention für den Einstiegspunkt an.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-150">The `callConvention` parameter indicates the calling convention for the entry point.</span></span> <span data-ttu-id="4cc1c-151">Wenn keine Aufrufkonvention angegeben wird, den Standardwert <xref:System.Reflection.CallingConventions> Wert `Standard` verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-151">If no calling convention is specified, a default <xref:System.Reflection.CallingConventions> value of `Standard` is used.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="typeDelegator.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-152">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-152">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-153">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-153">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-154">Gibt ein Array von <see cref="T:System.Reflection.ConstructorInfo" />-Objekten zurück, die Konstruktoren darstellen, die für den von der aktuellen <see cref="T:System.Reflection.TypeDelegator" />-Klasse umschlossenen Typ definiert sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-154">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing constructors defined for the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-155">Ein Array vom Typ <see langword="ConstructorInfo" />, das die angegebenen Konstruktoren enthält, die für diese Klasse definiert sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-155">An array of type <see langword="ConstructorInfo" /> containing the specified constructors defined for this class.</span>
          </span>
          <span data-ttu-id="4cc1c-156">Wenn keine Konstruktoren definiert sind, wird ein leeres Array zurückgegeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-156">If no constructors are defined, an empty array is returned.</span>
          </span>
          <span data-ttu-id="4cc1c-157">Je nach Wert eines angegebenen Parameters werden ausschließlich öffentliche Konstruktoren oder sowohl öffentliche als auch nicht öffentliche Konstruktoren zurückgegeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-157">Depending on the value of a specified parameter, only public constructors or both public and non-public constructors will be returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-158">Klasseninitialisierer stehen nur über `GetMember`, `GetMembers`, `FindMembers`, und `GetConstructors`.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-158">Class initializers are available only through `GetMember`, `GetMembers`, `FindMembers`, and `GetConstructors`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-159">Gibt alle für diesen Typ definierten benutzerdefinierten Attribute zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-159">Returns all the custom attributes defined for this type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="typeDelegator.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <span data-ttu-id="4cc1c-160">Gibt an, ob bei der Suche nach den Attributen die Vererbungskette dieses Typs durchsucht werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-160">Specifies whether to search this type's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-161">Gibt alle für diesen Typ festgelegten benutzerdefinierten Attribute zurück und gibt an, ob die Vererbungskette des Typs durchsucht werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-161">Returns all the custom attributes defined for this type, specifying whether to search the type's inheritance chain.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-162">Ein Array von Objekten mit allen für diesen Typ definierten benutzerdefinierten Attributen enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-162">An array of objects containing all the custom attributes defined for this type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="4cc1c-163">Ein benutzerdefinierter Attributtyp kann nicht geladen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-163">A custom attribute type cannot be loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="typeDelegator.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="4cc1c-164">Ein Array benutzerdefinierter Attribute, die durch den Typ bezeichnet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-164">An array of custom attributes identified by type.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="4cc1c-165">Gibt an, ob bei der Suche nach den Attributen die Vererbungskette dieses Typs durchsucht werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-165">Specifies whether to search this type's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-166">Gibt ein Array benutzerdefinierter Attribute zurück, die durch den Typ bezeichnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-166">Returns an array of custom attributes identified by type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-167">Ein Array von Objekten mit in diesem Typ definierten benutzerdefinierten Attributen, die mit dem <paramref name="attributeType" />-Parameter übereinstimmen und angeben, ob die Vererbungskette des Typs durchsucht werden soll. <see langword="null" />, wenn für diesen Typ keine benutzerdefinierten Attribute festgelegt sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-167">An array of objects containing the custom attributes defined in this type that match the <paramref name="attributeType" /> parameter, specifying whether to search the type's inheritance chain, or <see langword="null" /> if no custom attributes are defined on this type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4cc1c-168">
            <paramref name="attributeType" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-168">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="4cc1c-169">Ein benutzerdefinierter Attributtyp kann nicht geladen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-169">A custom attribute type cannot be loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="override this.GetElementType : unit -&gt; Type" Usage="typeDelegator.GetElementType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-170">Gibt die <see cref="T:System.Type" />-Klasse des Objekts zurück, das das aktuelle Array, den Zeiger oder ByRef umfasst oder auf das verwiesen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-170">Returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or ByRef.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-171">Die <see cref="T:System.Type" />-Klasse des Objekts, das das aktuelle Array, der Zeiger oder <see langword="ByRef" /> umfasst oder auf das verwiesen wird, oder <see langword="null" />, wenn die aktuelle <see cref="T:System.Type" />-Klasse kein Array, kein Zeiger und kein <see langword="ByRef" /> ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-171">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or <see langword="ByRef" />, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array, a pointer or a <see langword="ByRef" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="typeDelegator.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4cc1c-172">Der Name des abzurufenden Ereignisses.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-172">The name of the event to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-173">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-173">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-174">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-174">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-175">Gibt das angegebene Ereignis zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-175">Returns the specified event.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-176">Ein <see cref="T:System.Reflection.EventInfo" />-Objekt, das das von diesem Typ mit dem angegebenen Namen deklarierte oder geerbte Ereignis darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-176">An <see cref="T:System.Reflection.EventInfo" /> object representing the event declared or inherited by this type with the specified name.</span>
          </span>
          <span data-ttu-id="4cc1c-177">Diese Methode gibt <see langword="null" /> zurück, wenn kein entsprechendes Ereignis gefunden wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-177">This method returns <see langword="null" /> if no such event is found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-178">Wenn `bindingAttr` ist <xref:System.Reflection.BindingFlags>.`IgnoreCase`, wird die Groß-/Kleinschreibung, der die `name` Parameter wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-178">If `bindingAttr` is <xref:System.Reflection.BindingFlags>.`IgnoreCase`, the case of the `name` parameter is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4cc1c-179">Der <paramref name="name" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-179">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-180">Gibt ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten zurück, die sämtliche von der aktuellen <see langword="TypeDelegator" />-Klasse deklarierten oder geerbten öffentlichen Ereignisse darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-180">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events declared or inherited by the current <see langword="TypeDelegator" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="typeDelegator.GetEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-181">Gibt ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten zurück, die sämtliche von der aktuellen <see langword="TypeDelegator" />-Klasse deklarierten oder geerbten öffentlichen Ereignisse darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-181">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events declared or inherited by the current <see langword="TypeDelegator" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-182">Gibt ein Array vom Typ <see langword="EventInfo" /> zurück, das sämtliche vom aktuellen Typ deklarierten oder geerbten Ereignisse enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-182">Returns an array of type <see langword="EventInfo" /> containing all the events declared or inherited by the current type.</span>
          </span>
          <span data-ttu-id="4cc1c-183">Wenn keine Ereignisse vorhanden sind, wird ein leeres Array zurückgegeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-183">If there are no events, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="typeDelegator.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-184">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-184">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-185">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-185">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-186">Gibt die in <paramref name="bindingAttr" /> angegebenen Ereignisse zurück, die von der aktuellen <see langword="TypeDelegator" />-Klasse deklariert oder geerbt wurden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-186">Returns the events specified in <paramref name="bindingAttr" /> that are declared or inherited by the current <see langword="TypeDelegator" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-187">Ein Array vom Typ <see langword="EventInfo" />, das die in <paramref name="bindingAttr" /> angegebenen Ereignisse enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-187">An array of type <see langword="EventInfo" /> containing the events specified in <paramref name="bindingAttr" />.</span>
          </span>
          <span data-ttu-id="4cc1c-188">Wenn keine Ereignisse vorhanden sind, wird ein leeres Array zurückgegeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-188">If there are no events, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="typeDelegator.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4cc1c-189">Der Name des zu suchenden Felds.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-189">The name of the field to find.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-190">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-190">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-191">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-191">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-192">Gibt ein <see cref="T:System.Reflection.FieldInfo" />-Objekt zurück, das das Feld mit dem angegebenen Namen darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-192">Returns a <see cref="T:System.Reflection.FieldInfo" /> object representing the field with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-193">Ein <see langword="FieldInfo" />-Objekt, das das von diesem <see langword="TypeDelegator" /> mit dem angegebenen Namen deklarierte oder geerbte Feld darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-193">A <see langword="FieldInfo" /> object representing the field declared or inherited by this <see langword="TypeDelegator" /> with the specified name.</span>
          </span>
          <span data-ttu-id="4cc1c-194">Gibt <see langword="null" /> zurück, wenn kein entsprechendes Feld gefunden wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-194">Returns <see langword="null" /> if no such field is found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-195">Verwenden einer `bindingAttr` von <xref:System.Reflection.BindingFlags>. NonPublic, um alle öffentlichen und nicht öffentlichen Felder zurück.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-195">Use a `bindingAttr` of <xref:System.Reflection.BindingFlags>.NonPublic to return all public and nonpublic fields.</span></span> <span data-ttu-id="4cc1c-196">Verwendung `BindingFlags.IgnoreCase` auf die Felder, die Groß-/Kleinschreibung ignorieren, da es sich bei der Suche die Groß-/Kleinschreibung beachtet, in der Standardeinstellung werden.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-196">Use `BindingFlags.IgnoreCase` to ignore the case of the fields, as the search is case-sensitive by default.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4cc1c-197">Der <paramref name="name" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-197">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="typeDelegator.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-198">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-198">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-199">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-199">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-200">Gibt ein Array von <see cref="T:System.Reflection.FieldInfo" />-Objekten zurück, die die Datenfelder darstellen, die für den von der aktuellen <see cref="T:System.Reflection.TypeDelegator" />-Klasse umschlossenen Typ definiert sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-200">Returns an array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the data fields defined for the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-201">Ein Array vom Typ <see langword="FieldInfo" />, das die von der aktuellen <see langword="TypeDelegator" />-Klasse deklarierten oder geerbten Felder enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-201">An array of type <see langword="FieldInfo" /> containing the fields declared or inherited by the current <see langword="TypeDelegator" />.</span>
          </span>
          <span data-ttu-id="4cc1c-202">Wenn keine übereinstimmenden Felder vorhanden sind, wird ein leeres Array zurückgegeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-202">An empty array is returned if there are no matched fields.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-203">Die <xref:System.Reflection.TypeDelegator.GetFields%2A> Methode nicht zurückgegeben Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-203">The <xref:System.Reflection.TypeDelegator.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4cc1c-204">Ihr Code muss nicht von der Reihenfolge, in der Felder zurückgegeben werden, abhängen, da diese Reihenfolge abweichen kann.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-204">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 <span data-ttu-id="4cc1c-205">Verwenden einer `bindingAttr` von <xref:System.Reflection.BindingFlags>. NonPublic, um alle öffentlichen und nicht öffentlichen Felder zurück.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-205">Use a `bindingAttr` of <xref:System.Reflection.BindingFlags>.NonPublic to return all public and nonpublic fields.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetInterface : string * bool -&gt; Type" Usage="typeDelegator.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4cc1c-206">Der vollqualifizierte Name der von der aktuellen Klasse implementierten Schnittstelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-206">The fully qualified name of the interface implemented by the current class.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="4cc1c-207">
            <see langword="true" />, wenn die Groß- und Kleinschreibung ignoriert werden soll, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-207">
              <see langword="true" /> if the case is to be ignored; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-208">Gibt die angegebene Schnittstelle zurück, die durch den von der aktuellen <see cref="T:System.Reflection.TypeDelegator" />-Klasse umschlossenen Typ implementiert wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-208">Returns the specified interface implemented by the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-209">Ein <see langword="Type" />-Objekt, das die von der aktuellen Klasse direkt oder indirekt implementierte Schnittstelle mit dem vollqualifizierten Namen darstellt, der mit dem angegebenen Namen übereinstimmt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-209">A <see langword="Type" /> object representing the interface implemented (directly or indirectly) by the current class with the fully qualified name matching the specified name.</span>
          </span>
          <span data-ttu-id="4cc1c-210">Wenn keine mit dem Namen übereinstimmende Schnittstelle gefunden wurde, wird NULL zurückgegeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-210">If no interface that matches name is found, null is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4cc1c-211">Der <paramref name="name" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-211">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="typeDelegator.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="4cc1c-212">Der <see cref="T:System.Type" /> der Schnittstelle, deren Zuordnung abgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-212">The <see cref="T:System.Type" /> of the interface to retrieve a mapping of.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-213">Gibt eine Schnittstellenzuordnung für den angegebenen Schnittstellentyp zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-213">Returns an interface mapping for the specified interface type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-214">Ein <see cref="T:System.Reflection.InterfaceMapping" />-Objekt, das die Schnittstellenzuordnung für den <paramref name="interfaceType" /> darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-214">An <see cref="T:System.Reflection.InterfaceMapping" /> object representing the interface mapping for <paramref name="interfaceType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-215">Die schnittstellenzuordnung gibt an, wie eine Schnittstelle zu den tatsächlichen Methoden einer Klasse zugeordnet ist, das diese Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-215">The interface map denotes how an interface is mapped into the actual methods on a class that implements that interface.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="override this.GetInterfaces : unit -&gt; Type[]" Usage="typeDelegator.GetInterfaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-216">Gibt alle für die aktuelle Klasse und ihre Basisklassen implementierten Schnittstellen zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-216">Returns all the interfaces implemented on the current class and its base classes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-217">Ein Array vom Typ <see langword="Type" />, das alle für die aktuelle Klasse und ihre Basisklassen implementierten Schnittstellen enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-217">An array of type <see langword="Type" /> containing all the interfaces implemented on the current class and its base classes.</span>
          </span>
          <span data-ttu-id="4cc1c-218">Wenn keine definiert sind, wird ein leeres Array zurückgegeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-218">If none are defined, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeDelegator.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4cc1c-219">Der Name des abzurufenden Members.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-219">The name of the member to get.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="4cc1c-220">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-220">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-221">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-221">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-222">Der Typ der abzurufenden Member.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-222">The type of members to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-223">Gibt Member (Eigenschaften, Methoden, Konstruktoren, Felder, Ereignisse und geschachtelte Typen) zurück, die durch <paramref name="name" />, <paramref name="type" /> und <paramref name="bindingAttr" /> angegeben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-223">Returns members (properties, methods, constructors, fields, events, and nested types) specified by the given <paramref name="name" />, <paramref name="type" />, and <paramref name="bindingAttr" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-224">Ein Array vom Typ <see langword="MemberInfo" />, das alle Member der aktuellen Klasse und ihrer Basisklasse enthält, die den angegebenen Kriterien entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-224">An array of type <see langword="MemberInfo" /> containing all the members of the current class and its base class meeting the specified criteria.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-225">Wenn `bindingAttr` ist <xref:System.Reflection.BindingFlags>. NonPublic, werden alle Elemente berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-225">If `bindingAttr` is <xref:System.Reflection.BindingFlags>.NonPublic, all the members will be considered.</span></span> <span data-ttu-id="4cc1c-226">Wenn keine Übereinstimmungen vorhanden sind, wird ein leeres Array zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-226">If there are no matches, an empty array is returned.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4cc1c-227">Der <paramref name="name" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-227">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeDelegator.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-228">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-228">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-229">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-229">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-230">Gibt durch <paramref name="bindingAttr" /> angegebene Member zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-230">Returns members specified by <paramref name="bindingAttr" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-231">Ein Array vom Typ <see langword="MemberInfo" />, das alle den Kriterien des <paramref name="bindingAttr" />-Filters entsprechenden Member der aktuellen Klasse und ihrer Basisklassen enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-231">An array of type <see langword="MemberInfo" /> containing all the members of the current class and its base classes that meet the <paramref name="bindingAttr" /> filter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-232">Wenn `bindingAttr` ist <xref:System.Reflection.BindingFlags>. NonPublic, werden alle Elemente berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-232">If `bindingAttr` is <xref:System.Reflection.BindingFlags>.NonPublic, all the members will be considered.</span></span> <span data-ttu-id="4cc1c-233">Wenn keine Übereinstimmungen vorhanden sind, wird ein leeres Array zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-233">If there are no matches, an empty array is returned.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="typeDelegator.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4cc1c-234">Der Methodenname.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-234">The method name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-235">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-235">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-236">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-236">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4cc1c-237">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-237">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects using reflection.</span>
          </span>
          <span data-ttu-id="4cc1c-238">Wenn der <c>Binder</c><see langword="null" /> ist, wird der Standardbinder verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-238">If <c>binder</c> is <see langword="null" />, the default binder is used.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="4cc1c-239">Die Aufrufkonventionen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-239">The calling conventions.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4cc1c-240">Ein Array vom Typ <see langword="Type" />, das eine Liste mit Anzahl, Reihenfolge und Typen der Parameter enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-240">An array of type <see langword="Type" /> containing a list of the parameter number, order, and types.</span>
          </span>
          <span data-ttu-id="4cc1c-241">Typen können nicht <see langword="null" /> sein. Verwenden Sie für die Suche nach einer Methode ohne Parameter eine geeignete <see langword="GetMethod" />-Methode oder ein leeres Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-241">Types cannot be <see langword="null" />; use an appropriate <see langword="GetMethod" /> method or an empty array to search for a method without parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4cc1c-242">Ein Array vom Typ <see langword="ParameterModifier" /> mit derselben Länge wie das <c>types</c>-Array, dessen Elemente die Attribute darstellen, die den Parametern der abzurufenden Methode zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-242">An array of type <see langword="ParameterModifier" /> having the same length as the <c>types</c> array, whose elements represent the attributes associated with the parameters of the method to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-243">Sucht nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und verwendet dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-243">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-244">Ein <see langword="MethodInfoInfo" />-Objekt für die Implementierungsmethode, die mit den angegebenen Kriterien übereinstimmt, oder <see langword="null" />, wenn keine Übereinstimmung gefunden werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-244">A <see langword="MethodInfoInfo" /> object for the implementation method that matches the specified criteria, or <see langword="null" /> if a match cannot be found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-245">Die `callConvention` Parameter gibt die Aufrufkonvention für den Einstiegspunkt an.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-245">The `callConvention` parameter indicates the calling convention for the entry point.</span></span> <span data-ttu-id="4cc1c-246">Wenn kein <xref:System.Reflection.CallingConventions> angegeben ist, den Standardwert `CallingConventions` Wert `Standard` verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-246">If no <xref:System.Reflection.CallingConventions> is specified, a default `CallingConventions` value of `Standard` is used.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="typeDelegator.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-247">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-247">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-248">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-248">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-249">Gibt ein Array von <see cref="T:System.Reflection.MethodInfo" />-Objekten zurück, die angegebene Methoden darstellen, die für den von der aktuellen <see cref="T:System.Reflection.TypeDelegator" />-Klasse umschlossenen Typ definiert sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-249">Returns an array of <see cref="T:System.Reflection.MethodInfo" /> objects representing specified methods of the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-250">Ein Array von <see langword="MethodInfo" />-Objekten, die die für diese <see langword="TypeDelegator" />-Klasse definierten Methoden darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-250">An array of <see langword="MethodInfo" /> objects representing the methods defined on this <see langword="TypeDelegator" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="typeDelegator.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4cc1c-251">Der Name des geschachtelten Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-251">The nested type's name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-252">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-252">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-253">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-253">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-254">Gibt einen geschachtelten Typ zurück, der durch die <paramref name="name" />-Eigenschaft und in der <paramref name="bindingAttr" />-Eigenschaft angegeben wird, die durch den von der aktuellen <see cref="T:System.Reflection.TypeDelegator" />-Klasse dargestellten Typ deklariert oder geerbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-254">Returns a nested type specified by <paramref name="name" /> and in <paramref name="bindingAttr" /> that are declared or inherited by the type represented by the current <see cref="T:System.Reflection.TypeDelegator" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-255">Ein <see langword="Type" />-Objekt, das den geschachtelten Typ darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-255">A <see langword="Type" /> object representing the nested type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4cc1c-256">Der <paramref name="name" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-256">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="typeDelegator.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-257">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-257">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-258">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-258">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-259">Gibt die in der <paramref name="bindingAttr" />-Eigenschaft angegebenen geschachtelten Typen zurück, die durch den von der aktuellen <see cref="T:System.Reflection.TypeDelegator" />-Klasse umschlossenen Typ deklariert oder geerbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-259">Returns the nested types specified in <paramref name="bindingAttr" /> that are declared or inherited by the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-260">Ein Array vom Typ <see langword="Type" />, das die geschachtelten Typen enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-260">An array of type <see langword="Type" /> containing the nested types.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="typeDelegator.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-261">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-261">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-262">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-262">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-263">Gibt ein Array von <see cref="T:System.Reflection.PropertyInfo" />-Objekten zurück, die Eigenschaften darstellen, die für den von der aktuellen <see cref="T:System.Reflection.TypeDelegator" />-Klasse umschlossenen Typ definiert sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-263">Returns an array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing properties of the type wrapped by the current <see cref="T:System.Reflection.TypeDelegator" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-264">Ein Array von <see langword="PropertyInfo" />-Objekten, die für diese <see langword="TypeDelegator" />-Klasse definierte Eigenschaften darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-264">An array of <see langword="PropertyInfo" /> objects representing properties defined on this <see langword="TypeDelegator" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="typeDelegator.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4cc1c-265">Die abzurufende Eigenschaft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-265">The property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4cc1c-266">Eine Bitmaske, die sich auf die Ausführung der Suche auswirkt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-266">A bitmask that affects the way in which the search is conducted.</span>
          </span>
          <span data-ttu-id="4cc1c-267">Der Wert ist eine Kombination von 0 (null) oder mehr Bitflags aus den <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-267">The value is a combination of zero or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4cc1c-268">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-268">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span>
          </span>
          <span data-ttu-id="4cc1c-269">Wenn der <c>Binder</c><see langword="null" /> ist, wird der Standardbinder verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-269">If <c>binder</c> is <see langword="null" />, the default binder is used.</span>
          </span>
          <span data-ttu-id="4cc1c-270">Siehe <see cref="T:System.Reflection.Binder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-270">See <see cref="T:System.Reflection.Binder" />.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="4cc1c-271">Der Rückgabetyp der Eigenschaft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-271">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4cc1c-272">Eine Liste von Parametertypen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-272">A list of parameter types.</span>
          </span>
          <span data-ttu-id="4cc1c-273">In der Liste werden Anzahl, Reihenfolge und Typen der Parameter dargestellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-273">The list represents the number, order, and types of the parameters.</span>
          </span>
          <span data-ttu-id="4cc1c-274">Typen können nicht NULL sein. Verwenden Sie für die Suche nach einer Methode ohne Parameter eine geeignete <see langword="GetMethod" />-Methode oder ein leeres Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-274">Types cannot be null; use an appropriate <see langword="GetMethod" /> method or an empty array to search for a method without parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4cc1c-275">Ein Array derselben Länge wie Typen mit Elementen, die die Attribute darstellen, die den Parametern der abzurufenden Methode zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-275">An array of the same length as types with elements that represent the attributes associated with the parameters of the method to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-276">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-276">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-277">Ein <see cref="T:System.Reflection.PropertyInfo" />-Objekt für die Eigenschaft, die mit den angegebenen Kriterien übereinstimmt, oder NULL, wenn keine Übereinstimmung gefunden werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-277">A <see cref="T:System.Reflection.PropertyInfo" /> object for the property that matches the specified criteria, or null if a match cannot be found.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Reflection.TypeDelegator.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-278">Ruft die GUID (Globally Unique Identifier) des implementierten Typs ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-278">Gets the GUID (globally unique identifier) of the implemented type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4cc1c-279">Ein GUID.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-279">A GUID.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-280">Die GUID (globally unique Identifier) ist eine eindeutige ID der 128-Bit-Zeichenfolge zur Identifizierung einer Klasse oder eine Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-280">The GUID (globally unique identifier) is a 128-bit unique identification string used to identify a class or an interface.</span></span> <span data-ttu-id="4cc1c-281">Es wird hauptsächlich für die Interoperabilität zwischen Microsoft .NET Framework und COM.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-281">It is primarily useful for interoperability between the Microsoft .NET Framework and COM.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.HasElementTypeImpl : unit -&gt; bool" Usage="typeDelegator.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-282">Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" />-Typ einen anderen Typ einschließt oder darauf verweist, d. h., ob der aktuelle <see cref="T:System.Type" />-Typ ein Array, Zeiger oder ByRef ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-282">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer or a ByRef.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-283">
            <see langword="true" />, wenn der <see cref="T:System.Type" />-Typ ein Array, Zeiger oder ByRef ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-283">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer or a ByRef; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="typeDelegator.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4cc1c-284">Der Name des aufzurufenden Members.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-284">The name of the member to invoke.</span>
          </span>
          <span data-ttu-id="4cc1c-285">Dies kann ein Konstruktor, eine Methode, eine Eigenschaft oder ein Feld sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-285">This may be a constructor, method, property, or field.</span>
          </span>
          <span data-ttu-id="4cc1c-286">Wenn eine leere Zeichenfolge ("") übergeben wird, wird der Standardmember aufgerufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-286">If an empty string ("") is passed, the default member is invoked.</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="4cc1c-287">Das Attribut für den Aufruf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-287">The invocation attribute.</span>
          </span>
          <span data-ttu-id="4cc1c-288">Dabei muss es sich um eine der folgenden <see cref="T:System.Reflection.BindingFlags" />-Enumerationen handeln: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-288">This must be one of the following <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="Static" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="4cc1c-289">Es muss ein geeignetes Aufrufattribut angegeben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-289">A suitable invocation attribute must be specified.</span>
          </span>
          <span data-ttu-id="4cc1c-290">Wenn ein statischer Member aufgerufen werden soll, muss das <see langword="Static" />-Flag festgelegt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-290">If a static member is to be invoked, the <see langword="Static" /> flag must be set.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4cc1c-291">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see langword="MemberInfo" />-Objekten über Reflektion ermöglicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-291">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span>
          </span>
          <span data-ttu-id="4cc1c-292">Wenn der <c>Binder</c><see langword="null" /> ist, wird der Standardbinder verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-292">If <c>binder</c> is <see langword="null" />, the default binder is used.</span>
          </span>
          <span data-ttu-id="4cc1c-293">Siehe <see cref="T:System.Reflection.Binder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-293">See <see cref="T:System.Reflection.Binder" />.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="4cc1c-294">Das Objekt, für das der angegebene Member aufgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-294">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="4cc1c-295">Ein Array vom Typ <see langword="Object" />, das Anzahl, Reihenfolge und Typ der Parameter des aufzurufenden Members enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-295">An array of type <see langword="Object" /> that contains the number, order, and type of the parameters of the member to be invoked.</span>
          </span>
          <span data-ttu-id="4cc1c-296">Wenn <c>args</c> ein nicht initialisiertes <see langword="Object" /> enthält, wird dieses als leer behandelt und kann mit dem Standardbinder auf 0, 0.0 oder eine Zeichenfolge erweitert werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-296">If <c>args</c> contains an uninitialized <see langword="Object" />, it is treated as empty, which, with the default binder, can be widened to 0, 0.0 or a string.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4cc1c-297">Ein Array vom Typ <see langword="ParameterModifer" /> mit derselben Länge wie <c>args</c> und mit Elementen, die die Attribute darstellen, die den Argumenten des aufzurufenden Members zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-297">An array of type <see langword="ParameterModifer" /> that is the same length as <c>args</c>, with elements that represent the attributes associated with the arguments of the member to be invoked.</span>
          </span>
          <span data-ttu-id="4cc1c-298">Ein Parameter verfügt über Attribute, die ihm in der Signatur des Members zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-298">A parameter has attributes associated with it in the member's signature.</span>
          </span>
          <span data-ttu-id="4cc1c-299">Verwenden Sie für ByRef <see langword="ParameterModifer.ByRef" />, für keine Attribute verwenden Sie <see langword="ParameterModifer.None" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-299">For ByRef, use <see langword="ParameterModifer.ByRef" />, and for none, use <see langword="ParameterModifer.None" />.</span>
          </span>
          <span data-ttu-id="4cc1c-300">Der Standardbinder sucht für diese nach genauen Entsprechungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-300">The default binder does exact matching on these.</span>
          </span>
          <span data-ttu-id="4cc1c-301">Attribute wie <see langword="In" /> und <see langword="InOut" /> werden bei der Bindung nicht verwendet und können mithilfe von <see langword="ParameterInfo" /> angezeigt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-301">Attributes such as <see langword="In" /> and <see langword="InOut" /> are not used in binding, and can be viewed using <see langword="ParameterInfo" />.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="4cc1c-302">Eine Instanz von <see langword="CultureInfo" /> für die Steuerung der Umwandlung von Typen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-302">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="4cc1c-303">Dies ist erforderlich, um z. B. eine Zeichenfolge, die die Zahl 1000 darstellt, in einen <see langword="Double" />-Wert zu konvertieren, da die Zahl 1000 in den verschiedenen Kulturen unterschiedlich dargestellt wird.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-303">This is necessary, for example, to convert a string that represents 1000 to a <see langword="Double" /> value, since 1000 is represented differently by different cultures.</span>
          </span>
          <span data-ttu-id="4cc1c-304">Wenn <c>culture</c><see langword="null" /> ist, wird die <see langword="CultureInfo" /> für die <see langword="CultureInfo" /> des aktuellen Threads verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-304">If <c>culture</c> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread's <see langword="CultureInfo" /> is used.</span>
          </span>
        </param>
        <param name="namedParameters">
          <span data-ttu-id="4cc1c-305">Ein Array vom Typ <see langword="String" /> mit Parameternamen, die ab dem Element 0 mit dem <c>args</c>-Array übereinstimmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-305">An array of type <see langword="String" /> containing parameter names that match up, starting at element zero, with the <c>args</c> array.</span>
          </span>
          <span data-ttu-id="4cc1c-306">Das Array darf keine Lücken aufweisen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-306">There must be no holes in the array.</span>
          </span>
          <span data-ttu-id="4cc1c-307">Wenn <c>args</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-307">If <c>args</c>.</span>
          </span>
          <span data-ttu-id="4cc1c-308">
            <see langword="Length" /> größer ist als <c>namedParameters</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-308">
              <see langword="Length" /> is greater than <c>namedParameters</c>.</span>
          </span>
          <span data-ttu-id="4cc1c-309">
            <see langword="Length" />, die verbleibenden Parameter werden der Reihenfolge nach aufgefüllt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-309">
              <see langword="Length" />, the remaining parameters are filled in order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-310">Ruft den angegebenen Member auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-310">Invokes the specified member.</span>
          </span>
          <span data-ttu-id="4cc1c-311">Die Methode, die aufgerufen werden soll, muss zugänglich sein und mit der angegebenen Argumentliste unter den Einschränkungen des angegebenen Binders und der Aufrufattribute die spezifischste Übereinstimmung bereitstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-311">The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-312">Ein <see langword="Object" />, das den Rückgabewert des aufgerufenen Members darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-312">An <see langword="Object" /> representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-313">Eine Methode wird aufgerufen werden, wenn die beiden folgenden Bedingungen erfüllt sind:</span><span class="sxs-lookup"><span data-stu-id="4cc1c-313">A method will be invoked if both the following conditions are true:</span></span>  
  
-   <span data-ttu-id="4cc1c-314">Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl der Argumente in der angegebenen Argumentliste (es sei denn, die Standardargumente für den Member definiert sind).</span><span class="sxs-lookup"><span data-stu-id="4cc1c-314">The number of parameters in the method declaration equals the number of arguments in the specified argument list (unless default arguments are defined on the member).</span></span>  
  
-   <span data-ttu-id="4cc1c-315">Der Typ der einzelnen Argumente kann von der Binder in den Typ des Parameters konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-315">The type of each arguments can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="4cc1c-316">Der Binder findet alle übereinstimmenden Methoden.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-316">The binder will find all the matching methods.</span></span> <span data-ttu-id="4cc1c-317">Diese Methoden gefunden werden, basierend auf den Typ der Bindung, die angefordert (`BindingFlags.MethodInvoke`, `BindingFlags.GetProperties`und so weiter).</span><span class="sxs-lookup"><span data-stu-id="4cc1c-317">These methods are found based upon the type of binding requested (`BindingFlags.MethodInvoke`, `BindingFlags.GetProperties`, and so on).</span></span> <span data-ttu-id="4cc1c-318">Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen, die in der Binder definiert gefiltert.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-318">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="4cc1c-319">Nachdem die Methode ausgewählt ist, wird sie aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-319">After the method is selected, it will be invoked.</span></span> <span data-ttu-id="4cc1c-320">Barrierefreiheit wird an diesem Punkt überprüft.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-320">Accessibility is checked at that point.</span></span> <span data-ttu-id="4cc1c-321">Die Suche kann gesteuert werden durchsucht, welche Gruppe von Methoden auf Grundlage der Eingabehilfen-Attribut, das der Methode zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-321">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="4cc1c-322">Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Methode ist verantwortlich für das Auswählen der Methode aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-322">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="4cc1c-323">Der Standardbinder wählt die spezifischste Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-323">The default binder selects the most specific match.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4cc1c-324">Zugriffseinschränkungen für voll vertrauenswürdigen Code ignoriert.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-324">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="4cc1c-325">D. h. private Konstruktoren, Methoden, Felder und Eigenschaften zugegriffen werden können, und Sie aufgerufen wird, mithilfe von Reflektion, wenn der Code vollständig vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-325">That is, private constructors, methods, fields, and properties can be accessed and invoked using reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="4cc1c-326">Derzeit `InvokeMember` führt der Microsoft .NET Framework-Reflektion-Semantik für jeden Typ des Objekts.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-326">Currently, `InvokeMember` performs the Microsoft .NET Framework reflection semantics for every type of object.</span></span>  
  
 <span data-ttu-id="4cc1c-327">Wenn der Member, die anhand des Namens ein Array ist und die `BindingFlags.GetField` Flag wird festgelegt, auf `invokeAttr`, `args` Array gibt an, die Elemente, deren Werte zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-327">If the member specified by name is an array and the `BindingFlags.GetField` flag is set on `invokeAttr`, the `args` array specifies the elements whose values are to be returned.</span></span> <span data-ttu-id="4cc1c-328">Beispielsweise der folgende Aufruf über `Type` Objekt `t` gibt den Wert des ersten Elements des Zeichenfolgenarrays MyArray, ein Element des aufrufenden Objekts ist:</span><span class="sxs-lookup"><span data-stu-id="4cc1c-328">For example, the following call through `Type` object `t` returns the value of the first element of the string array MyArray, which is a member of the calling object:</span></span>  
  
 `String ret = (String) t.InvokeMember ("MyArray", BindingFlags.GetField, null, this, new Variant[]{0});`  
  
 <span data-ttu-id="4cc1c-329">Sie können `InvokeMember` ein oder mehrere Elemente eines Arrays Member festlegen.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-329">You can use `InvokeMember` to set one or more elements of a member array.</span></span> <span data-ttu-id="4cc1c-330">Alle Elemente werden auf den gleichen Wert festgelegt.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-330">All elements are set to the same value.</span></span> <span data-ttu-id="4cc1c-331">Die `args` Array muss wie folgt formatiert sein:</span><span class="sxs-lookup"><span data-stu-id="4cc1c-331">The `args` array must be formatted as follows:</span></span>  
  
```  
{index1,  
    index2,, value}  
```  
  
 <span data-ttu-id="4cc1c-332">Beispielsweise ist zum Festlegen von MyArray des ersten Elements aus dem vorherigen Beispiel die Syntax wie folgt:</span><span class="sxs-lookup"><span data-stu-id="4cc1c-332">For example, to set the first member of MyArray from the previous example, the syntax is as follows:</span></span>  
  
```csharp  
t.InvokeMember ("MyArray", BindingFlags.SetField, null, this, new  
    Variant[]{0,"Updated"});  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="override this.IsArrayImpl : unit -&gt; bool" Usage="typeDelegator.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-333">Gibt einen Wert zurück, der angibt, ob <see cref="T:System.Type" /> ein Array ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-333">Returns a value that indicates whether the <see cref="T:System.Type" /> is an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-334">
            <see langword="true" />, wenn <see cref="T:System.Type" /> ein Array ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-334">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : System.Reflection.TypeInfo -&gt; bool" Usage="typeDelegator.IsAssignableFrom typeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">
          <span data-ttu-id="4cc1c-335">Der zu überprüfende Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-335">The type to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-336">Gibt einen Wert zurück, der angibt, ob der angegebene Typ dem Typ zugewiesen werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-336">Returns a value that indicates whether the specified type can be assigned to this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-337">
            <see langword="true" />, wenn der angegebene Typ diesem Typ zugeordnet werden kann; andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-337">
              <see langword="true" /> if the specified type can be assigned to this type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="override this.IsByRefImpl : unit -&gt; bool" Usage="typeDelegator.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-338">Gibt einen Wert zurück, der angibt, ob der <see cref="T:System.Type" /> als Verweis übergeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-338">Returns a value that indicates whether the <see cref="T:System.Type" /> is passed by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-339">
            <see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis übergeben wird, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-339">
              <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Reflection.TypeDelegator.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="override this.IsCOMObjectImpl : unit -&gt; bool" Usage="typeDelegator.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-340">Gibt einen Wert zurück, der angibt, ob das <see cref="T:System.Type" /> ein COM-Objekt ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-340">Returns a value that indicates whether the <see cref="T:System.Type" /> is a COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-341">
            <see langword="true" />, wenn <see cref="T:System.Type" /> ein COM-Objekt ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-341">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Reflection.TypeDelegator.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-342">Ruft einen Wert ab, der angibt, ob dieses Objekt einen konstruierten generischen Typ darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-342">Gets a value that indicates whether this object represents a constructed generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4cc1c-343">
            <see langword="true" />, wenn dieses Objekt einen konstruierten generischen Typ darstellt, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-343">
              <see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="typeDelegator.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="4cc1c-344">Gibt an, ob bei der Suche nach den Attributen die Vererbungskette dieses Typs durchsucht werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-344">Specifies whether to search this type's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="4cc1c-345">Ein Array benutzerdefinierter Attribute, die durch den Typ bezeichnet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-345">An array of custom attributes identified by type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4cc1c-346">Gibt an, ob ein durch <paramref name="attributeType" /> bezeichnetes benutzerdefiniertes Attribut definiert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-346">Indicates whether a custom attribute identified by <paramref name="attributeType" /> is defined.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-347">
            <see langword="true" />, wenn ein von <paramref name="attributeType" /> bezeichnetes benutzerdefiniertes Attribut definiert ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-347">
              <see langword="true" /> if a custom attribute identified by <paramref name="attributeType" /> is defined; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4cc1c-348">
            <paramref name="attributeType" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-348">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">
          <span data-ttu-id="4cc1c-349">Der benutzerdefinierte Attributtyp kann nicht geladen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-349">The custom attribute type cannot be loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Reflection.TypeDelegator.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Reflection.TypeDelegator.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPointerImpl : unit -&gt; bool" Usage="typeDelegator.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-350">Gibt einen Wert zurück, der angibt, ob das <see cref="T:System.Type" /> ein Zeiger ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-350">Returns a value that indicates whether the <see cref="T:System.Type" /> is a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-351">
            <see langword="true" />, wenn <see cref="T:System.Type" /> ein Zeiger ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-351">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPrimitiveImpl : unit -&gt; bool" Usage="typeDelegator.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-352">Gibt einen Wert zurück, der angibt, ob <see cref="T:System.Type" /> zu den primitiven Typen gehört.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-352">Returns a value that indicates whether the <see cref="T:System.Type" /> is one of the primitive types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-353">
            <see langword="true" />, wenn <see cref="T:System.Type" /> zu den primitiven Typen gehört, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-353">
              <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Reflection.TypeDelegator.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Reflection.TypeDelegator.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.TypeDelegator.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.IsValueTypeImpl : unit -&gt; bool" Usage="typeDelegator.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-354">Gibt einen Wert zurück, der angibt, ob der Typ ein Werttyp, d. h. weder eine Klasse noch eine Schnittstelle ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-354">Returns a value that indicates whether the type is a value type; that is, not a class or an interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4cc1c-355">
            <see langword="true" />, wenn der Typ ein Werttyp ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-355">
              <see langword="true" /> if the type is a value type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Reflection.TypeDelegator.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public override int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataToken : int" Usage="System.Reflection.TypeDelegator.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-356">Ruft einen Wert ab, der diese Entität in Metadaten identifiziert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-356">Gets a value that identifies this entity in metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4cc1c-357">Ein Wert, der diese Entität in Verbindung mit dem Modul in Metadaten eindeutig identifiziert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-357">A value which, in combination with the module, uniquely identifies this entity in metadata.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-358">Die Token erhalten haben, verwenden diese Eigenschaft können auf die nicht verwaltete Reflektions-API übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-358">The tokens obtained using this property can be passed to the unmanaged reflection API.</span></span> <span data-ttu-id="4cc1c-359">Weitere Informationen finden Sie unter [nicht verwaltete Reflektions-API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span><span class="sxs-lookup"><span data-stu-id="4cc1c-359">For more information, see [Unmanaged Reflection API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.TypeDelegator.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-360">Ruft das Modul ab, das den implementierten Typ enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-360">Gets the module that contains the implemented type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4cc1c-361">Ein <see cref="T:System.Reflection.Module" />-Objekt, das das Modul des implementierten Typs darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-361">A <see cref="T:System.Reflection.Module" /> object representing the module of the implemented type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-362">Ein Modul ist eine geladen werden kann, die Typendeklarationen und Implementierungen enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-362">A module is a loadable unit that can contain type declarations and implementations.</span></span> <span data-ttu-id="4cc1c-363">Module enthalten genügend Informationen zum Aktivieren der common Language Runtime das Auffinden aller Implementierungsbits, wenn das Modul geladen wird.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-363">Modules contain enough information to enable the common language runtime to locate all implementation bits when the module is loaded.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.TypeDelegator.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-364">Ruft den Namen des implementierten Typs ohne den Pfad ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-364">Gets the name of the implemented type, with the path removed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4cc1c-365">Ein <see langword="String" />, der den nicht gekennzeichneten Namen des Typs enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-365">A <see langword="String" /> containing the type's non-qualified name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-366">Eine Zeichenfolge, die den Namen der aktuellen `TypeDelegator`-Klasse enthält.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-366">A string containing the name of the current `TypeDelegator`.</span></span> <span data-ttu-id="4cc1c-367">Es wird nur der einfache Name, nicht den vollqualifizierten Namen zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-367">Only the simple name, not the fully qualified name, is returned.</span></span> <span data-ttu-id="4cc1c-368">Rufen Sie den Namen und den Pfad mit <xref:System.Reflection.TypeDelegator.FullName%2A>.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-368">To get the name and the path, use <xref:System.Reflection.TypeDelegator.FullName%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Reflection.TypeDelegator.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-369">Ruft den Namespace des implementierten Typs ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-369">Gets the namespace of the implemented type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4cc1c-370">Ein <see langword="String" />, der den Namespace des Typs enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-370">A <see langword="String" /> containing the type's namespace.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-371">Diese Eigenschaft ruft eine Zeichenfolge, die mit dem Namespace des aktuellen `TypeDelegator`.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-371">This property gets a string containing the namespace of the current `TypeDelegator`.</span></span> <span data-ttu-id="4cc1c-372">Z. B. wenn die `TypeDelegator` ist <xref:System.Reflection.TypeFilter>, ist der zurückgegebene Namespace <xref:System.Reflection>.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-372">For example, if the `TypeDelegator` is <xref:System.Reflection.TypeFilter>, the returned namespace is <xref:System.Reflection>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Reflection.TypeDelegator.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-373">Ruft ein Handle für die interne Metadatendarstellung eines implementierten Typs ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-373">Gets a handle to the internal metadata representation of an implemented type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4cc1c-374">Ein <see langword="RuntimeTypeHandle" />-Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-374">A <see langword="RuntimeTypeHandle" /> object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4cc1c-375">Ein Typhandle ist, einen eindeutigen ganzzahligen-Wert, der jeden Typ zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-375">A type handle is a unique integer value associated with each type.</span></span> <span data-ttu-id="4cc1c-376">Das Handle ist während der Laufzeit eindeutig.</span><span class="sxs-lookup"><span data-stu-id="4cc1c-376">The handle is unique during the runtime.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.RuntimeTypeHandle" />
      </Docs>
    </Member>
    <Member MemberName="typeImpl">
      <MemberSignature Language="C#" Value="protected Type typeImpl;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Type typeImpl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.TypeDelegator.typeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected typeImpl As Type " />
      <MemberSignature Language="C++ CLI" Value="protected: Type ^ typeImpl;" />
      <MemberSignature Language="F#" Value="val mutable typeImpl : Type" Usage="System.Reflection.TypeDelegator.typeImpl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-377">Ein Wert, der Typinformationen angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-377">A value indicating type information.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.TypeDelegator.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Reflection.TypeDelegator.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4cc1c-378">Ruft die zugrunde liegende <see cref="T:System.Type" />-Klasse ab, die den implementierten Typ darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-378">Gets the underlying <see cref="T:System.Type" /> that represents the implemented type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4cc1c-379">Der zugrunde liegende Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4cc1c-379">The underlying type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>