<Type Name="MetadataLoadContext" FullName="System.Reflection.MetadataLoadContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dbe1f9f922a0714774bf096c7d979beb21c909b1" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86788457" /></Metadata><TypeSignature Language="C#" Value="public sealed class MetadataLoadContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MetadataLoadContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MetadataLoadContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MetadataLoadContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MetadataLoadContext sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type MetadataLoadContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine isolierte Umgebung mit Type-Objekten dar, die nur zu Prüfzwecken geladen wird. Jedes MetadataLoadContext-Objekt kann eigene Bindungsregeln besitzen und ist von allen anderen MetadataLoadContext-Objekten isoliert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

Ein `MetadataLoadContext` dient als Wörterbuch, das Assemblynamen an Instanzen bindet, <xref:System.Reflection.Assembly> die zuvor in den Kontext geladen wurden oder geladen werden müssen.

Assemblys werden strikt als Metadaten behandelt. Es gibt keine Einschränkungen beim Laden von Assemblys basierend auf der Zielplattform, der CPU-Architektur oder der Zeiger Größe. Es gibt keine Einschränkungen für die Assembly, die als Kernassembly (**mscorlib**) festgelegt ist.

Weitere Informationen und Beispiele finden Sie unter Gewusst [wie: Überprüfen von Assemblyinhalten mithilfe von MetadataLoadContext](/dotnet/standard/assembly/inspect-contents-using-metadataloadcontext).

]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MetadataLoadContext (System.Reflection.MetadataAssemblyResolver resolver, string coreAssemblyName = default);" FrameworkAlternate="dotnet-plat-ext-3.0;dotnet-plat-ext-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.MetadataAssemblyResolver resolver, string coreAssemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.#ctor(System.Reflection.MetadataAssemblyResolver,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resolver As MetadataAssemblyResolver, Optional coreAssemblyName As String = Nothing)" />
      <MemberSignature Language="F#" Value="new System.Reflection.MetadataLoadContext : System.Reflection.MetadataAssemblyResolver * string -&gt; System.Reflection.MetadataLoadContext" Usage="new System.Reflection.MetadataLoadContext (resolver, coreAssemblyName)" />
      <MemberSignature Language="C#" Value="public MetadataLoadContext (System.Reflection.MetadataAssemblyResolver resolver, string? coreAssemblyName = default);" FrameworkAlternate="dotnet-plat-ext-5.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resolver" Type="System.Reflection.MetadataAssemblyResolver" />
        <Parameter Name="coreAssemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resolver">Eine <see cref="T:System.Reflection.MetadataAssemblyResolver" />-Instanz.</param>
        <param name="coreAssemblyName">Der Name der Assembly, die grundlegende Typen wie <see cref="T:System.Object" /> enthält. In der Regel ist dies „mscorlib“.</param>
        <summary>Erstellt ein neues <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CoreAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly CoreAssembly { get; }" FrameworkAlternate="dotnet-plat-ext-3.0;dotnet-plat-ext-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly CoreAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MetadataLoadContext.CoreAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CoreAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Assembly ^ CoreAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CoreAssembly : System.Reflection.Assembly" Usage="System.Reflection.MetadataLoadContext.CoreAssembly" />
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly? CoreAssembly { get; }" FrameworkAlternate="dotnet-plat-ext-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Assembly ab, die die Systemassembly einschließlich bekannter Typen wie <see cref="T:System.Int32" />bezeichnet, oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die Kernassembly wird anders behandelt als andere Assemblys, da Verweise auf diese bekannten Typen den Assemblyverweis im Gegensatz zu normalen Typen nicht enthalten.

In der Regel heißt diese Assembly "mscorlib" oder "netstandard". Wenn die Kernassembly nicht gefunden werden kann, wird der Wert verwendet `null` , und viele andere Reflektionsmethoden, einschließlich derjenigen, die Methoden Signaturen analysieren, lösen eine Ausnahme aus.

`CoreAssembly`Wird festgelegt, indem der `coreAssemblyName` an den-Konstruktor übergebene-Parameter <xref:System.Reflection.MetadataAssemblyResolver> an die-Methode übergeben wird <xref:System.Reflection.MetadataAssemblyResolver.Resolve%2A?displayProperty=nameWithType> .

Wenn `coreAssemblyName` im Konstruktor von kein Argument angegeben wurde <xref:System.Reflection.MetadataLoadContext> , werden Standardwerte verwendet, einschließlich "mscorlib", "System. Runtime" und "netstandard".

Die angegebene Kernassembly muss die Kern Typen nicht direkt enthalten. Sie kann Sie an andere Assemblys weiterleiten. Daher ist es durchaus zulässig, die mscorlib-Fassade als die angegebene Kernassembly zu verwenden.

Beachten Sie, dass <xref:System.Runtime> es sich nicht um eine ideale Kernassembly handelt, da einige der Interop-bezogenen Pseudo benutzerdefinierten Attributtypen, z. b., ausgeschlossen werden <xref:System.Runtime.InteropServices.DllImportAttribute> . Dies kann jedoch der Fall sein, wenn Sie keine Interessen an diesen Attributen haben. Die CustomAttribute-API überspringt diese Attribute, wenn die Kernassembly nicht die erforderlichen Typen enthält.

Die Kernassembly wird erst nach Bedarf geladen. Die folgenden APIs bewirken nicht die Suche nach der Kernassembly:

* <xref:System.Reflection.MetadataLoadContext.LoadFromStream%2A?displayProperty=nameWithType>
* <xref:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath%2A?displayProperty=nameWithType>
* <xref:System.Reflection.MetadataLoadContext.LoadFromByteArray%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetName%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.FullName?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.DefinedTypes?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetForwardedTypes%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)?displayProperty=nameWithType>
* <xref:System.Type.Name?displayProperty=nameWithType>
* <xref:System.Type.FullName?displayProperty=nameWithType>
* <xref:System.Type.AssemblyQualifiedName?displayProperty=nameWithType>

Wenn eine Kernassembly nicht gefunden werden kann oder wenn in der Kernassembly Typen fehlen, wirkt sich dies auf das Verhalten von <xref:System.Reflection.MetadataLoadContext> wie folgt aus:

* APIs, die Signaturen oder TypeSpecs analysieren und die Ergebnisse als Objekte zurückgeben müssen, lösen <xref:System.Type> eine Ausnahme aus. Beispiel:

  * <xref:System.Reflection.MethodInfo.ReturnType?displayProperty=nameWithType>
  * <xref:System.Reflection.MethodBase.GetParameters%2A?displayProperty=nameWithType>
  * <xref:System.Type.BaseType?displayProperty=nameWithType>
  * <xref:System.Type.GetInterfaces%2A?displayProperty=nameWithType>

* APIs, die Typen mit bekannten Kern Typen vergleichen müssen, lösen keine Ausnahme aus, und der Vergleich wird als ausgewertet `false` . Wenn Sie z. b. keine Kernassembly angeben, <xref:System.Type.IsPrimitive> gibt `false` für alles zurück, auch für Typen mit dem Namen <xref:System.Int32> . Entsprechend <xref:System.Type.GetTypeCode%2A?displayProperty=nameWithType> wird <xref:System.TypeCode.Object> für alles zurückgegeben.

* Wenn eine Metadatenentität Flags dieser Oberfläche als Pseudo benutzerdefiniertes Attribut festlegt und die Kernassembly nicht den Pseudo benutzerdefinierten Attributtyp, den erforderlichen Konstruktor oder einen der Parametertypen des Konstruktors enthält, löst <xref:System.Reflection.MetadataLoadContext> nicht aus. Das Attribut "Pseudo Benutzer definiert" wird aus der Liste der zurückgegebenen Attribute ausgelassen.
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="metadataLoadContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle nativen Ressourcen wie z. B. Dateisperren für Assemblydateien frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

Nach der Beseitigung ist es nicht sicher, Objekte zu verwenden, <xref:System.Reflection.Assembly> die von der- <xref:System.Reflection.MetadataLoadContext> oder Reflektionsobjekte ausgegeben werden, die von diesen Objekten ausgegeben werden <xref:System.Reflection.Assembly> .

Obwohl von-Objekten, die von bereitgestellt werden <xref:System.Reflection.MetadataLoadContext> , eine ausgelöst <xref:System.ObjectDisposedException> werden soll, ist dies nicht garantiert.

Einige APIs können fixierte oder zuvor zwischengespeicherte Daten zurückgeben. Der Zugriff auf Objekte *während* eines <xref:System.Reflection.MetadataLoadContext.Dispose%2A> Methoden Aufrufens führt möglicherweise zu einer nicht verwalteten Zugriffsverletzung und einem FailFast.
         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As IEnumerable(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.GetAssemblies : unit -&gt; seq&lt;System.Reflection.Assembly&gt;" Usage="metadataLoadContext.GetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine atomische Momentaufnahme der Assemblys zurück, die in das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt geladen wurden.</summary>
        <returns>Eine aufzählbare Sammlung von <see xref="T:System.Reflection.Assembly" />-Objekten.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyName (assemblyName As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Eine <see cref="T:System.Reflection.AssemblyName" />-Instanz.</param>
        <summary>Löst den angegebenen Assemblynamen auf und ordnet diesen einer Assembly zu. Wenn vorher eine Assembly an diesen Namen gebunden war, wird diese Assembly zurückgegeben. Andernfalls ruft das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt das angegebene <see cref="T:System.Reflection.MetadataAssemblyResolver" />-Objekt auf.</summary>
        <returns>Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

Beachten Sie, dass das Verhalten dieser Methode mit dem Verhalten des <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A?displayProperty=nameWithType> Auflösungs Ereignisses übereinstimmt, jedoch nicht mit dem Verhalten von übereinstimmt <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> . (Letzteres gibt an, ohne das Auflösungs Ereignis zu erhöhen.)
          ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der Resolver gibt <see langword="null" /> zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyName (assemblyName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : string -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Ein <see cref="T:System.String" />-Objekt, das den Namen der Assembly darstellt.</param>
        <summary>Löst den angegebenen Assemblynamen auf und ordnet diesen einer Assembly zu. Wenn vorher eine Assembly an diesen Namen gebunden war, wird diese Assembly zurückgegeben. Andernfalls ruft das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt das angegebene <see cref="T:System.Reflection.MetadataAssemblyResolver" />-Objekt auf.</summary>
        <returns>Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

Beachten Sie, dass das Verhalten dieser Methode mit dem Verhalten des <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A?displayProperty=nameWithType> Auflösungs Ereignisses übereinstimmt, jedoch nicht mit dem Verhalten von übereinstimmt <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> . (Letzteres gibt an, ohne das Auflösungs Ereignis zu erhöhen.)

]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der Resolver gibt <see langword="null" /> zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyPath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyPath (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyPath(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyPath (assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyPath(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyPath : string -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyPath assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath">Ein <see cref="T:System.String" />-Objekt, das den Pfad zur Assembly darstellt.</param>
        <summary>Lädt eine Assembly mithilfe eines angegebenen Datenträgerpfads und bindet an diesen den zugehörigen Assemblynamen innerhalb des <see cref="T:System.Reflection.MetadataLoadContext" />-Objekts. Wenn eine vorherige Assembly mit dem gleichen Namen bereits in das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt geladen wurde, wird diese zurückgegeben.</summary>
        <returns>Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.FileLoadException">Die beiden Assemblys besitzen nicht dieselbe MVID.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromByteArray">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromByteArray (byte[] assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromByteArray(unsigned int8[] assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromByteArray(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromByteArray (assembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromByteArray(cli::array &lt;System::Byte&gt; ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromByteArray : byte[] -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromByteArray assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="assembly">Ein Bytearray, das eine Assembly enthält.</param>
        <summary>Lädt eine Assembly aus einem Bytearray und bindet an dieses den zugehörigen Assemblynamen innerhalb des <see cref="T:System.Reflection.MetadataLoadContext" />-Objekts. Wenn eine vorherige Assembly mit dem gleichen Namen bereits in das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt geladen wurde, wird diese zurückgegeben.</summary>
        <returns>Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.FileLoadException">Die beiden Assemblys besitzen nicht dieselbe MVID.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromStream(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromStream (assembly As Stream) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromStream assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly">Ein <see cref="T:System.IO.Stream" />-Objekt, das eine Assembly enthält.</param>
        <summary>Lädt eine Assembly aus einem Stream und bindet an diesen den zugehörigen Assemblynamen innerhalb des <see cref="T:System.Reflection.MetadataLoadContext" />-Objekts. Wenn eine vorherige Assembly mit dem gleichen Namen bereits in das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt geladen wurde, wird diese zurückgegeben.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> Der <xref:System.Reflection.MetadataLoadContext> übernimmt den Besitz des, der an <xref:System.IO.Stream> Diese Methode übermittelt wird. Der ursprüngliche Besitzer darf seine Position nicht mutieren, den verwerfen <xref:System.IO.Stream> oder davon ausgehen, dass seine Position unverändert bleibt.

]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Die beiden Assemblys besitzen nicht dieselbe MVID.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
