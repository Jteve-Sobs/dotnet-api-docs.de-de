<Type Name="MetadataLoadContext" FullName="System.Reflection.MetadataLoadContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="483d36d82360ba1ca86e8144cae50af883f5d66a" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83972270" /></Metadata><TypeSignature Language="C#" Value="public sealed class MetadataLoadContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MetadataLoadContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MetadataLoadContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MetadataLoadContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MetadataLoadContext sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type MetadataLoadContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="5883d-101">Stellt eine isolierte Umgebung mit Type-Objekten dar, die nur zu Prüfzwecken geladen wird.</span><span class="sxs-lookup"><span data-stu-id="5883d-101">Represents a closed universe of Type objects loaded for inspection-only purposes.</span></span> <span data-ttu-id="5883d-102">Jedes MetadataLoadContext-Objekt kann eigene Bindungsregeln besitzen und ist von allen anderen MetadataLoadContext-Objekten isoliert.</span><span class="sxs-lookup"><span data-stu-id="5883d-102">Each MetadataLoadContext can have its own binding rules and is isolated from all other MetadataLoadContexts.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5883d-103">Ein `MetadataLoadContext` dient als Wörterbuch, das Assemblynamen an <xref:System.Reflection.Assembly> Instanzen bindet, die zuvor in den Kontext geladen wurden oder geladen werden müssen.</span><span class="sxs-lookup"><span data-stu-id="5883d-103">A `MetadataLoadContext` serves as a dictionary that binds assembly names to <xref:System.Reflection.Assembly> instances that were previously loaded into the context or need to be loaded.</span></span>

<span data-ttu-id="5883d-104">Assemblys werden strikt als Metadaten behandelt.</span><span class="sxs-lookup"><span data-stu-id="5883d-104">Assemblies are treated strictly as metadata.</span></span> <span data-ttu-id="5883d-105">Es gibt keine Einschränkungen beim Laden von Assemblys basierend auf der Zielplattform, der CPU-Architektur oder der Zeiger Größe.</span><span class="sxs-lookup"><span data-stu-id="5883d-105">There are no restrictions on loading assemblies based on target platform, CPU architecture, or pointer size.</span></span> <span data-ttu-id="5883d-106">Es gibt keine Einschränkungen für die Assembly, die als Kernassembly (**mscorlib**) festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="5883d-106">There are no restrictions on the assembly designated as the core assembly (**mscorlib**).</span></span>

<span data-ttu-id="5883d-107">Weitere Informationen und Beispiele finden Sie unter Gewusst [wie: Überprüfen von Assemblyinhalten mithilfe von MetadataLoadContext](/dotnet/standard/assembly/inspect-contents-using-metadataloadcontext).</span><span class="sxs-lookup"><span data-stu-id="5883d-107">For more information and examples, see [How to: Inspect assembly contents using MetadataLoadContext](/dotnet/standard/assembly/inspect-contents-using-metadataloadcontext).</span></span>

]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MetadataLoadContext (System.Reflection.MetadataAssemblyResolver resolver, string coreAssemblyName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.MetadataAssemblyResolver resolver, string coreAssemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.#ctor(System.Reflection.MetadataAssemblyResolver,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resolver As MetadataAssemblyResolver, Optional coreAssemblyName As String = null)" />
      <MemberSignature Language="F#" Value="new System.Reflection.MetadataLoadContext : System.Reflection.MetadataAssemblyResolver * string -&gt; System.Reflection.MetadataLoadContext" Usage="new System.Reflection.MetadataLoadContext (resolver, coreAssemblyName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resolver" Type="System.Reflection.MetadataAssemblyResolver" />
        <Parameter Name="coreAssemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resolver"><span data-ttu-id="5883d-108">Eine <see cref="T:System.Reflection.MetadataAssemblyResolver" />-Instanz.</span><span class="sxs-lookup"><span data-stu-id="5883d-108">A <see cref="T:System.Reflection.MetadataAssemblyResolver" /> instance.</span></span></param>
        <param name="coreAssemblyName"><span data-ttu-id="5883d-109">Der Name der Assembly, die grundlegende Typen wie <see cref="T:System.Object" /> enthält.</span><span class="sxs-lookup"><span data-stu-id="5883d-109">The name of the assembly that contains the core types such as <see cref="T:System.Object" />.</span></span> <span data-ttu-id="5883d-110">In der Regel ist dies „mscorlib“.</span><span class="sxs-lookup"><span data-stu-id="5883d-110">Typically, this would be "mscorlib".</span></span></param>
        <summary><span data-ttu-id="5883d-111">Erstellt ein neues <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="5883d-111">Creates a new <see cref="T:System.Reflection.MetadataLoadContext" /> object.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CoreAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly CoreAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly CoreAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MetadataLoadContext.CoreAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CoreAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Assembly ^ CoreAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CoreAssembly : System.Reflection.Assembly" Usage="System.Reflection.MetadataLoadContext.CoreAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5883d-112">Ruft die Assembly ab, die die Systemassembly einschließlich bekannter Typen wie <see cref="T:System.Int32" />bezeichnet, oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="5883d-112">Gets or sets the assembly that denotes the "system assembly" that houses the well-known types such as <see cref="T:System.Int32" />.</span></span></summary>
        <value><span data-ttu-id="5883d-113">Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</span><span class="sxs-lookup"><span data-stu-id="5883d-113">An <see cref="T:System.Reflection.Assembly" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="5883d-114">Die Kernassembly wird anders behandelt als andere Assemblys, da Verweise auf diese bekannten Typen den Assemblyverweis im Gegensatz zu normalen Typen nicht enthalten.</span><span class="sxs-lookup"><span data-stu-id="5883d-114">The core assembly is treated differently than other assemblies because references to these well-known types do not include the assembly reference, unlike normal types.</span></span>

<span data-ttu-id="5883d-115">In der Regel heißt diese Assembly "mscorlib" oder "netstandard".</span><span class="sxs-lookup"><span data-stu-id="5883d-115">Typically, this assembly is named "mscorlib" or "netstandard".</span></span> <span data-ttu-id="5883d-116">Wenn die Kernassembly nicht gefunden werden kann, wird der Wert `null`, und viele andere Reflektionsmethoden, einschließlich derjenigen, die Methoden Signaturen analysieren, lösen eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="5883d-116">If the core assembly cannot be found, the value will be `null`, and many other reflection methods, including those that parse method signatures, will throw an exception.</span></span>

<span data-ttu-id="5883d-117">Die `CoreAssembly` wird durch Übergeben des `coreAssemblyName`-Parameters bestimmt, der an den <xref:System.Reflection.MetadataAssemblyResolver>-Konstruktor übergeben wird, an die <xref:System.Reflection.MetadataAssemblyResolver.Resolve%2A?displayProperty=nameWithType>-Methode.</span><span class="sxs-lookup"><span data-stu-id="5883d-117">The `CoreAssembly` is determined by passing the `coreAssemblyName` parameter passed to the <xref:System.Reflection.MetadataAssemblyResolver> constructor to the <xref:System.Reflection.MetadataAssemblyResolver.Resolve%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="5883d-118">Wenn im Konstruktor von <xref:System.Reflection.MetadataLoadContext>kein `coreAssemblyName` Argument angegeben wurde, werden Standardwerte verwendet, einschließlich "mscorlib", "System. Runtime" und "netstandard".</span><span class="sxs-lookup"><span data-stu-id="5883d-118">If no `coreAssemblyName` argument was specified in the constructor of <xref:System.Reflection.MetadataLoadContext>, then default values are used, including "mscorlib", "System.Runtime" and "netstandard".</span></span>

<span data-ttu-id="5883d-119">Die angegebene Kernassembly muss die Kern Typen nicht direkt enthalten.</span><span class="sxs-lookup"><span data-stu-id="5883d-119">The designated core assembly does not need to contain the core types directly.</span></span> <span data-ttu-id="5883d-120">Sie kann Sie an andere Assemblys weiterleiten.</span><span class="sxs-lookup"><span data-stu-id="5883d-120">It can type forward them to other assemblies.</span></span> <span data-ttu-id="5883d-121">Daher ist es durchaus zulässig, die mscorlib-Fassade als die angegebene Kernassembly zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="5883d-121">Thus, it is perfectly permissible to use the mscorlib facade as the designated core assembly.</span></span>

<span data-ttu-id="5883d-122">Beachten Sie, dass <xref:System.Runtime> keine ideale Kernassembly ist, da einige der Interop-bezogenen Pseudo benutzerdefinierten Attributtypen, z. b. <xref:System.Runtime.InteropServices.DllImportAttribute>, ausgeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="5883d-122">Note that <xref:System.Runtime> is not an ideal core assembly because it excludes some of the interop-related pseudo-custom attribute types such as <xref:System.Runtime.InteropServices.DllImportAttribute>.</span></span> <span data-ttu-id="5883d-123">Dies kann jedoch der Fall sein, wenn Sie keine Interessen an diesen Attributen haben.</span><span class="sxs-lookup"><span data-stu-id="5883d-123">However, it can serve if you have no interest in those attributes.</span></span> <span data-ttu-id="5883d-124">Die CustomAttribute-API überspringt diese Attribute, wenn die Kernassembly nicht die erforderlichen Typen enthält.</span><span class="sxs-lookup"><span data-stu-id="5883d-124">The CustomAttributes API will skip those attributes if the core assembly does not include the necessary types.</span></span>

<span data-ttu-id="5883d-125">Die Kernassembly wird erst nach Bedarf geladen.</span><span class="sxs-lookup"><span data-stu-id="5883d-125">The core assembly is not loaded until necessary.</span></span> <span data-ttu-id="5883d-126">Die folgenden APIs bewirken nicht die Suche nach der Kernassembly:</span><span class="sxs-lookup"><span data-stu-id="5883d-126">The following APIs do not trigger the search for the core assembly:</span></span>

* <xref:System.Reflection.MetadataLoadContext.LoadFromStream%2A?displayProperty=nameWithType>
* <xref:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath%2A?displayProperty=nameWithType>
* <xref:System.Reflection.MetadataLoadContext.LoadFromByteArray%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetName%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.FullName?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.DefinedTypes?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetForwardedTypes%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)?displayProperty=nameWithType>
* <xref:System.Type.Name?displayProperty=nameWithType>
* <xref:System.Type.FullName?displayProperty=nameWithType>
* <xref:System.Type.AssemblyQualifiedName?displayProperty=nameWithType>

<span data-ttu-id="5883d-127">Wenn eine Kernassembly nicht gefunden werden kann oder wenn in der Kernassembly Typen fehlen, wirkt sich dies auf das Verhalten der <xref:System.Reflection.MetadataLoadContext> wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="5883d-127">If a core assembly cannot be found or if the core assembly is missing types, this will affect the behavior of the <xref:System.Reflection.MetadataLoadContext> as follows:</span></span>

* <span data-ttu-id="5883d-128">APIs, die Signaturen oder TypeSpecs analysieren und die Ergebnisse als <xref:System.Type> Objekte zurückgeben müssen, lösen eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="5883d-128">APIs that need to parse signatures or typespecs and return the results as <xref:System.Type> objects will throw an exception.</span></span> <span data-ttu-id="5883d-129">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="5883d-129">For example:</span></span>

  * <xref:System.Reflection.MethodInfo.ReturnType?displayProperty=nameWithType>
  * <xref:System.Reflection.MethodBase.GetParameters%2A?displayProperty=nameWithType>
  * <xref:System.Type.BaseType?displayProperty=nameWithType>
  * <xref:System.Type.GetInterfaces%2A?displayProperty=nameWithType>

* <span data-ttu-id="5883d-130">APIs, die Typen mit bekannten Kerntypen vergleichen müssen, lösen keine Ausnahme aus, und der Vergleich wird zu `false`ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="5883d-130">APIs that need to compare types to well-known core types will not throw an exception, and the comparison will evaluate to `false`.</span></span> <span data-ttu-id="5883d-131">Wenn Sie z. b. keine Kernassembly angeben, gibt <xref:System.Type.IsPrimitive> `false` für alles zurück, auch Typen mit dem Namen <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="5883d-131">For example, if you do not specify a core assembly, <xref:System.Type.IsPrimitive> will return `false` for everything, even types named <xref:System.Int32>.</span></span> <span data-ttu-id="5883d-132">Ebenso werden <xref:System.Type.GetTypeCode%2A?displayProperty=nameWithType> <xref:System.TypeCode.Object> für alle Elemente zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="5883d-132">Similarly, <xref:System.Type.GetTypeCode%2A?displayProperty=nameWithType> will return <xref:System.TypeCode.Object> for everything.</span></span>

* <span data-ttu-id="5883d-133">Wenn eine Metadatenentität Flags für diese Oberfläche als Pseudo benutzerdefiniertes Attribut festlegt und die Kernassembly nicht den Pseudo benutzerdefinierten Attributtyp, den erforderlichen Konstruktor oder einen der Parametertypen des Konstruktors enthält, wird der <xref:System.Reflection.MetadataLoadContext> nicht ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5883d-133">If a metadata entity sets flags that surface as a pseudo-custom attribute, and the core assembly does not contain the pseudo-custom attribute type, the necessary constructor or any of the parameter types of the constructor, the <xref:System.Reflection.MetadataLoadContext> will not throw.</span></span> <span data-ttu-id="5883d-134">Das Attribut "Pseudo Benutzer definiert" wird aus der Liste der zurückgegebenen Attribute ausgelassen.</span><span class="sxs-lookup"><span data-stu-id="5883d-134">It will omit the pseudo-custom attribute from the list of returned attributes.</span></span>
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="metadataLoadContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5883d-135">Gibt alle nativen Ressourcen wie z. B. Dateisperren für Assemblydateien frei.</span><span class="sxs-lookup"><span data-stu-id="5883d-135">Releases any native resources (such as file locks on assembly files).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="5883d-136">Nach der Beseitigung ist es nicht sicher, dass <xref:System.Reflection.Assembly> Objekte verwendet werden, die durch die <xref:System.Reflection.MetadataLoadContext> oder Reflektionsobjekte, die von diesen <xref:System.Reflection.Assembly> Objekten ausgegeben werden, ausgegeben werden</span><span class="sxs-lookup"><span data-stu-id="5883d-136">After disposal, it is not safe to use any <xref:System.Reflection.Assembly> objects dispensed by the <xref:System.Reflection.MetadataLoadContext> or any reflection objects dispensed by those <xref:System.Reflection.Assembly> objects.</span></span>

<span data-ttu-id="5883d-137">Obwohl die von der <xref:System.Reflection.MetadataLoadContext> bereitgestellten Objekte eine <xref:System.ObjectDisposedException>auslösen, ist dies nicht sichergestellt.</span><span class="sxs-lookup"><span data-stu-id="5883d-137">Though objects provided by the <xref:System.Reflection.MetadataLoadContext> strive to throw an <xref:System.ObjectDisposedException>, this is not guaranteed.</span></span>

<span data-ttu-id="5883d-138">Einige APIs können fixierte oder zuvor zwischengespeicherte Daten zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="5883d-138">Some APIs may return fixed or previously cached data.</span></span> <span data-ttu-id="5883d-139">Der Zugriff auf Objekte *während* eines <xref:System.Reflection.MetadataLoadContext.Dispose%2A> Methoden Aufrufens kann zu einer nicht verwalteten Zugriffsverletzung und einem FailFast führen.</span><span class="sxs-lookup"><span data-stu-id="5883d-139">Accessing objects *during* a <xref:System.Reflection.MetadataLoadContext.Dispose%2A> method call may result in an unmanaged access violation and failfast.</span></span>
         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As IEnumerable(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.GetAssemblies : unit -&gt; seq&lt;System.Reflection.Assembly&gt;" Usage="metadataLoadContext.GetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5883d-140">Gibt eine atomische Momentaufnahme der Assemblys zurück, die in das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt geladen wurden.</span><span class="sxs-lookup"><span data-stu-id="5883d-140">Return an atomic snapshot of the assemblies that have been loaded into the <see cref="T:System.Reflection.MetadataLoadContext" />.</span></span></summary>
        <returns><span data-ttu-id="5883d-141">Eine aufzählbare Auflistung von <see xref="T:System.Reflection.Assembly" />-Objekten.</span><span class="sxs-lookup"><span data-stu-id="5883d-141">An enumerable collection of <see xref="T:System.Reflection.Assembly" /> objects.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyName (assemblyName As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="5883d-142">Eine <see cref="T:System.Reflection.AssemblyName" />-Instanz.</span><span class="sxs-lookup"><span data-stu-id="5883d-142">An <see cref="T:System.Reflection.AssemblyName" /> instance.</span></span></param>
        <summary><span data-ttu-id="5883d-143">Löst den angegebenen Assemblynamen auf und ordnet diesen einer Assembly zu.</span><span class="sxs-lookup"><span data-stu-id="5883d-143">Resolves the supplied assembly name to an assembly.</span></span> <span data-ttu-id="5883d-144">Wenn vorher eine Assembly an diesen Namen gebunden war, wird diese Assembly zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="5883d-144">If an assembly was previously bound to this name, that assembly is returned.</span></span> <span data-ttu-id="5883d-145">Andernfalls ruft das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt das angegebene <see cref="T:System.Reflection.MetadataAssemblyResolver" />-Objekt auf.</span><span class="sxs-lookup"><span data-stu-id="5883d-145">Otherwise, the <see cref="T:System.Reflection.MetadataLoadContext" /> calls the specified <see cref="T:System.Reflection.MetadataAssemblyResolver" />.</span></span></summary>
        <returns><span data-ttu-id="5883d-146">Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</span><span class="sxs-lookup"><span data-stu-id="5883d-146">An <see cref="T:System.Reflection.Assembly" /> instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

<span data-ttu-id="5883d-147">Beachten Sie, dass das Verhalten dieser Methode mit dem Verhalten des <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A?displayProperty=nameWithType> Auflösungs Ereignisses übereinstimmt, jedoch nicht mit dem Verhalten <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="5883d-147">Note that the behavior of this method matches the behavior of the <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A?displayProperty=nameWithType> resolve event, but does not match the behavior of <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5883d-148">(Letzteres gibt an, ohne das Auflösungs Ereignis zu erhöhen.)</span><span class="sxs-lookup"><span data-stu-id="5883d-148">(The latter gives up without raising its resolve event.)</span></span>
          ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="5883d-149">Der Resolver gibt <see langword="null" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="5883d-149">The resolver returns <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyName (assemblyName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : string -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="5883d-150">Ein <see cref="T:System.String" />-Objekt, das den Namen der Assembly darstellt.</span><span class="sxs-lookup"><span data-stu-id="5883d-150">A <see cref="T:System.String" /> representing the assembly name.</span></span></param>
        <summary><span data-ttu-id="5883d-151">Löst den angegebenen Assemblynamen auf und ordnet diesen einer Assembly zu.</span><span class="sxs-lookup"><span data-stu-id="5883d-151">Resolves the supplied assembly name to an assembly.</span></span> <span data-ttu-id="5883d-152">Wenn vorher eine Assembly an diesen Namen gebunden war, wird diese Assembly zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="5883d-152">If an assembly was previously bound to this name, that assembly is returned.</span></span> <span data-ttu-id="5883d-153">Andernfalls ruft das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt das angegebene <see cref="T:System.Reflection.MetadataAssemblyResolver" />-Objekt auf.</span><span class="sxs-lookup"><span data-stu-id="5883d-153">Otherwise, the <see cref="T:System.Reflection.MetadataLoadContext" /> calls the specified <see cref="T:System.Reflection.MetadataAssemblyResolver" />.</span></span></summary>
        <returns><span data-ttu-id="5883d-154">Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</span><span class="sxs-lookup"><span data-stu-id="5883d-154">An <see cref="T:System.Reflection.Assembly" /> instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

<span data-ttu-id="5883d-155">Beachten Sie, dass das Verhalten dieser Methode mit dem Verhalten des <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A?displayProperty=nameWithType> Auflösungs Ereignisses übereinstimmt, aber nicht mit dem Verhalten <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="5883d-155">Note that the behavior of this method matches the behavior of the <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A?displayProperty=nameWithType> resolve event but does not match the behavior of <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5883d-156">(Letzteres gibt an, ohne das Auflösungs Ereignis zu erhöhen.)</span><span class="sxs-lookup"><span data-stu-id="5883d-156">(The latter gives up without raising its resolve event.)</span></span>

]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="5883d-157">Der Resolver gibt <see langword="null" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="5883d-157">The resolver returns <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyPath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyPath (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyPath(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyPath (assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyPath(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyPath : string -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyPath assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath"><span data-ttu-id="5883d-158">Ein <see cref="T:System.String" />-Objekt, das den Pfad zur Assembly darstellt.</span><span class="sxs-lookup"><span data-stu-id="5883d-158">A <see cref="T:System.String" /> representing the path to the assembly.</span></span></param>
        <summary><span data-ttu-id="5883d-159">Lädt eine Assembly mithilfe eines angegebenen Datenträgerpfads und bindet an diesen den zugehörigen Assemblynamen innerhalb des <see cref="T:System.Reflection.MetadataLoadContext" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="5883d-159">Loads an assembly from a specific path on the disk and binds its assembly name to it in the <see cref="T:System.Reflection.MetadataLoadContext" />.</span></span> <span data-ttu-id="5883d-160">Wenn eine vorherige Assembly mit dem gleichen Namen bereits in das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt geladen wurde, wird diese zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="5883d-160">If a prior assembly with the same name was already loaded into the <see cref="T:System.Reflection.MetadataLoadContext" />, the prior assembly will be returned.</span></span></summary>
        <returns><span data-ttu-id="5883d-161">Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</span><span class="sxs-lookup"><span data-stu-id="5883d-161">An <see cref="T:System.Reflection.Assembly" /> instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="5883d-162">Die beiden Assemblys besitzen nicht dieselbe MVID.</span><span class="sxs-lookup"><span data-stu-id="5883d-162">The two assemblies do not have the same Mvid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromByteArray">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromByteArray (byte[] assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromByteArray(unsigned int8[] assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromByteArray(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromByteArray (assembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromByteArray(cli::array &lt;System::Byte&gt; ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromByteArray : byte[] -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromByteArray assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="5883d-163">Ein Bytearray, das eine Assembly enthält.</span><span class="sxs-lookup"><span data-stu-id="5883d-163">A byte array holding an assembly.</span></span></param>
        <summary><span data-ttu-id="5883d-164">Lädt eine Assembly aus einem Bytearray und bindet an dieses den zugehörigen Assemblynamen innerhalb des <see cref="T:System.Reflection.MetadataLoadContext" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="5883d-164">Loads an assembly from a byte array and binds its assembly name to it in the <see cref="T:System.Reflection.MetadataLoadContext" />.</span></span> <span data-ttu-id="5883d-165">Wenn eine vorherige Assembly mit dem gleichen Namen bereits in das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt geladen wurde, wird diese zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="5883d-165">If a prior assembly with the same name was already loaded into the <see cref="T:System.Reflection.MetadataLoadContext" />, the prior assembly will be returned.</span></span></summary>
        <returns><span data-ttu-id="5883d-166">Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</span><span class="sxs-lookup"><span data-stu-id="5883d-166">An <see cref="T:System.Reflection.Assembly" /> instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="5883d-167">Die beiden Assemblys besitzen nicht dieselbe MVID.</span><span class="sxs-lookup"><span data-stu-id="5883d-167">The two assemblies do not have the same Mvid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromStream(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromStream (assembly As Stream) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromStream assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="5883d-168">Ein <see cref="T:System.IO.Stream" />-Array, das eine Assembly enthält.</span><span class="sxs-lookup"><span data-stu-id="5883d-168">A <see cref="T:System.IO.Stream" /> holding an assembly.</span></span></param>
        <summary><span data-ttu-id="5883d-169">Lädt eine Assembly aus einem Stream und bindet an diesen den zugehörigen Assemblynamen innerhalb des <see cref="T:System.Reflection.MetadataLoadContext" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="5883d-169">Loads an assembly from a stream and binds its assembly name to it in the <see cref="T:System.Reflection.MetadataLoadContext" />.</span></span> <span data-ttu-id="5883d-170">Wenn eine vorherige Assembly mit dem gleichen Namen bereits in das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt geladen wurde, wird diese zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="5883d-170">If a prior assembly with the same name was already loaded into the <see cref="T:System.Reflection.MetadataLoadContext" />, the prior assembly will be returned.</span></span></summary>
        <returns><span data-ttu-id="5883d-171">Die geladene Assembly.</span><span class="sxs-lookup"><span data-stu-id="5883d-171">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> <span data-ttu-id="5883d-172">Der <xref:System.Reflection.MetadataLoadContext> übernimmt den Besitz des <xref:System.IO.Stream>, der an diese Methode übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="5883d-172">The <xref:System.Reflection.MetadataLoadContext> takes ownership of the <xref:System.IO.Stream> passed into this method.</span></span> <span data-ttu-id="5883d-173">Der ursprüngliche Besitzer darf seine Position nicht mutieren, den <xref:System.IO.Stream>verwerfen oder davon ausgehen, dass seine Position unverändert bleibt.</span><span class="sxs-lookup"><span data-stu-id="5883d-173">The original owner must not mutate its position, dispose the <xref:System.IO.Stream>, or assume that its position will stay unchanged.</span></span>

]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="5883d-174">Die beiden Assemblys besitzen nicht dieselbe MVID.</span><span class="sxs-lookup"><span data-stu-id="5883d-174">The two assemblies do not have the same Mvid.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
