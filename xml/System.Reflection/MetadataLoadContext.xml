<Type Name="MetadataLoadContext" FullName="System.Reflection.MetadataLoadContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2b6a57dbb5dc6a01c5eba76ff27d3fa458a46188" /><Meta Name="ms.sourcegitcommit" Value="93667418e6e77da6ba7109a407c61b8969cec4ec" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/05/2019" /><Meta Name="ms.locfileid" Value="67571125" /></Metadata><TypeSignature Language="C#" Value="public sealed class MetadataLoadContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MetadataLoadContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MetadataLoadContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MetadataLoadContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MetadataLoadContext sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type MetadataLoadContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine isolierte Umgebung mit Type-Objekten dar, die nur zu Prüfzwecken geladen wird. Jedes MetadataLoadContext-Objekt kann eigene Bindungsregeln besitzen und ist von allen anderen MetadataLoadContext-Objekten isoliert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

## Remarks

Ein `MetadataLoadContext` dient als ein Wörterbuch, das Assemblynamen, bindet <xref:System.Reflection.Assembly> -Instanzen, die in den Kontext oder die Notwendigkeit, die geladen werden zuvor geladen wurden.

Assemblys werden ausschließlich als Metadaten behandelt. Es gibt keine Einschränkungen zum Laden von Assemblys auf Grundlage der Zielplattform, die CPU-Architektur und die Größe des Zeigers. Es gibt keine Einschränkungen für die Assembly als die Core-Assembly (**"mscorlib"**).

]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MetadataLoadContext (System.Reflection.MetadataAssemblyResolver resolver, string coreAssemblyName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.MetadataAssemblyResolver resolver, string coreAssemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.#ctor(System.Reflection.MetadataAssemblyResolver,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resolver As MetadataAssemblyResolver, Optional coreAssemblyName As String = null)" />
      <MemberSignature Language="F#" Value="new System.Reflection.MetadataLoadContext : System.Reflection.MetadataAssemblyResolver * string -&gt; System.Reflection.MetadataLoadContext" Usage="new System.Reflection.MetadataLoadContext (resolver, coreAssemblyName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resolver" Type="System.Reflection.MetadataAssemblyResolver" />
        <Parameter Name="coreAssemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resolver">Eine <see cref="T:System.Reflection.MetadataAssemblyResolver" />-Instanz.</param>
        <param name="coreAssemblyName">Der Name der Assembly, die grundlegende Typen wie <see cref="T:System.Object" /> enthält. In der Regel ist dies „mscorlib“.</param>
        <summary>Erstellt ein neues <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CoreAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly CoreAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly CoreAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MetadataLoadContext.CoreAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CoreAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Assembly ^ CoreAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CoreAssembly : System.Reflection.Assembly" Usage="System.Reflection.MetadataLoadContext.CoreAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Assembly ab, die die Systemassembly einschließlich bekannter Typen wie <see cref="T:System.Int32" />bezeichnet, oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die Kern-Assembly ist anders als andere Assemblys behandelt werden, da Verweise auf diese bekannten Typen nicht über den der Assemblyverweis verweist, im Gegensatz zu normalen Typen beinhalten.
            
In der Regel wird diese Assembly "Mscorlib" oder "Netstandard" benannt. Wenn die Kern-Assembly nicht gefunden werden kann, wird der Wert `null`, und viele andere Reflektionsmethoden, einschließlich derjenigen, die Methodensignaturen, analysieren, werden eine Ausnahme ausgelöst.
            
Die `CoreAssembly` richtet sich nach der Übergabe der `coreAssemblyName` Parameter zu übergeben, um die <xref:System.Reflection.MetadataAssemblyResolver> Konstruktor, um die <xref:System.Reflection.MetadataAssemblyResolver.Resolve%2A?displayProperty=nameWithType> Methode.

Wenn kein `coreAssemblyName` Argument wurde angegeben, in den Konstruktor der <xref:System.Reflection.MetadataLoadContext>, und klicken Sie dann die Standardwerte verwendet werden, wie z.B. "Mscorlib", "System.Runtime" und "Netstandard".
            
Die Kern der angegebenen Assembly muss nicht auf die grundlegenden Typen enthalten. Sie können eingeben, an andere Assemblys weitergeleitet werden. Daher ist es durchaus zulässig, die die Fassade "mscorlib" als die angegebenen Core-Assembly verwendet.
            
Beachten Sie, dass <xref:System.Runtime> ist keine Assembly ideal Core, da es einige Pseudo benutzerdefiniertes Attribut Interop-bezogenen Typen wie z. B. schließt <xref:System.Runtime.InteropServices.DllImportAttribute>. Jedoch kann diese dienen, wenn Sie kein Interesse an der die Attribute haben. Die CustomAttributes-API überspringt die Attribute, wenn die erforderlichen Typen nicht von die Kern-Assembly enthalten ist.
            
Die Kern-Assembly wird erst ggf. nicht geladen werden. Die folgenden APIs lösen keine Suche nach der Core-Assembly:

* <xref:System.Reflection.MetadataLoadContext.LoadFromStream%2A?displayProperty=nameWithType>
* <xref:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath%2A?displayProperty=nameWithType>
* <xref:System.Reflection.MetadataLoadContext.LoadFromByteArray%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetName%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.FullName?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.DefinedTypes?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetForwardedTypes%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)?displayProperty=nameWithType>
* <xref:System.Type.Name?displayProperty=nameWithType>
* <xref:System.Type.FullName?displayProperty=nameWithType>
* <xref:System.Type.AssemblyQualifiedName?displayProperty=nameWithType>
            
Wenn eine Core-Assembly kann nicht gefunden werden oder wenn die Kernassembly Typen vorhanden ist, dies sich das Verhalten von wirkt der <xref:System.Reflection.MetadataLoadContext> wie folgt:
            
* APIs, die Signaturen oder Typespecs zu analysieren und die Ergebnisse als zurückgeben müssen <xref:System.Type> Objekte werden eine Ausnahme ausgelöst. Beispiel:

  * <xref:System.Reflection.MethodInfo.ReturnType?displayProperty=nameWithType>
  * <xref:System.Reflection.MethodBase.GetParameters%2A?displayProperty=nameWithType>
  * <xref:System.Type.BaseType?displayProperty-nameWithType>
  * <xref:System.Type.GetInterfaces%2A?displayProperty=nameWithType>

* APIs, die zum Vergleichen von Typen bekannten grundlegenden Typen benötigen, wird keine Ausnahme ausgelöst, und der Vergleich wird dieser als `false`. Angenommen, Sie keine Core-Assembly angeben <xref:System.Type.IsPrimitive> zurück `false` für alle Elemente auch Typen, die mit dem Namen <xref:System.Int32>. Auf ähnliche Weise <xref:System.Type.GetTypeCode%2A?displayProperty=nameWithType> zurück <xref:System.TypeCode.Object> für alles.
            
* Wenn eine Metadatenentität Flags, die dann als Pseudo benutzerdefiniertes Attribut, und die Core-Assembly nicht den Pseudo benutzerdefinierten Attributtyp, die den erforderlichen Konstruktor angegeben wird, oder eines der die Parametertypen des Konstruktors enthält, der <xref:System.Reflection.MetadataLoadContext> keine Ausnahme auslöst. Es lässt das Pseudo benutzerdefinierte Attribut aus der Liste der zurückgegebenen Attribute.
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="metadataLoadContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle nativen Ressourcen wie z. B. Dateisperren für Assemblydateien frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Nach der Beseitigung, es ist nicht sicher verwenden <xref:System.Reflection.Assembly> Objekte Schiffsteil abgesehen von der <xref:System.Reflection.MetadataLoadContext> oder alle Reflection-Objekte, die durch die Schiffsteil abgesehen <xref:System.Reflection.Assembly> Objekte.

Wenn Objekte von bereitgestellt der <xref:System.Reflection.MetadataLoadContext> bemühen uns um das Auslösen einer <xref:System.ObjectDisposedException>, dies ist nicht gewährleistet.

Einige APIs möglicherweise behoben oder zuvor zwischengespeicherten Daten zurück. Zugreifen auf Objekte *während* eine <xref:System.Reflection.MetadataLoadContext.Dispose%2A> Methodenaufruf in einem nicht verwalteten zugriffsverletzung und Failfast führen kann.
         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As IEnumerable(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.GetAssemblies : unit -&gt; seq&lt;System.Reflection.Assembly&gt;" Usage="metadataLoadContext.GetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine atomische Momentaufnahme der Assemblys zurück, die in das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt geladen wurden.</summary>
        <returns>Eine aufzählbare Sammlung von <see xref="T:System.Reflection.Assembly" />-Objekten.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Eine <see cref="T:System.Reflection.AssemblyName" />-Instanz.</param>
        <summary>Löst den angegebenen Assemblynamen auf und ordnet diesen einer Assembly zu. Wenn vorher eine Assembly an diesen Namen gebunden war, wird diese Assembly zurückgegeben. Andernfalls ruft das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt das angegebene <see cref="T:System.Reflection.MetadataAssemblyResolver" />-Objekt auf.</summary>
        <returns>Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
Beachten Sie, dass das Verhalten dieser Methode das Verhalten entspricht dem <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A?displayProperty=nameWithType> Ereignis aufgelöst, aber nicht das Verhalten des mit <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>. (Letzteres gibt ohne die Resolve-Ereignis auszulösen.)
          ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der Resolver gibt <see langword="null" /> zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyName (assemblyName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : string -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Ein <see cref="T:System.String" />-Objekt, das den Namen der Assembly darstellt.</param>
        <summary>Löst den angegebenen Assemblynamen auf und ordnet diesen einer Assembly zu. Wenn vorher eine Assembly an diesen Namen gebunden war, wird diese Assembly zurückgegeben. Andernfalls ruft das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt das angegebene <see cref="T:System.Reflection.MetadataAssemblyResolver" />-Objekt auf.</summary>
        <returns>Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

Beachten Sie, dass das Verhalten dieser Methode das Verhalten entspricht dem <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A?displayProperty=nameWithType> Ereignis aufgelöst, aber nicht das Verhalten des mit <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>. (Letzteres gibt ohne die Resolve-Ereignis auszulösen.)

]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der Resolver gibt <see langword="null" /> zurück.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyPath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyPath (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyPath(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyPath (assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyPath(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyPath : string -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyPath assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath">Ein <see cref="T:System.String" />-Objekt, das den Pfad zur Assembly darstellt.</param>
        <summary>Lädt eine Assembly mithilfe eines angegebenen Datenträgerpfads und bindet an diesen den zugehörigen Assemblynamen innerhalb des <see cref="T:System.Reflection.MetadataLoadContext" />-Objekts. Wenn eine vorherige Assembly mit dem gleichen Namen bereits in das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt geladen wurde, wird diese zurückgegeben.</summary>
        <returns>Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.FileLoadException">Die beiden Assemblys besitzen nicht dieselbe MVID.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromByteArray">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromByteArray (byte[] assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromByteArray(unsigned int8[] assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromByteArray(System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromByteArray(cli::array &lt;System::Byte&gt; ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromByteArray : byte[] -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromByteArray assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="assembly">Ein <see cref="T:System.Byte[]" />-Array, das eine Assembly enthält.</param>
        <summary>Lädt eine Assembly aus einem Bytearray und bindet an dieses den zugehörigen Assemblynamen innerhalb des <see cref="T:System.Reflection.MetadataLoadContext" />-Objekts. Wenn eine vorherige Assembly mit dem gleichen Namen bereits in das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt geladen wurde, wird diese zurückgegeben.</summary>
        <returns>Eine <see cref="T:System.Reflection.Assembly" />-Instanz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.FileLoadException">Die beiden Assemblys besitzen nicht dieselbe MVID.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromStream assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly">Ein <see cref="T:System.IO.Stream" />-Objekt, das eine Assembly enthält.</param>
        <summary>Lädt eine Assembly aus einem Stream und bindet an diesen den zugehörigen Assemblynamen innerhalb des <see cref="T:System.Reflection.MetadataLoadContext" />-Objekts. Wenn eine vorherige Assembly mit dem gleichen Namen bereits in das <see cref="T:System.Reflection.MetadataLoadContext" />-Objekt geladen wurde, wird diese zurückgegeben.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> Die <xref:System.Reflection.MetadataLoadContext> übernimmt den Besitz der <xref:System.IO.Stream> an diese Methode übergeben. Des ursprünglichen Besitzers muss nicht geändert wird, seine Position, freigeben, die <xref:System.IO.Stream>, oder Sie davon ausgehen, dass seine Position unverändert bleiben.

]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Die beiden Assemblys besitzen nicht dieselbe MVID.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
