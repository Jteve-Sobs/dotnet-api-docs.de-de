<Type Name="Binder" FullName="System.Reflection.Binder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e52d82e248c05335efb0d6b73255499c9180a3cc" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57917647" /></Metadata><TypeSignature Language="C#" Value="public abstract class Binder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Binder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Binder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Binder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Binder abstract" />
  <TypeSignature Language="F#" Value="type Binder = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wählt einen Member aus einer Liste von Kandidaten aus und führt eine Typkonvertierung vom tatsächlichen Argumenttyp zum formalen Argumenttyp durch.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementierungen der <xref:System.Reflection.Binder> Klasse werden durch Methoden verwendet, z. B. <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>, die aus einer Reihe von möglichen Member auswählt, ausgeführt werden, basierend auf einem Satz von Parametertypen und Argumentwerte; <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, der auswählt, dass einer Methode basierend auf Parametertypen; und So weiter.  
  
 Eine Standardimplementierung der <xref:System.Reflection.Binder> Klasse erfolgt über die <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Beispiel implementiert und zeigt alle Mitglieder der `Binder` Klasse. Die private Methode `CanConvertFrom` kompatible Typen für einen bestimmten Typ findet.  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Beim Erben von <see cref="T:System.Reflection.Binder" />, müssen Sie die folgenden Member überschreiben: <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, <see cref="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />, <see cref="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />, <see cref="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />, und <see cref="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Binder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Binder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Reflection.Binder" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird von den Konstruktoren von abgeleiteten Klassen, die zum Initialisieren der Zustand in diesem Typ aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindToField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo BindToField (System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo BindToField(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.FieldInfo[] match, object value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function BindToField (bindingAttr As BindingFlags, match As FieldInfo(), value As Object, culture As CultureInfo) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ BindToField(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ match, System::Object ^ value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member BindToField : System.Reflection.BindingFlags * System.Reflection.FieldInfo[] * obj * System.Globalization.CultureInfo -&gt; System.Reflection.FieldInfo" Usage="binder.BindToField (bindingAttr, match, value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.FieldInfo[]" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination von <see cref="T:System.Reflection.BindingFlags" />-Werten.</param>
        <param name="match">Die Reihe der Felder, die Kandidaten für Übereinstimmungen sind. Wenn beispielsweise ein <see cref="T:System.Reflection.Binder" />-Objekt von <see cref="Overload:System.Type.InvokeMember" /> verwendet wird, gibt dieser Parameter die Reihe von Feldern an, die von der Reflektion als mögliche Übereinstimmungen bestimmt wurden, typischerweise weil sie den entsprechenden Membernamen aufweisen. Die von <see cref="P:System.Type.DefaultBinder" /> bereitgestellte Standardimplementierung ändert die Reihenfolge dieses Arrays.</param>
        <param name="value">Der Feldwert, mit dem ein übereinstimmendes Feld gesucht wird.</param>
        <param name="culture">Eine Instanz von <see cref="T:System.Globalization.CultureInfo" />, mit der in Binderimplementierungen mit Typumwandlungen die Umwandlung von Datentypen gesteuert wird. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.  
  
Hinweis   Wenn eine Binderimplementierung beispielsweise die Umwandlung von Zeichenfolgenwerten in numerische Typen zulässt, ist dieser Parameter erforderlich, um einen <see langword="String" />, der 1.000 darstellt, in einen <see langword="Double" />-Wert zu konvertieren, da 1.000 in verschiedenen Kulturen unterschiedlich dargestellt wird. Der Standardbinder führt keine solchen Zeichenfolgenumwandlungen aus.</param>
        <summary>Wählt anhand der angegebenen Kriterien ein Feld aus der angegebenen Gruppe von Feldern aus.</summary>
        <returns>Das entsprechende Feld.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `bindingAttr` enthält keine <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, gebotenen standardbinderimplementierung <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> gibt einfach das erste Element der `match`. Keine Auswahl erfolgt.  
  
 Diese Methode steuert die Bindung von bereitgestellten <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Für den Standardbinder enthält <paramref name="bindingAttr" /><see cref="F:System.Reflection.BindingFlags.SetField" />, und <paramref name="match" /> enthält mehrere Felder, die gleichwertige Übereinstimmungen für <paramref name="value" /> sind. <paramref name="value" /> enthält beispielsweise ein <c>MyClass</c>-Objekt, das die <c>IMyClass</c>-Schnittstelle implementiert, und <paramref name="match" /> enthält ein Feld vom Typ <c>MyClass</c> sowie ein Feld vom Typ <c>IMyClass</c>.</exception>
        <exception cref="T:System.MissingFieldException">Für den Standardbinder enthält <paramref name="bindingAttr" /><see cref="F:System.Reflection.BindingFlags.SetField" />, und <paramref name="match" /> enthält keine Felder, die <paramref name="value" /> annehmen können.</exception>
        <exception cref="T:System.NullReferenceException">Für den Standardbinder enthält <paramref name="bindingAttr" /><see cref="F:System.Reflection.BindingFlags.SetField" />, und <paramref name="match" /> ist <see langword="null" /> oder ein leeres Array.  
  
- oder - 
 <paramref name="bindingAttr" /> enthält <see cref="F:System.Reflection.BindingFlags.SetField" />, und <paramref name="value" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
      </Docs>
    </Member>
    <Member MemberName="BindToMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase BindToMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, out object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase BindToMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, object[]&amp; args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] names, [out] object&amp; state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function BindToMethod (bindingAttr As BindingFlags, match As MethodBase(), ByRef args As Object(), modifiers As ParameterModifier(), culture As CultureInfo, names As String(), ByRef state As Object) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodBase ^ BindToMethod(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::MethodBase ^&gt; ^ match, cli::array &lt;System::Object ^&gt; ^ % args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ names, [Runtime::InteropServices::Out] System::Object ^ % state);" />
      <MemberSignature Language="F#" Value="abstract member BindToMethod : System.Reflection.BindingFlags * System.Reflection.MethodBase[] *  * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] *  -&gt; System.Reflection.MethodBase" Usage="binder.BindToMethod (bindingAttr, match, args, modifiers, culture, names, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="args" Type="System.Object[]" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="names" Type="System.String[]" />
        <Parameter Name="state" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination von <see cref="T:System.Reflection.BindingFlags" />-Werten.</param>
        <param name="match">Die Reihe der Methoden, die Kandidaten für Übereinstimmungen sind. Wenn beispielsweise ein <see cref="T:System.Reflection.Binder" />-Objekt von <see cref="Overload:System.Type.InvokeMember" /> verwendet wird, gibt dieser Parameter die Reihe von Methoden an, die von der Reflektion als mögliche Übereinstimmungen bestimmt wurden, typischerweise weil sie den entsprechenden Membernamen aufweisen. Die von <see cref="P:System.Type.DefaultBinder" /> bereitgestellte Standardimplementierung ändert die Reihenfolge dieses Arrays.</param>
        <param name="args">Die übergebenen Argumente. Der Binder kann die Reihenfolge der Argumente in diesem Array ändern. Der Standardbinder ändert beispielsweise die Reihenfolge der Argumente, wenn mit dem <paramref name="names" />-Parameter eine andere Reihenfolge als eine positionelle Reihenfolge angegeben wird. Wenn eine Binderimplementierung Argumenttypen umwandelt, können auch die Typen und Werte der Argumente geändert werden.</param>
        <param name="modifiers">Ein Array von Parametermodifizierern, die bei Bindungen die Verwendung von Parametersignaturen ermöglichen, in denen die Typen geändert wurden. Dieser Parameter wird von der Standardbinderimplementierung nicht verwendet.</param>
        <param name="culture">Eine Instanz von <see cref="T:System.Globalization.CultureInfo" />, mit der in Binderimplementierungen mit Typumwandlungen die Umwandlung von Datentypen gesteuert wird. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.  
  
Hinweis   Wenn eine Binderimplementierung beispielsweise die Umwandlung von Zeichenfolgenwerten in numerische Typen zulässt, ist dieser Parameter erforderlich, um einen <see langword="String" />, der 1.000 darstellt, in einen <see langword="Double" />-Wert zu konvertieren, da 1.000 in verschiedenen Kulturen unterschiedlich dargestellt wird. Der Standardbinder führt keine solchen Zeichenfolgenumwandlungen aus.</param>
        <param name="names">Die Parameternamen, wenn Parameternamen bei Zuordnungen berücksichtigt werden müssen, oder <see langword="null" />, wenn Argumente als rein positionell behandelt werden müssen. Parameternamen müssen beispielsweise verwendet werden, wenn Argumente nicht in positioneller Reihenfolge angegeben sind.</param>
        <param name="state">Nach der Rückgabe der Methode enthält <paramref name="state" /> ein vom Binder bereitgestelltes Objekt, das die Änderung der Reihenfolge von Argumenten verfolgt. Der Binder erstellt dieses Objekt und ist der einzige Consumer dieses Objekts. Wenn <paramref name="state" /> bei der Rückgabe von <see langword="null" /> nicht <see langword="BindToMethod" /> ist, müssen Sie <paramref name="state" /> an die <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />-Methode übergeben, wenn Sie <paramref name="args" /> mit der ursprünglichen Reihenfolge wiederherstellen möchten, damit Sie beispielsweise die Werte von <see langword="ref" />-Parametern (<see langword="ByRef" />-Parametern in Visual Basic) abrufen können.</param>
        <summary>Wählt eine aufzurufende Methode anhand der bereitgestellten Argumente aus der angegebenen Gruppe von Methoden aus.</summary>
        <returns>Die entsprechende Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardbinder berücksichtigt beide Parameter, die Werte aufweisen und `params` Arrays (`ParamArray` Arrays in Visual Basic). Daher ist es möglich, eine Übereinstimmung zu finden, in Fällen, in denen `args` und `match` nicht die gleiche Anzahl von Elementen enthalten.  
  
 Der Binder kann ein Client das Array von Argumenten an seiner ursprünglichen Form zugeordnet werden, wenn durch das Argumentarray verändert wurde <xref:System.Reflection.Binder.BindToMethod%2A>. Verwenden Sie diese neuzuordnung-Funktion, um durch Verweis übergebenen Argumenten zurück zu erhalten, wenn solche Argumente vorhanden sind. Wenn Sie Argumente nach Namen übergeben, Argumentarrays der Binder. Die `state` Parameter verfolgt des Arguments neuanordnung, sodass der Bindung des <xref:System.Reflection.Binder.ReorderArgumentArray%2A> Methode, um das Argumentarray in seiner ursprünglichen Form neu anordnen.  
  
 Die <xref:System.Reflection.Binder.BindToMethod%2A> Methode wird verwendet, durch die <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Für den Standardbinder enthält <paramref name="match" /> mehrere Methoden, die gleichwertige Übereinstimmungen für <paramref name="args" /> darstellen. <paramref name="args" /> enthält beispielsweise ein <c>MyClass</c>-Objekt, das die <c>IMyClass</c>-Schnittstelle implementiert, und <paramref name="match" /> enthält eine Methode, die <c>MyClass</c> annimmt, sowie eine Methode, die <c>IMyClass</c> annimmt.</exception>
        <exception cref="T:System.MissingMethodException">Für den Standardbinder enthält <paramref name="match" /> keine Methoden, die die in <paramref name="args" /> bereitgestellten Argumente annehmen können.</exception>
        <exception cref="T:System.ArgumentException">Für den Standardbinder ist <paramref name="match" /> gleich <see langword="null" /> oder ein leeres Array.</exception>
        <altmember cref="T:System.Reflection.MethodBase" />
      </Docs>
    </Member>
    <Member MemberName="CanChangeType">
      <MemberSignature Language="C#" Value="public virtual bool CanChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.CanChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanChangeType(System::Object ^ value, Type ^ type, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member CanChangeType : obj * Type * System.Globalization.CultureInfo -&gt; bool&#xA;override this.CanChangeType : obj * Type * System.Globalization.CultureInfo -&gt; bool" Usage="binder.CanChangeType (value, type, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="xamarinios-10.8" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="xamarinios-10.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="type">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeType">
      <MemberSignature Language="C#" Value="public abstract object ChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ ChangeType(System::Object ^ value, Type ^ type, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member ChangeType : obj * Type * System.Globalization.CultureInfo -&gt; obj" Usage="binder.ChangeType (value, type, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das in einen neuen <see langword="Type" /> geändert werden soll.</param>
        <param name="type">Der neue <see langword="Type" />, den <paramref name="value" /> annimmt.</param>
        <param name="culture">Eine Instanz von <see cref="T:System.Globalization.CultureInfo" />, mit der die Umwandlung von Datentypen gesteuert wird. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.  
  
Hinweis   Dieser Parameter ist z. B. erforderlich, um einen <see langword="String" />, mit dem 1.000 dargestellt wird, in einen <see langword="Double" />-Wert zu konvertieren, da 1.000 in verschiedenen Sprachen unterschiedlich dargestellt wird.</param>
        <summary>Ändert den Typ des angegebenen <see langword="Object" /> in den angegebenen <see langword="Type" />.</summary>
        <returns>Ein Objekt, das den gegebenen Wert als neuen Typ enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reflektion modelliert die Zugriffsregeln des allgemeinen Typsystems. Wenn der Aufrufer in der gleichen Assembly ist, wird z. B. spezielle Berechtigungen von der Aufrufer nicht für interne Member benötigt. Andernfalls, benötigt der Aufrufer <xref:System.Security.Permissions.ReflectionPermission>. Dies ist konsistent mit der Suche nach Membern, die geschützt werden, private und so weiter.  
  
 Im Allgemeinen gilt, die `ChangeType` nur Erweiterungsumwandlungen keine Daten verloren gehen durchführen sollte. Ein Beispiel für eine erweiternde Konvertierung ist eine Umwandlung, die eine 32-Bit-Ganzzahl mit Vorzeichen in einen Wert, der eine 64-Bit-Ganzzahl mit Vorzeichen ist. Dies ist über eine einschränkende Konvertierung, unterschieden, die Daten verloren gehen können. Ein Beispiel für eine einschränkende Konvertierung ist eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen Koersion.  
  
 In der folgende Tabelle werden die Umwandlungen aufgelistet, die ausgeführt werden, die standardmäßig `ChangeType`.  
  
|Quelltyp|Zieltyp|  
|-----------------|-----------------|  
|Beliebiger Typ|Basistyp.|  
|Beliebiger Typ|Die Schnittstelle, die er implementiert.|  
|Char|UInt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Ohne Verweis|Per-Verweis.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReorderArgumentArray">
      <MemberSignature Language="C#" Value="public abstract void ReorderArgumentArray (ref object[] args, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReorderArgumentArray(object[]&amp; args, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ReorderArgumentArray (ByRef args As Object(), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ReorderArgumentArray(cli::array &lt;System::Object ^&gt; ^ % args, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member ReorderArgumentArray :  * obj -&gt; unit" Usage="binder.ReorderArgumentArray (args, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" RefType="ref" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="args">Die übergebenen tatsächlichen Argumente. Sowohl die Typen als auch die Werte der Argumente können geändert werden.</param>
        <param name="state">Ein vom Binder bereitgestelltes Objekt, das die Neuanordnung von Argumenten verfolgt.</param>
        <summary>Stellt nach dem Beenden der <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />-Methode das <paramref name="args" />-Argument in der Form wieder her, wie es von der <see langword="BindToMethod" />-Methode übergeben wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die common Language Runtime ruft diese Methode auf, wenn `state` nicht `null` nach einer Rückgabe von `BindToMethod`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase SelectMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase SelectMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SelectMethod (bindingAttr As BindingFlags, match As MethodBase(), types As Type(), modifiers As ParameterModifier()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodBase ^ SelectMethod(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::MethodBase ^&gt; ^ match, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member SelectMethod : System.Reflection.BindingFlags * System.Reflection.MethodBase[] * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodBase" Usage="binder.SelectMethod (bindingAttr, match, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination von <see cref="T:System.Reflection.BindingFlags" />-Werten.</param>
        <param name="match">Die Reihe der Methoden, die Kandidaten für Übereinstimmungen sind. Wenn beispielsweise ein <see cref="T:System.Reflection.Binder" />-Objekt von <see cref="Overload:System.Type.InvokeMember" /> verwendet wird, gibt dieser Parameter die Reihe von Methoden an, die von der Reflektion als mögliche Übereinstimmungen bestimmt wurden, typischerweise weil sie den entsprechenden Membernamen aufweisen. Die von <see cref="P:System.Type.DefaultBinder" /> bereitgestellte Standardimplementierung ändert die Reihenfolge dieses Arrays.</param>
        <param name="types">Die Parametertypen, mit denen nach einer übereinstimmenden Methode gesucht wird.</param>
        <param name="modifiers">Ein Array von Parametermodifizierern, die bei Bindungen die Verwendung von Parametersignaturen ermöglichen, in denen die Typen geändert wurden.</param>
        <summary>Wählt anhand des Argumenttyps eine Methode aus der angegebenen Gruppe von Methoden aus.</summary>
        <returns>Die entsprechende Methode, sofern eine solche gefunden wurde, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte zurückgeben `null` Wenn keine Methode mit die Kriterien entspricht. Diese Methode steuert, die von bereitgestellte Auswahl der `GetConstructor` und `GetMethod` Methoden `Type`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Für den Standardbinder enthält <paramref name="match" /> mehrere Methoden, die gleichwertige Übereinstimmungen für die von <paramref name="types" /> beschriebenen Parametertypen darstellen. Das Array in <paramref name="types" /> enthält beispielsweise ein <see cref="T:System.Type" />-Objekt für <c>MyClass</c>, und das Array in <paramref name="match" /> enthält eine Methode, die eine Basisklasse von <c>MyClass</c> annimmt, sowie eine Methode, die eine von <c>MyClass</c> implementierte Schnittstelle annimmt.</exception>
        <exception cref="T:System.ArgumentException">Für den Standardbinder ist <paramref name="match" /> gleich <see langword="null" /> oder ein leeres Array.  
  
- oder - 
Ein Element von <paramref name="types" /> ist von <see cref="T:System.Type" /> abgeleitet, weist jedoch nicht den Typ <see langword="RuntimeType" /> auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectProperty">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo SelectProperty (System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, Type returnType, Type[] indexes, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo SelectProperty(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.PropertyInfo[] match, class System.Type returnType, class System.Type[] indexes, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SelectProperty (bindingAttr As BindingFlags, match As PropertyInfo(), returnType As Type, indexes As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::PropertyInfo ^ SelectProperty(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ match, Type ^ returnType, cli::array &lt;Type ^&gt; ^ indexes, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member SelectProperty : System.Reflection.BindingFlags * System.Reflection.PropertyInfo[] * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="binder.SelectProperty (bindingAttr, match, returnType, indexes, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.PropertyInfo[]" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="indexes" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination von <see cref="T:System.Reflection.BindingFlags" />-Werten.</param>
        <param name="match">Die Reihe der Eigenschaften, die Kandidaten für Übereinstimmungen sind. Wenn beispielsweise ein <see cref="T:System.Reflection.Binder" />-Objekt von <see cref="Overload:System.Type.InvokeMember" /> verwendet wird, gibt dieser Parameter die Reihe von Eigenschaften an, die von der Reflektion als mögliche Übereinstimmungen bestimmt wurden, typischerweise weil sie den entsprechenden Membernamen aufweisen. Die von <see cref="P:System.Type.DefaultBinder" /> bereitgestellte Standardimplementierung ändert die Reihenfolge dieses Arrays.</param>
        <param name="returnType">Der Rückgabewert, den die übereinstimmende Eigenschaft aufweisen muss.</param>
        <param name="indexes">Die Indextypen der gesuchten Eigenschaft. Wird für Indexeigenschaften verwendet, z. B. den Indexer für eine Klasse.</param>
        <param name="modifiers">Ein Array von Parametermodifizierern, die bei Bindungen die Verwendung von Parametersignaturen ermöglichen, in denen die Typen geändert wurden.</param>
        <summary>Wählt anhand der angegebenen Kriterien eine Eigenschaft aus der angegebenen Gruppe von Eigenschaften aus.</summary>
        <returns>Die entsprechende Eigenschaft.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode steuert, die von bereitgestellte Auswahl der `GetProperty` Methode `Type`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Für den Standardbinder enthält <paramref name="match" /> mehrere Eigenschaften, die gleichwertige Übereinstimmungen für <paramref name="returnType" /> und <paramref name="indexes" /> darstellen.</exception>
        <exception cref="T:System.ArgumentException">Für den Standardbinder ist <paramref name="match" /> gleich <see langword="null" /> oder ein leeres Array.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
      </Docs>
    </Member>
  </Members>
</Type>