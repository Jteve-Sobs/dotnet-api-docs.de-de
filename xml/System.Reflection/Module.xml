<Type Name="Module" FullName="System.Reflection.Module">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="88e4476d5ef058db442104a6de9cd62319cef64d" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37640670" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Module, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Module extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Module, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Module" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Module&#xA;Implements _Module, ICustomAttributeProvider, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Module abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Module, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Module = class&#xA;    interface ISerializable&#xA;    interface ICustomAttributeProvider&#xA;    interface _Module" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Module</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Module))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="defe3-101">Performs reflection on a module.</span>
      <span class="sxs-lookup">
        <span data-stu-id="defe3-101">Performs reflection on a module.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-102">Ein Modul ist eine portierbare ausführbare Datei, beispielsweise type.dll oder application.exe, bestehend aus einem oder mehreren Klassen und Schnittstellen.</span><span class="sxs-lookup"><span data-stu-id="defe3-102">A module is a portable executable file, such as type.dll or application.exe, consisting of one or more classes and interfaces.</span></span> <span data-ttu-id="defe3-103">Ein einzelnes Modul kann mehrere Namespaces enthalten, und ein Namespace kann mehrere Module umfassen.</span><span class="sxs-lookup"><span data-stu-id="defe3-103">There may be multiple namespaces contained in a single module, and a namespace may span multiple modules.</span></span>  
  
 <span data-ttu-id="defe3-104">Wenn ein Modul oder mehrere Module als Einheit bereitgestellt werden, bilden sie eine Assembly.</span><span class="sxs-lookup"><span data-stu-id="defe3-104">One or more modules deployed as a unit compose an assembly.</span></span> <span data-ttu-id="defe3-105">Informationen zum Erstellen einer Assembly mit mehr als einem Modul finden Sie unter [Multifile Assemblys](~/docs/framework/app-domains/multifile-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="defe3-105">For information about creating an assembly with more than one module, see [Multifile Assemblies](~/docs/framework/app-domains/multifile-assemblies.md).</span></span>  
  
 <span data-ttu-id="defe3-106">Beachten Sie, dass ein .NET Framework-Modul nicht als Modul in Visual Basic ist die mit dem Programmierer zum Organisieren von Funktionen und Unterroutinen in einer Anwendung verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="defe3-106">Note that a .NET Framework module is not the same as a module in Visual Basic, which is used by a programmers to organize functions and subroutines in an application.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="defe3-107">Der folgende Code veranschaulicht, wie Sie mithilfe der Reflektion zum Abrufen von Informationen zu Modulen:</span><span class="sxs-lookup"><span data-stu-id="defe3-107">The following code examples show how to use reflection to get information about modules:</span></span>  
  
 [!code-csharp[System.Reflection.Module#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module/CS/source.cs#1)]
 [!code-vb[System.Reflection.Module#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="defe3-108">für volle Vertrauenswürdigkeit für erben.</span>
      <span class="sxs-lookup">
        <span data-stu-id="defe3-108">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="defe3-109">Diese Klasse kann nicht von teilweise vertrauenswürdigem Code nicht geerbt werden.</span>
      <span class="sxs-lookup">
        <span data-stu-id="defe3-109">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Module ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Module();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="defe3-110">Initializes a new instance of the <see cref="T:System.Reflection.Module" /> class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-110">Initializes a new instance of the <see cref="T:System.Reflection.Module" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-111">Dieser Konstruktor wird von abgeleiteten Klassen aufgerufen, während der Erstellung der <xref:System.Reflection.Module> Objekte.</span><span class="sxs-lookup"><span data-stu-id="defe3-111">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Module> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Module.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-112">Gets the appropriate <see cref="T:System.Reflection.Assembly" /> for this instance of <see cref="T:System.Reflection.Module" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-112">Gets the appropriate <see cref="T:System.Reflection.Assembly" /> for this instance of <see cref="T:System.Reflection.Module" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="defe3-113">Ein <see langword="Assembly" />-Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-113">An <see langword="Assembly" /> object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="defe3-114">Das folgende Beispiel zeigt den vollständigen Namen der angegebenen Assembly in das angegebene Modul an.</span><span class="sxs-lookup"><span data-stu-id="defe3-114">The following example displays the full name of the specified assembly in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.Assembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Module.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-115">Gets a collection that contains this module's custom attributes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-115">Gets a collection that contains this module's custom attributes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="defe3-116">Eine Auflistung, die benutzerdefinierten Attribute dieses Moduls enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-116">A collection that contains this module's custom attributes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="module.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="defe3-117">The object to compare with this instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-117">The object to compare with this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-118">Determines whether this module and the specified object are equal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-118">Determines whether this module and the specified object are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-119">
            <see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-119">
              <see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTypeName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeName" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeName As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterTypeName : System.Reflection.TypeFilter" Usage="System.Reflection.Module.FilterTypeName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-120">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-120">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span>
          </span>
          <span data-ttu-id="defe3-121">This field is case-sensitive and read-only.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-121">This field is case-sensitive and read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-122">Der Filter unterstützt kein nachfolgendes Zeichen "\*" Platzhalter.</span><span class="sxs-lookup"><span data-stu-id="defe3-122">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="defe3-123">Das folgende Beispiel zeigt die Modulnamen, die die angegebenen Suchkriterien entsprechen.</span><span class="sxs-lookup"><span data-stu-id="defe3-123">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FilterTypeNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeNameIgnoreCase As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterTypeNameIgnoreCase : System.Reflection.TypeFilter" Usage="System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-124">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-124">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span>
          </span>
          <span data-ttu-id="defe3-125">This field is case-insensitive and read-only.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-125">This field is case-insensitive and read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-126">Der Filter unterstützt kein nachfolgendes Zeichen "\*" Platzhalter.</span><span class="sxs-lookup"><span data-stu-id="defe3-126">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="defe3-127">Das folgende Beispiel zeigt die Modulnamen, die mit die angegebenen Suchkriterien entsprechen, ignorieren die Groß-/Kleinschreibung übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="defe3-127">The following example displays the module names that match the specified search criteria, ignoring the case.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] FindTypes (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindTypes(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindTypes (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindTypes(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindTypes : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindTypes : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="module.FindTypes (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">
          <span data-ttu-id="defe3-128">The delegate used to filter the classes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-128">The delegate used to filter the classes.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="defe3-129">An Object used to filter the classes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-129">An Object used to filter the classes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-130">Returns an array of classes accepted by the given filter and filter criteria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-130">Returns an array of classes accepted by the given filter and filter criteria.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-131">An array of type <see langword="Type" /> containing classes that were accepted by the filter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-131">An array of type <see langword="Type" /> containing classes that were accepted by the filter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-132"><xref:System.Reflection.ReflectionTypeLoadException> ist eine spezielle Klasse Load-Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="defe3-132"><xref:System.Reflection.ReflectionTypeLoadException> is a special class load exception.</span></span> <span data-ttu-id="defe3-133">Die `ReflectionTypeLoadException.Types` -Eigenschaft enthält das Array von Klassen, die im Modul definiert und geladen wurden.</span><span class="sxs-lookup"><span data-stu-id="defe3-133">The `ReflectionTypeLoadException.Types` property contains the array of classes that were defined in the module and were loaded.</span></span> <span data-ttu-id="defe3-134">Dieses Array kann einige null-Werte enthalten.</span><span class="sxs-lookup"><span data-stu-id="defe3-134">This array may contain some null values.</span></span> <span data-ttu-id="defe3-135">Die `ReflectionTypeLoadException.LoaderExceptions` -Eigenschaft ist ein Array von Ausnahmen, die Ausnahmen darstellen, die vom Klassenladeprogramm ausgelöst wurden.</span><span class="sxs-lookup"><span data-stu-id="defe3-135">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the class loader.</span></span> <span data-ttu-id="defe3-136">Die Lücken in der Klasse-Array entsprechen den Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="defe3-136">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="defe3-137">Der Delegat, der vom `filter` wird aufgerufen, für jede Klasse in das Modul übergeben die `Type` Objekt, das die Klasse darstellt, sowie die angegebenen `filterCriteria`.</span><span class="sxs-lookup"><span data-stu-id="defe3-137">The delegate given by `filter` is called for each class in the module, passing along the `Type` object representing the class as well as the given `filterCriteria`.</span></span> <span data-ttu-id="defe3-138">Wenn `filter` gibt eine bestimmte Klasse ",", Klasse in das zurückgegebene Array eingeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="defe3-138">If `filter` returns a particular class, that class will be included in the returned array.</span></span> <span data-ttu-id="defe3-139">Wenn `filter` gibt `null`, alle Klassen zurückgegeben und `filterCriteria` wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="defe3-139">If `filter` returns `null`, all classes are returned and `filterCriteria` is ignored.</span></span>  
  
 <span data-ttu-id="defe3-140">`FindTypes` kann nicht verwendet werden, um parametrisierte Typen wie Arrays zu suchen.</span><span class="sxs-lookup"><span data-stu-id="defe3-140">`FindTypes` cannot be used to look up parameterized types such as arrays.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="defe3-141">Das folgende Beispiel veranschaulicht die `FindTypes` Methode.</span><span class="sxs-lookup"><span data-stu-id="defe3-141">The following example demonstrates the `FindTypes` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">
          <span data-ttu-id="defe3-142">One or more classes in a module could not be loaded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-142">One or more classes in a module could not be loaded.</span>
          </span>
        </exception>
        <altmember cref="F:System.Reflection.Module.FilterTypeName" />
        <altmember cref="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public virtual string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.FullyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullyQualifiedName : string" Usage="System.Reflection.Module.FullyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-143">Gets a string representing the fully qualified name and path to this module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-143">Gets a string representing the fully qualified name and path to this module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="defe3-144">Der vollqualifizierte Modulname.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-144">The fully qualified module name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-145">Verwenden Sie zum Abrufen der Namen ohne die Pfadangabe <xref:System.Reflection.Module.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="defe3-145">To get the name without the path, use <xref:System.Reflection.Module.Name%2A>.</span></span>  
  
 <span data-ttu-id="defe3-146">Wenn die Assembly für dieses Modul aus einem Bytearray geladen wurde und dann die `FullyQualifiedName` für das Modul: \<unbekannt >.</span><span class="sxs-lookup"><span data-stu-id="defe3-146">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="defe3-147">Im Fall von Modulname ist plattformabhängig.</span><span class="sxs-lookup"><span data-stu-id="defe3-147">The case of module name is platform-dependent.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="defe3-148">Das folgende Beispiel zeigt den vollqualifizierten Namen des angegebenen Moduls.</span><span class="sxs-lookup"><span data-stu-id="defe3-148">The following example displays the fully qualified name of the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="defe3-149">The caller does not have the required permissions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-149">The caller does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="defe3-150">für den Zugriff auf Informationen im Pfad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-150">for access to information in the path.</span>
          </span>
          <span data-ttu-id="defe3-151">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-151">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-152">Returns custom attributes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-152">Returns custom attributes.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="module.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <span data-ttu-id="defe3-153">This argument is ignored for objects of this type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-153">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-154">Returns all custom attributes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-154">Returns all custom attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-155">An array of type <see langword="Object" /> containing all custom attributes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-155">An array of type <see langword="Object" /> containing all custom attributes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="defe3-156">Das folgende Beispiel zeigt die Modulnamen, die die angegebenen Suchkriterien entsprechen.</span><span class="sxs-lookup"><span data-stu-id="defe3-156">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="module.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="defe3-157">The type of attribute to get.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-157">The type of attribute to get.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="defe3-158">This argument is ignored for objects of this type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-158">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-159">Gets custom attributes of the specified type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-159">Gets custom attributes of the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-160">An array of type <see langword="Object" /> containing all custom attributes of the specified type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-160">An array of type <see langword="Object" /> containing all custom attributes of the specified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="defe3-161">Das folgende Beispiel zeigt die Modulnamen des angegebenen Typs, die die angegebenen Suchkriterien entsprechen.</span><span class="sxs-lookup"><span data-stu-id="defe3-161">The following example displays the module names of the specified type that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="defe3-162">
            <paramref name="attributeType" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-162">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-163">
            <paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-163">
              <paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span>
          </span>
          <span data-ttu-id="defe3-164">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-164">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="module.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="defe3-165">Returns a list of <see cref="T:System.Reflection.CustomAttributeData" /> objects for the current module, which can be used in the reflection-only context.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-165">Returns a list of <see cref="T:System.Reflection.CustomAttributeData" /> objects for the current module, which can be used in the reflection-only context.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-166">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-166">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current module.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-167">Verwenden Sie diese Methode, um die benutzerdefinierten Attribute des Codes in den ReflectionOnly Kontext, in Fällen zu untersuchen, in dem die benutzerdefinierten Attribute selbst im Code definiert werden, die in den ReflectionOnly-Kontext geladen wird.</span><span class="sxs-lookup"><span data-stu-id="defe3-167">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="defe3-168">Methoden, z. B. <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> und <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> kann nicht in diesen Fällen verwendet werden, da sie Instanzen der Attribute erstellen.</span><span class="sxs-lookup"><span data-stu-id="defe3-168">Methods such as <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="defe3-169">Code in den ReflectionOnly Kontext kann nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="defe3-169">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="defe3-170">Weitere Informationen und Beispielcode finden Sie in der <xref:System.Reflection.CustomAttributeData> Klasse.</span><span class="sxs-lookup"><span data-stu-id="defe3-170">For more information and example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-171">Returns a specified field.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-171">Returns a specified field.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="module.GetField name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="defe3-172">The field name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-172">The field name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-173">Returns a field having the specified name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-173">Returns a field having the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-174">A <see langword="FieldInfo" /> object having the specified name, or <see langword="null" /> if the field does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-174">A <see langword="FieldInfo" /> object having the specified name, or <see langword="null" /> if the field does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="defe3-175">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-175">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="module.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="defe3-176">The field name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-176">The field name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="defe3-177">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-177">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-178">Returns a field having the specified name and binding attributes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-178">Returns a field having the specified name and binding attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-179">A <see langword="FieldInfo" /> object having the specified name and binding attributes, or <see langword="null" /> if the field does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-179">A <see langword="FieldInfo" /> object having the specified name and binding attributes, or <see langword="null" /> if the field does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="defe3-180">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-180">The <paramref name="name" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-181">Returns the global fields defined on the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-181">Returns the global fields defined on the module.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="member this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="module.GetFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="defe3-182">Returns the global fields defined on the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-182">Returns the global fields defined on the module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-183">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the global fields defined on the module; if there are no global fields, an empty array is returned.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-183">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the global fields defined on the module; if there are no global fields, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-184">Die <xref:System.Reflection.Module.GetFields%2A> Methode nicht zurückgegeben Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="defe3-184">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="defe3-185">Ihr Code muss nicht von der Reihenfolge, in der Felder zurückgegeben werden, abhängen, da diese Reihenfolge abweichen kann.</span><span class="sxs-lookup"><span data-stu-id="defe3-185">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="module.GetFields bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">
          <span data-ttu-id="defe3-186">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-186">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-187">Returns the global fields defined on the module that match the specified binding flags.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-187">Returns the global fields defined on the module that match the specified binding flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-188">An array of type <see cref="T:System.Reflection.FieldInfo" /> representing the global fields defined on the module that match the specified binding flags; if no global fields match the binding flags, an empty array is returned.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-188">An array of type <see cref="T:System.Reflection.FieldInfo" /> representing the global fields defined on the module that match the specified binding flags; if no global fields match the binding flags, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-189">Die <xref:System.Reflection.Module.GetFields%2A> Methode nicht zurückgegeben Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="defe3-189">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="defe3-190">Ihr Code muss nicht von der Reihenfolge, in der Felder zurückgegeben werden, abhängen, da diese Reihenfolge abweichen kann.</span><span class="sxs-lookup"><span data-stu-id="defe3-190">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="module.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="defe3-191">Returns the hash code for this instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-191">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-192">A 32-bit signed integer hash code.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-192">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-193">Returns a method having the specified criteria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-193">Returns a method having the specified criteria.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="module.GetMethod name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="defe3-194">The method name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-194">The method name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-195">Returns a method having the specified name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-195">Returns a method having the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-196">A <see langword="MethodInfo" /> object having the specified name, or <see langword="null" /> if the method does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-196">A <see langword="MethodInfo" /> object having the specified name, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="defe3-197">
            <paramref name="name" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-197">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="module.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="defe3-198">The method name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-198">The method name.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="defe3-199">The parameter types to search for.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-199">The parameter types to search for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-200">Returns a method having the specified name and parameter types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-200">Returns a method having the specified name and parameter types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-201">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-201">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="defe3-202">
            <paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-202">
              <paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="module.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="defe3-203">The method name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-203">The method name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="defe3-204">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-204">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="defe3-205">An object that implements <see langword="Binder" />, containing properties related to this method.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-205">An object that implements <see langword="Binder" />, containing properties related to this method.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="defe3-206">The calling convention for the method.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-206">The calling convention for the method.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="defe3-207">The parameter types to search for.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-207">The parameter types to search for.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="defe3-208">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-208">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-209">Returns a method having the specified name, binding information, calling convention, and parameter types and modifiers.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-209">Returns a method having the specified name, binding information, calling convention, and parameter types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-210">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-210">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="defe3-211">
            <paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-211">
              <paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="module.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="defe3-212">The method name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-212">The method name.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="defe3-213">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-213">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="defe3-214">An object that implements <see langword="Binder" />, containing properties related to this method.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-214">An object that implements <see langword="Binder" />, containing properties related to this method.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="defe3-215">The calling convention for the method.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-215">The calling convention for the method.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="defe3-216">The parameter types to search for.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-216">The parameter types to search for.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="defe3-217">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-217">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-218">Returns the method implementation in accordance with the specified criteria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-218">Returns the method implementation in accordance with the specified criteria.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-219">A <see langword="MethodInfo" /> object containing implementation information as specified, or <see langword="null" /> if the method does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-219">A <see langword="MethodInfo" /> object containing implementation information as specified, or <see langword="null" /> if the method does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="defe3-220">
            <paramref name="types" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-220">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-221">Returns the global methods defined on the module</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-221">Returns the global methods defined on the module</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="member this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="module.GetMethods " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="defe3-222">Returns the global methods defined on the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-222">Returns the global methods defined on the module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-223">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the global methods defined on the module; if there are no global methods, an empty array is returned.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-223">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the global methods defined on the module; if there are no global methods, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="module.GetMethods bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">
          <span data-ttu-id="defe3-224">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-224">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-225">Returns the global methods defined on the module that match the specified binding flags.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-225">Returns the global methods defined on the module that match the specified binding flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-226">An array of type <see cref="T:System.Reflection.MethodInfo" /> representing the global methods defined on the module that match the specified binding flags; if no global methods match the binding flags, an empty array is returned.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-226">An array of type <see cref="T:System.Reflection.MethodInfo" /> representing the global methods defined on the module that match the specified binding flags; if no global methods match the binding flags, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="module.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="defe3-227">The information and data needed to serialize or deserialize an object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-227">The information and data needed to serialize or deserialize an object.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="defe3-228">The context for the serialization.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-228">The context for the serialization.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-229">Provides an <see cref="T:System.Runtime.Serialization.ISerializable" /> implementation for serialized objects.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-229">Provides an <see cref="T:System.Runtime.Serialization.ISerializable" /> implementation for serialized objects.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="defe3-230">
            <paramref name="info" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-230">
              <paramref name="info" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="defe3-231">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-231">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="defe3-232">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-232">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public virtual void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetPEKind (ByRef peKind As PortableExecutableKinds, ByRef machine As ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetPEKind([Runtime::InteropServices::Out] System::Reflection::PortableExecutableKinds % peKind, [Runtime::InteropServices::Out] System::Reflection::ImageFileMachine % machine);" />
      <MemberSignature Language="F#" Value="abstract member GetPEKind :  *  -&gt; unit&#xA;override this.GetPEKind :  *  -&gt; unit" Usage="module.GetPEKind (peKind, machine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds&amp;" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">
          <span data-ttu-id="defe3-233">When this method returns, a combination of the <see cref="T:System.Reflection.PortableExecutableKinds" /> values indicating the nature of the code in the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-233">When this method returns, a combination of the <see cref="T:System.Reflection.PortableExecutableKinds" /> values indicating the nature of the code in the module.</span>
          </span>
        </param>
        <param name="machine">
          <span data-ttu-id="defe3-234">When this method returns, one of the <see cref="T:System.Reflection.ImageFileMachine" /> values indicating the platform targeted by the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-234">When this method returns, one of the <see cref="T:System.Reflection.ImageFileMachine" /> values indicating the platform targeted by the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-235">Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-235">Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSignerCertificate () As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::X509Certificates::X509Certificate ^ GetSignerCertificate();" />
      <MemberSignature Language="F#" Value="abstract member GetSignerCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate&#xA;override this.GetSignerCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate" Usage="module.GetSignerCertificate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="defe3-236">Returns an <see langword="X509Certificate" /> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-236">Returns an <see langword="X509Certificate" /> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</span>
          </span>
          <span data-ttu-id="defe3-237">If the assembly has not been Authenticode signed, <see langword="null" /> is returned.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-237">If the assembly has not been Authenticode signed, <see langword="null" /> is returned.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-238">An <see langword="X509Certificate" /> object, or <see langword="null" /> if the assembly to which this module belongs has not been Authenticode signed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-238">An <see langword="X509Certificate" /> object, or <see langword="null" /> if the assembly to which this module belongs has not been Authenticode signed.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-239">Returns the specified type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-239">Returns the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="module.GetType className" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">
          <span data-ttu-id="defe3-240">The name of the type to locate.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-240">The name of the type to locate.</span>
          </span>
          <span data-ttu-id="defe3-241">The name must be fully qualified with the namespace.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-241">The name must be fully qualified with the namespace.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-242">Returns the specified type, performing a case-sensitive search.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-242">Returns the specified type, performing a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-243">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-243">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="defe3-244">Wenn der Typ in eine andere Assembly weitergeleitet wurde, wird er weiterhin von dieser Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="defe3-244">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="defe3-245">Informationen zum Weiterleiten von Typen finden Sie unter [Typweiterleitung in der Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="defe3-245">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="defe3-246">Ein Typ abgerufen werden kann, von einem bestimmten Modul über <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="defe3-246">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="defe3-247">Aufrufen von <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> für das Modul mit dem Manifest wird nicht durchsucht die gesamte Assembly.</span><span class="sxs-lookup"><span data-stu-id="defe3-247">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="defe3-248">Zum Abrufen eines Typs aus einer Assembly, unabhängig davon, welches Modul ist, rufen Sie <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="defe3-248">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="defe3-249">Das folgende Beispiel zeigt den Namen eines Typs im angegebenen Modul an.</span><span class="sxs-lookup"><span data-stu-id="defe3-249">The following example displays the name of a type in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="defe3-250">
            <paramref name="className" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-250">
              <paramref name="className" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="defe3-251">The class initializers are invoked and an exception is thrown.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-251">The class initializers are invoked and an exception is thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-252">
            <paramref name="className" /> is a zero-length string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-252">
              <paramref name="className" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="defe3-253">
            <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-253">
              <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="defe3-254">
            <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-254">
              <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="defe3-255">-or-  The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-255">-or-  The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="defe3-256">
            <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-256">
              <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="defe3-257">-or-  <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-257">-or-  <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="module.GetType (className, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">
          <span data-ttu-id="defe3-258">The name of the type to locate.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-258">The name of the type to locate.</span>
          </span>
          <span data-ttu-id="defe3-259">The name must be fully qualified with the namespace.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-259">The name must be fully qualified with the namespace.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="defe3-260">
            <see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-260">
              <see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-261">Returns the specified type, searching the module with the specified case sensitivity.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-261">Returns the specified type, searching the module with the specified case sensitivity.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-262">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-262">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="defe3-263">Wenn der Typ in eine andere Assembly weitergeleitet wurde, wird er weiterhin von dieser Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="defe3-263">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="defe3-264">Informationen zum Weiterleiten von Typen finden Sie unter [Typweiterleitung in der Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="defe3-264">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="defe3-265">Ein Typ abgerufen werden kann, von einem bestimmten Modul über <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="defe3-265">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="defe3-266">Aufrufen von <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> für das Modul mit dem Manifest wird nicht durchsucht die gesamte Assembly.</span><span class="sxs-lookup"><span data-stu-id="defe3-266">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="defe3-267">Zum Abrufen eines Typs aus einer Assembly, unabhängig davon, welches Modul ist, rufen Sie <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="defe3-267">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="defe3-268">Das folgende Beispiel zeigt den Namen eines Typs im angegebenen Modul angeben `false` für die `ignoreCase` an, damit dieser Fall nicht ignoriert wird.</span><span class="sxs-lookup"><span data-stu-id="defe3-268">The following example displays the name of a type in the specified module, specifying `false` for the `ignoreCase` parameter so that case will not be ignored.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="defe3-269">
            <paramref name="className" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-269">
              <paramref name="className" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="defe3-270">The class initializers are invoked and an exception is thrown.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-270">The class initializers are invoked and an exception is thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-271">
            <paramref name="className" /> is a zero-length string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-271">
              <paramref name="className" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="defe3-272">
            <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-272">
              <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="defe3-273">
            <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-273">
              <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="defe3-274">-or-  The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-274">-or-  The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="defe3-275">
            <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-275">
              <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="defe3-276">-or-  <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-276">-or-  <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="module.GetType (className, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">
          <span data-ttu-id="defe3-277">The name of the type to locate.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-277">The name of the type to locate.</span>
          </span>
          <span data-ttu-id="defe3-278">The name must be fully qualified with the namespace.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-278">The name must be fully qualified with the namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="defe3-279">
            <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-279">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="defe3-280">
            <see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-280">
              <see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-281">Returns the specified type, specifying whether to make a case-sensitive search of the module and whether to throw an exception if the type cannot be found.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-281">Returns the specified type, specifying whether to make a case-sensitive search of the module and whether to throw an exception if the type cannot be found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-282">A <see cref="T:System.Type" /> object representing the specified type, if the type is declared in this module; otherwise, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-282">A <see cref="T:System.Type" /> object representing the specified type, if the type is declared in this module; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-283">Die `throwOnError` Parameter wirkt sich auf nur was geschieht, wenn der Typ nicht gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="defe3-283">The `throwOnError` parameter affects only what happens when the type is not found.</span></span> <span data-ttu-id="defe3-284">Es hat keine Auswirkungen auf andere Ausnahmen, die ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="defe3-284">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="defe3-285">Insbesondere, wenn der Typ befindet sich aber nicht geladen werden <xref:System.TypeLoadException> kann ausgelöst werden, auch wenn `throwOnError` ist `false`.</span><span class="sxs-lookup"><span data-stu-id="defe3-285">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="defe3-286">Wenn der Typ in eine andere Assembly weitergeleitet wurde, wird er weiterhin von dieser Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="defe3-286">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="defe3-287">Informationen zum Weiterleiten von Typen finden Sie unter [Typweiterleitung in der Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="defe3-287">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="defe3-288">Ein Typ abgerufen werden kann, von einem bestimmten Modul über <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="defe3-288">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="defe3-289">Aufrufen von <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> für das Modul mit dem Manifest wird nicht durchsucht die gesamte Assembly.</span><span class="sxs-lookup"><span data-stu-id="defe3-289">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="defe3-290">Zum Abrufen eines Typs aus einer Assembly, unabhängig davon, welches Modul ist, rufen Sie <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="defe3-290">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="defe3-291">Das folgende Beispiel zeigt den Namen eines Typs im angegebenen Modul an.</span><span class="sxs-lookup"><span data-stu-id="defe3-291">The following example displays the name of a type in the specified module.</span></span> <span data-ttu-id="defe3-292">Die `throwOnError` und `ignoreCase` als Parameter angegeben sind `false`.</span><span class="sxs-lookup"><span data-stu-id="defe3-292">The `throwOnError` and `ignoreCase` parameters are specified as `false`.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="defe3-293">
            <paramref name="className" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-293">
              <paramref name="className" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="defe3-294">The class initializers are invoked and an exception is thrown.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-294">The class initializers are invoked and an exception is thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-295">
            <paramref name="className" /> is a zero-length string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-295">
              <paramref name="className" /> is a zero-length string.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="defe3-296">
            <paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-296">
              <paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="defe3-297">
            <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-297">
              <paramref name="className" /> requires a dependent assembly that could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="defe3-298">
            <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-298">
              <paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span>
          </span>
          <span data-ttu-id="defe3-299">-or-  The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-299">-or-  The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="defe3-300">
            <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-300">
              <paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span>
          </span>
          <span data-ttu-id="defe3-301">-or-  <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-301">-or-  <paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="module.GetTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="defe3-302">Returns all the types defined within this module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-302">Returns all the types defined within this module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-303">An array of type <see langword="Type" /> containing types defined within the module that is reflected by this instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-303">An array of type <see langword="Type" /> containing types defined within the module that is reflected by this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-304">`ReflectionTypeLoadException` ist eine besondere Ausnahme beim Laden.</span><span class="sxs-lookup"><span data-stu-id="defe3-304">`ReflectionTypeLoadException` is a special load exception.</span></span> <span data-ttu-id="defe3-305">Die `ReflectionTypeLoadException.Types` -Eigenschaft enthält das Array von Typen, die im Modul definiert und geladen wurden.</span><span class="sxs-lookup"><span data-stu-id="defe3-305">The `ReflectionTypeLoadException.Types` property contains the array of types that were defined in the module and were loaded.</span></span> <span data-ttu-id="defe3-306">Dieses Array kann einige null-Werte enthalten.</span><span class="sxs-lookup"><span data-stu-id="defe3-306">This array may contain some null values.</span></span> <span data-ttu-id="defe3-307">Die `ReflectionTypeLoadException.LoaderExceptions` -Eigenschaft ist ein Array von Ausnahmen, die Ausnahmen darstellen, die vom Ladeprogramm ausgelöst wurden.</span><span class="sxs-lookup"><span data-stu-id="defe3-307">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the loader.</span></span> <span data-ttu-id="defe3-308">Die Lücken in der Klasse-Array entsprechen den Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="defe3-308">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="defe3-309">Z. B. wenn eine der Klassen der Klasseninitialisierer löst eine Ausnahme bei der es geladen wird, eine `TargetInvocationException` befindet sich in das entsprechende Element von der `LoaderExceptions` Array.</span><span class="sxs-lookup"><span data-stu-id="defe3-309">For example, if the class initializers of one of the classes throws an exception while it is being loaded, a `TargetInvocationException` is stored in the corresponding element of the `LoaderExceptions` array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="defe3-310">Wenn ein Typ in eine andere Assembly weitergeleitet wurde, ist es nicht im zurückgegebenen Array enthalten.</span><span class="sxs-lookup"><span data-stu-id="defe3-310">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="defe3-311">Informationen zum Weiterleiten von Typen finden Sie unter [Typweiterleitung in der Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="defe3-311">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">
          <span data-ttu-id="defe3-312">One or more classes in a module could not be loaded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-312">One or more classes in a module could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="defe3-313">The caller does not have the required permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-313">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="defe3-314">Reflection-Berechtigung für das aktuelle Modul.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-314">Reflection permission for the current module.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="module.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="defe3-315">The type of custom attribute to test for.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-315">The type of custom attribute to test for.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="defe3-316">This argument is ignored for objects of this type.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-316">This argument is ignored for objects of this type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-317">Returns a value that indicates whether the specified attribute type has been applied to this module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-317">Returns a value that indicates whether the specified attribute type has been applied to this module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-318">
            <see langword="true" /> if one or more instances of <paramref name="attributeType" /> have been applied to this module; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-318">
              <see langword="true" /> if one or more instances of <paramref name="attributeType" /> have been applied to this module; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="defe3-319">Das folgende Beispiel veranschaulicht die Verwendung des der `IsDefined` Methode.</span><span class="sxs-lookup"><span data-stu-id="defe3-319">The following example demonstrates a use of the `IsDefined` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="defe3-320">
            <paramref name="attributeType" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-320">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-321">
            <paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-321">
              <paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span>
          </span>
          <span data-ttu-id="defe3-322">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-322">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public virtual bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsResource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsResource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsResource();" />
      <MemberSignature Language="F#" Value="abstract member IsResource : unit -&gt; bool&#xA;override this.IsResource : unit -&gt; bool" Usage="module.IsResource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="defe3-323">Gets a value indicating whether the object is a resource.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-323">Gets a value indicating whether the object is a resource.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-324">
            <see langword="true" /> if the object is a resource; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-324">
              <see langword="true" /> if the object is a resource; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="defe3-325">Das folgende Beispiel veranschaulicht die Verwendung des der `IsResource` Methode.</span><span class="sxs-lookup"><span data-stu-id="defe3-325">The following example demonstrates a use of the `IsResource` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsResource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public virtual int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MDStreamVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MDStreamVersion As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MDStreamVersion { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MDStreamVersion : int" Usage="System.Reflection.Module.MDStreamVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-326">Gets the metadata stream version.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-326">Gets the metadata stream version.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="defe3-327">Eine 32-Bit-Ganzzahl, die die Metadatenstreamversion darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-327">A 32-bit integer representing the metadata stream version.</span>
          </span>
          <span data-ttu-id="defe3-328">Die beiden höherwertigen Bytes stellen die Hauptversionsnummer dar und die beiden niederwertigen Bytes dar, die Nebenversionsnummer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-328">The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="defe3-329">Weitere Informationen zu den Metadatenheader finden Sie unter "Partition II: Metadata Definition and Semantics" in der Dokumentation für die Common Language Infrastructure (CLI).</span><span class="sxs-lookup"><span data-stu-id="defe3-329">For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</span></span> <span data-ttu-id="defe3-330">Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# und Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) auf der ECMA-Website.</span><span class="sxs-lookup"><span data-stu-id="defe3-330">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public virtual int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataToken : int" Usage="System.Reflection.Module.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-331">Gets a token that identifies the module in metadata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-331">Gets a token that identifies the module in metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="defe3-332">Ein Ganzzahltoken, das das aktuelle Modul in den Metadaten angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-332">An integer token that identifies the current module in metadata.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-333">Die Token erhalten haben, verwenden diese Eigenschaft können an die nicht verwaltete Reflektions-API übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="defe3-333">The tokens obtained using this property can be passed to the unmanaged Reflection API.</span></span> <span data-ttu-id="defe3-334">Weitere Informationen finden Sie unter [nicht verwaltete Reflektions-API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span><span class="sxs-lookup"><span data-stu-id="defe3-334">For more information, see [Unmanaged Reflection API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="defe3-335">Informationen zum Metadatentoken finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="defe3-335">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="defe3-336">Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# und Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) auf der ECMA-Website.</span><span class="sxs-lookup"><span data-stu-id="defe3-336">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleHandle">
      <MemberSignature Language="C#" Value="public ModuleHandle ModuleHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ModuleHandle ModuleHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModuleHandle As ModuleHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ModuleHandle ModuleHandle { ModuleHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.ModuleHandle : ModuleHandle" Usage="System.Reflection.Module.ModuleHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ModuleHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-337">Gets a handle for the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-337">Gets a handle for the module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="defe3-338">Ein <see cref="T:System.ModuleHandle" /> Struktur für das aktuelle Modul.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-338">A <see cref="T:System.ModuleHandle" /> structure for the current module.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public virtual Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleVersionId" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ModuleVersionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid ModuleVersionId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.ModuleVersionId : Guid" Usage="System.Reflection.Module.ModuleVersionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-339">Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-339">Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="defe3-340">Eine <see cref="T:System.Guid" />, die zur Unterscheidung zwischen zwei Versionen eines Moduls verwendet werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-340">A <see cref="T:System.Guid" /> that can be used to distinguish between two versions of a module.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-341">In nicht verwalteten Metadaten, die GUID zurückgegeben, durch die <xref:System.Reflection.Module.ModuleVersionId%2A> Eigenschaft wird als bezeichnet die `mvid`, und wird im GUID-Heap gespeichert.</span><span class="sxs-lookup"><span data-stu-id="defe3-341">In unmanaged metadata, the GUID returned by the <xref:System.Reflection.Module.ModuleVersionId%2A> property is referred to as the `mvid`, and is stored in the GUID heap.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="defe3-342">Weitere Informationen zu Metadaten finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="defe3-342">More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="defe3-343">Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# und Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) auf der ECMA-Website.</span><span class="sxs-lookup"><span data-stu-id="defe3-343">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Module.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-344">Gets a <see langword="String" /> representing the name of the module with the path removed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-344">Gets a <see langword="String" /> representing the name of the module with the path removed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="defe3-345">Der Modulname ohne Pfad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-345">The module name with no path.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-346">`Name` ist eine plattformabhängige Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="defe3-346">`Name` is a platform-dependent string.</span></span>  
  
 <span data-ttu-id="defe3-347">Wenn die Assembly für dieses Modul aus einem Bytearray geladen wurde und dann die `FullyQualifiedName` für das Modul: \<unbekannt >.</span><span class="sxs-lookup"><span data-stu-id="defe3-347">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
 <span data-ttu-id="defe3-348">Rufen Sie den Namen und den Pfad mit <xref:System.Reflection.Module.FullyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="defe3-348">To get the name and the path, use <xref:System.Reflection.Module.FullyQualifiedName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="defe3-349">Dieses Beispiel zeigt die Auswirkungen der `ScopeName`, `FullyQualifiedName`, und `Name` Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="defe3-349">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.Name Example/CS/source.cs#1)]
 [!code-vb[Classic Module.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Module * System.Reflection.Module -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="defe3-350">The first object to compare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-350">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="defe3-351">The second object to compare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-351">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-352">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are equal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-352">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-353">
            <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-353">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Module * System.Reflection.Module -&gt; bool" Usage="System.Reflection.Module.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="defe3-354">The first object to compare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-354">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="defe3-355">The second object to compare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-355">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-356">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are not equal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-356">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-357">
            <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-357">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-358">Returns the field identified by a metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-358">Returns the field identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo ResolveField (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveField (metadataToken As Integer) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ ResolveField(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveField : int -&gt; System.Reflection.FieldInfo" Usage="module.ResolveField metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="defe3-359">A metadata token that identifies a field in the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-359">A metadata token that identifies a field in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-360">Returns the field identified by the specified metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-360">Returns the field identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-361">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-361">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-362">Auflösen ein Metadatentoken, das ein Feld identifiziert, dessen übergeordnetes Element `TypeSpec` hat eine Signatur mit Elementtyp `ELEMENT_TYPE_VAR` oder `ELEMENT_TYPE_MVAR`, verwenden Sie die <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> methodenüberladung, die Ihnen ermöglicht, den erforderlichen Kontext bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="defe3-362">To resolve a metadata token that identifies a field whose parent `TypeSpec` has a signature containing element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="defe3-363">D. h., wenn Sie ein Metadatentoken für ein Feld auflösen, der abhängig von der generischen Typparameter des generischen Typs bzw. die generische Methode, die in der das Token eingebettet ist, müssen Sie die Überladung verwenden, die Sie diesen Typparameter bereitstellen können.</span><span class="sxs-lookup"><span data-stu-id="defe3-363">That is, when you are resolving a metadata token for a field that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="defe3-364">Informationen zum Metadatentoken finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="defe3-364">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="defe3-365">Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# und Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) auf der ECMA-Website.</span><span class="sxs-lookup"><span data-stu-id="defe3-365">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="defe3-366">Code, der demonstriert das Auflösen von token mit dem generischen Kontext (d. h. die generischen Typparameter des generischen Typs bzw. die generische Methode, die in dem das Token eingebettet ist) finden Sie unter den <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode.</span><span class="sxs-lookup"><span data-stu-id="defe3-366">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-367">
            <paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-367">
              <paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span>
          </span>
          <span data-ttu-id="defe3-368">-or-  <paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-368">-or-  <paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="defe3-369">
            <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-369">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveField (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ ResolveField(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveField : int * Type[] * Type[] -&gt; System.Reflection.FieldInfo&#xA;override this.ResolveField : int * Type[] * Type[] -&gt; System.Reflection.FieldInfo" Usage="module.ResolveField (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="defe3-370">A metadata token that identifies a field in the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-370">A metadata token that identifies a field in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="defe3-371">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-371">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="defe3-372">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-372">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-373">Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-373">Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-374">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-374">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-375">Verwenden der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode für den Typ, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="defe3-375">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="defe3-376">Verwenden der <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methode für die Methode, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="defe3-376">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="defe3-377">Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="defe3-377">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="defe3-378">Informationen zum Metadatentoken finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="defe3-378">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="defe3-379">Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# und Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) auf der ECMA-Website.</span><span class="sxs-lookup"><span data-stu-id="defe3-379">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="defe3-380">Code, der demonstriert das Auflösen von token mit dem generischen Kontext (d. h. die generischen Typparameter des generischen Typs bzw. die generische Methode, die in dem das Token eingebettet ist) finden Sie unter den <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode.</span><span class="sxs-lookup"><span data-stu-id="defe3-380">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-381">
            <paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-381">
              <paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span>
          </span>
          <span data-ttu-id="defe3-382">-or-  <paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-382">-or-  <paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="defe3-383">
            <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-383">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-384">Returns the type or member identified by a metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-384">Returns the type or member identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo ResolveMember (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMember (metadataToken As Integer) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MemberInfo ^ ResolveMember(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveMember : int -&gt; System.Reflection.MemberInfo" Usage="module.ResolveMember metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="defe3-385">A metadata token that identifies a type or member in the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-385">A metadata token that identifies a type or member in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-386">Returns the type or member identified by the specified metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-386">Returns the type or member identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-387">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-387">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-388">Ein Metadatentoken für auflösen eine `MethodSpec` oder `TypeSpec` dessen Signatur den Elementtyp enthält `ELEMENT_TYPE_VAR` oder `ELEMENT_TYPE_MVAR`, verwenden Sie die <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> methodenüberladung, die Ihnen ermöglicht, den erforderlichen Kontext bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="defe3-388">To resolve a metadata token for a `MethodSpec` or `TypeSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="defe3-389">D. h., wenn Sie ein Metadatentoken für einen Member auflösen, der abhängig von der generischen Typparameter des generischen Typs bzw. die generische Methode, die in der das Token eingebettet ist, müssen Sie die Überladung verwenden, die Sie diesen Typparameter bereitstellen können.</span><span class="sxs-lookup"><span data-stu-id="defe3-389">That is, when you are resolving a metadata token for a member that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="defe3-390">Informationen zum Metadatentoken finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="defe3-390">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="defe3-391">Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# und Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) auf der ECMA-Website.</span><span class="sxs-lookup"><span data-stu-id="defe3-391">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="defe3-392">Code, der demonstriert das Auflösen von token mit dem generischen Kontext (d. h. die generischen Typparameter des generischen Typs bzw. die generische Methode, die in dem das Token eingebettet ist) finden Sie unter den <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode.</span><span class="sxs-lookup"><span data-stu-id="defe3-392">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-393">
            <paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-393">
              <paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span>
          </span>
          <span data-ttu-id="defe3-394">-or-  <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-394">-or-  <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
          <span data-ttu-id="defe3-395">-or-  <paramref name="metadataToken" /> identifies a property or event.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-395">-or-  <paramref name="metadataToken" /> identifies a property or event.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="defe3-396">
            <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-396">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMember (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MemberInfo ^ ResolveMember(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveMember : int * Type[] * Type[] -&gt; System.Reflection.MemberInfo&#xA;override this.ResolveMember : int * Type[] * Type[] -&gt; System.Reflection.MemberInfo" Usage="module.ResolveMember (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="defe3-397">A metadata token that identifies a type or member in the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-397">A metadata token that identifies a type or member in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="defe3-398">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-398">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="defe3-399">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-399">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-400">Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-400">Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-401">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-401">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-402">Verwenden der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode für den Typ, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="defe3-402">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="defe3-403">Verwenden der <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methode für die Methode, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="defe3-403">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="defe3-404">Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="defe3-404">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="defe3-405">Informationen zum Metadatentoken finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="defe3-405">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="defe3-406">Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# und Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) auf der ECMA-Website.</span><span class="sxs-lookup"><span data-stu-id="defe3-406">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="defe3-407">Code, der demonstriert das Auflösen von token mit dem generischen Kontext (d. h. die generischen Typparameter des generischen Typs bzw. die generische Methode, die in dem das Token eingebettet ist) finden Sie unter den <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode.</span><span class="sxs-lookup"><span data-stu-id="defe3-407">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-408">
            <paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-408">
              <paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span>
          </span>
          <span data-ttu-id="defe3-409">-or-  <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-409">-or-  <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
          <span data-ttu-id="defe3-410">-or-  <paramref name="metadataToken" /> identifies a property or event.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-410">-or-  <paramref name="metadataToken" /> identifies a property or event.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="defe3-411">
            <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-411">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-412">Returns the method identified by a metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-412">Returns the method identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase ResolveMethod (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMethod (metadataToken As Integer) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodBase ^ ResolveMethod(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveMethod : int -&gt; System.Reflection.MethodBase" Usage="module.ResolveMethod metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="defe3-413">A metadata token that identifies a method or constructor in the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-413">A metadata token that identifies a method or constructor in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-414">Returns the method or constructor identified by the specified metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-414">Returns the method or constructor identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-415">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor that is identified by the specified metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-415">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-416">Ein Metadatentoken für auflösen eine `MethodSpec` dessen Signatur den Elementtyp enthält `ELEMENT_TYPE_VAR` oder `ELEMENT_TYPE_MVAR`, verwenden Sie die <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> methodenüberladung, die Ihnen ermöglicht, den erforderlichen Kontext bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="defe3-416">To resolve a metadata token for a `MethodSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="defe3-417">Wenn Sie also ein Metadatentoken für eine Methode, die abhängig von der generischen Typparameter des generischen Typs bzw. die generische Methode, die in der das Token eingebettet ist auflösen, müssen Sie, also die Überladung verwenden, die Sie diesen Typparameter bereitstellen können.</span><span class="sxs-lookup"><span data-stu-id="defe3-417">That is, when you are resolving a metadata token for a method that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="defe3-418">Informationen zum Metadatentoken finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="defe3-418">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="defe3-419">Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# und Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) auf der ECMA-Website.</span><span class="sxs-lookup"><span data-stu-id="defe3-419">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="defe3-420">Das folgende Beispiel zeigt, wie Sie mit den zwei Überladungen der <xref:System.Reflection.Module.ResolveMethod%2A> Methode zum Auflösen von Metadatentoken vom Aufruf Standorte in generischen und nicht generische Kontexten.</span><span class="sxs-lookup"><span data-stu-id="defe3-420">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="defe3-421">Das Codebeispiel definiert zwei generische Typen, `G1<Tg1>` und `G2<Tg2>` (`G1(Of Tg1)` und `G2(Of Tg2)` in Visual Basic), von denen jede verfügt über eine generische Methode.</span><span class="sxs-lookup"><span data-stu-id="defe3-421">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>` (`G1(Of Tg1)` and `G2(Of Tg2)` in Visual Basic), each of which has a generic method.</span></span> <span data-ttu-id="defe3-422">`G1<Tg1>` verfügt auch über eine nicht generische Methode, die den Typparameter verwendet `Tg1` für den Parameter.</span><span class="sxs-lookup"><span data-stu-id="defe3-422">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="defe3-423">Die generische Methode `GM2<Tgm2>` im Typ `G2<Tg2>` enthält mehrere Methodenaufrufe:</span><span class="sxs-lookup"><span data-stu-id="defe3-423">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="defe3-424">Fall 1: Die generische Methode `GM1<Tgm1>` aufgerufen wird, verwenden die Typparameter der `G2<Tg2>` und `GM2<Tgm2>` den Typargumenten.</span><span class="sxs-lookup"><span data-stu-id="defe3-424">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="defe3-425">Das heißt, die Parametertypen der aufgerufenen Methode hängt von den Typen, die verwendet werden, erstellen Sie einen geschlossenen generischen Typ aus der Typdefinition für `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="defe3-425">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="defe3-426">Fall 2: Die nicht generische Methode `M1` aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="defe3-426">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="defe3-427">Die Parameter dieser Methode verwendet den Typparameter des definierenden Typs `G1<Tg1>`, das in diesem Fall durch den Typparameter des einschließenden Typs ersetzt wird `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="defe3-427">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="defe3-428">Fall 3: Die generische Methode `GM1<Tgm1>` aufgerufen wird, wird die Angabe <xref:System.Int32> und <xref:System.Object> für die Typargumente eines generischen Typs und der generischen Methode bzw.</span><span class="sxs-lookup"><span data-stu-id="defe3-428">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="defe3-429">Dieser Methodenaufruf ist nicht von den Typparametern des einschließenden Typs oder -Methode abhängig.</span><span class="sxs-lookup"><span data-stu-id="defe3-429">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="defe3-430">Fall 4: Die nicht generische Methode `M1` von der `Example` -Klasse aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="defe3-430">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="defe3-431">Dieser Methodenaufruf ist nicht von den Typparametern des einschließenden Typs oder -Methode abhängig.</span><span class="sxs-lookup"><span data-stu-id="defe3-431">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="defe3-432">Darüber hinaus definiert das Beispiel die nicht generische `Example` Klasse.</span><span class="sxs-lookup"><span data-stu-id="defe3-432">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="defe3-433">Diese Klasse verfügt über eine Methode `M` , die eine generische Methode aufruft:</span><span class="sxs-lookup"><span data-stu-id="defe3-433">This class has a method `M` that makes a call to a generic method:</span></span>  
  
-   <span data-ttu-id="defe3-434">Fall 5: Die generische Methode `GM1` aufgerufen wird, wird die Angabe <xref:System.Int32> und <xref:System.Object> für die Typargumente eines generischen Typs und der generischen Methode bzw.</span><span class="sxs-lookup"><span data-stu-id="defe3-434">Case 5: The generic method `GM1` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="defe3-435">Der Kontext für diese Methode hat keine einschließenden generischen Typ- oder Methodendefinition.</span><span class="sxs-lookup"><span data-stu-id="defe3-435">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="defe3-436">Für jeden Fall erstellt das Beispiel zunächst eine <xref:System.Reflection.MethodInfo> , die die aufgerufene Methode darstellt, und klicken Sie dann löst das token mithilfe der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode zu überladen, mit der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> und <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methoden, um die Werte für die `genericTypeArguments` und `genericMethodArguments` Parameter.</span><span class="sxs-lookup"><span data-stu-id="defe3-436">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="defe3-437">Dieses Verfahren funktioniert in allen Fällen auf, da die Methoden zurückgeben <xref:System.Type.EmptyTypes?displayProperty=nameWithType> für nicht generische Kontexte.</span><span class="sxs-lookup"><span data-stu-id="defe3-437">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="defe3-438">Im Beispiel wird die aufgelöste <xref:System.Reflection.MethodInfo> mit der erstellten <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="defe3-438">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="defe3-439">Im Beispiel wird dann versucht wird, verwenden die <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> -methodenüberladung, um das Token aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="defe3-439">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="defe3-440">Dies funktioniert in Fällen, 3, 4 und 5, da die Methodenaufrufe nicht von dem generischen Kontext abhängen.</span><span class="sxs-lookup"><span data-stu-id="defe3-440">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="defe3-441">In Fällen, 1 und 2 wird eine Ausnahme ausgelöst, weil nicht genügend Informationen, das Token aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="defe3-441">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="defe3-442">Die Metadaten-token-Werte sind als eine Enumeration hartcodiert.</span><span class="sxs-lookup"><span data-stu-id="defe3-442">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="defe3-443">Wenn Sie dieses Codebeispiel ändern, werden die Tokenwerte wahrscheinlich ändern.</span><span class="sxs-lookup"><span data-stu-id="defe3-443">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="defe3-444">Um die neuen Werte für die token zu bestimmen, den Code kompilieren und mithilfe von Ildasm.exe mit der **/TOKENS** Option aus, um die Assembly zu untersuchen.</span><span class="sxs-lookup"><span data-stu-id="defe3-444">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="defe3-445">Die Token finden Sie unter den Punkt des Aufrufs.</span><span class="sxs-lookup"><span data-stu-id="defe3-445">The tokens can be found at the points of call.</span></span> <span data-ttu-id="defe3-446">Legen Sie die neuen Werte in der Enumeration und kompilieren Sie das Beispiel erneut.</span><span class="sxs-lookup"><span data-stu-id="defe3-446">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-447">
            <paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-447">
              <paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span>
          </span>
          <span data-ttu-id="defe3-448">-or-  <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-448">-or-  <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="defe3-449">
            <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-449">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMethod (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBase ^ ResolveMethod(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveMethod : int * Type[] * Type[] -&gt; System.Reflection.MethodBase&#xA;override this.ResolveMethod : int * Type[] * Type[] -&gt; System.Reflection.MethodBase" Usage="module.ResolveMethod (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="defe3-450">A metadata token that identifies a method or constructor in the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-450">A metadata token that identifies a method or constructor in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="defe3-451">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-451">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="defe3-452">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-452">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-453">Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-453">Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-454">A <see cref="T:System.Reflection.MethodBase" /> object representing the method that is identified by the specified metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-454">A <see cref="T:System.Reflection.MethodBase" /> object representing the method that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-455">Verwenden der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode für den Typ, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="defe3-455">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="defe3-456">Verwenden der <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methode für die Methode, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericMethodArguments`.</span><span class="sxs-lookup"><span data-stu-id="defe3-456">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericMethodArguments`.</span></span> <span data-ttu-id="defe3-457">Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="defe3-457">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="defe3-458">Informationen zum Metadatentoken finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="defe3-458">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="defe3-459">Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# und Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) auf der ECMA-Website.</span><span class="sxs-lookup"><span data-stu-id="defe3-459">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="defe3-460">Das folgende Beispiel zeigt, wie Sie mit den zwei Überladungen der <xref:System.Reflection.Module.ResolveMethod%2A> Methode zum Auflösen von Metadatentoken vom Aufruf Standorte in generischen und nicht generische Kontexten.</span><span class="sxs-lookup"><span data-stu-id="defe3-460">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="defe3-461">Das Codebeispiel definiert zwei generische Typen, `G1<Tg1>` und `G2<Tg2>`, von denen jede verfügt über eine generische Methode.</span><span class="sxs-lookup"><span data-stu-id="defe3-461">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>`, each of which has a generic method.</span></span> <span data-ttu-id="defe3-462">`G1<Tg1>` verfügt auch über eine nicht generische Methode, die den Typparameter verwendet `Tg1` für den Parameter.</span><span class="sxs-lookup"><span data-stu-id="defe3-462">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="defe3-463">Die generische Methode `GM2<Tgm2>` im Typ `G2<Tg2>` enthält mehrere Methodenaufrufe:</span><span class="sxs-lookup"><span data-stu-id="defe3-463">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="defe3-464">Fall 1: Die generische Methode `GM1<Tgm1>` aufgerufen wird, verwenden die Typparameter der `G2<Tg2>` und `GM2<Tgm2>` den Typargumenten.</span><span class="sxs-lookup"><span data-stu-id="defe3-464">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="defe3-465">Das heißt, die Parametertypen der aufgerufenen Methode hängt von den Typen, die verwendet werden, erstellen Sie einen geschlossenen generischen Typ aus der Typdefinition für `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="defe3-465">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="defe3-466">Fall 2: Die nicht generische Methode `M1` aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="defe3-466">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="defe3-467">Die Parameter dieser Methode verwendet den Typparameter des definierenden Typs `G1<Tg1>`, das in diesem Fall durch den Typparameter des einschließenden Typs ersetzt wird `G2<Tg2>`.</span><span class="sxs-lookup"><span data-stu-id="defe3-467">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="defe3-468">Fall 3: Die generische Methode `GM1<Tgm1>` aufgerufen wird, wird die Angabe <xref:System.Int32> und <xref:System.Object> für die Typargumente eines generischen Typs und der generischen Methode bzw.</span><span class="sxs-lookup"><span data-stu-id="defe3-468">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="defe3-469">Dieser Methodenaufruf ist nicht von den Typparametern des einschließenden Typs oder -Methode abhängig.</span><span class="sxs-lookup"><span data-stu-id="defe3-469">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="defe3-470">Fall 4: Die nicht generische Methode `M1` von der `Example` -Klasse aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="defe3-470">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="defe3-471">Dieser Methodenaufruf ist nicht von den Typparametern des einschließenden Typs oder -Methode abhängig.</span><span class="sxs-lookup"><span data-stu-id="defe3-471">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="defe3-472">Darüber hinaus definiert das Beispiel die nicht generische `Example` Klasse.</span><span class="sxs-lookup"><span data-stu-id="defe3-472">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="defe3-473">Diese Klasse verfügt über eine Methode `M` , die eine generische Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="defe3-473">This class has a method `M` that makes a call to a generic method.</span></span>  
  
-   <span data-ttu-id="defe3-474">Fall 5: Die generische Methode `GM1<Tgm1>` aufgerufen wird, wird die Angabe <xref:System.Int32> und <xref:System.Object> für die Typargumente eines generischen Typs und der generischen Methode bzw.</span><span class="sxs-lookup"><span data-stu-id="defe3-474">Case 5: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="defe3-475">Der Kontext für diese Methode hat keine einschließenden generischen Typ- oder Methodendefinition.</span><span class="sxs-lookup"><span data-stu-id="defe3-475">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="defe3-476">Für jeden Fall erstellt das Beispiel zunächst eine <xref:System.Reflection.MethodInfo> , die die aufgerufene Methode darstellt, und klicken Sie dann löst das token mithilfe der <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode zu überladen, mit der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> und <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methoden, um die Werte für die `genericTypeArguments` und `genericMethodArguments` Parameter.</span><span class="sxs-lookup"><span data-stu-id="defe3-476">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="defe3-477">Dieses Verfahren funktioniert in allen Fällen auf, da die Methoden zurückgeben <xref:System.Type.EmptyTypes?displayProperty=nameWithType> für nicht generische Kontexte.</span><span class="sxs-lookup"><span data-stu-id="defe3-477">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="defe3-478">Im Beispiel wird die aufgelöste <xref:System.Reflection.MethodInfo> mit der erstellten <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="defe3-478">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="defe3-479">Im Beispiel wird dann versucht wird, verwenden die <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> -methodenüberladung, um das Token aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="defe3-479">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="defe3-480">Dies funktioniert in Fällen, 3, 4 und 5, da die Methodenaufrufe nicht von dem generischen Kontext abhängen.</span><span class="sxs-lookup"><span data-stu-id="defe3-480">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="defe3-481">In Fällen, 1 und 2 wird eine Ausnahme ausgelöst, weil nicht genügend Informationen, das Token aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="defe3-481">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="defe3-482">Die Metadaten-token-Werte sind als eine Enumeration hartcodiert.</span><span class="sxs-lookup"><span data-stu-id="defe3-482">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="defe3-483">Wenn Sie dieses Codebeispiel ändern, werden die Tokenwerte wahrscheinlich ändern.</span><span class="sxs-lookup"><span data-stu-id="defe3-483">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="defe3-484">Um die neuen Werte für die token zu bestimmen, den Code kompilieren und mithilfe von Ildasm.exe mit der **/TOKENS** Option aus, um die Assembly zu untersuchen.</span><span class="sxs-lookup"><span data-stu-id="defe3-484">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="defe3-485">Die Token finden Sie unter den Punkt des Aufrufs.</span><span class="sxs-lookup"><span data-stu-id="defe3-485">The tokens can be found at the points of call.</span></span> <span data-ttu-id="defe3-486">Legen Sie die neuen Werte in der Enumeration und kompilieren Sie das Beispiel erneut.</span><span class="sxs-lookup"><span data-stu-id="defe3-486">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-487">
            <paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-487">
              <paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span>
          </span>
          <span data-ttu-id="defe3-488">-or-  <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-488">-or-  <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="defe3-489">
            <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-489">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public virtual byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveSignature (metadataToken As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ResolveSignature(int metadataToken);" />
      <MemberSignature Language="F#" Value="abstract member ResolveSignature : int -&gt; byte[]&#xA;override this.ResolveSignature : int -&gt; byte[]" Usage="module.ResolveSignature metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="defe3-490">A metadata token that identifies a signature in the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-490">A metadata token that identifies a signature in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-491">Returns the signature blob identified by a metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-491">Returns the signature blob identified by a metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-492">An array of bytes representing the signature blob.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-492">An array of bytes representing the signature blob.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="defe3-493">Informationen zum Metadatentoken und Signaturen finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="defe3-493">Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="defe3-494">Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# und Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) auf der ECMA-Website.</span><span class="sxs-lookup"><span data-stu-id="defe3-494">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-495">
            <paramref name="metadataToken" /> is not a valid <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, signature, or <see langword="FieldDef" /> token in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-495">
              <paramref name="metadataToken" /> is not a valid <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, signature, or <see langword="FieldDef" /> token in the scope of the current module.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="defe3-496">
            <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-496">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public virtual string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveString (metadataToken As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveString(int metadataToken);" />
      <MemberSignature Language="F#" Value="abstract member ResolveString : int -&gt; string&#xA;override this.ResolveString : int -&gt; string" Usage="module.ResolveString metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="defe3-497">A metadata token that identifies a string in the string heap of the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-497">A metadata token that identifies a string in the string heap of the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-498">Returns the string identified by the specified metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-498">Returns the string identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-499">A <see cref="T:System.String" /> containing a string value from the metadata string heap.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-499">A <see cref="T:System.String" /> containing a string value from the metadata string heap.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="defe3-500">Informationen zum Metadatentoken finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="defe3-500">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="defe3-501">Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# und Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) auf der ECMA-Website.</span><span class="sxs-lookup"><span data-stu-id="defe3-501">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-502">
            <paramref name="metadataToken" /> is not a token for a string in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-502">
              <paramref name="metadataToken" /> is not a token for a string in the scope of the current module.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="defe3-503">
            <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-503">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-504">Returns the type identified by a metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-504">Returns the type identified by a metadata token.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public Type ResolveType (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type ResolveType(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveType (metadataToken As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ ResolveType(int metadataToken);" />
      <MemberSignature Language="F#" Value="member this.ResolveType : int -&gt; Type" Usage="module.ResolveType metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="defe3-505">A metadata token that identifies a type in the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-505">A metadata token that identifies a type in the module.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-506">Returns the type identified by the specified metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-506">Returns the type identified by the specified metadata token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-507">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-507">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-508">Ein Metadatentoken für Auflösen einer `TypeSpec` , deren Signatur enthält `ELEMENT_TYPE_VAR` oder `ELEMENT_TYPE_MVAR`, verwenden die <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> methodenüberladung, die Ihnen ermöglicht, den erforderlichen Kontext bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="defe3-508">To resolve a metadata token for a `TypeSpec` whose signature contains `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="defe3-509">D. h., wenn Sie ein Metadatentoken für einen Typ auflösen, der abhängig von der generischen Typparameter des generischen Typs bzw. die generische Methode, die in der das Token eingebettet ist, müssen Sie die Überladung verwenden, die Sie diesen Typparameter bereitstellen können.</span><span class="sxs-lookup"><span data-stu-id="defe3-509">That is, when you are resolving a metadata token for a type that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="defe3-510">Informationen zum Metadatentoken finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="defe3-510">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="defe3-511">Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# und Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) auf der ECMA-Website.</span><span class="sxs-lookup"><span data-stu-id="defe3-511">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-512">
            <paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-512">
              <paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span>
          </span>
          <span data-ttu-id="defe3-513">-or-  <paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-513">-or-  <paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="defe3-514">
            <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-514">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public virtual Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveType (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ ResolveType(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="abstract member ResolveType : int * Type[] * Type[] -&gt; Type&#xA;override this.ResolveType : int * Type[] * Type[] -&gt; Type" Usage="module.ResolveType (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">
          <span data-ttu-id="defe3-515">A metadata token that identifies a type in the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-515">A metadata token that identifies a type in the module.</span>
          </span>
        </param>
        <param name="genericTypeArguments">
          <span data-ttu-id="defe3-516">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-516">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span>
          </span>
        </param>
        <param name="genericMethodArguments">
          <span data-ttu-id="defe3-517">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-517">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-518">Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-518">Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-519">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-519">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-520">Verwenden der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode für den Typ, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="defe3-520">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="defe3-521">Verwenden der <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> Methode für die Methode, in denen `metadataToken` befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für `genericTypeArguments`.</span><span class="sxs-lookup"><span data-stu-id="defe3-521">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="defe3-522">Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="defe3-522">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="defe3-523">Informationen zum Metadatentoken finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="defe3-523">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="defe3-524">Die Dokumentation ist online verfügbar. finden Sie unter [ECMA c# und Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) auf der ECMA-Website.</span><span class="sxs-lookup"><span data-stu-id="defe3-524">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="defe3-525">Code, der demonstriert das Auflösen von token mit dem generischen Kontext (d. h. die generischen Typparameter des generischen Typs bzw. die generische Methode, die in dem das Token eingebettet ist) finden Sie unter den <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> Methode.</span><span class="sxs-lookup"><span data-stu-id="defe3-525">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="defe3-526">
            <paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-526">
              <paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span>
          </span>
          <span data-ttu-id="defe3-527">-or-  <paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-527">-or-  <paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="defe3-528">
            <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-528">
              <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public virtual string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ScopeName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ScopeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ScopeName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScopeName : string" Usage="System.Reflection.Module.ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="defe3-529">Gets a string representing the name of the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-529">Gets a string representing the name of the module.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="defe3-530">Der Modulname.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-530">The module name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-531">Die `ScopeName` Eigenschaft wird nicht von der common Language Runtime verwendet, aber Sie können es verwenden, um eine beliebige Zeichenfolge, die Sie möchten in der Eigenschaft gespeichert wird, wenn Sie ein Modul mit die Metadaten-APIs ausgeben.</span><span class="sxs-lookup"><span data-stu-id="defe3-531">The `ScopeName` property is not used by the common language runtime, but you can use it to store any string you want in the property when you emit a module using the metadata APIs.</span></span> <span data-ttu-id="defe3-532">Reflektion selbst lässt Sie festlegen, jedoch nicht die `ScopeName` Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="defe3-532">Reflection itself does not allow you to set the `ScopeName` property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="defe3-533">Dieses Beispiel zeigt die Auswirkungen der `ScopeName`, `FullyQualifiedName`, und `Name` Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="defe3-533">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.ScopeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.ScopeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CS/source.cs#1)]
 [!code-vb[Classic Module.ScopeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Module.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Module.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Module::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="defe3-534">Reserved for future use.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-534">Reserved for future use.</span>
          </span>
          <span data-ttu-id="defe3-535">Must be IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-535">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="defe3-536">Passed-in array of names to be mapped.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-536">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="defe3-537">Count of the names to be mapped.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-537">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="defe3-538">The locale context in which to interpret the names.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-538">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="defe3-539">Caller-allocated array that receives the IDs corresponding to the names.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-539">Caller-allocated array that receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-540">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-540">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-541">Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="defe3-541">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="defe3-542">Weitere Informationen zu `IDispatch::GetIDsOfNames`, finden Sie unter der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="defe3-542">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="defe3-543">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-543">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Module.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="defe3-544">The type information to return.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-544">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="defe3-545">The locale identifier for the type information.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-545">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="defe3-546">Receives a pointer to the requested type information object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-546">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-547">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-547">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-548">Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="defe3-548">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="defe3-549">Weitere Informationen zu `IDispatch::GetTypeInfo`, finden Sie unter der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="defe3-549">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="defe3-550">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-550">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Module.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="defe3-551">Points to a location that receives the number of type information interfaces provided by the object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-551">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-552">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-552">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-553">Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="defe3-553">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="defe3-554">Weitere Informationen zu `IDispatch::GetTypeInfoCount`, finden Sie unter der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="defe3-554">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="defe3-555">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-555">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.Invoke">
      <MemberSignature Language="C#" Value="void _Module.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Module.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Module::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="defe3-556">Identifies the member.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-556">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="defe3-557">Reserved for future use.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-557">Reserved for future use.</span>
          </span>
          <span data-ttu-id="defe3-558">Must be IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-558">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="defe3-559">The locale context in which to interpret arguments.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-559">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="defe3-560">Flags describing the context of the call.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-560">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="defe3-561">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-561">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="defe3-562">Pointer to the location where the result is to be stored.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-562">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="defe3-563">Pointer to a structure that contains exception information.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-563">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="defe3-564">The index of the first argument that has an error.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-564">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="defe3-565">Provides access to properties and methods exposed by an object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-565">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="defe3-566">Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="defe3-566">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="defe3-567">Weitere Informationen zu `IDispatch::Invoke`, finden Sie unter der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="defe3-567">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="defe3-568">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-568">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="module.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="defe3-569">Returns the name of the module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-569">Returns the name of the module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="defe3-570">A <see langword="String" /> representing the name of this module.</span>
          <span class="sxs-lookup">
            <span data-stu-id="defe3-570">A <see langword="String" /> representing the name of this module.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="defe3-571">Das folgende Beispiel veranschaulicht die Verwendung des der `ToString` Methode.</span><span class="sxs-lookup"><span data-stu-id="defe3-571">The following example demonstrates a use of the `ToString` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.ToString Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>