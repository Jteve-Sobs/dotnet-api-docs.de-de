<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Module.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac599434ae0ca2ae257e847cbb424c20883be128c2c.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">99434ae0ca2ae257e847cbb424c20883be128c2c</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Performs reflection on a module.</source>
          <target state="translated">Führt die Reflektion für ein Modul durch.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>A module is a portable executable file, such as type.dll or application.exe, consisting of one or more classes and interfaces.</source>
          <target state="translated">Ein Modul ist eine portierbare ausführbare Datei, z. B. type.dll oder application.exe, bestehend aus einem oder mehreren Klassen und Schnittstellen.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>There may be multiple namespaces contained in a single module, and a namespace may span multiple modules.</source>
          <target state="translated">Ein einzelnes Modul kann mehrere Namespaces enthalten, und ein Namespace kann mehrere Module umfassen.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>One or more modules deployed as a unit compose an assembly.</source>
          <target state="translated">Wenn ein Modul oder mehrere Module als Einheit bereitgestellt werden, bilden sie eine Assembly.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>For information about creating an assembly with more than one module, see <bpt id="p1">[</bpt>Multifile Assemblies<ept id="p1">](~/docs/framework/app-domains/multifile-assemblies.md)</ept>.</source>
          <target state="translated">Informationen zum Erstellen einer Assemblys mit mehr als einem Modul finden Sie unter <bpt id="p1">[</bpt>Multifile Assemblys<ept id="p1">](~/docs/framework/app-domains/multifile-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>Note that a .NET Framework module is not the same as a module in Visual Basic, which is used by a programmers to organize functions and subroutines in an application.</source>
          <target state="translated">Beachten Sie, dass ein .NET Framework-Modul nicht als Modul in Visual Basic ist durch einen Programmierer dient zum Organisieren von Funktionen und Unterroutinen in einer Anwendung.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>The following code examples show how to use reflection to get information about modules:</source>
          <target state="translated">Die folgenden Codebeispiele zeigen, wie die Reflexion zum Abrufen von Informationen zu Modulen verwenden:</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>for full trust for inheritors.</source>
          <target state="translated">für volle Vertrauenswürdigkeit für erben.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Module">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Diese Klasse kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.#ctor">
          <source>This constructor is invoked by derived classes during the construction of <ph id="ph1">&lt;xref:System.Reflection.Module&gt;</ph> objects.</source>
          <target state="translated">Dieser Konstruktor wird von abgeleiteten Klassen aufgerufen, während der Erstellung der <ph id="ph1">&lt;xref:System.Reflection.Module&gt;</ph> Objekte.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.Assembly">
          <source>Gets the appropriate <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> for this instance of <ph id="ph2">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>.</source>
          <target state="translated">Ruft die entsprechende <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> für diese Instanz von <ph id="ph2">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Assembly">
          <source>An <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph> object.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Assembly">
          <source>The following example displays the full name of the specified assembly in the specified module.</source>
          <target state="translated">Das folgende Beispiel zeigt den vollständigen Namen der angegebenen Assembly im angegebenen Modul an.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.CustomAttributes">
          <source>Gets a collection that contains this module's custom attributes.</source>
          <target state="translated">Ruft eine Sammlung ab, die die benutzerdefinierten Attribute dieses Moduls enthält.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.CustomAttributes">
          <source>A collection that contains this module's custom attributes.</source>
          <target state="translated">Eine Sammlung, die die benutzerdefinierten Attribute dieses Moduls enthält.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.Equals(System.Object)">
          <source>The object to compare with this instance.</source>
          <target state="translated">Das Objekt, das mit dieser Instanz verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.Equals(System.Object)">
          <source>Determines whether this module and the specified object are equal.</source>
          <target state="translated">Bestimmt, ob dieses Modul und das angegebene Objekt gleich sind.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is equal to this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="o" /&gt;</ph> gleich dieser Instanz ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeName">
          <source>A <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph> object that filters the list of types defined in this module based upon the name.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph>-Objekt, das die Liste der in diesem Modul definierten Typen basierend auf dem Namen filtert.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeName">
          <source>This field is case-sensitive and read-only.</source>
          <target state="translated">In diesem Feld wird Groß-/Kleinschreibung berücksichtigt, und es ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeName">
          <source>The filter supports a trailing "*" wildcard.</source>
          <target state="translated">Der Filter unterstützt einen abschließenden "*" Platzhalter.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeName">
          <source>The following example displays the module names that match the specified search criteria.</source>
          <target state="translated">Das folgende Beispiel zeigt den Modulnamen, die die angegebenen Suchkriterien entsprechen.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>A <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph> object that filters the list of types defined in this module based upon the name.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="TypeFilter" /&gt;</ph>-Objekt, das die Liste der in diesem Modul definierten Typen basierend auf dem Namen filtert.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>This field is case-insensitive and read-only.</source>
          <target state="translated">In diesem Feld wird Groß-/Kleinschreibung nicht berücksichtigt, und es ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>The filter supports a trailing "*" wildcard.</source>
          <target state="translated">Der Filter unterstützt einen abschließenden "*" Platzhalter.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
          <source>The following example displays the module names that match the specified search criteria, ignoring the case.</source>
          <target state="translated">Das folgende Beispiel zeigt den Modulnamen, die die angegebenen Suchkriterien ignorieren die Groß-/Kleinschreibung entsprechen.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The delegate used to filter the classes.</source>
          <target state="translated">Der Delegat, der zum Filtern der Klassen verwendet wird.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>An Object used to filter the classes.</source>
          <target state="translated">Ein Objekt, das zum Filtern der Klassen verwendet wird.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>Returns an array of classes accepted by the given filter and filter criteria.</source>
          <target state="translated">Gibt ein Array von Klassen zurück, die vom angegebenen Filter und den Filterkriterien akzeptiert werden.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing classes that were accepted by the filter.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see langword="Type" /&gt;</ph> mit Klassen, die vom Filter akzeptiert wurden.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph> is a special class load exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph> ist eine besondere Klasse Load-Ausnahme.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> property contains the array of classes that were defined in the module and were loaded.</source>
          <target state="translated">Die <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> -Eigenschaft enthält das Array von Klassen, die im Modul definiert und geladen wurden.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>This array may contain some null values.</source>
          <target state="translated">Dieses Array kann einige null-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> property is an array of exceptions that represent the exceptions that were thrown by the class loader.</source>
          <target state="translated">Die <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> Eigenschaft ist ein Array von Ausnahmen, die Ausnahmen darstellen, die vom Klassenladeprogramm ausgelöst wurden.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The holes in the class array line up with the exceptions.</source>
          <target state="translated">Richten Sie die Lücken in der Klasse Array mit den Ausnahmen.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The delegate given by <ph id="ph1">`filter`</ph> is called for each class in the module, passing along the <ph id="ph2">`Type`</ph> object representing the class as well as the given <ph id="ph3">`filterCriteria`</ph>.</source>
          <target state="translated">Der Delegat, der vom <ph id="ph1">`filter`</ph> wird aufgerufen, für jede Klasse in das Modul, das weiter und übergibt dabei die <ph id="ph2">`Type`</ph> Objekt, das die Klasse darstellt, sowie die angegebenen <ph id="ph3">`filterCriteria`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>If <ph id="ph1">`filter`</ph> returns a particular class, that class will be included in the returned array.</source>
          <target state="translated">Wenn <ph id="ph1">`filter`</ph> gibt eine bestimmte Klasse, dass die Klasse in das zurückgegebene Array eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>If <ph id="ph1">`filter`</ph> returns <ph id="ph2">`null`</ph>, all classes are returned and <ph id="ph3">`filterCriteria`</ph> is ignored.</source>
          <target state="translated">Wenn <ph id="ph1">`filter`</ph> gibt <ph id="ph2">`null`</ph>, werden alle Klassen zurückgegeben und <ph id="ph3">`filterCriteria`</ph> wird ignoriert.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">`FindTypes`</ph> cannot be used to look up parameterized types such as arrays.</source>
          <target state="translated"><ph id="ph1">`FindTypes`</ph> kann nicht verwendet werden, um parametrisierte Typen z. B. Arrays zu suchen.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>The following example demonstrates the <ph id="ph1">`FindTypes`</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">`FindTypes`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
          <source>One or more classes in a module could not be loaded.</source>
          <target state="translated">Mindestens eine Klasse in einem Modul konnte nicht geladen werden.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>Gets a string representing the fully qualified name and path to this module.</source>
          <target state="translated">Ruft eine Zeichenfolge ab, die den vollqualifizierten Namen und Pfad zu diesem Modul darstellt.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The fully qualified module name.</source>
          <target state="translated">Der vollqualifizierte Modulname.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>To get the name without the path, use <ph id="ph1">&lt;xref:System.Reflection.Module.Name%2A&gt;</ph>.</source>
          <target state="translated">Verwenden Sie zum Abrufen der Namen ohne die Pfadangabe <ph id="ph1">&lt;xref:System.Reflection.Module.Name%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>If the assembly for this module was loaded from a byte array then the <ph id="ph1">`FullyQualifiedName`</ph> for the module will be: <ph id="ph2">\&lt;</ph>Unknown&gt;.</source>
          <target state="translated">Wenn die Assembly für dieses Modul aus einem Bytearray geladen wurde und dann die <ph id="ph1">`FullyQualifiedName`</ph> für das Modul: <ph id="ph2">\&lt;</ph>unbekannt &gt;.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The case of module name is platform-dependent.</source>
          <target state="translated">Die Groß-/Kleinschreibung des Moduls ist plattformabhängig.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The following example displays the fully qualified name of the specified module.</source>
          <target state="translated">Das folgende Beispiel zeigt den vollqualifizierten Namen des angegebenen Moduls.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>for access to information in the path.</source>
          <target state="translated">für den Zugriff auf Informationen im Pfad.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.FullyQualifiedName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns custom attributes.</source>
          <target state="translated">Gibt benutzerdefinierte Attribute zurück.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Dieses Argument wird für Objekte dieses Typs ignoriert.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>Returns all custom attributes.</source>
          <target state="translated">Gibt alle benutzerdefinierten Attribute zurück.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>An array of type <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing all custom attributes.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see langword="Object" /&gt;</ph> mit allen benutzerdefinierten Attributen.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)">
          <source>The following example displays the module names that match the specified search criteria.</source>
          <target state="translated">Das folgende Beispiel zeigt den Modulnamen, die die angegebenen Suchkriterien entsprechen.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type of attribute to get.</source>
          <target state="translated">Der Typ der abzurufenden Attribute.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Dieses Argument wird für Objekte dieses Typs ignoriert.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Gets custom attributes of the specified type.</source>
          <target state="translated">Ruft benutzerdefinierte Attribute des angegebenen Typs ab.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of type <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing all custom attributes of the specified type.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see langword="Object" /&gt;</ph> mit allen benutzerdefinierten Attributen vom angegebenen Typ.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The following example displays the module names of the specified type that match the specified search criteria.</source>
          <target state="translated">Das folgende Beispiel zeigt die Modulnamen des angegebenen Typs, die die angegebenen Suchkriterien entsprechen.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist kein von der Laufzeit angegebenes <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist beispielsweise ein <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Returns a list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects for the current module, which can be used in the reflection-only context.</source>
          <target state="translated">Gibt eine Liste von <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph>-Objekten für das aktuelle Modul zurück, die im Reflektionskontext verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>A generic list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects representing data about the attributes that have been applied to the current module.</source>
          <target state="translated">Eine generische Liste von <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph>-Objekten, die Daten zu den Attributen darstellen, die auf das aktuelle Modul angewendet wurden.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</source>
          <target state="translated">Verwenden Sie diese Methode, um die benutzerdefinierten Attribute des Codes in den ReflectionOnly Kontext, in Fällen zu untersuchen, in dem die benutzerdefinierten Attribute selbst im Code definiert werden, die in den reflektionsbezogenen Kontext geladen wird.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Methods such as <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> cannot be used in such cases, because they create instances of the attributes.</source>
          <target state="translated">Methoden, z. B. <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> kann nicht in solchen Fällen verwendet werden, da sie Instanzen der Attribute erstellen.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>Code in the reflection-only context cannot be executed.</source>
          <target state="translated">Code in den ReflectionOnly Kontext kann nicht ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetCustomAttributesData">
          <source>For more information and example code, see the <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> class.</source>
          <target state="translated">Weitere Informationen und Beispielcode finden Sie unter der <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns a specified field.</source>
          <target state="translated">Gibt ein angegebenes Feld zurück.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>The field name.</source>
          <target state="translated">Der Feldname.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>Returns a field having the specified name.</source>
          <target state="translated">Gibt ein Feld mit dem angegebenen Namen zurück.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>A <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> object having the specified name, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the field does not exist.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph>-Objekt mit dem angegebenen Namen oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn das Feld nicht existiert.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="name" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The field name.</source>
          <target state="translated">Der Feldname.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>One of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Eines der <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>-Bitflags zum Steuern der Suche.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns a field having the specified name and binding attributes.</source>
          <target state="translated">Gibt ein Feld mit dem angegebenen Namen und Bindungsattributen zurück.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> object having the specified name and binding attributes, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the field does not exist.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph>-Objekt mit dem angegebenen Namen und Bindungsattributen oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn das Feld nicht existiert.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="name" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the global fields defined on the module.</source>
          <target state="translated">Gibt die globalen Felder zurück, die im Modul definiert sind.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields">
          <source>Returns the global fields defined on the module.</source>
          <target state="translated">Gibt die globalen Felder zurück, die im Modul definiert sind.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing the global fields defined on the module; if there are no global fields, an empty array is returned.</source>
          <target state="translated">Ein Array aus <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>-Objekten, das die im Modul definierten globalen Felder darstellt. Wenn keine globalen Felder vorhanden sind, wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> Methode gibt keinen zurück Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">Der Code muss nicht auf die Reihenfolge, in der Felder zurückgegeben werden, abhängen, da dieser Reihenfolge variieren kann.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limit the search.</source>
          <target state="translated">Eine bitweise Kombination von <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>-Werten, die die Suche einschränken.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>Returns the global fields defined on the module that match the specified binding flags.</source>
          <target state="translated">Gibt die für das Modul definierten globalen Felder zurück, die den angegebenen Bindungsflags entsprechen.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> representing the global fields defined on the module that match the specified binding flags; if no global fields match the binding flags, an empty array is returned.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, das die für das Modul definierten globalen Felder darstellt, die den angegebenen Bindungsflags entsprechen; wenn keine globalen Felder den Bindungsflags entsprechen, wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Module.GetFields%2A&gt;</ph> Methode gibt keinen zurück Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">Der Code muss nicht auf die Reihenfolge, in der Felder zurückgegeben werden, abhängen, da dieser Reihenfolge variieren kann.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Gibt den Hashcode für diese Instanz zurück.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns a method having the specified criteria.</source>
          <target state="translated">Gibt eine Methode mit den angegebenen Kriterien zurück.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source>The method name.</source>
          <target state="translated">Der Methodenname.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source>Returns a method having the specified name.</source>
          <target state="translated">Gibt eine Methode mit dem angegebenen Namen zurück.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object having the specified name, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph>-Objekt mit dem angegebenen Namen oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn die Methode nicht existiert.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>The method name.</source>
          <target state="translated">Der Methodenname.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>The parameter types to search for.</source>
          <target state="translated">Die zu suchenden Parametertypen.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>Returns a method having the specified name and parameter types.</source>
          <target state="translated">Gibt eine Methode mit den angegebenen Namen und Parametertypen zurück.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object in accordance with the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph>-Objekt, das den angegebenen Kriterien entspricht, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn die Methode nicht vorhanden ist.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph4">&lt;see langword="null" /&gt;</ph>, oder <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) ist <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">Der Methodenname.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Eines der <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>-Bitflags zum Steuern der Suche.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that implements <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, containing properties related to this method.</source>
          <target state="translated">Ein Objekt, das <ph id="ph1">&lt;see langword="Binder" /&gt;</ph> implementiert, das auf diese Methode bezogene Eigenschaften enthält.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling convention for the method.</source>
          <target state="translated">Die Aufrufkonvention für die Methode.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The parameter types to search for.</source>
          <target state="translated">Die zu suchenden Parametertypen.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</source>
          <target state="translated">Ein Array von Parametermodifizierern, das zur Bindung mit Parametersignaturen verwendet wird, in denen die Typen geändert wurden.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Returns a method having the specified name, binding information, calling convention, and parameter types and modifiers.</source>
          <target state="translated">Gibt eine Methode mit dem angegebenen Namen, den Bindungsinformationen, der Aufrufkonvention, Parametertypen und Modifizierern zurück.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object in accordance with the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph>-Objekt, das den angegebenen Kriterien entspricht, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn die Methode nicht vorhanden ist.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph4">&lt;see langword="null" /&gt;</ph>, oder <ph id="ph5">&lt;paramref name="types" /&gt;</ph> (i) ist <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">Der Methodenname.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Eines der <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>-Bitflags zum Steuern der Suche.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that implements <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, containing properties related to this method.</source>
          <target state="translated">Ein Objekt, das <ph id="ph1">&lt;see langword="Binder" /&gt;</ph> implementiert, das auf diese Methode bezogene Eigenschaften enthält.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling convention for the method.</source>
          <target state="translated">Die Aufrufkonvention für die Methode.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The parameter types to search for.</source>
          <target state="translated">Die zu suchenden Parametertypen.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</source>
          <target state="translated">Ein Array von Parametermodifizierern, das zur Bindung mit Parametersignaturen verwendet wird, in denen die Typen geändert wurden.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Returns the method implementation in accordance with the specified criteria.</source>
          <target state="translated">Gibt die Methodenimplementierung in Übereinstimmung mit den angegebenen Kriterien zurück.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> object containing implementation information as specified, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method does not exist.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph>-Objekt mit den angegebenen Implementierungsinformationen oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn die Methode nicht vorhanden ist.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the global methods defined on the module</source>
          <target state="translated">Gibt die für das Modul definierten globalen Methoden zurück.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods">
          <source>Returns the global methods defined on the module.</source>
          <target state="translated">Gibt die globalen Methoden zurück, die im Modul definiert sind.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all the global methods defined on the module; if there are no global methods, an empty array is returned.</source>
          <target state="translated">Ein Array aus <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>-Objekten, das alle im Modul definierten globalen Methoden darstellt. Wenn keine globalen Methoden vorhanden sind, wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limit the search.</source>
          <target state="translated">Eine bitweise Kombination von <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>-Werten, die die Suche einschränken.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns the global methods defined on the module that match the specified binding flags.</source>
          <target state="translated">Gibt die für das Modul definierten globalen Methoden zurück, die den angegebenen Bindungsflags entsprechen.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> representing the global methods defined on the module that match the specified binding flags; if no global methods match the binding flags, an empty array is returned.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, das die für das Modul definierten globalen Methoden darstellt, die den angegebenen Bindungsflags entsprechen; wenn keine globalen Methoden den Bindungsflags entsprechen, wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The information and data needed to serialize or deserialize an object.</source>
          <target state="translated">Die zum Serialisieren bzw. Deserialisieren eines Objekts benötigten Informationen und Daten.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The context for the serialization.</source>
          <target state="translated">Der Kontext für die Serialisierung.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Provides an <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> implementation for serialized objects.</source>
          <target state="translated">Stellt eine <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph>-Implementierung für serialisierte Objekte bereit.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, a combination of the <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph> values indicating the nature of the code in the module.</source>
          <target state="translated">Diese Methode gibt eine Kombination der <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph>-Werte zurück, die die Merkmale des Codes im Modul angeben.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, one of the <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph> values indicating the platform targeted by the module.</source>
          <target state="translated">Diese Methode gibt einen der <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph>-Werte zurück, die die Plattform angeben, die das Ziel des Moduls darstellt.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</source>
          <target state="translated">Ruft ein Paar von Werten ab, die die Merkmale des Codes in einem Modul und die Plattform angeben, die das Ziel dieses Moduls darstellt.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetSignerCertificate">
          <source>Returns an <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph>-Objekt zurück, das dem in der Authenticode-Signatur enthaltenen Zertifikat der Assembly entspricht, zu der dieses Modul gehört.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetSignerCertificate">
          <source>If the assembly has not been Authenticode signed, <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Wenn die Assembly nicht mit Authenticode signiert wurde, wird <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetSignerCertificate">
          <source>An <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph> object, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the assembly to which this module belongs has not been Authenticode signed.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="X509Certificate" /&gt;</ph>-Objekt oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn die Assembly, zu der dieses Modul gehört, nicht mit Authenticode signiert wurde.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the specified type.</source>
          <target state="translated">Gibt den angegebenen Typ zurück.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The name of the type to locate.</source>
          <target state="translated">Der Name des zu suchenden Typs.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The name must be fully qualified with the namespace.</source>
          <target state="translated">Der Name muss im Namespace vollqualifiziert sein.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>Returns the specified type, performing a case-sensitive search.</source>
          <target state="translated">Gibt den angegebenen Typ zurück. Bei der Suche wird die Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the given type, if the type is in this module; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="Type" /&gt;</ph>-Objekt, das den angegebenen Typ darstellt, wenn der Typ sich in diesem Modul befindet; andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Wenn der Typ an einer anderen Assembly weitergeleitet wurde, ist es immer noch von dieser Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Informationen zum Weiterleiten von Typen finden Sie unter <bpt id="p1">[</bpt>Typweiterleitung in der Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ein Typ abgerufen werden kann, aus einem bestimmten Modul mit <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>Calling <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> on the module that contains the manifest will not search the entire assembly.</source>
          <target state="translated">Aufrufen von <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> für das Modul mit dem Manifest wird nicht durchsucht die gesamte Assembly.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Zum Abrufen eines Typs aus einer Assembly, unabhängig davon, welches Modul ist, rufen Sie <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The following example displays the name of a type in the specified module.</source>
          <target state="translated">Das folgende Beispiel zeigt den Namen eines Typs im angegebenen Modul an.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The class initializers are invoked and an exception is thrown.</source>
          <target state="translated">Die Klasseninitialisierer werden aufgerufen, und eine Ausnahme wird ausgelöst.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> ist eine Zeichenfolge mit der Länge 0 (null).</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die nicht gefunden wurde.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die gefunden wurde, aber nicht geladen werden konnte.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen, und <ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die nicht vorab geladen wurde.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die Datei ist jedoch keine gültige Assembly.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die für eine Version der Laufzeit kompiliert wurde, die höher als die derzeit geladene Version ist.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The name of the type to locate.</source>
          <target state="translated">Der Name des zu suchenden Typs.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The name must be fully qualified with the namespace.</source>
          <target state="translated">Der Name muss im Namespace vollqualifiziert sein.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for case-insensitive search; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> für die Suche ohne Beachtung der Groß-/Kleinschreibung; andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>Returns the specified type, searching the module with the specified case sensitivity.</source>
          <target state="translated">Durchsucht das Modul mit der angegebenen Groß-/Kleinschreibung und gibt den angegebenen Typ zurück.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the given type, if the type is in this module; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="Type" /&gt;</ph>-Objekt, das den angegebenen Typ darstellt, wenn der Typ sich in diesem Modul befindet; andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Wenn der Typ an einer anderen Assembly weitergeleitet wurde, ist es immer noch von dieser Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Informationen zum Weiterleiten von Typen finden Sie unter <bpt id="p1">[</bpt>Typweiterleitung in der Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ein Typ abgerufen werden kann, aus einem bestimmten Modul mit <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>Calling <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> on the module that contains the manifest will not search the entire assembly.</source>
          <target state="translated">Aufrufen von <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> für das Modul mit dem Manifest wird nicht durchsucht die gesamte Assembly.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Zum Abrufen eines Typs aus einer Assembly, unabhängig davon, welches Modul ist, rufen Sie <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The following example displays the name of a type in the specified module, specifying <ph id="ph1">`false`</ph> for the <ph id="ph2">`ignoreCase`</ph> parameter so that case will not be ignored.</source>
          <target state="translated">Das folgende Beispiel zeigt den Namen eines Typs im angegebenen Modul angeben <ph id="ph1">`false`</ph> für die <ph id="ph2">`ignoreCase`</ph> an, damit dieser Fall werden nicht ignoriert.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The class initializers are invoked and an exception is thrown.</source>
          <target state="translated">Die Klasseninitialisierer werden aufgerufen, und eine Ausnahme wird ausgelöst.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> ist eine Zeichenfolge mit der Länge 0 (null).</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die nicht gefunden wurde.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die gefunden wurde, aber nicht geladen werden konnte.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen, und <ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die nicht vorab geladen wurde.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die Datei ist jedoch keine gültige Assembly.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die für eine Version der Laufzeit kompiliert wurde, die höher als die derzeit geladene Version ist.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name of the type to locate.</source>
          <target state="translated">Der Name des zu suchenden Typs.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name must be fully qualified with the namespace.</source>
          <target state="translated">Der Name muss im Namespace vollqualifiziert sein.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, damit <ph id="ph3">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for case-insensitive search; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> für die Suche ohne Beachtung der Groß-/Kleinschreibung; andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Returns the specified type, specifying whether to make a case-sensitive search of the module and whether to throw an exception if the type cannot be found.</source>
          <target state="translated">Gibt den angegebenen Typ zurück, wobei angegeben wird, ob bei der Suche im Modul die Groß- und Kleinschreibung berücksichtigt wird, und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden werden kann.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the specified type, if the type is declared in this module; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das den angegebenen Typ darstellt, wenn der Typ in diesem Modul deklariert ist, andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter affects only what happens when the type is not found.</source>
          <target state="translated">Die <ph id="ph1">`throwOnError`</ph> Parameter wirkt sich auf nur was geschieht, wenn der Typ nicht gefunden wird.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>It does not affect any other exceptions that might be thrown.</source>
          <target state="translated">Dies beeinflusst keine andere Ausnahmen, die möglicherweise ausgelöst werden.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In particular, if the type is found but cannot be loaded, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> can be thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Insbesondere, wenn der Typ gefunden wird, kann nicht geladen werden kann <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> kann ausgelöst werden, selbst wenn <ph id="ph2">`throwOnError`</ph> ist <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">Wenn der Typ an einer anderen Assembly weitergeleitet wurde, ist es immer noch von dieser Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Informationen zum Weiterleiten von Typen finden Sie unter <bpt id="p1">[</bpt>Typweiterleitung in der Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ein Typ abgerufen werden kann, aus einem bestimmten Modul mit <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Calling <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> on the module that contains the manifest will not search the entire assembly.</source>
          <target state="translated">Aufrufen von <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph> für das Modul mit dem Manifest wird nicht durchsucht die gesamte Assembly.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Zum Abrufen eines Typs aus einer Assembly, unabhängig davon, welches Modul ist, rufen Sie <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following example displays the name of a type in the specified module.</source>
          <target state="translated">Das folgende Beispiel zeigt den Namen eines Typs im angegebenen Modul an.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> and <ph id="ph2">`ignoreCase`</ph> parameters are specified as <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Die <ph id="ph1">`throwOnError`</ph> und <ph id="ph2">`ignoreCase`</ph> als Parameter angegeben sind <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The class initializers are invoked and an exception is thrown.</source>
          <target state="translated">Die Klasseninitialisierer werden aufgerufen, und eine Ausnahme wird ausgelöst.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> ist eine Zeichenfolge mit der Länge 0 (null).</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, and the type cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und der Typ wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die nicht gefunden wurde.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die gefunden wurde, aber nicht geladen werden konnte.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">Die aktuelle Assembly wurde in den reflektionsbezogenen Kontext geladen, und <ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die nicht vorab geladen wurde.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die Datei ist jedoch keine gültige Assembly.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> erfordert eine abhängige Assembly, die für eine Version der Laufzeit kompiliert wurde, die höher als die derzeit geladene Version ist.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>Returns all the types defined within this module.</source>
          <target state="translated">Gibt alle in diesem Modul definierten Typen zurück.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing types defined within the module that is reflected by this instance.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, das Typen enthält, die in dem von dieser Instanz reflektierten Modul definiert werden.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source><ph id="ph1">`ReflectionTypeLoadException`</ph> is a special load exception.</source>
          <target state="translated"><ph id="ph1">`ReflectionTypeLoadException`</ph> ist eine besondere Ausnahme beim Laden.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> property contains the array of types that were defined in the module and were loaded.</source>
          <target state="translated">Die <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> -Eigenschaft enthält das Array von Typen, die im Modul definiert und geladen wurden.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>This array may contain some null values.</source>
          <target state="translated">Dieses Array kann einige null-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> property is an array of exceptions that represent the exceptions that were thrown by the loader.</source>
          <target state="translated">Die <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> Eigenschaft ist ein Array von Ausnahmen, die Ausnahmen darstellen, die vom Ladeprogramm ausgelöst wurden.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>The holes in the class array line up with the exceptions.</source>
          <target state="translated">Richten Sie die Lücken in der Klasse Array mit den Ausnahmen.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>For example, if the class initializers of one of the classes throws an exception while it is being loaded, a <ph id="ph1">`TargetInvocationException`</ph> is stored in the corresponding element of the <ph id="ph2">`LoaderExceptions`</ph> array.</source>
          <target state="translated">Z. B. wenn eine der Klassen der Klasseninitialisierer löst eine Ausnahme während der es wird geladen, eine <ph id="ph1">`TargetInvocationException`</ph> befindet sich in dem entsprechenden Element des der <ph id="ph2">`LoaderExceptions`</ph> Array.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>If a type has been forwarded to another assembly, it is not included in the returned array.</source>
          <target state="translated">Wenn Sie ein Typ an einer anderen Assembly weitergeleitet wurde, ist es nicht im zurückgegebenen Array enthalten.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">Informationen zum Weiterleiten von Typen finden Sie unter <bpt id="p1">[</bpt>Typweiterleitung in der Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>One or more classes in a module could not be loaded.</source>
          <target state="translated">Mindestens eine Klasse in einem Modul konnte nicht geladen werden.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.GetTypes">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.GetTypes">
          <source>Reflection permission for the current module.</source>
          <target state="translated">Reflektionsberechtigung für das aktuelle Modul.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>The type of custom attribute to test for.</source>
          <target state="translated">Der Typ des benutzerdefinierten Attributs, auf das getestet werden soll.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Dieses Argument wird für Objekte dieses Typs ignoriert.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>Returns a value that indicates whether the specified attribute type has been applied to this module.</source>
          <target state="translated">Gibt einen Wert zurück, der angibt, ob der angegebene Attributtyp auf dieses Modul angewendet wurde.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> have been applied to this module; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn eine oder mehrere Instanzen von <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> auf dieses Modul angewendet werden, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsDefined`</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">`IsDefined`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist kein von der Laufzeit angegebenes <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist beispielsweise ein <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsResource">
          <source>Gets a value indicating whether the object is a resource.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob das Objekt eine Ressource ist.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.IsResource">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the object is a resource; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das Objekt eine Ressource ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.IsResource">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsResource`</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">`IsResource`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>Gets the metadata stream version.</source>
          <target state="translated">Ruft die Metadatenstreamversion ab.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>A 32-bit integer representing the metadata stream version.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die die Metadatenstreamversion darstellt.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</source>
          <target state="translated">Die beiden höherwertigen Bytes stellen die Hauptversionsnummer dar und die beiden niederwertigen Bytes die Nebenversionsnummer.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</source>
          <target state="translated">Weitere Informationen zu den Metadatenheader finden Sie unter "Partition II: Metadata Definition and Semantics" in der Dokumentation für die Common Language Infrastructure (CLI).</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MDStreamVersion">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.MetadataToken">
          <source>Gets a token that identifies the module in metadata.</source>
          <target state="translated">Ruft ein Token ab, das das Modul in den Metadaten angibt.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>An integer token that identifies the current module in metadata.</source>
          <target state="translated">Ein Ganzzahltoken, das das aktuelle Modul in den Metadaten angibt.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>The tokens obtained using this property can be passed to the unmanaged Reflection API.</source>
          <target state="translated">Das Token mit dieser Eigenschaft können auf der nicht verwalteten Reflektions-API übergeben werden.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>For more information, see <bpt id="p1">[</bpt>Unmanaged Reflection API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>nicht verwalteten Reflektions-API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.MetadataToken">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.ModuleHandle">
          <source>Gets a handle for the module.</source>
          <target state="translated">Ruft ein Handle für das Modul ab.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.ModuleHandle" /&gt;</ph> structure for the current module.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.ModuleHandle" /&gt;</ph>-Struktur für das aktuelle Modul.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</source>
          <target state="translated">Ruft einen universellen eindeutigen Bezeichner (Universally Unique Identifier, UUID) ab, der zur Unterscheidung zwischen zwei Versionen eines Moduls verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>A <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> that can be used to distinguish between two versions of a module.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph>, die zur Unterscheidung zwischen zwei Versionen eines Moduls verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>In unmanaged metadata, the GUID returned by the <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> property is referred to as the <ph id="ph2">`mvid`</ph>, and is stored in the GUID heap.</source>
          <target state="translated">In nicht verwalteten Metadaten, die GUID zurückgegeben, indem Sie die <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> Eigenschaft wird als bezeichnet den <ph id="ph2">`mvid`</ph>, und im GUID-Heap gespeichert wird.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Weitere Informationen zu Metadaten kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ModuleVersionId">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.Name">
          <source>Gets a <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the name of the module with the path removed.</source>
          <target state="translated">Ruft einen <ph id="ph1">&lt;see langword="String" /&gt;</ph> ab, der den Namen des Moduls ohne den Pfad darstellt.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>The module name with no path.</source>
          <target state="translated">Der Modulname ohne Pfad.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source><ph id="ph1">`Name`</ph> is a platform-dependent string.</source>
          <target state="translated"><ph id="ph1">`Name`</ph> ist eine plattformabhängige Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>If the assembly for this module was loaded from a byte array then the <ph id="ph1">`FullyQualifiedName`</ph> for the module will be: <ph id="ph2">\&lt;</ph>Unknown&gt;.</source>
          <target state="translated">Wenn die Assembly für dieses Modul aus einem Bytearray geladen wurde und dann die <ph id="ph1">`FullyQualifiedName`</ph> für das Modul: <ph id="ph2">\&lt;</ph>unbekannt &gt;.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>To get the name and the path, use <ph id="ph1">&lt;xref:System.Reflection.Module.FullyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">Verwenden Sie zum Abrufen der Name und Pfad <ph id="ph1">&lt;xref:System.Reflection.Module.FullyQualifiedName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.Name">
          <source>This example shows the effect of the <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, and <ph id="ph3">`Name`</ph> properties.</source>
          <target state="translated">Dieses Beispiel zeigt die Auswirkung der <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, und <ph id="ph3">`Name`</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source>The first object to compare.</source>
          <target state="translated">Das erste zu vergleichende Objekt.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source>The second object to compare.</source>
          <target state="translated">Das zweite zu vergleichende Objekt.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> objects are equal.</source>
          <target state="translated">Gibt an, ob zwei <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>-Objekte gleich sind.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="left" /&gt;</ph> und <ph id="ph3">&lt;paramref name="right" /&gt;</ph> gleich sind, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source>The first object to compare.</source>
          <target state="translated">Das erste zu vergleichende Objekt.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source>The second object to compare.</source>
          <target state="translated">Das zweite zu vergleichende Objekt.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Gibt an, ob zwei <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>-Objekte ungleich sind.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="left" /&gt;</ph> und <ph id="ph3">&lt;paramref name="right" /&gt;</ph> ungleich sind, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the field identified by a metadata token.</source>
          <target state="translated">Gibt das von einem Metadatentoken angegebene Feld zurück.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>A metadata token that identifies a field in the module.</source>
          <target state="translated">Ein Metadatentoken, das ein Feld im Modul angibt.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>Returns the field identified by the specified metadata token.</source>
          <target state="translated">Gibt das vom angegebenen Metadatentoken angegebene Feld zurück.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field that is identified by the specified metadata token.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>-Objekt, das das durch das angegebene Metadatentoken angegebene Feld darstellt.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>To resolve a metadata token that identifies a field whose parent <ph id="ph1">`TypeSpec`</ph> has a signature containing element type <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Auflösen ein Metadatentoken, das einen Feld identifiziert, dessen übergeordnetes Objekt <ph id="ph1">`TypeSpec`</ph> verfügt über eine Signatur, die mit dem Elementtyp <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> oder <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, verwenden Sie die <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> methodenüberladung, die Ihnen ermöglicht, den erforderlichen Kontext bereitzustellen.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>That is, when you are resolving a metadata token for a field that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">D. h. Wenn Sie ein Metadatentoken für ein Feld auflösen, die davon abhängen die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist, müssen Sie die Überladung verwenden, die Sie diesen Typparameter bereitstellen können.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a field in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein Token für ein Feld.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a field whose parent <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> has a signature containing element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> gibt ein Feld an, dessen übergeordnete <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> eine Signatur mit Elementtyp <ph id="ph3">&lt;see langword="var" /&gt;</ph> (Typparameter eines generischen Typs) oder <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (Typparameter einer generischen Methode) aufweist.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a field in the module.</source>
          <target state="translated">Ein Metadatentoken, das ein Feld im Modul angibt.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente des Typs darstellen, in dessen Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn dieser Typ nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente der Methode darstellen, in deren Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn diese Methode nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Gibt das vom angegebenen Metadatentoken angegebene Feld im von den angegebenen generischen Typparametern definierten Kontext zurück.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field that is identified by the specified metadata token.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>-Objekt, das das durch das angegebene Metadatentoken angegebene Feld darstellt.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> -Methode des Typs, in dem <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> Methode für die Methode, in denen <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a field in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein Token für ein Feld.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a field whose parent <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> has a signature containing element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> gibt ein Feld an, dessen übergeordnete <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> eine Signatur mit Elementtyp <ph id="ph3">&lt;see langword="var" /&gt;</ph> (Typparameter eines generischen Typs) oder <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (Typparameter einer generischen Methode) aufweist, und die erforderlichen Argumente des generischen Typs wurden nicht für <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> und/oder <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> angegeben.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the type or member identified by a metadata token.</source>
          <target state="translated">Gibt den von einem Metadatentoken angegebenen Typ oder Member zurück.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>A metadata token that identifies a type or member in the module.</source>
          <target state="translated">Ein Metadatentoken, das einen Typ oder Member im Modul angibt.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>Returns the type or member identified by the specified metadata token.</source>
          <target state="translated">Gibt den vom angegebenen Metadatentoken angegebenen Typ oder Member zurück.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object representing the type or member that is identified by the specified metadata token.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Objekt, das den Typ oder Member darstellt, der vom angegebenen Metadatentoken angegeben wird.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>To resolve a metadata token for a <ph id="ph1">`MethodSpec`</ph> or <ph id="ph2">`TypeSpec`</ph> whose signature contains element type <ph id="ph3">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph4">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph5">&lt;xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Ein Metadatentoken für Auflösen einer <ph id="ph1">`MethodSpec`</ph> oder <ph id="ph2">`TypeSpec`</ph> , dessen Signatur enthält Elementtyp <ph id="ph3">`ELEMENT_TYPE_VAR`</ph> oder <ph id="ph4">`ELEMENT_TYPE_MVAR`</ph>, verwenden die <ph id="ph5">&lt;xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> methodenüberladung, die Ihnen ermöglicht, den erforderlichen Kontext bereitzustellen.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>That is, when you are resolving a metadata token for a member that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">D. h. Wenn Sie ein Metadatentoken für ein Element aufgelöst werden, die davon abhängen die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist, müssen Sie die Überladung verwenden, die Sie diesen Typparameter bereitstellen können.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type or member in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Gültigkeitsbereich des aktuellen Moduls kein Token für einen Typ oder Member.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> or <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph4">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist eine <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> oder eine <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph>, deren Signatur Elementtyp <ph id="ph4">&lt;see langword="var" /&gt;</ph> (Typparameter eines generischen Typs) oder <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (Typparameter einer generischen Methode) enthält.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a property or event.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> gibt eine Eigenschaft oder ein Ereignis an.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type or member in the module.</source>
          <target state="translated">Ein Metadatentoken, das einen Typ oder Member im Modul angibt.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente des Typs darstellen, in dessen Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn dieser Typ nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente der Methode darstellen, in deren Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn diese Methode nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Gibt den vom angegebenen Metadatentoken angegebenen Typ oder Member im von den angegebenen generischen Typparametern definierten Kontext zurück.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object representing the type or member that is identified by the specified metadata token.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Objekt, das den Typ oder Member darstellt, der vom angegebenen Metadatentoken angegeben wird.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> -Methode des Typs, in dem <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> Methode für die Methode, in denen <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type or member in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Gültigkeitsbereich des aktuellen Moduls kein Token für einen Typ oder Member.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> or <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph4">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist eine <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> oder eine <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph>, deren Signatur Elementtyp <ph id="ph4">&lt;see langword="var" /&gt;</ph> (Typparameter eines generischen Typs) oder <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (Typparameter einer generischen Methode) enthält, und die erforderlichen Argumente des generischen Typs wurden nicht für <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> und/oder <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph> angegeben.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a property or event.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> gibt eine Eigenschaft oder ein Ereignis an.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the method identified by a metadata token.</source>
          <target state="translated">Gibt die von einem Metadatentoken angegebene Methode zurück.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>A metadata token that identifies a method or constructor in the module.</source>
          <target state="translated">Ein Metadatentoken, das eine Methode oder einen Konstruktor im Modul identifiziert.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Returns the method or constructor identified by the specified metadata token.</source>
          <target state="translated">Gibt die Methode oder den Konstruktor zurück, die bzw. der vom angegebenen Metadatentoken angegeben wird.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method or constructor that is identified by the specified metadata token.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>-Objekt, das die Methode oder den Konstruktor darstellt, die bzw. der vom angegebenen Metadatentoken angegeben wird.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>To resolve a metadata token for a <ph id="ph1">`MethodSpec`</ph> whose signature contains element type <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Ein Metadatentoken für Auflösen einer <ph id="ph1">`MethodSpec`</ph> , dessen Signatur enthält Elementtyp <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> oder <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, verwenden die <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> methodenüberladung, die Ihnen ermöglicht, den erforderlichen Kontext bereitzustellen.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>That is, when you are resolving a metadata token for a method that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">D. h. Wenn Sie ein Metadatentoken für eine Methode, die die generischen Typparameter eines generischen Typs hängt und/oder der generischen Methode, die in der das Token eingebettet wird aufgelöst werden, müssen Sie die Überladung verwenden, die Sie diesen Typparameter bereitstellen können.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The following example shows how to use the two overloads of the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> method to resolve metadata tokens from call sites in generic and non-generic contexts.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die zwei Überladungen der <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> -Methode zum Auflösen von Metadatentoken Aufrufs in generischen und nicht generischen Kontexten sites.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The code example defines two generic types, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> and <ph id="ph2">`G2&lt;Tg2&gt;`</ph> (<ph id="ph3">`G1(Of Tg1)`</ph> and <ph id="ph4">`G2(Of Tg2)`</ph> in Visual Basic), each of which has a generic method.</source>
          <target state="translated">Das Codebeispiel definiert zwei generische Typen <ph id="ph1">`G1&lt;Tg1&gt;`</ph> und <ph id="ph2">`G2&lt;Tg2&gt;`</ph> (<ph id="ph3">`G1(Of Tg1)`</ph> und <ph id="ph4">`G2(Of Tg2)`</ph> in Visual Basic), von denen jede verfügt über eine generische Methode.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">`G1&lt;Tg1&gt;`</ph> also has a non-generic method that uses the type parameter <ph id="ph2">`Tg1`</ph> for its parameter.</source>
          <target state="translated"><ph id="ph1">`G1&lt;Tg1&gt;`</ph> verfügt auch über eine nicht generische Methode, die die Typparameter <ph id="ph2">`Tg1`</ph> für ihre Parameter.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The generic method <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> in type <ph id="ph2">`G2&lt;Tg2&gt;`</ph> contains several method calls:</source>
          <target state="translated">Die generische Methode <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> im Typ <ph id="ph2">`G2&lt;Tg2&gt;`</ph> enthält mehrere Methodenaufrufe:</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 1: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, using the type parameters of <ph id="ph2">`G2&lt;Tg2&gt;`</ph> and <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> as the type arguments.</source>
          <target state="translated">Fall 1: Die generische Methode <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> aufgerufen wird, wird die Verwendung der Typparameter der <ph id="ph2">`G2&lt;Tg2&gt;`</ph> und <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> als Typargumente.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">Das heißt, die Parametertypen der aufgerufenen Methode hängen die Typen, die verwendet werden, so erstellen Sie einen geschlossenen generischen Typs aus der Typdefinition für <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 2: The non-generic method <ph id="ph1">`M1`</ph> is called.</source>
          <target state="translated">Fall 2: Die nicht generische Methode <ph id="ph1">`M1`</ph> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The parameter of this method uses the type parameter of the defining type, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, which is replaced in this case by the type parameter of the enclosing type, <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">Die Parameter dieser Methode verwendet den Typparameter des definierenden Typs <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, das in diesem Fall durch den Typparameter von einschließenden Typ ersetzt wird <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 3: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Fall 3: Die generische Methode <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> aufgerufen wird, wird die Angabe <ph id="ph2">&lt;xref:System.Int32&gt;</ph> und <ph id="ph3">&lt;xref:System.Object&gt;</ph> für die Typargumente eines generischen Typs und der generischen Methode bzw.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Dieser Methodenaufruf ist nicht von den Typparametern des einschließenden Typs oder der Methode abhängig.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 4: The non-generic method <ph id="ph1">`M1`</ph> of the <ph id="ph2">`Example`</ph> class is called.</source>
          <target state="translated">Fall 4: Die nicht generische Methode <ph id="ph1">`M1`</ph> von der <ph id="ph2">`Example`</ph> -Klasse aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Dieser Methodenaufruf ist nicht von den Typparametern des einschließenden Typs oder der Methode abhängig.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>In addition, the example defines the non-generic <ph id="ph1">`Example`</ph> class.</source>
          <target state="translated">Darüber hinaus definiert das Beispiel die nicht generische <ph id="ph1">`Example`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This class has a method <ph id="ph1">`M`</ph> that makes a call to a generic method:</source>
          <target state="translated">Diese Klasse verfügt über eine Methode <ph id="ph1">`M`</ph> , die eine generische Methode aufruft:</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Case 5: The generic method <ph id="ph1">`GM1`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Fall 5: Die generische Methode <ph id="ph1">`GM1`</ph> aufgerufen wird, wird die Angabe <ph id="ph2">&lt;xref:System.Int32&gt;</ph> und <ph id="ph3">&lt;xref:System.Object&gt;</ph> für die Typargumente eines generischen Typs und der generischen Methode bzw.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The context for this method has no enclosing generic type or generic method.</source>
          <target state="translated">Der Kontext für diese Methode hat keine einschließenden generischen Typ- oder Methodendefinition.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>For each case, the example first constructs a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents the called method, and then resolves the token using the <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, using the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> methods to get the values for the <ph id="ph5">`genericTypeArguments`</ph> and <ph id="ph6">`genericMethodArguments`</ph> parameters.</source>
          <target state="translated">Für jeden Fall im Beispiel wird zuerst erstellt ein <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , die die aufgerufene Methode darstellt, und löst dann das token mithilfe der <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> Methode zu überladen, mit der <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> Methoden zum Abrufen der Werte für die <ph id="ph5">`genericTypeArguments`</ph> und <ph id="ph6">`genericMethodArguments`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This technique works in all cases, because the methods return <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> for non-generic contexts.</source>
          <target state="translated">Dieses Verfahren kann in allen Fällen auf, da es sich bei den Methoden zurückgegebenen <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> für nicht generische Kontexte.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The example compares the resolved <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the constructed <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Im Beispiel vergleicht die aufgelöste <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> mit erstellten <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The example then attempts to use the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> method overload to resolve the token.</source>
          <target state="translated">Im Beispiel wird dann versucht, mithilfe der <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> -methodenüberladung, um das Token zu beheben.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</source>
          <target state="translated">Dies funktioniert in Fällen, 3, 4 und 5, da die Methodenaufrufe nicht generische Kontext abhängig sind.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</source>
          <target state="translated">In Fällen, 1 und 2 wird eine Ausnahme ausgelöst, da es nicht genügend Informationen zum Auflösen des Tokens ist.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The metadata token values are hard-coded as an enumeration.</source>
          <target state="translated">Die Tokenwerte Metadaten werden als eine Enumeration hartcodiert.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>If you change this code example, the token values are likely to change.</source>
          <target state="translated">Wenn Sie dieses Codebeispiel ändern, werden die Tokenwerte wahrscheinlich geändert.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>To determine the new token values, compile the code and use Ildasm.exe with the <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> option to examine the assembly.</source>
          <target state="translated">Um die neuen Werte zu bestimmen, den Code kompilieren und mithilfe von Ildasm.exe mit der <bpt id="p1">**</bpt>/Token<ept id="p1">**</ept> Option aus, um die Assembly zu untersuchen.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>The tokens can be found at the points of call.</source>
          <target state="translated">Das Token können an den Positionen des Aufrufs gefunden werden.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>Insert the new values into the enumeration, and recompile the example.</source>
          <target state="translated">Fügen Sie die neuen Werte in der Enumeration und kompilieren Sie das Beispiel.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a method or constructor in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein Token für eine Methode oder einen Konstruktor.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist eine <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph>, deren Signatur Elementtyp <ph id="ph3">&lt;see langword="var" /&gt;</ph> (Typparameter eines generischen Typs) oder <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (Typparameter einer generischen Methode) enthält.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a method or constructor in the module.</source>
          <target state="translated">Ein Metadatentoken, das eine Methode oder einen Konstruktor im Modul identifiziert.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente des Typs darstellen, in dessen Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn dieser Typ nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente der Methode darstellen, in deren Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn diese Methode nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Gibt die vom angegebenen Metadatentoken angegebene Methode oder den vom angegebenen Metadatentoken angegebenen Konstruktor im von den angegebenen generischen Typparametern definierten Kontext zurück.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method that is identified by the specified metadata token.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>-Objekt, das die Methode darstellt, die durch das angegebene Metadatentoken angegeben wird.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> -Methode des Typs, in dem <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericMethodArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> Methode für die Methode, in denen <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericMethodArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The following example shows how to use the two overloads of the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> method to resolve metadata tokens from call sites in generic and non-generic contexts.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie die zwei Überladungen der <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%2A&gt;</ph> -Methode zum Auflösen von Metadatentoken Aufrufs in generischen und nicht generischen Kontexten sites.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The code example defines two generic types, <ph id="ph1">`G1&lt;Tg1&gt;`</ph> and <ph id="ph2">`G2&lt;Tg2&gt;`</ph>, each of which has a generic method.</source>
          <target state="translated">Das Codebeispiel definiert zwei generische Typen <ph id="ph1">`G1&lt;Tg1&gt;`</ph> und <ph id="ph2">`G2&lt;Tg2&gt;`</ph>, von denen jede verfügt über eine generische Methode.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">`G1&lt;Tg1&gt;`</ph> also has a non-generic method that uses the type parameter <ph id="ph2">`Tg1`</ph> for its parameter.</source>
          <target state="translated"><ph id="ph1">`G1&lt;Tg1&gt;`</ph> verfügt auch über eine nicht generische Methode, die die Typparameter <ph id="ph2">`Tg1`</ph> für ihre Parameter.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The generic method <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> in type <ph id="ph2">`G2&lt;Tg2&gt;`</ph> contains several method calls:</source>
          <target state="translated">Die generische Methode <ph id="ph1">`GM2&lt;Tgm2&gt;`</ph> im Typ <ph id="ph2">`G2&lt;Tg2&gt;`</ph> enthält mehrere Methodenaufrufe:</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 1: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, using the type parameters of <ph id="ph2">`G2&lt;Tg2&gt;`</ph> and <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> as the type arguments.</source>
          <target state="translated">Fall 1: Die generische Methode <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> aufgerufen wird, wird die Verwendung der Typparameter der <ph id="ph2">`G2&lt;Tg2&gt;`</ph> und <ph id="ph3">`GM2&lt;Tgm2&gt;`</ph> als Typargumente.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">Das heißt, die Parametertypen der aufgerufenen Methode hängen die Typen, die verwendet werden, so erstellen Sie einen geschlossenen generischen Typs aus der Typdefinition für <ph id="ph1">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 2: The non-generic method <ph id="ph1">`M1`</ph> is called.</source>
          <target state="translated">Fall 2: Die nicht generische Methode <ph id="ph1">`M1`</ph> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The parameter of this method uses the type parameter of the defining type, <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, which is replaced in this case by the type parameter of the enclosing type, <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</source>
          <target state="translated">Die Parameter dieser Methode verwendet den Typparameter des definierenden Typs <ph id="ph1">`G1&lt;Tg1&gt;`</ph>, das in diesem Fall durch den Typparameter von einschließenden Typ ersetzt wird <ph id="ph2">`G2&lt;Tg2&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 3: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Fall 3: Die generische Methode <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> aufgerufen wird, wird die Angabe <ph id="ph2">&lt;xref:System.Int32&gt;</ph> und <ph id="ph3">&lt;xref:System.Object&gt;</ph> für die Typargumente eines generischen Typs und der generischen Methode bzw.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Dieser Methodenaufruf ist nicht von den Typparametern des einschließenden Typs oder der Methode abhängig.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 4: The non-generic method <ph id="ph1">`M1`</ph> of the <ph id="ph2">`Example`</ph> class is called.</source>
          <target state="translated">Fall 4: Die nicht generische Methode <ph id="ph1">`M1`</ph> von der <ph id="ph2">`Example`</ph> -Klasse aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This method call does not depend on the type parameters of the enclosing type or method.</source>
          <target state="translated">Dieser Methodenaufruf ist nicht von den Typparametern des einschließenden Typs oder der Methode abhängig.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>In addition, the example defines the non-generic <ph id="ph1">`Example`</ph> class.</source>
          <target state="translated">Darüber hinaus definiert das Beispiel die nicht generische <ph id="ph1">`Example`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This class has a method <ph id="ph1">`M`</ph> that makes a call to a generic method.</source>
          <target state="translated">Diese Klasse verfügt über eine Methode <ph id="ph1">`M`</ph> , die eine generische Methode aufruft.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Case 5: The generic method <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> is called, specifying <ph id="ph2">&lt;xref:System.Int32&gt;</ph> and <ph id="ph3">&lt;xref:System.Object&gt;</ph> for the type arguments of the generic type and the generic method, respectively.</source>
          <target state="translated">Fall 5: Die generische Methode <ph id="ph1">`GM1&lt;Tgm1&gt;`</ph> aufgerufen wird, wird die Angabe <ph id="ph2">&lt;xref:System.Int32&gt;</ph> und <ph id="ph3">&lt;xref:System.Object&gt;</ph> für die Typargumente eines generischen Typs und der generischen Methode bzw.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The context for this method has no enclosing generic type or generic method.</source>
          <target state="translated">Der Kontext für diese Methode hat keine einschließenden generischen Typ- oder Methodendefinition.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>For each case, the example first constructs a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents the called method, and then resolves the token using the <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, using the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> methods to get the values for the <ph id="ph5">`genericTypeArguments`</ph> and <ph id="ph6">`genericMethodArguments`</ph> parameters.</source>
          <target state="translated">Für jeden Fall im Beispiel wird zuerst erstellt ein <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , die die aufgerufene Methode darstellt, und löst dann das token mithilfe der <ph id="ph2">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> Methode zu überladen, mit der <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> Methoden zum Abrufen der Werte für die <ph id="ph5">`genericTypeArguments`</ph> und <ph id="ph6">`genericMethodArguments`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This technique works in all cases, because the methods return <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> for non-generic contexts.</source>
          <target state="translated">Dieses Verfahren kann in allen Fällen auf, da es sich bei den Methoden zurückgegebenen <ph id="ph1">&lt;xref:System.Type.EmptyTypes?displayProperty=nameWithType&gt;</ph> für nicht generische Kontexte.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The example compares the resolved <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the constructed <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Im Beispiel vergleicht die aufgelöste <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> mit erstellten <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The example then attempts to use the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> method overload to resolve the token.</source>
          <target state="translated">Im Beispiel wird dann versucht, mithilfe der <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%29&gt;</ph> -methodenüberladung, um das Token zu beheben.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</source>
          <target state="translated">Dies funktioniert in Fällen, 3, 4 und 5, da die Methodenaufrufe nicht generische Kontext abhängig sind.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</source>
          <target state="translated">In Fällen, 1 und 2 wird eine Ausnahme ausgelöst, da es nicht genügend Informationen zum Auflösen des Tokens ist.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The metadata token values are hard-coded as an enumeration.</source>
          <target state="translated">Die Tokenwerte Metadaten werden als eine Enumeration hartcodiert.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>If you change this code example, the token values are likely to change.</source>
          <target state="translated">Wenn Sie dieses Codebeispiel ändern, werden die Tokenwerte wahrscheinlich geändert.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>To determine the new token values, compile the code and use Ildasm.exe with the <bpt id="p1">**</bpt>/TOKENS<ept id="p1">**</ept> option to examine the assembly.</source>
          <target state="translated">Um die neuen Werte zu bestimmen, den Code kompilieren und mithilfe von Ildasm.exe mit der <bpt id="p1">**</bpt>/Token<ept id="p1">**</ept> Option aus, um die Assembly zu untersuchen.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The tokens can be found at the points of call.</source>
          <target state="translated">Das Token können an den Positionen des Aufrufs gefunden werden.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Insert the new values into the enumeration, and recompile the example.</source>
          <target state="translated">Fügen Sie die neuen Werte in der Enumeration und kompilieren Sie das Beispiel.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a method or constructor in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein Token für eine Methode oder einen Konstruktor.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist eine <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph>, deren Signatur Elementtyp <ph id="ph3">&lt;see langword="var" /&gt;</ph> (Typparameter eines generischen Typs) oder <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (Typparameter einer generischen Methode) enthält, und die erforderlichen Argumente des generischen Typs wurden für <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> und/oder <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> nicht angegeben.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>A metadata token that identifies a signature in the module.</source>
          <target state="translated">Ein Metadatentoken, das eine Signatur im Modul angibt.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>Returns the signature blob identified by a metadata token.</source>
          <target state="translated">Gibt das von einem Metadatentoken angegebene Signatur-BLOB zurück.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>An array of bytes representing the signature blob.</source>
          <target state="translated">Ein Bytearray, das den Signatur-BLOB darstellt.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken und Signaturen kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph>, signature, or <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph> token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist keine gültige <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph> oder Signatur bzw. kein gültiges <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph>-Token im Bereich des aktuellen Moduls.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>A metadata token that identifies a string in the string heap of the module.</source>
          <target state="translated">Ein Metadatentoken, das eine Zeichenfolge im Zeichenfolgenheap des Moduls angibt.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>Returns the string identified by the specified metadata token.</source>
          <target state="translated">Gibt die vom angegebenen Metadatentoken angegebene Zeichenfolge zurück.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing a string value from the metadata string heap.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, der einen Zeichenfolgenwert aus dem Metadaten-Zeichenfolgenheap enthält.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a string in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Gültigkeitsbereich des aktuellen Moduls kein Token für eine Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="T:System.Reflection.Module">
          <source>Returns the type identified by a metadata token.</source>
          <target state="translated">Gibt den von einem Metadatentoken angegebenen Typ zurück.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>A metadata token that identifies a type in the module.</source>
          <target state="translated">Ein Metadatentoken, das einen Typ im Modul identifiziert.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>Returns the type identified by the specified metadata token.</source>
          <target state="translated">Gibt den vom angegebenen Metadatentoken angegebenen Typ zurück.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the type that is identified by the specified metadata token.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das den Typ darstellt, der durch das angegebene Metadatentoken angegeben wird.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>To resolve a metadata token for a <ph id="ph1">`TypeSpec`</ph> whose signature contains <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> or <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, use the <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method overload, which allows you to supply the necessary context.</source>
          <target state="translated">Ein Metadatentoken für Auflösen einer <ph id="ph1">`TypeSpec`</ph> enthält, dessen Signatur <ph id="ph2">`ELEMENT_TYPE_VAR`</ph> oder <ph id="ph3">`ELEMENT_TYPE_MVAR`</ph>, verwenden die <ph id="ph4">&lt;xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> methodenüberladung, die Ihnen ermöglicht, den erforderlichen Kontext bereitzustellen.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>That is, when you are resolving a metadata token for a type that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</source>
          <target state="translated">Wenn Sie ein Metadatentoken für einen Typ aufgelöst werden, die davon abhängen die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist, müssen Sie eine Überladung verwenden, die Sie diesen Typparameter bereitstellen können.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein Token für einen Typ.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist eine <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph>, deren Signatur Elementtyp <ph id="ph3">&lt;see langword="var" /&gt;</ph> (Typparameter eines generischen Typs) oder <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (Typparameter einer generischen Methode) enthält.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type in the module.</source>
          <target state="translated">Ein Metadatentoken, das einen Typ im Modul identifiziert.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente des Typs darstellen, in dessen Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn dieser Typ nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente der Methode darstellen, in deren Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn diese Methode nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Gibt den vom angegebenen Metadatentoken angegebenen Typ im von den angegebenen generischen Typparametern definierten Kontext zurück.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the type that is identified by the specified metadata token.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das den Typ darstellt, der durch das angegebene Metadatentoken angegeben wird.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> -Methode des Typs, in dem <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> Methode für die Methode, in denen <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein Token für einen Typ.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist eine <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph>, deren Signatur Elementtyp <ph id="ph3">&lt;see langword="var" /&gt;</ph> (Typparameter eines generischen Typs) oder <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (Typparameter einer generischen Methode) enthält, und die erforderlichen Argumente des generischen Typs wurden für <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> und/oder <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> nicht angegeben.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="P:System.Reflection.Module.ScopeName">
          <source>Gets a string representing the name of the module.</source>
          <target state="translated">Ruft eine Zeichenfolge ab, die den Namen des Moduls darstellt.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>The module name.</source>
          <target state="translated">Der Modulname.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>The <ph id="ph1">`ScopeName`</ph> property is not used by the common language runtime, but you can use it to store any string you want in the property when you emit a module using the metadata APIs.</source>
          <target state="translated">Die <ph id="ph1">`ScopeName`</ph> Eigenschaft wird nicht von der common Language Runtime verwendet, aber Sie können es verwenden, um eine beliebige Zeichenfolge, die Sie möchten in der Eigenschaft zu speichern, wenn Sie ein Modul mit dem Metadaten-APIs ausgeben.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>Reflection itself does not allow you to set the <ph id="ph1">`ScopeName`</ph> property.</source>
          <target state="translated">Die Reflektion selbst lässt keine Festlegen der <ph id="ph1">`ScopeName`</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Module.ScopeName">
          <source>This example shows the effect of the <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, and <ph id="ph3">`Name`</ph> properties.</source>
          <target state="translated">Dieses Beispiel zeigt die Auswirkung der <ph id="ph1">`ScopeName`</ph>, <ph id="ph2">`FullyQualifiedName`</ph>, und <ph id="ph3">`Name`</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Für zukünftige Verwendung reserviert.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Muss IID_NULL sein.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Das übergebene Array von zuzuordnenden Namen.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Die Anzahl der zuzuordnenden Namen.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array that receives the IDs corresponding to the names.</source>
          <target state="translated">Das vom Aufrufer zugeordnete Array, das die IDs entsprechend den Namen empfängt.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Die zurückzugebenden Typinformationen.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Der Gebietsschemabezeichner für die Typinformationen.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Empfängt einen Zeiger auf das angeforderte Objekt mit den Typinformationen.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Bezeichnet den Member.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Für zukünftige Verwendung reserviert.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Muss IID_NULL sein.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Flags, die den Kontext des Aufrufs beschreiben.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Der Index des ersten Arguments mit einem Fehler.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::Invoke`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ToString">
          <source>Returns the name of the module.</source>
          <target state="translated">Gibt den Namen des Moduls zurück.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Module.ToString">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the name of this module.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="String" /&gt;</ph>, der den Namen dieses Moduls darstellt.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Module.ToString">
          <source>The following example demonstrates a use of the <ph id="ph1">`ToString`</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">`ToString`</ph> Methode.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>