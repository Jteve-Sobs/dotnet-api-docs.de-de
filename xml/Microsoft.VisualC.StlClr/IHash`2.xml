<Type Name="IHash&lt;TKey,TValue&gt;" FullName="Microsoft.VisualC.StlClr.IHash&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1c70694660ef684be49d7a7263211df5c5ad4ce7" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73376991" /></Metadata><TypeSignature Language="C#" Value="public interface IHash&lt;TKey,TValue&gt; : ICloneable, Microsoft.VisualC.StlClr.Generic.IBidirectionalContainer&lt;TValue&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract beforefieldinit IHash`2&lt;TKey, TValue&gt; implements class Microsoft.VisualC.StlClr.Generic.IBidirectionalContainer`1&lt;!TValue&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualC.StlClr.IHash`2" />
  <TypeSignature Language="VB.NET" Value="Public Interface IHash(Of TKey, TValue)&#xA;Implements IBidirectionalContainer(Of TValue), ICloneable, ICollection" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public interface class IHash : ICloneable, Microsoft::VisualC::StlClr::Generic::IBidirectionalContainer&lt;TValue&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type IHash&lt;'Key, 'Value&gt; = interface&#xA;    interface IBidirectionalContainer&lt;'Value&gt;&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>Microsoft.VisualC.StlClr.Generic.IBidirectionalContainer&lt;TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1005")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Der Typ der Schlüsselkomponente eines Elements in der kontrollierten Sequenz.</typeparam>
    <typeparam name="TValue">Der Typ der Wertkomponente eines Elements in der kontrollierten Sequenz.</typeparam>
    <summary>Definiert die Schnittstelle der folgenden STL/CLR-Objekte: <c>hash_map</c>, <c>hash_multimap</c>, <c>hash_set</c> und <c>hash_multiset</c>.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[unnamed_parm](~/includes/unnamed-parm-md.md)]  
  
 Weitere Informationen finden Sie unter [Hash\_Map (STL/CLR)](/cpp/dotnet/hash-map-stl-clr), [Hash\_Multimap (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr), [Hash\_Satz (STL/CLR)](/cpp/dotnet/hash-set-stl-clr)und [Hash\_Multiset (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="begin">
      <MemberSignature Language="C#" Value="public void begin (ref Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt; );" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void begin(class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt;&amp; ) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.begin(Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function begin (ByRef  As ContainerBidirectionalIterator(Of TValue)) As Void" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ^ begin(Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^ % );" />
      <MemberSignature Language="F#" Value="abstract member begin : ContainerBidirectionalIterator -&gt; unit" Usage="iHash.begin " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="" Type="Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="">Ein bidirektionaler Iterator, der das erste Element der kontrollierten Sequenz oder die Position unmittelbar nach dem Ende einer leeren Sequenz bestimmt. Sie können damit einen Iterator abrufen, der den <paramref name="current" /> Anfang der kontrollierten Sequenz bestimmt; der Zustand kann sich jedoch ändern, sobald sich die Länge der kontrollierten Sequenz ändert.</param>
        <summary>Legt den Anfang der kontrollierten Sequenz fest.</summary>
        <returns>Ein Iterator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: begin (STL/CLR)](/cpp/dotnet/hash-map-begin-stl-clr), [Hash\_multimap:: begin (STL/CLR)](/cpp/dotnet/hash-multimap-begin-stl-clr), [Hash\_Set:: begin (STL/CLR)](/cpp/dotnet/hash-set-begin-stl-clr)und [Hash\_multiset:: begin (STL/CLR)](/cpp/dotnet/hash-multiset-begin-stl-clr).  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="bucket_count">
      <MemberSignature Language="C#" Value="public int bucket_count ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 bucket_count() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.bucket_count" />
      <MemberSignature Language="VB.NET" Value="Public Function bucket_count () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int bucket_count();" />
      <MemberSignature Language="F#" Value="abstract member bucket_count : unit -&gt; int" Usage="iHash.bucket_count " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermittelt die Anzahl von Buckets in der Hashtabelle.</summary>
        <returns>Die aktuelle Anzahl von Buckets in der Hashtabelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: bucket_count (STL/CLR)](/cpp/dotnet/hash-map-bucket-count-stl-clr), [Hash\_multimap:: bucket_count (STL/CLR)](/cpp/dotnet/hash-multimap-bucket-count-stl-clr), [Hash\_Set:: bucket_count (STL/CLR)](/cpp/dotnet/hash-set-bucket-count-stl-clr)und [Hash\_multiset:: bucket_count (STL/CLR) ](/cpp/dotnet/hash-multiset-bucket-count-stl-clr).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="clear">
      <MemberSignature Language="C#" Value="public void clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void clear();" />
      <MemberSignature Language="F#" Value="abstract member clear : unit -&gt; unit" Usage="iHash.clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus dem Container.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: Clear (STL/CLR)](/cpp/dotnet/hash-map-clear-stl-clr), [Hash\_multimap:: Clear (STL/CLR)](/cpp/dotnet/hash-multimap-clear-stl-clr), [Hash\_Set:: Clear (STL/CLR)](/cpp/dotnet/hash-set-clear-stl-clr)und [Hash\_multiset:: Clear (STL/CLR)](/cpp/dotnet/hash-multiset-clear-stl-clr).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="count">
      <MemberSignature Language="C#" Value="public int count (TKey _Keyval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 count(!TKey _Keyval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.count(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function count (_Keyval As TKey) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int count(TKey _Keyval);" />
      <MemberSignature Language="F#" Value="abstract member count : 'Key -&gt; int" Usage="iHash.count _Keyval" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="_Keyval" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="_Keyval">Der Schlüsselwert, der gesucht werden soll.</param>
        <summary>Sucht die Anzahl der Elemente, die zu einem angegebenen Schlüssel passen.</summary>
        <returns>Die Anzahl der Elemente in der kontrollierten Sequenz, die den gleichen Schlüssel aufweisen wie <paramref name="_Keyval" />. Damit können Sie die Anzahl der Elemente in der kontrollierten Sequenz ermitteln, die derzeit einem angegebenen Schlüssel entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: count (STL/CLR)](/cpp/dotnet/hash-map-count-stl-clr), [Hash\_multimap:: count (STL/CLR)](/cpp/dotnet/hash-multimap-count-stl-clr), [Hash\_Set:: count (STL/CLR)](/cpp/dotnet/hash-set-count-stl-clr)und [Hash\_multiset:: count (STL/CLR)](/cpp/dotnet/hash-multiset-count-stl-clr).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="empty">
      <MemberSignature Language="C#" Value="public bool empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.empty" />
      <MemberSignature Language="VB.NET" Value="Public Function empty () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool empty();" />
      <MemberSignature Language="F#" Value="abstract member empty : unit -&gt; bool" Usage="iHash.empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prüft, ob der Container leer ist.</summary>
        <returns><see langword="true" />, wenn der Container leer ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: Empty (STL/CLR)](/cpp/dotnet/hash-map-empty-stl-clr), [Hash\_multimap:: Empty (STL/CLR)](/cpp/dotnet/hash-multimap-empty-stl-clr), [Hash\_Set:: Empty (STL/CLR)](/cpp/dotnet/hash-set-empty-stl-clr)und [Hash\_multiset:: Empty (STL/CLR)](/cpp/dotnet/hash-multiset-empty-stl-clr).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="end">
      <MemberSignature Language="C#" Value="public void end (ref Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt; );" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void end(class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt;&amp; ) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.end(Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function end (ByRef  As ContainerBidirectionalIterator(Of TValue)) As Void" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ^ end(Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^ % );" />
      <MemberSignature Language="F#" Value="abstract member end : ContainerBidirectionalIterator -&gt; unit" Usage="iHash.end " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="" Type="Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="">Ein bidirektionaler Iterator, der auf eine Position unmittelbar nach dem Ende der kontrollierten Sequenz verweist. Sie können damit einen Iterator abrufen, der das Ende der kontrollierten Sequenz bestimmt. Sein Status ändert sich nicht, wenn sich die Länge der kontrollierten Sequenz ändert.</param>
        <summary>Legt das Ende der kontrollierten Sequenz fest.</summary>
        <returns>Ein Iterator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: End (STL/CLR)](/cpp/dotnet/hash-map-end-stl-clr), [Hash\_multimap:: End (STL/CLR)](/cpp/dotnet/hash-multimap-end-stl-clr), [Hash\_Set:: End (STL/CLR)](/cpp/dotnet/hash-set-end-stl-clr)und [Hash\_multiset:: End (STL/CLR)](/cpp/dotnet/hash-multiset-end-stl-clr).  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="equal_range">
      <MemberSignature Language="C#" Value="public void equal_range (ref Microsoft.VisualC.StlClr.GenericPair&lt;Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;,Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;&gt; , TKey _Keyval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void equal_range(class Microsoft.VisualC.StlClr.GenericPair`2&lt;class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt;, class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt;&gt;&amp; , !TKey _Keyval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.equal_range(Microsoft.VisualC.StlClr.GenericPair{Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1},Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}}@,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function equal_range (ByRef  As GenericPair(Of ContainerBidirectionalIterator(Of TValue), ContainerBidirectionalIterator(Of TValue)), _Keyval As TKey) As Void" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ^ equal_range(Microsoft::VisualC::StlClr::GenericPair&lt;Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^, Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^&gt; ^ % , TKey _Keyval);" />
      <MemberSignature Language="F#" Value="abstract member equal_range : GenericPair * 'Key -&gt; unit" Usage="iHash.equal_range (, _Keyval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="" Type="Microsoft.VisualC.StlClr.GenericPair&lt;Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;,Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;&gt;" RefType="ref" />
        <Parameter Name="_Keyval" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="">Ein Iteratorpaar, das den Bereich der Elemente in der kontrollierten Sequenz bestimmt, die derzeit einem angegebenen Schlüssel entsprechen.</param>
        <param name="_Keyval">Der Schlüsselwert, der gesucht werden soll.</param>
        <summary>Sucht den Bereich, der einem angegebenen Schlüssel entspricht.</summary>
        <returns>Ein Paar von Iteratoren.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: equal_range (STL/CLR)][Hash\_Map:: equal_range (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#equal_range)), [Hash\_multimap:: equal_range (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#equal_range), [Hash\_Set:: equal_range (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#equal_range)und [Hash.\_multiset:: equal_range (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#equal_range).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="erase">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt Elemente aus dem Container.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: Erase (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#erase), [Hash\_multimap:: Erase (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#erase), [Hash\_Set:: Erase (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#erase)und [Hash\_multiset:: Erase (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#erase).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="erase">
      <MemberSignature Language="C#" Value="public int erase (TKey _Keyval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 erase(!TKey _Keyval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.erase(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function erase (_Keyval As TKey) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int erase(TKey _Keyval);" />
      <MemberSignature Language="F#" Value="abstract member erase : 'Key -&gt; int" Usage="iHash.erase _Keyval" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="_Keyval" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="_Keyval">Der Schlüsselwert, der gelöscht werden soll.</param>
        <summary>Entfernt Elemente aus dem Container, die dem angegebenen Schlüssel entsprechen.</summary>
        <returns>Die Anzahl der entfernten Elemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: Erase (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#erase), [Hash\_multimap:: Erase (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#erase), [Hash\_Set:: Erase (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#erase)und [Hash\_multiset:: Erase (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#erase).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="erase">
      <MemberSignature Language="C#" Value="public void erase (ref Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt; , Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt; _Where);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void erase(class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt;&amp; , class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt; _Where) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.erase(Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}@,Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}|System.Runtime.CompilerServices.IsByValue)" />
      <MemberSignature Language="VB.NET" Value="Public Function erase (ByRef  As ContainerBidirectionalIterator(Of TValue), _Where As ContainerBidirectionalIterator(Of TValue)) As Void" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ^ erase(Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^ % , Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^ _Where);" />
      <MemberSignature Language="F#" Value="abstract member erase : ContainerBidirectionalIterator * Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;'Value&gt; -&gt; unit" Usage="iHash.erase (, _Where)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="" Type="Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;" RefType="ref" />
        <Parameter Name="_Where" Type="Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="">Ein Iterator, der das erste Element nach dem entfernten Element bestimmt, oder <see cref="M:Microsoft.VisualC.StlClr.IHash`2.end(Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}@)" />, wenn kein solches Element vorhanden ist.</param>
        <param name="_Where">Ein Iterator, der auf das Element zeigt, das gelöscht werden soll.</param>
        <summary>Entfernt das Element aus dem Container, das vom angegebenen Iterator angegeben wird.</summary>
        <returns>Ein Iterator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Weitere Informationen finden Sie unter [Hash\_Map:: Erase (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#erase), [Hash\_multimap:: Erase (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#erase), [Hash\_Set:: Erase (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#erase)und [Hash\_multiset:: Erase (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#erase).

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="erase">
      <MemberSignature Language="C#" Value="public void erase (ref Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt; , Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt; _First_iter, Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt; _Last_iter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void erase(class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt;&amp; , class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt; _First_iter, class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt; _Last_iter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.erase(Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}@,Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}|System.Runtime.CompilerServices.IsByValue,Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}|System.Runtime.CompilerServices.IsByValue)" />
      <MemberSignature Language="VB.NET" Value="Public Function erase (ByRef  As ContainerBidirectionalIterator(Of TValue), _First_iter As ContainerBidirectionalIterator(Of TValue), _Last_iter As ContainerBidirectionalIterator(Of TValue)) As Void" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ^ erase(Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^ % , Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^ _First_iter, Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^ _Last_iter);" />
      <MemberSignature Language="F#" Value="abstract member erase : ContainerBidirectionalIterator * Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;'Value&gt; * Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;'Value&gt; -&gt; unit" Usage="iHash.erase (, _First_iter, _Last_iter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="" Type="Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;" RefType="ref" />
        <Parameter Name="_First_iter" Type="Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;" />
        <Parameter Name="_Last_iter" Type="Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="">Ein Iterator, der das erste Element nach den entfernten Elementen bestimmt, oder <see cref="M:Microsoft.VisualC.StlClr.IHash`2.end(Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}@)" />, wenn kein solches Element vorhanden ist.</param>
        <param name="_First_iter">Ein Iterator, der auf den Anfang des Bereichs zeigt, der gelöscht werden soll.</param>
        <param name="_Last_iter">Ein Iterator, der auf die Position unmittelbar nach dem Bereich zeigt, der gelöscht werden soll.</param>
        <summary>Entfernt die Elemente zwischen den angegebenen Iteratoren aus dem Container.</summary>
        <returns>Ein Iterator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Weitere Informationen finden Sie unter [Hash\_Map:: Erase (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#erase), [Hash\_multimap:: Erase (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#erase), [Hash\_Set:: Erase (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#erase)und [Hash\_multiset:: Erase (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#erase).

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="find">
      <MemberSignature Language="C#" Value="public void find (ref Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt; , TKey _Keyval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void find(class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt;&amp; , !TKey _Keyval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.find(Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}@,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function find (ByRef  As ContainerBidirectionalIterator(Of TValue), _Keyval As TKey) As Void" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ^ find(Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^ % , TKey _Keyval);" />
      <MemberSignature Language="F#" Value="abstract member find : ContainerBidirectionalIterator * 'Key -&gt; unit" Usage="iHash.find (, _Keyval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="" Type="Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;" RefType="ref" />
        <Parameter Name="_Keyval" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="">Ein Iterator, der eines der gesuchten Elemente bestimmt, oder <see cref="M:Microsoft.VisualC.StlClr.IHash`2.end(Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}@)" />, wenn keine Elemente gefunden werden.</param>
        <param name="_Keyval">Der Schlüsselwert, der gesucht werden soll.</param>
        <summary>Sucht ein Element, das einem angegebenen Schlüssel entspricht.</summary>
        <returns>Ein Iterator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: Find (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#find), [Hash\_multimap:: Find (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#find), [Hash\_Set:: Find (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#find)und [Hash\_multiset:: Find (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#find).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="hash_delegate">
      <MemberSignature Language="C#" Value="public Microsoft.VisualC.StlClr.UnaryDelegate&lt;TKey,int&gt; hash_delegate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.VisualC.StlClr.UnaryDelegate`2&lt;!TKey, int32&gt; hash_delegate() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.hash_delegate" />
      <MemberSignature Language="VB.NET" Value="Public Function hash_delegate () As UnaryDelegate(Of TKey, Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualC::StlClr::UnaryDelegate&lt;TKey, int&gt; ^ hash_delegate();" />
      <MemberSignature Language="F#" Value="abstract member hash_delegate : unit -&gt; Microsoft.VisualC.StlClr.UnaryDelegate&lt;'Key, int&gt;" Usage="iHash.hash_delegate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualC.StlClr.UnaryDelegate&lt;TKey,System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Delegaten zurück, mit dem ein Schlüsselwert in eine Ganzzahl konvertiert wird.</summary>
        <returns>Der Delegat, mit dem ein Schlüsselwert in eine Ganzzahl konvertiert wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: hash_delegate (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#hash_delegate), [Hash\_multimap:: hash_delegate (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#hash_delegate), [Hash\_Set:: hash_delegate (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#hash_delegate)und [Hash\_multiset:: hash_delegate (STL/ CLR)](/cpp/dotnet/hash-multiset-stl-clr#hash_delegate).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="insert">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt dem Container Elemente hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: Insert (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#insert), [Hash\_multimap:: Insert (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#insert), [Hash\_Set:: Insert (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#insert)und [Hash\_multiset:: Insert (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#insert).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="insert">
      <MemberSignature Language="C#" Value="public void insert (System.Collections.IEnumerable _Right);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void insert(class System.Collections.IEnumerable _Right) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.insert(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub insert (_Right As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void insert(System::Collections::IEnumerable ^ _Right);" />
      <MemberSignature Language="F#" Value="abstract member insert : System.Collections.IEnumerable -&gt; unit" Usage="iHash.insert _Right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="_Right" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="_Right">Die Enumeration, die in den Container eingefügt werden soll.</param>
        <summary>Fügt dem Container die angegebene Enumeration hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: Insert (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#insert), [Hash\_multimap:: Insert (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#insert), [Hash\_Set:: Insert (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#insert)und [Hash\_multiset:: Insert (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#insert).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="insert">
      <MemberSignature Language="C#" Value="public void insert (Microsoft.VisualC.StlClr.Generic.IInputIterator&lt;TValue&gt; _First, Microsoft.VisualC.StlClr.Generic.IInputIterator&lt;TValue&gt; _Last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void insert(class Microsoft.VisualC.StlClr.Generic.IInputIterator`1&lt;!TValue&gt; _First, class Microsoft.VisualC.StlClr.Generic.IInputIterator`1&lt;!TValue&gt; _Last) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.insert(Microsoft.VisualC.StlClr.Generic.IInputIterator{`1},Microsoft.VisualC.StlClr.Generic.IInputIterator{`1})" />
      <MemberSignature Language="VB.NET" Value="Public Sub insert (_First As IInputIterator(Of TValue), _Last As IInputIterator(Of TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void insert(Microsoft::VisualC::StlClr::Generic::IInputIterator&lt;TValue&gt; ^ _First, Microsoft::VisualC::StlClr::Generic::IInputIterator&lt;TValue&gt; ^ _Last);" />
      <MemberSignature Language="F#" Value="abstract member insert : Microsoft.VisualC.StlClr.Generic.IInputIterator&lt;'Value&gt; * Microsoft.VisualC.StlClr.Generic.IInputIterator&lt;'Value&gt; -&gt; unit" Usage="iHash.insert (_First, _Last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="_First" Type="Microsoft.VisualC.StlClr.Generic.IInputIterator&lt;TValue&gt;" />
        <Parameter Name="_Last" Type="Microsoft.VisualC.StlClr.Generic.IInputIterator&lt;TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="_First">Ein Iterator, der auf den Anfang des Bereichs von Elementen zeigt, die eingefügt werden sollen.</param>
        <param name="_Last">Ein Iterator, der auf das Element unmittelbar nach dem Bereich von Elementen zeigt, die eingefügt werden sollen.</param>
        <summary>Fügt dem Container die Elemente hinzu, die von den angegebenen Iteratoren angegeben wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: Insert (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#insert), [Hash\_multimap:: Insert (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#insert), [Hash\_Set:: Insert (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#insert)und [Hash\_multiset:: Insert (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#insert).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="insert">
      <MemberSignature Language="C#" Value="public void insert (ref Microsoft.VisualC.StlClr.GenericPair&lt;Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;,bool&gt; , TValue _Val);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void insert(class Microsoft.VisualC.StlClr.GenericPair`2&lt;class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt;, bool&gt;&amp; , !TValue _Val) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.insert(Microsoft.VisualC.StlClr.GenericPair{Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1},System.Boolean}@,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function insert (ByRef  As GenericPair(Of ContainerBidirectionalIterator(Of TValue), Boolean), _Val As TValue) As Void" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ^ insert(Microsoft::VisualC::StlClr::GenericPair&lt;Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^, bool&gt; ^ % , TValue _Val);" />
      <MemberSignature Language="F#" Value="abstract member insert : GenericPair * 'Value -&gt; unit" Usage="iHash.insert (, _Val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="" Type="Microsoft.VisualC.StlClr.GenericPair&lt;Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;,System.Boolean&gt;" RefType="ref" />
        <Parameter Name="_Val" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="">Ein Wertepaar X. Wenn X.second <see langword="true" /> ist, bezeichnet X.first das neu eingefügte Element; andernfalls bezeichnet X.first ein Element mit einer gleichwertigen Reihenfolge, die bereits vorhanden ist, und es wird kein neues Element eingefügt.</param>
        <param name="_Val">Der Schlüsselwert, der in den Container eingefügt werden soll.</param>
        <summary>Fügt dem Container den angegebenen Wert hinzu.</summary>
        <returns>Ein Paar von Iteratoren.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: Insert (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#insert), [Hash\_multimap:: Insert (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#insert), [Hash\_Set:: Insert (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#insert)und [Hash\_multiset:: Insert (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#insert).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="insert">
      <MemberSignature Language="C#" Value="public void insert (ref Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt; , Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt; _Where, TValue _Val);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void insert(class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt;&amp; , class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt; _Where, !TValue _Val) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.insert(Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}@,Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}|System.Runtime.CompilerServices.IsByValue,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function insert (ByRef  As ContainerBidirectionalIterator(Of TValue), _Where As ContainerBidirectionalIterator(Of TValue), _Val As TValue) As Void" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ^ insert(Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^ % , Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^ _Where, TValue _Val);" />
      <MemberSignature Language="F#" Value="abstract member insert : ContainerBidirectionalIterator * Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;'Value&gt; * 'Value -&gt; unit" Usage="iHash.insert (, _Where, _Val)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="" Type="Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;" RefType="ref" />
        <Parameter Name="_Where" Type="Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;" />
        <Parameter Name="_Val" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="">Ein Iterator, der das neu eingefügte Element entwirft</param>
        <param name="_Where">Ein Iterator, der angibt, wo im Container das Element eingefügt werden soll. Dies ist nur ein Hinweis und wird verwendet, um die Leistung zu verbessern. Das Element wird möglicherweise nicht an dieser Position eingefügt.</param>
        <param name="_Val">Der Schlüsselwert, der in den Container eingefügt werden soll.</param>
        <summary>Fügt dem Container das angegebene Element hinzu.</summary>
        <returns>Ein Iterator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Weitere Informationen finden Sie unter [Hash\_Map:: Insert (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#insert), [Hash\_multimap:: Insert (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#insert), [Hash\_Set:: Insert (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#insert)und [Hash\_multiset:: Insert (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#insert).

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="key_comp">
      <MemberSignature Language="C#" Value="public Microsoft.VisualC.StlClr.BinaryDelegate&lt;TKey,TKey,bool&gt; key_comp ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.VisualC.StlClr.BinaryDelegate`3&lt;!TKey, !TKey, bool&gt; key_comp() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.key_comp" />
      <MemberSignature Language="VB.NET" Value="Public Function key_comp () As BinaryDelegate(Of TKey, TKey, Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualC::StlClr::BinaryDelegate&lt;TKey, TKey, bool&gt; ^ key_comp();" />
      <MemberSignature Language="F#" Value="abstract member key_comp : unit -&gt; Microsoft.VisualC.StlClr.BinaryDelegate&lt;'Key, 'Key, bool&gt;" Usage="iHash.key_comp " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualC.StlClr.BinaryDelegate&lt;TKey,TKey,System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Delegaten zurück, mit dem die kontrollierte Sequenz sortiert wird. Damit können Sie zwei Schlüssel vergleichen.</summary>
        <returns>Der Delegat, mit dem die kontrollierte Sequenz sortiert wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: key_comp (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#key_comp), [Hash\_multimap:: key_comp (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#key_comp), [Hash\_Set:: key_comp (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#key_comp)und [Hash\_multiset:: key_comp (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#key_comp).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="load_factor">
      <MemberSignature Language="C#" Value="public float load_factor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 load_factor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.load_factor" />
      <MemberSignature Language="VB.NET" Value="Public Function load_factor () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float load_factor();" />
      <MemberSignature Language="F#" Value="abstract member load_factor : unit -&gt; single" Usage="iHash.load_factor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermittelt die durchschnittliche Anzahl von Elementen je Bucket in der Hashtabelle.</summary>
        <returns>Die durchschnittliche Anzahl von Elementen je Bucket in der Hashtabelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: load_factor (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#load_factor), [Hash\_multimap:: load_factor (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#load_factor), [Hash\_Set:: load_factor (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#load_factor)und [Hash\_multiset:: load_factor (STL/CLR) ](/cpp/dotnet/hash-multiset-stl-clr#load_factor).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="lower_bound">
      <MemberSignature Language="C#" Value="public void lower_bound (ref Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt; , TKey _Keyval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void lower_bound(class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt;&amp; , !TKey _Keyval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.lower_bound(Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}@,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function lower_bound (ByRef  As ContainerBidirectionalIterator(Of TValue), _Keyval As TKey) As Void" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ^ lower_bound(Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^ % , TKey _Keyval);" />
      <MemberSignature Language="F#" Value="abstract member lower_bound : ContainerBidirectionalIterator * 'Key -&gt; unit" Usage="iHash.lower_bound (, _Keyval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="" Type="Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;" RefType="ref" />
        <Parameter Name="_Keyval" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="">Ein Iterator, der das erste Element in der kontrollierten Sequenz bestimmt, das in das gleiche Bucket entschlüsselt wird wie <paramref name="_Keyval" /> und dessen Sortierung <paramref name="_Keyval" /> entspricht. Wenn kein solches Element vorhanden ist, wird <see cref="M:Microsoft.VisualC.StlClr.IHash`2.end(Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}@)" /> zurückgegeben.</param>
        <param name="_Keyval">Der Schlüsselwert, der gesucht werden soll.</param>
        <summary>Sucht den Anfang des Bereichs von Elementen, die einem angegebenen Schlüssel entsprechen.</summary>
        <returns>Ein Iterator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: lower_bound (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#lower_bound), [Hash\_multimap:: lower_bound (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#lower_bound), [Hash\_Set:: lower_bound (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#lower_bound)und [Hash\_multiset:: lower_bound (STL/CLR) ](/cpp/dotnet/hash-multiset-stl-clr#lower_bound).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="max_load_factor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die maximale Anzahl von Elementen je Bucket in der Hashtabelle ab oder legt diese fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: max_load_factor (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#max_load_factor), [Hash\_multimap:: max_load_factor (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#max_load_factor), [Hash\_Set:: max_load_factor (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#load_factor)und [Hash\_multiset:: max_load_ Faktor (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#max_load_factor).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="max_load_factor">
      <MemberSignature Language="C#" Value="public float max_load_factor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 max_load_factor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.max_load_factor" />
      <MemberSignature Language="VB.NET" Value="Public Function max_load_factor () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float max_load_factor();" />
      <MemberSignature Language="F#" Value="abstract member max_load_factor : unit -&gt; single" Usage="iHash.max_load_factor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die maximale Anzahl von Elementen je Bucket in der Hashtabelle ab.</summary>
        <returns>Die maximale Anzahl von Elementen je Bucket in der Hashtabelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: max_load_factor (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#max_load_factor), [Hash\_multimap:: max_load_factor (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#max_load_factor), [Hash\_Set:: max_load_factor (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#load_factor)und [Hash\_multiset:: max_load_ Faktor (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#max_load_factor).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="max_load_factor">
      <MemberSignature Language="C#" Value="public void max_load_factor (float _Newmax);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void max_load_factor(float32 _Newmax) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.max_load_factor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub max_load_factor (_Newmax As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void max_load_factor(float _Newmax);" />
      <MemberSignature Language="F#" Value="abstract member max_load_factor : single -&gt; unit" Usage="iHash.max_load_factor _Newmax" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="_Newmax" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="_Newmax">Die maximale Anzahl von Elementen je Bucket in der Hashtabelle.</param>
        <summary>Legt die maximale Anzahl von Elementen je Bucket in der Hashtabelle fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: max_load_factor (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#max_load_factor), [Hash\_multimap:: max_load_factor (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#max_load_factor), [Hash\_Set:: max_load_factor (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#load_factor)und [Hash\_multiset:: max_load_ Faktor (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#max_load_factor).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="rbegin">
      <MemberSignature Language="C#" Value="public void rbegin (ref Microsoft.VisualC.StlClr.Generic.ReverseBidirectionalIterator&lt;TValue&gt; );" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void rbegin(class Microsoft.VisualC.StlClr.Generic.ReverseBidirectionalIterator`1&lt;!TValue&gt;&amp; ) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.rbegin(Microsoft.VisualC.StlClr.Generic.ReverseBidirectionalIterator{`1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function rbegin (ByRef  As ReverseBidirectionalIterator(Of TValue)) As Void" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ^ rbegin(Microsoft::VisualC::StlClr::Generic::ReverseBidirectionalIterator&lt;TValue&gt; ^ % );" />
      <MemberSignature Language="F#" Value="abstract member rbegin : ReverseBidirectionalIterator -&gt; unit" Usage="iHash.rbegin " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="" Type="Microsoft.VisualC.StlClr.Generic.ReverseBidirectionalIterator&lt;TValue&gt;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="">Ein umgekehrter Iterator, der das letzte Element der kontrollierten Sequenz oder die Position unmittelbar nach dem Anfang einer leeren Sequenz bestimmt. Demzufolge wird der <paramref name="beginning" /> der umgekehrten Sequenz bestimmt. Sie können damit einen Iterator abrufen, der den <paramref name="current" /> Anfang der kontrollierten Sequenz in umgekehrter Reihenfolge bestimmt. Sein Status kann sich ändern, wenn sich die Länge der kontrollierten Sequenz ändert.</param>
        <summary>Legt den Anfang der umgekehrten kontrollierten Sequenz fest.</summary>
        <returns>Ein Iterator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: rbegin (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#rbegin), [Hash\_multimap:: rbegin (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#rbegin), [Hash\_Set:: rbegin (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#rbegin)und [Hash\_multiset:: rbegin (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#rbegin).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="rehash">
      <MemberSignature Language="C#" Value="public void rehash (int _Buckets);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void rehash(int32 _Buckets) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.rehash(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub rehash (_Buckets As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void rehash(int _Buckets);" />
      <MemberSignature Language="F#" Value="abstract member rehash : int -&gt; unit" Usage="iHash.rehash _Buckets" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="_Buckets" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="_Buckets">Die Anzahl von Buckets für die Hashtabelle.</param>
        <summary>Erstellt die Hashtabelle neu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: rehash (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#rehash), [Hash\_multimap:: rehash (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#rehash), [Hash\_Set:: rehash (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#rehash)und [Hash\_multiset:: rehash (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#rehash).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="rend">
      <MemberSignature Language="C#" Value="public void rend (ref Microsoft.VisualC.StlClr.Generic.ReverseBidirectionalIterator&lt;TValue&gt; );" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void rend(class Microsoft.VisualC.StlClr.Generic.ReverseBidirectionalIterator`1&lt;!TValue&gt;&amp; ) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.rend(Microsoft.VisualC.StlClr.Generic.ReverseBidirectionalIterator{`1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function rend (ByRef  As ReverseBidirectionalIterator(Of TValue)) As Void" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ^ rend(Microsoft::VisualC::StlClr::Generic::ReverseBidirectionalIterator&lt;TValue&gt; ^ % );" />
      <MemberSignature Language="F#" Value="abstract member rend : ReverseBidirectionalIterator -&gt; unit" Usage="iHash.rend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="" Type="Microsoft.VisualC.StlClr.Generic.ReverseBidirectionalIterator&lt;TValue&gt;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="">Ein umgekehrter Iterator, der auf eine Position unmittelbar nach dem Anfang der kontrollierten Sequenz verweist. Demzufolge wird der <paramref name="end" /> der umgekehrten Sequenz bestimmt. Sie können damit einen Iterator abrufen, der das <paramref name="current" /> Ende der kontrollierten Sequenz in umgekehrter Reihenfolge bestimmt. Sein Status kann sich ändern, wenn sich die Länge der kontrollierten Sequenz ändert.</param>
        <summary>Legt das Ende der umgekehrten kontrollierten Sequenz fest.</summary>
        <returns>Ein Iterator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: rend (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#rend), [Hash\_multimap:: rend (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#rend), [Hash\_Set:: rend (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#rend)und [Hash\_multiset:: rend (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#rend).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="size">
      <MemberSignature Language="C#" Value="public int size ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 size() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.size" />
      <MemberSignature Language="VB.NET" Value="Public Function size () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int size();" />
      <MemberSignature Language="F#" Value="abstract member size : unit -&gt; int" Usage="iHash.size " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zählt die Anzahl der Elemente im Container.</summary>
        <returns>Die Länge der kontrollierten Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: Size (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#size), [Hash\_multimap:: Size (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#size), [Hash\_Set:: Size (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#size)und [Hash\_multiset:: Size (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#size).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="swap">
      <MemberSignature Language="C#" Value="public void swap (Microsoft.VisualC.StlClr.IHash&lt;TKey,TValue&gt; _Right);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void swap(class Microsoft.VisualC.StlClr.IHash`2&lt;!TKey, !TValue&gt; _Right) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.swap(Microsoft.VisualC.StlClr.IHash{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Sub swap (_Right As IHash(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void swap(Microsoft::VisualC::StlClr::IHash&lt;TKey, TValue&gt; ^ _Right);" />
      <MemberSignature Language="F#" Value="abstract member swap : Microsoft.VisualC.StlClr.IHash&lt;'Key, 'Value&gt; -&gt; unit" Usage="iHash.swap _Right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="_Right" Type="Microsoft.VisualC.StlClr.IHash&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="_Right">Der Container, mit dem der Inhalt getauscht werden soll.</param>
        <summary>Vertauscht den Inhalt von zwei Containern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: Swap (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#swap), [Hash\_multimap:: Swap (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#swap), [Hash\_Set:: Swap (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#swap)und [Hash\_multiset:: Swap (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#swap).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="upper_bound">
      <MemberSignature Language="C#" Value="public void upper_bound (ref Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt; , TKey _Keyval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void upper_bound(class Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator`1&lt;!TValue&gt;&amp; , !TKey _Keyval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.upper_bound(Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}@,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function upper_bound (ByRef  As ContainerBidirectionalIterator(Of TValue), _Keyval As TKey) As Void" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ^ upper_bound(Microsoft::VisualC::StlClr::Generic::ContainerBidirectionalIterator&lt;TValue&gt; ^ % , TKey _Keyval);" />
      <MemberSignature Language="F#" Value="abstract member upper_bound : ContainerBidirectionalIterator * 'Key -&gt; unit" Usage="iHash.upper_bound (, _Keyval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="" Type="Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator&lt;TValue&gt;" RefType="ref" />
        <Parameter Name="_Keyval" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="">Ein Iterator, der das erste Element nach dem letzten Element in der kontrollierten Sequenz bestimmt, das in das gleiche Bucket entschlüsselt wird wie <paramref name="_Keyval" /> und dessen Sortierung <paramref name="_Keyval" /> entspricht. Wenn kein solches Element vorhanden ist, wird <see cref="M:Microsoft.VisualC.StlClr.IHash`2.end(Microsoft.VisualC.StlClr.Generic.ContainerBidirectionalIterator{`1}@)" /> zurückgegeben.</param>
        <param name="_Keyval">Der Schlüsselwert, der gesucht werden soll.</param>
        <summary>Sucht das Ende des Bereichs von Elementen, die einem angegebenen Schlüssel entsprechen.</summary>
        <returns>Ein Iterator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: upper_bound (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#upper_bound), [Hash\_multimap:: upper_bound (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#upper_bound), [Hash\_Set:: upper_bound (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#upper_bound)und [Hash\_multiset:: upper_bound (STL/CLR) ](/cpp/dotnet/hash-multiset-stl-clr#upper_bound).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="value_comp">
      <MemberSignature Language="C#" Value="public Microsoft.VisualC.StlClr.BinaryDelegate&lt;TValue,TValue,bool&gt; value_comp ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.VisualC.StlClr.BinaryDelegate`3&lt;!TValue, !TValue, bool&gt; value_comp() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualC.StlClr.IHash`2.value_comp" />
      <MemberSignature Language="VB.NET" Value="Public Function value_comp () As BinaryDelegate(Of TValue, TValue, Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualC::StlClr::BinaryDelegate&lt;TValue, TValue, bool&gt; ^ value_comp();" />
      <MemberSignature Language="F#" Value="abstract member value_comp : unit -&gt; Microsoft.VisualC.StlClr.BinaryDelegate&lt;'Value, 'Value, bool&gt;" Usage="iHash.value_comp " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualC.STLCLR</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualC.StlClr.BinaryDelegate&lt;TValue,TValue,System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Delegaten zurück, mit dem die kontrollierte Sequenz sortiert wird.</summary>
        <returns>Der Delegat, mit dem die kontrollierte Sequenz sortiert wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Hash\_Map:: value_comp (STL/CLR)](/cpp/dotnet/hash-map-stl-clr#value_comp), [Hash\_multimap:: value_comp (STL/CLR)](/cpp/dotnet/hash-multimap-stl-clr#value_comp), [Hash\_Set:: value_comp (STL/CLR)](/cpp/dotnet/hash-set-stl-clr#value_comp)und [Hash\_multiset:: value_comp (STL/CLR)](/cpp/dotnet/hash-multiset-stl-clr#value_comp).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
