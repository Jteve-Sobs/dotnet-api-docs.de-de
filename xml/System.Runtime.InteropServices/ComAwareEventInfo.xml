<Type Name="ComAwareEventInfo" FullName="System.Runtime.InteropServices.ComAwareEventInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a50bc1c6bf61c6387ace86a09185889744af6d54" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480054" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ComAwareEventInfo : System.Reflection.EventInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ComAwareEventInfo extends System.Reflection.EventInfo" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.ComAwareEventInfo" />
  <TypeSignature Language="VB.NET" Value="Public Class ComAwareEventInfo&#xA;Inherits EventInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class ComAwareEventInfo : System::Reflection::EventInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.EventInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Lässt die spät gebundene Registrierung eines Ereignishandlers zu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise betten Compiler automatisch Aufrufe an die <xref:System.Runtime.InteropServices.ComAwareEventInfo.AddEventHandler%28System.Object%2CSystem.Delegate%29?displayProperty=nameWithType> und <xref:System.Runtime.InteropServices.ComAwareEventInfo.RemoveEventHandler%28System.Object%2CSystem.Delegate%29?displayProperty=nameWithType> Methoden, anstatt regelmäßige Ereignishandler hinzufügen und entfernen Sie Ereignishandlermethoden für Ereignisse. Dies geschieht, wenn die Schnittstelle, dass das entsprechende Ereignis definiert ist, muss eingebettet werden.  
  
 Sie können dies angeben, indem Sie die gesamte Assembly einbetten, die die Schnittstelle enthält, mit der **/link** Option in der Compiler oder durch Festlegen der **Interop-Typen einbetten** Eigenschaft `True` in Visual Studio.  
  
 Die <xref:System.Runtime.InteropServices.ComAwareEventInfo> Typ leitet sich von der <xref:System.Reflection.EventInfo> -Klasse ab und überschreibt die <xref:System.Reflection.EventInfo.AddEventHandler%28System.Object%2CSystem.Delegate%29?displayProperty=nameWithType> und <xref:System.Reflection.EventInfo.RemoveEventHandler%28System.Object%2CSystem.Delegate%29?displayProperty=nameWithType> Methoden.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ComAwareEventInfo (Type type, string eventName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string eventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.ComAwareEventInfo.#ctor(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ComAwareEventInfo(Type ^ type, System::String ^ eventName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="eventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Objekttyp.</param>
        <param name="eventName">Der Name eines Ereignisses für <c>type</c>.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.InteropServices.ComAwareEventInfo" />-Klasse unter Verwendung des angegebenen Typs und Namens des Ereignisses für den Typ.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEventHandler">
      <MemberSignature Language="C#" Value="public override void AddEventHandler (object target, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void AddEventHandler(object target, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.ComAwareEventInfo.AddEventHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub AddEventHandler (target As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void AddEventHandler(System::Object ^ target, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="target">Das Zielobjekt, an das der Ereignisdelegat gebunden werden soll.</param>
        <param name="handler">Der Ereignisdelegat.</param>
        <summary>Fügt einen Ereignishandler an ein COM-Objekt an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ähnelt der <xref:System.Reflection.EventInfo.AddEventHandler%28System.Object%2CSystem.Delegate%29?displayProperty=nameWithType> Methode, außer dass sie Ihnen die Möglichkeit, Ereignisse auf COM-Objekte anzufügen.  
  
 Wenn `target` ist ein COM-Objekt, diese Methode fügt einen Delegaten auf ein Ereignis mithilfe der <xref:System.Runtime.InteropServices.ComEventsHelper.Combine%28System.Object%2CSystem.Guid%2CSystem.Int32%2CSystem.Delegate%29?displayProperty=nameWithType> Methode.  
  
 <xref:System.Runtime.InteropServices.ComAwareEventInfo.AddEventHandler%2A> erleichtert die Registrierung COM Ereignissenken, die Aufrufe an den entsprechenden verwalteten Delegaten weiterleiten. Es benötigt die folgenden Informationen:  
  
-   Das Zielobjekt selbst (`target`).  
  
-   Die GUID der Quellschnittstelle.  
  
-   Die DispID der Methode für die COM-Schnittstelle, die das angegebene Ereignis entspricht.  
  
-   Der Delegat, der aufgerufen wird, wenn das entsprechende Ereignis wird, die COM-Objekt ausgelöst (`handler`).  
  
 <xref:System.Runtime.InteropServices.ComAwareEventInfo.AddEventHandler%2A> Sucht nach der entsprechenden COM-Quellschnittstelle (angegeben als der erste Parameter der <xref:System.Runtime.InteropServices.ComEventInterfaceAttribute.%23ctor%28System.Type%2CSystem.Type%29?displayProperty=nameWithType> Konstruktor). Es sucht dann nach einer Methode für die Quellschnittstelle, deren Name mit dem Ereignisnamen identisch ist. Der Wert des `GuidAttribute` in der Quelle ist die GUID, die an übergeben wird <xref:System.Runtime.InteropServices.ComEventsHelper.Combine%28System.Object%2CSystem.Guid%2CSystem.Int32%2CSystem.Delegate%29?displayProperty=nameWithType>; der Wert der `DispIDAttribute` auf die Methode ist die DispID-Wert, der übergeben wird <xref:System.Runtime.InteropServices.ComEventsHelper.Combine%28System.Object%2CSystem.Guid%2CSystem.Int32%2CSystem.Delegate%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit nicht verwaltetem Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.EventAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.ComAwareEventInfo.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As EventAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::EventAttributes Attributes { System::Reflection::EventAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Attribute für dieses Ereignis ab.</summary>
        <value>Die Schreibschutzattribute für dieses Ereignis.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In einem 4-Byte-Ganzzahl dar, die eine Bitmap der Attribute für das Ereignis, das von dieser Instanz reflektiert wird festgelegt, werden die Attribute zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.ComAwareEventInfo.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Klasse ab, die diesen Member deklariert.</summary>
        <value>Das <see cref="T:System.Type" />-Objekt für die Klasse, in der dieser Member deklariert ist.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Reflection.MemberInfo.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="GetAddMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetAddMethod (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetAddMethod(bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.ComAwareEventInfo.GetAddMethod(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAddMethod (nonPublic As Boolean) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetAddMethod(bool nonPublic);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">
          <see langword="true" />, wenn nicht öffentliche Methoden zurückgegeben werden sollen, andernfalls <see langword="false" />.</param>
        <summary>Ruft die Methode ab, mit der der Ereignisquelle ein Ereignishandlerdelegat hinzugefügt wurde.</summary>
        <returns>Die Methode, mit der der Ereignisquelle ein Ereignishandlerdelegat hinzugefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft die <xref:System.Reflection.EventInfo.GetAddMethod%2A?displayProperty=nameWithType>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MethodAccessException">
          <paramref name="nonPublic" /> ist <see langword="true" />, und die zum Hinzufügen eines Ereignishandlerdelegaten verwendete Methode ist nicht öffentlich, aber der Aufrufer hat keine Berechtigung zum Reflektieren nicht öffentlicher Methoden.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt alle auf diesen Member angewendeten Attribute zurück, wenn sie in einer abgeleiteten Klasse überschrieben wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.ComAwareEventInfo.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <see langword="true" />, um die Vererbungskette dieses Members nach den Attributen zu durchsuchen; andernfalls <see langword="false" />.</param>
        <summary>Ruft ein Array ab, das alle auf diesen Member angewendeten benutzerdefinierten Attribute enthält, wenn sie in einer abgeleiteten Klasse überschrieben wird.</summary>
        <returns>Ein Array, das alle benutzerdefinierte Attribute enthält, oder ein Array ohne Elemente, wenn keine Attribute definiert wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft die <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> Methode des zugrunde liegenden <xref:System.Reflection.EventInfo> Objekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dieser Member gehört zu einem Typ, der in den auf Reflexionen beschränkten Kontext geladen wird. Weitere Informationen finden Sie unter [Gewusst wie: Laden von Assemblys in den reflexionsbezogenen Kontext](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</exception>
        <exception cref="T:System.TypeLoadException">Ein benutzerdefinierter Attributtyp kann nicht geladen werden.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.ComAwareEventInfo.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Der zu suchende Attributtyp. Es können nur Attribute zurückgegeben werden, die diesem Typ zugewiesen werden können.</param>
        <param name="inherit">
          <see langword="true" />, um die Vererbungskette dieses Members nach den Attributen zu durchsuchen; andernfalls <see langword="false" />.</param>
        <summary>Ruft ein Array ab, das alle auf diesen Member angewendeten benutzerdefinierten Attribute des angegebenen Typs enthält, wenn sie in einer abgeleiteten Klasse überschrieben wird.</summary>
        <returns>Ein Array, das alle benutzerdefinierte Attribute des angegebenen Typs enthält, oder ein Array ohne Elemente, wenn keine Attribute definiert wurden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Dieser Member gehört zu einem Typ, der in den auf Reflexionen beschränkten Kontext geladen wird. Weitere Informationen finden Sie unter [Gewusst wie: Laden von Assemblys in den reflektionsbezogenen Kontext](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</exception>
        <exception cref="T:System.TypeLoadException">Ein benutzerdefinierter Attributtyp kann nicht geladen werden.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetRaiseMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetRaiseMethod (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetRaiseMethod(bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.ComAwareEventInfo.GetRaiseMethod(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRaiseMethod (nonPublic As Boolean) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetRaiseMethod(bool nonPublic);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">
          <see langword="true" />, wenn nicht öffentliche Methoden zurückgegeben werden sollen, andernfalls <see langword="false" />.</param>
        <summary>Gibt die Methode zurück, die beim Auslösen des Ereignisses aufgerufen wurde, wenn sie in einer abgeleiteten Klasse überschrieben wird.</summary>
        <returns>Das Objekt, das beim Auslösen des Ereignisses aufgerufen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `null` für Ereignisse, die mit dem c# deklariert werden `event` Schlüsselwort oder Visual Basic `Event` Schlüsselwort. Dies ist, da die C#- und Visual Basic-Compiler eine solche Methode nicht generieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MethodAccessException">
          <paramref name="nonPublic" /> ist <see langword="true" />, und die zum Hinzufügen eines Ereignishandlerdelegaten verwendete Methode ist nicht öffentlich, aber der Aufrufer hat keine Berechtigung zum Reflektieren nicht öffentlicher Methoden.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRemoveMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetRemoveMethod (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetRemoveMethod(bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.ComAwareEventInfo.GetRemoveMethod(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRemoveMethod (nonPublic As Boolean) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetRemoveMethod(bool nonPublic);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">
          <see langword="true" />, wenn nicht öffentliche Methoden zurückgegeben werden sollen, andernfalls <see langword="false" />.</param>
        <summary>Ruft das <see cref="T:System.Reflection.MethodInfo" />-Objekt zum Entfernen einer Methode des Ereignisses ab, wenn sie in einer abgeleiteten Klasse überschrieben wird.</summary>
        <returns>Die Methode, mit der ein Ereignishandlerdelegat aus der Ereignisquelle entfernt wurde.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MethodAccessException">
          <paramref name="nonPublic" /> ist <see langword="true" />, und die zum Hinzufügen eines Ereignishandlerdelegaten verwendete Methode ist nicht öffentlich, aber der Aufrufer hat keine Berechtigung zum Reflektieren nicht öffentlicher Methoden.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.ComAwareEventInfo.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Der zu suchende Attributtyp.</param>
        <param name="inherit">
          <see langword="true" />, um die Vererbungskette dieses Members nach den Attributen zu durchsuchen; andernfalls <see langword="false" />.</param>
        <summary>Gibt an, ob eine oder mehrere Instanzen des angegebenen Attributs auf diesen Member angewendet wurden.</summary>
        <returns>
          <see langword="true" />, wenn das angegebene Attribut auf diesen Member angewendet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.Delegate" />
        <altmember cref="T:System.EventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.ComAwareEventInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des aktuellen Members ab.</summary>
        <value>Der Name dieses Members.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Reflection.MemberInfo.Name" />
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.ComAwareEventInfo.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Klassenobjekt ab, das zum Initialisieren dieser Instanz verwendet wurde.</summary>
        <value>Das <see cref="T:System.Type" />-Objekt, das zum Initialisieren des aktuellen Objekts verwendet wurde.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveEventHandler">
      <MemberSignature Language="C#" Value="public override void RemoveEventHandler (object target, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void RemoveEventHandler(object target, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.ComAwareEventInfo.RemoveEventHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub RemoveEventHandler (target As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void RemoveEventHandler(System::Object ^ target, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="target">Das Zielobjekt, an das der Ereignisdelegat gebunden ist.</param>
        <param name="handler">Der Ereignisdelegat.</param>
        <summary>Trennt einen Ereignishandler von einem COM-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ähnelt der <xref:System.Reflection.EventInfo.RemoveEventHandler%28System.Object%2CSystem.Delegate%29?displayProperty=nameWithType> -Methode, mit dem Unterschied, dass Sie zum Trennen von Ereignissen von COM-Objekte können.  
  
 Wenn `target` ist ein COM-Objekt, gibt diese Methode einen Delegaten für ein Ereignis mithilfe der <xref:System.Runtime.InteropServices.ComEventsHelper.Remove%28System.Object%2CSystem.Guid%2CSystem.Int32%2CSystem.Delegate%29?displayProperty=nameWithType> Methode.  
  
 <xref:System.Runtime.InteropServices.ComAwareEventInfo.RemoveEventHandler%2A> erleichtert das Aufheben der Registrierung von COM-Ereignissenken, die Aufrufe an den entsprechenden verwalteten Delegaten weiterleiten. Es benötigt die folgenden Informationen:  
  
-   Das Zielobjekt selbst (`target`).  
  
-   Die GUID der Quellschnittstelle.  
  
-   Die DispID der Methode für die COM-Schnittstelle, die das angegebene Ereignis entspricht.  
  
-   Der Delegat, der aufgerufen wird, wenn das entsprechende Ereignis wird, die COM-Objekt ausgelöst (`handler`).  
  
 <xref:System.Runtime.InteropServices.ComAwareEventInfo.RemoveEventHandler%2A> Sucht nach der entsprechenden COM-Quellschnittstelle (angegeben als der erste Parameter der <xref:System.Runtime.InteropServices.ComEventInterfaceAttribute.%23ctor%28System.Type%2CSystem.Type%29?displayProperty=nameWithType> Konstruktor). Es wird eine Methode für die Quellschnittstelle gesucht, deren Name mit dem Ereignisnamen identisch ist. Der Wert des `GuidAttribute` in der Quelle ist die GUID, die an übergeben wird <xref:System.Runtime.InteropServices.ComEventsHelper.Remove%28System.Object%2CSystem.Guid%2CSystem.Int32%2CSystem.Delegate%29?displayProperty=nameWithType>; der Wert der `DispIDAttribute` auf die Methode ist die DispID-Wert, der übergeben wird <xref:System.Runtime.InteropServices.ComEventsHelper.Remove%28System.Object%2CSystem.Guid%2CSystem.Int32%2CSystem.Delegate%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das Ereignis besitzt keinen öffentlichen <see langword="remove" />-Accessor.</exception>
        <exception cref="T:System.ArgumentException">Der übergebene Handler kann nicht verwendet werden.</exception>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para>  
 Fangen Sie in [.NET für Windows Store-Apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder der [portablen Klassenbibliothek](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) stattdessen <see cref="T:System.Exception" /> ab.  
  
</para>
          </block>  
  
 Der <paramref name="target" />-Parameter ist <see langword="null" />, und das Ereignis ist nicht statisch.  
  
 - oder -   
  
 Die <see cref="T:System.Reflection.EventInfo" /> ist im Ziel nicht deklariert.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 Fangen Sie in [.NET für Windows Store-Apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder der [portablen Klassenbibliothek](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) stattdessen die Basisklassenausnahme <see cref="T:System.MemberAccessException" /> ab.  
  
</para>
          </block>  
  
 Der Aufrufer verfügt nicht über Zugriffsberechtigung für diesen Member.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Betrieb mit nicht verwaltetem Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>