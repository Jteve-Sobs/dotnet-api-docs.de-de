<Type Name="MemoryMarshal" FullName="System.Runtime.InteropServices.MemoryMarshal">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4b72b383c1a2d34aaf25828fee6752a6a0b385bd" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86763562" /></Metadata><TypeSignature Language="C#" Value="public static class MemoryMarshal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit MemoryMarshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.MemoryMarshal" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryMarshal" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryMarshal abstract sealed" />
  <TypeSignature Language="F#" Value="type MemoryMarshal = class" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Memory" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="c6c2e-101">Stellt Methoden für die Interoperabilität mit <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> und <see cref="T:System.ReadOnlySpan`1" /> bereit.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-101">Provides methods to interoperate with <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />,  <see cref="T:System.Span`1" />, and  <see cref="T:System.ReadOnlySpan`1" />.</span></span></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsBytes&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;byte&gt; AsBytes&lt;T&gt; (ReadOnlySpan&lt;T&gt; span) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; AsBytes&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsBytes(Of T As Structure) (span As ReadOnlySpan(Of T)) As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static ReadOnlySpan&lt;System::Byte&gt; AsBytes(ReadOnlySpan&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member AsBytes : ReadOnlySpan&lt;'T (requires 'T : struct)&gt; -&gt; ReadOnlySpan&lt;byte&gt; (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.AsBytes span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-102">Der Typ der Elemente in der schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-102">The type of items in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="c6c2e-103">Der zu konvertierende Quellslice.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-103">The source slice to convert.</span></span></param>
        <summary><span data-ttu-id="c6c2e-104">Wandelt ein <see cref="T:System.ReadOnlySpan`1" /> eines primitiven Typs, <paramref name="T" />, in ein <see langword="ReadOnlySpan&lt;Byte&gt;" /> um.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-104">Casts a <see cref="T:System.ReadOnlySpan`1" /> of one primitive type, <paramref name="T" />, to a <see langword="ReadOnlySpan&lt;Byte&gt;" />.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-105">Der schreibgeschützte Span des Typs <see cref="T:System.Byte" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-105">A read-only span of type <see cref="T:System.Byte" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-106">`T` kann keine Zeiger oder Verweise enthalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-106">`T` cannot contain pointers or references.</span></span> <span data-ttu-id="c6c2e-107">`T` wird zur Laufzeit geprüft, um die Typsicherheit beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-107">`T` is checked at runtime in order to preserve type safety.</span></span>  

      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c6c2e-108"><paramref name="T" /> enthält Verweise oder Zeiger.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-108"><paramref name="T" /> contains references or pointers.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="c6c2e-109">Die <see cref="P:System.ReadOnlySpan`1.Length" />-Eigenschaft des neuen <see cref="T:System.ReadOnlySpan`1" /> würde <see cref="F:System.Int32.MaxValue" /> überschreiten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-109">The <see cref="P:System.ReadOnlySpan`1.Length" /> property of the new <see cref="T:System.ReadOnlySpan`1" /> would exceed <see cref="F:System.Int32.MaxValue" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsBytes&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;byte&gt; AsBytes&lt;T&gt; (Span&lt;T&gt; span) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;unsigned int8&gt; AsBytes&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Span`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsBytes(Of T As Structure) (span As Span(Of T)) As Span(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static Span&lt;System::Byte&gt; AsBytes(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member AsBytes : Span&lt;'T (requires 'T : struct)&gt; -&gt; Span&lt;byte&gt; (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.AsBytes span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-110">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-110">The type of items in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="c6c2e-111">Der zu konvertierende Quellslice.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-111">The source slice to convert.</span></span></param>
        <summary><span data-ttu-id="c6c2e-112">Wandelt ein <see cref="T:System.Span`1" /> eines primitiven Typs, <paramref name="T" />, in ein <see langword="Span&lt;Byte&gt;" /> um.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-112">Casts a <see cref="T:System.Span`1" /> of one primitive type, <paramref name="T" />, to a <see langword="Span&lt;Byte&gt;" />.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-113">Ein Span des Typs <see cref="T:System.Byte" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-113">A span of type <see cref="T:System.Byte" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-114">`T` kann keine Zeiger oder Verweise enthalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-114">`T` cannot contain pointers or references.</span></span> <span data-ttu-id="c6c2e-115">`T` wird zur Laufzeit geprüft, um die Typsicherheit beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-115">`T` is checked at runtime in order to preserve type safety.</span></span>  

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c6c2e-116"><paramref name="T" /> enthält Verweise oder Zeiger.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-116"><paramref name="T" /> contains references or pointers.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="c6c2e-117">Die <see cref="P:System.Span`1.Length" />-Eigenschaft des neuen <see cref="T:System.Span`1" /> würde <see cref="F:System.Int32.MaxValue" /> überschreiten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-117">The <see cref="P:System.Span`1.Length" /> property of the new <see cref="T:System.Span`1" /> would exceed <see cref="F:System.Int32.MaxValue" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? AsMemory&lt;T&gt; (ReadOnlyMemory&lt;T&gt;? memory);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsMemory(Of T) (memory As ReadOnlyMemory(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static Memory&lt;T&gt; AsMemory(ReadOnlyMemory&lt;T&gt; memory);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ReadOnlyMemory&lt;'T&gt; -&gt; Memory&lt;'T&gt;" Usage="System.Runtime.InteropServices.MemoryMarshal.AsMemory memory" />
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (ReadOnlyMemory&lt;T&gt; memory);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-118">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-118">The type of items in the read-only memory buffer.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="c6c2e-119">Der schreibgeschützte Speicherpuffer.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-119">The read-only memory buffer.</span></span></param>
        <summary><span data-ttu-id="c6c2e-120">Erstellt eine <see cref="T:System.Memory`1" />-Instanz aus einem <see cref="T:System.ReadOnlyMemory`1" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-120">Creates a <see cref="T:System.Memory`1" /> instance from a <see cref="T:System.ReadOnlyMemory`1" />.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-121">Ein Arbeitsspeicherblock, der den gleichen Speicher wie <see cref="T:System.ReadOnlyMemory`1" /> darstellt.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-121">A memory block that represents the same memory as the <see cref="T:System.ReadOnlyMemory`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-122">Diese Methode muss mit äußerster Vorsicht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-122">This method must be used with extreme caution.</span></span> <span data-ttu-id="c6c2e-123"><xref:System.ReadOnlyMemory%601> wird verwendet, um unveränderliche Daten und anderen Arbeitsspeicher darzustellen, in den nicht geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-123"><xref:System.ReadOnlyMemory%601> is used to represent immutable data and other memory that is not meant to be written to.</span></span> <span data-ttu-id="c6c2e-124"><xref:System.Memory%601> die von dieser Methode erstellten Instanzen sollten nicht in geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-124"><xref:System.Memory%601> instances created by this method should not be written to.</span></span> <span data-ttu-id="c6c2e-125">Der Zweck dieser Methode besteht darin, Variablen zu ermöglichen, die als typisiert sind <xref:System.Memory%601> , aber nur zum Lesen zum Speichern eines verwendet werden <xref:System.ReadOnlyMemory%601> .</span><span class="sxs-lookup"><span data-stu-id="c6c2e-125">The purpose of this method is to allow variables typed as <xref:System.Memory%601> but only used for reading to store a <xref:System.ReadOnlyMemory%601>.</span></span> 

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsRef&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly T AsRef&lt;T&gt; (ReadOnlySpan&lt;byte&gt; span) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T AsRef&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsRef(Of T As Structure) (span As ReadOnlySpan(Of Byte)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static T&amp; ^ AsRef(ReadOnlySpan&lt;System::Byte&gt; span);" />
      <MemberSignature Language="F#" Value="static member AsRef : ReadOnlySpan&lt;byte&gt; -&gt; 'T (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.AsRef span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>T</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-5.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-126">Der Typ des zurückgegebenen Verweises.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-126">The type of the returned reference.</span></span></typeparam>
        <param name="span"><span data-ttu-id="c6c2e-127">Der neu zu interpretierende Bereich.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-127">The read-only span to reinterpret.</span></span></param>
        <summary><span data-ttu-id="c6c2e-128">Interpretiert einen schreibgeschützten Bereich von Bytes neu als schreibgeschützten Verweis auf die Struktur vom Typ <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-128">Reinterprets a read-only span of bytes as a read-only reference to the structure of type <paramref name="T" />.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-129">Der schreibgeschützte Verweis auf die Struktur vom Typ <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-129">The read-only reference to the structure of type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-130">`T` kann keine Zeiger oder Verweise enthalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-130">`T` cannot contain pointers or references.</span></span> <span data-ttu-id="c6c2e-131">Sie wird zur Laufzeit geprüft, um die Typsicherheit beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-131">It is checked at runtime in order to preserve type safety.</span></span>  

<span data-ttu-id="c6c2e-132">Diese Methode wird nur auf Plattformen unterstützt, die einen falsch ausgerichteten Speicherzugriff unterstützen, oder wenn der Speicherblock auf andere Weise ausgerichtet wird.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-132">This method is supported only on platforms that support misaligned memory access or when the memory block is aligned by other means.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsRef&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T AsRef&lt;T&gt; (Span&lt;byte&gt; span) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T AsRef&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Span`1&lt;unsigned int8&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsRef(Of T As Structure) (span As Span(Of Byte)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static T % AsRef(Span&lt;System::Byte&gt; span);" />
      <MemberSignature Language="F#" Value="static member AsRef : Span&lt;byte&gt; -&gt; 'T (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.AsRef span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-133">Der Typ des zurückgegebenen Verweises.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-133">The type of the returned reference.</span></span></typeparam>
        <param name="span"><span data-ttu-id="c6c2e-134">Der neu zu interpretierende Bereich.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-134">The span to reinterpret.</span></span></param>
        <summary><span data-ttu-id="c6c2e-135">Interpretiert einen Bereich von Bytes neu als Verweis auf die Struktur vom Typ <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-135">Reinterprets a span of bytes as a reference to the structure of type <paramref name="T" />.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-136">Der Verweis auf die Struktur vom Typ <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-136">The reference to the structure of type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-137">`T` kann keine Zeiger oder Verweise enthalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-137">`T` cannot contain pointers or references.</span></span> <span data-ttu-id="c6c2e-138">Sie wird zur Laufzeit geprüft, um die Typsicherheit beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-138">It is checked at runtime in order to preserve type safety.</span></span>  

<span data-ttu-id="c6c2e-139">Diese Methode wird nur auf Plattformen unterstützt, die einen falsch ausgerichteten Speicherzugriff unterstützen, oder wenn der Speicherblock auf andere Weise ausgerichtet wird.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-139">This method is supported only on platforms that support misaligned memory access or when the memory block is aligned by other means.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;TTo&gt; Cast&lt;TFrom,TTo&gt; (ReadOnlySpan&lt;TFrom&gt; span) where TFrom : struct where TTo : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!TTo&gt; Cast&lt;struct .ctor (class System.ValueType) TFrom, struct .ctor (class System.ValueType) TTo&gt;(valuetype System.ReadOnlySpan`1&lt;!!TFrom&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cast(Of TFrom As Structure, TTo As Structure) (span As ReadOnlySpan(Of TFrom)) As ReadOnlySpan(Of TTo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : value class where TTo : value class static ReadOnlySpan&lt;TTo&gt; Cast(ReadOnlySpan&lt;TFrom&gt; span);" />
      <MemberSignature Language="F#" Value="static member Cast : ReadOnlySpan&lt;'From (requires 'From : struct)&gt; -&gt; ReadOnlySpan&lt;'o (requires 'o : struct)&gt; (requires 'From : struct and 'o : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.Cast span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;TFrom&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFrom"><span data-ttu-id="c6c2e-140">Der Typ der Quell Spanne.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-140">The type of the source span.</span></span></typeparam>
        <typeparam name="TTo"><span data-ttu-id="c6c2e-141">Der Typ der Zielspanne.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-141">The type of the target span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="c6c2e-142">Der zu konvertierende Quellslice.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-142">The source slice to convert.</span></span></param>
        <summary><span data-ttu-id="c6c2e-143">Wandelt einen schreibgeschützten Span eines primitiven Typs in einen schreibgeschützten Span eines anderen primitiven Typs um.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-143">Casts a read-only span of one primitive type to a read-only span of another primitive type.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-144">Die konvertierte schreibgeschützte Span.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-144">The converted read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-145">Weder `TFrom` noch `TTo` können Zeiger oder Verweise enthalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-145">Neither `TFrom` nor `TTo` can contain pointers or references.</span></span> <span data-ttu-id="c6c2e-146">`TFrom` und `TTo` werden zur Laufzeit geprüft, um die Typsicherheit beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-146">`TFrom` and `TTo` are checked at runtime in order to preserve type safety.</span></span>  

<span data-ttu-id="c6c2e-147">Diese Methode wird nur auf Plattformen unterstützt, die einen falsch ausgerichteten Speicherzugriff unterstützen, oder wenn der Speicherblock auf andere Weise ausgerichtet wird.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-147">This method is supported only on platforms that support misaligned memory access or when the memory block is aligned by other means.</span></span>

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c6c2e-148"><paramref name="TFrom" /> oder <paramref name="TTo" /> enthält Verweise oder Zeiger.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-148"><paramref name="TFrom" /> or <paramref name="TTo" /> contains references or pointers.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;TTo&gt; Cast&lt;TFrom,TTo&gt; (Span&lt;TFrom&gt; span) where TFrom : struct where TTo : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!TTo&gt; Cast&lt;struct .ctor (class System.ValueType) TFrom, struct .ctor (class System.ValueType) TTo&gt;(valuetype System.Span`1&lt;!!TFrom&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cast(Of TFrom As Structure, TTo As Structure) (span As Span(Of TFrom)) As Span(Of TTo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : value class where TTo : value class static Span&lt;TTo&gt; Cast(Span&lt;TFrom&gt; span);" />
      <MemberSignature Language="F#" Value="static member Cast : Span&lt;'From (requires 'From : struct)&gt; -&gt; Span&lt;'o (requires 'o : struct)&gt; (requires 'From : struct and 'o : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.Cast span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;TFrom&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFrom"><span data-ttu-id="c6c2e-149">Der Typ der Quell Spanne.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-149">The type of the source span.</span></span></typeparam>
        <typeparam name="TTo"><span data-ttu-id="c6c2e-150">Der Typ der Zielspanne.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-150">The type of the target span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="c6c2e-151">Der zu konvertierende Quellslice.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-151">The source slice to convert.</span></span></param>
        <summary><span data-ttu-id="c6c2e-152">Wandelt einen Span eines primitiven Typs in einen Span eines anderen primitiven Typs um.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-152">Casts a span of one primitive type to a span of another primitive type.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-153">Der konvertierte Span.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-153">The converted span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-154">Weder `TFrom` noch `TTo` können Zeiger oder Verweise enthalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-154">Neither `TFrom` nor `TTo` can contain pointers or references.</span></span> <span data-ttu-id="c6c2e-155">`TFrom` und `TTo` werden zur Laufzeit geprüft, um die Typsicherheit beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-155">`TFrom` and `TTo` are checked at runtime in order to preserve type safety.</span></span>  

<span data-ttu-id="c6c2e-156">Wenn die Größe der beiden Typen unterschiedlich ist, kombiniert oder teilt die Umwandlung Werte, was zu einer Änderung der Länge führt.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-156">If the sizes of the two types are different, the cast combines or splits values, which leads to a change in length.</span></span>

<span data-ttu-id="c6c2e-157">Wenn z. `TFrom` b. ist <xref:System.Int64> , `ReadOnlySpan<Int64>` enthält den einzelnen Wert, 0x0100001111110, und `TTo` ist <xref:System.Int32> , enthält die resultierende `ReadOnlySpan<Int32>` zwei Werte.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-157">For example, if `TFrom` is <xref:System.Int64>, the `ReadOnlySpan<Int64>` contains a single value, 0x0100001111110F0F, and `TTo` is <xref:System.Int32>, the resulting `ReadOnlySpan<Int32>` contains two values.</span></span> <span data-ttu-id="c6c2e-158">Die Werte lauten 0x11110f 0F und 0x01000011 in einer Little-in-Architektur, z. b. x86.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-158">The values are 0x11110F0F and 0x01000011 on a little-endian architecture, such as x86.</span></span> <span data-ttu-id="c6c2e-159">In einer Big-End-Architektur wird die Reihenfolge der beiden Werte umgekehrt, d. h. 0x01000011, gefolgt von 0x11110f 0F.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-159">On a big-endian architecture, the order of the two values is reversed, i.e. 0x01000011, followed by 0x11110F0F.</span></span>

<span data-ttu-id="c6c2e-160">Ein weiteres Beispiel: Wenn `TFrom` ist <xref:System.Int32> , `ReadOnlySpan<Int32>` enthält die Werte 1, 2 und 3, und `TTo` ist <xref:System.Int64> , das resultierende `ReadOnlySpan<Int64>` enthält einen einzelnen Wert: 0x0000000200000001 für eine Little-in-Architektur und 0x0000000100000002 in einer Big-in-Architektur.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-160">As another example, if `TFrom` is <xref:System.Int32>, the `ReadOnlySpan<Int32>` contains the values of 1, 2 and 3, and `TTo` is <xref:System.Int64>, the resulting `ReadOnlySpan<Int64>` contains a single value: 0x0000000200000001 on a little-endian architecture and 0x0000000100000002 on a big-endian architecture.</span></span>

<span data-ttu-id="c6c2e-161">Diese Methode wird nur auf Plattformen unterstützt, die einen falsch ausgerichteten Speicherzugriff unterstützen, oder wenn der Speicherblock auf andere Weise ausgerichtet wird.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-161">This method is supported only on platforms that support misaligned memory access or when the memory block is aligned by other means.</span></span>

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c6c2e-162"><paramref name="TFrom" /> oder <paramref name="TTo" /> enthält Verweise oder Zeiger.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-162"><paramref name="TFrom" /> or <paramref name="TTo" /> contains references or pointers.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromPinnedArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? CreateFromPinnedArray&lt;T&gt; (T[]? array, int start, int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; CreateFromPinnedArray&lt;T&gt;(!!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromPinnedArray(Of T) (array As T(), start As Integer, length As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static Memory&lt;T&gt; CreateFromPinnedArray(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="static member CreateFromPinnedArray : 'T[] * int * int -&gt; Memory&lt;'T&gt;" Usage="System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray (array, start, length)" />
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; CreateFromPinnedArray&lt;T&gt; (T[] array, int start, int length);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-163">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-163">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="c6c2e-164">Das bereits angeheftete Quellarray.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-164">The pre-pinned source array.</span></span></param>
        <param name="start"><span data-ttu-id="c6c2e-165">Der Index von <paramref name="array" />, bei dem der Speicherblock begonnen wird.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-165">The index of <paramref name="array" /> at which to begin the memory block.</span></span></param>
        <param name="length"><span data-ttu-id="c6c2e-166">Die Anzahl der Elemente, die in den Speicherblock eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-166">The number of items to include in the memory block.</span></span></param>
        <summary><span data-ttu-id="c6c2e-167">Erstellt einen neuen Speicherpuffer über dem Abschnitt des bereits angehefteten Zielarrays, der beim Index <paramref name="start" /> beginnt und aus <paramref name="length" />-Elementen besteht.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-167">Creates a new memory buffer over the portion of the pre-pinned target array beginning at the <paramref name="start" /> index and consisting of <paramref name="length" /> items.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-168">Ein Speicherblock über die angegebenen Elemente von <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-168">A block of memory over the specified elements of <paramref name="array" />.</span></span> <span data-ttu-id="c6c2e-169">Wenn <paramref name="array" /><see langword="null" /> ist, oder wenn <paramref name="start" /> und <paramref name="length" /> 0 sind, gibt die Methode eine <see cref="T:System.Memory`1" /> Instanz von <see cref="P:System.Memory`1.Length" /> Null wieder.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-169">If <paramref name="array" /> is <see langword="null" />, or if <paramref name="start" /> and <paramref name="length" /> are 0, the method returns a <see cref="T:System.Memory`1" /> instance of <see cref="P:System.Memory`1.Length" /> zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-170">Das Array muss bereits fixiert sein, bevor diese Methode aufgerufen wird, und dieses Array darf nicht gelöst werden, während der <xref:System.Memory%601> zurückgegebene Puffer noch verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-170">The array must already be pinned before this method is called, and that array must not be unpinned while the <xref:System.Memory%601> buffer that it returns is still in use.</span></span> <span data-ttu-id="c6c2e-171">Das Aufrufen dieser Methode für ein nicht angeheftete Array kann zu einer Beschädigung des Arbeitsspeichers führen.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-171">Calling this method on an unpinned array could result in memory corruption.</span></span>

       ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="c6c2e-172"><paramref name="array" /> ist kovariant, und den Typ von <paramref name="array" /> ist nicht genau <paramref name="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-172"><paramref name="array" /> is covariant, and the type of <paramref name="array" /> is not exactly <paramref name="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c6c2e-173">Der <paramref name="start" />- oder der Endindex liegt nicht im Bereich von 0 bis <see cref="P:System.Array.Length" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-173">The <paramref name="start" /> or the end index is not in the range of 0 to <see cref="P:System.Array.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReadOnlySpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt;? CreateReadOnlySpan&lt;T&gt; (ref T reference, int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; CreateReadOnlySpan&lt;T&gt;(!!T&amp; reference, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateReadOnlySpan(Of T) (ByRef reference As T, length As Integer) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static ReadOnlySpan&lt;T&gt; CreateReadOnlySpan(T % reference, int length);" />
      <MemberSignature Language="F#" Value="static member CreateReadOnlySpan : 'T * int -&gt; ReadOnlySpan&lt;'T&gt;" Usage="System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan (reference, length)" />
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; CreateReadOnlySpan&lt;T&gt; (ref T reference, int length);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reference" Type="T" RefType="ref" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-174">Der Typ der Datenelemente.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-174">The type of the data items.</span></span></typeparam>
        <param name="reference"><span data-ttu-id="c6c2e-175">Ein Verweis auf Daten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-175">A reference to data.</span></span></param>
        <param name="length"><span data-ttu-id="c6c2e-176">Die Anzahl der <paramref name="T" />-Elemente, die in <paramref name="reference" /> enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-176">The number of <paramref name="T" /> elements that <paramref name="reference" /> contains.</span></span></param>
        <summary><span data-ttu-id="c6c2e-177">Erstellt ein neues schreibgeschützten Span über einen Teil eines regulären verwalteten Objekts.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-177">Creates a new read-only span over a portion of a regular managed object.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-178">Ein schreibgeschützter Span.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-178">A read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-179">Diese Methode kann nützlich sein, wenn ein Teil eines verwalteten Objekts ein festes Array darstellt.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-179">This method can be useful if part of a managed object represents a fixed array.</span></span> 

> [!WARNING]
> <span data-ttu-id="c6c2e-180">Diese Methode sollte mit Bedacht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-180">This method should be used with caution.</span></span> <span data-ttu-id="c6c2e-181">Dies ist gefährlich, da das- `length` Argument nicht aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-181">It is dangerous because the `length` argument is not checked.</span></span> <span data-ttu-id="c6c2e-182">Außerdem wird die Lebensdauer der zurückgegebenen Spanne nicht durch Spannen abhängige Sprachen auf Sicherheit überprüft.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-182">In addition, the lifetime of the returned span is not validated for safety by span-aware languages.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? CreateSpan&lt;T&gt; (ref T reference, int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; CreateSpan&lt;T&gt;(!!T&amp; reference, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSpan(Of T) (ByRef reference As T, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static Span&lt;T&gt; CreateSpan(T % reference, int length);" />
      <MemberSignature Language="F#" Value="static member CreateSpan : 'T * int -&gt; Span&lt;'T&gt;" Usage="System.Runtime.InteropServices.MemoryMarshal.CreateSpan (reference, length)" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; CreateSpan&lt;T&gt; (ref T reference, int length);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reference" Type="T" RefType="ref" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-183">Der Typ der Datenelemente.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-183">The type of the data items.</span></span></typeparam>
        <param name="reference"><span data-ttu-id="c6c2e-184">Ein Verweis auf Daten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-184">A reference to data.</span></span></param>
        <param name="length"><span data-ttu-id="c6c2e-185">Die Anzahl der <paramref name="T" />-Elemente, die in <paramref name="reference" /> enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-185">The number of <paramref name="T" /> elements that <paramref name="reference" /> contains.</span></span></param>
        <summary><span data-ttu-id="c6c2e-186">Erstellt einen neuen Span über einen Teil eines regulären verwalteten Objekts.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-186">Creates a new span over a portion of a regular managed object.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-187">Ein Span.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-187">A span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-188">Diese Methode kann nützlich sein, wenn ein Teil eines verwalteten Objekts ein festes Array darstellt.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-188">This method can be useful if part of a managed object represents a fixed array.</span></span> 

> [!WARNING]
> <span data-ttu-id="c6c2e-189">Diese Methode sollte mit Bedacht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-189">This method should be used with caution.</span></span> <span data-ttu-id="c6c2e-190">Dies ist gefährlich, da das- `length` Argument nicht aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-190">It is dangerous because the `length` argument is not checked.</span></span> <span data-ttu-id="c6c2e-191">Außerdem wird die Lebensdauer der zurückgegebenen Spanne nicht durch Spannen abhängige Sprachen auf Sicherheit überprüft.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-191">In addition, the lifetime of the returned span is not validated for safety by span-aware languages.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayDataReference&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T GetArrayDataReference&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetArrayDataReference&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetArrayDataReference(Of T) (array As T()) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % GetArrayDataReference(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member GetArrayDataReference : 'T[] -&gt; 'T" Usage="System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReference&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T GetReference&lt;T&gt; (ReadOnlySpan&lt;T&gt;? span);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetReference&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReference(Of T) (span As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % GetReference(ReadOnlySpan&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member GetReference : ReadOnlySpan&lt;'T&gt; -&gt; 'T" Usage="System.Runtime.InteropServices.MemoryMarshal.GetReference span" />
      <MemberSignature Language="C#" Value="public static ref T GetReference&lt;T&gt; (ReadOnlySpan&lt;T&gt; span);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-192">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-192">The type of items in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="c6c2e-193">Der schreibgeschützte Span, aus dem der Verweis abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-193">The read-only span from which the reference is retrieved.</span></span></param>
        <summary><span data-ttu-id="c6c2e-194">Gibt einen Verweis auf das Element des schreibgeschützten Span bei Index 0 zurück.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-194">Returns a reference to the element of the read-only span at index 0.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-195">Ein Verweis auf das Element bei Index 0.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-195">A reference to the element at index 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-196">Wenn die schreibgeschützte Spanne leer ist, gibt diese Methode einen Verweis auf den Speicherort zurück, an dem das Element am Index 0 gespeichert wäre.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-196">If the read-only span is empty, this method returns a reference to the location where the element at index 0 would have been stored.</span></span> <span data-ttu-id="c6c2e-197">Ein solcher Verweis ist möglicherweise `null` .</span><span class="sxs-lookup"><span data-stu-id="c6c2e-197">Such a reference may or may not be `null`.</span></span> <span data-ttu-id="c6c2e-198">Der zurückgegebene Verweis kann zum Fixieren verwendet werden, er darf jedoch nie dereferenziert werden.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-198">The returned reference can be used for pinning, but it must never be dereferenced.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReference&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T GetReference&lt;T&gt; (Span&lt;T&gt;? span);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetReference&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReference(Of T) (span As Span(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % GetReference(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member GetReference : Span&lt;'T&gt; -&gt; 'T" Usage="System.Runtime.InteropServices.MemoryMarshal.GetReference span" />
      <MemberSignature Language="C#" Value="public static ref T GetReference&lt;T&gt; (Span&lt;T&gt; span);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-199">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-199">The type of items in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="c6c2e-200">Der Span, aus dem der Verweis abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-200">The span from which the reference is retrieved.</span></span></param>
        <summary><span data-ttu-id="c6c2e-201">Gibt einen Verweis auf das Element des Span bei Index 0 zurück.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-201">Returns a reference to the element of the span at index 0.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-202">Ein Verweis auf das Element bei Index 0.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-202">A reference to the element at index 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-203">Wenn die Spanne leer ist, gibt diese Methode einen Verweis auf den Speicherort zurück, an dem das Element am Index 0 gespeichert wäre.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-203">If the span is empty, this method returns a reference to the location where the element at index 0 would have been stored.</span></span> <span data-ttu-id="c6c2e-204">Ein solcher Verweis ist möglicherweise `null` .</span><span class="sxs-lookup"><span data-stu-id="c6c2e-204">Such a reference may or may not be `null`.</span></span> <span data-ttu-id="c6c2e-205">Der zurückgegebene Verweis kann zum Fixieren verwendet werden, er darf jedoch nie dereferenziert werden.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-205">The returned reference can be used for pinning, but it must never be dereferenced.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Read&lt;T&gt; (ReadOnlySpan&lt;byte&gt; source) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Read&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read(Of T As Structure) (source As ReadOnlySpan(Of Byte)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static T Read(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member Read : ReadOnlySpan&lt;byte&gt; -&gt; 'T (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.Read source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-206">Der Typ des Elements, das aus der schreibgeschützten Spanne abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-206">The type of the item to retrieve from the read-only span.</span></span></typeparam>
        <param name="source"><span data-ttu-id="c6c2e-207">Ein schreibgeschützter Span.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-207">A read-only span.</span></span></param>
        <summary><span data-ttu-id="c6c2e-208">Liest eine Struktur des Typ</span><span class="sxs-lookup"><span data-stu-id="c6c2e-208">Reads a structure of type</span></span> <param name="T" /> <span data-ttu-id="c6c2e-209">aus dem schreibgeschützten Bytes-Span.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-209">out of a read-only span of bytes.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-210">Die aus dem schreibgeschützten Span abgerufene Struktur.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-210">The structure retrieved from the read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-211">`T` kann keine Zeiger oder Verweise enthalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-211">`T` cannot contain pointers or references.</span></span> <span data-ttu-id="c6c2e-212">Sie wird zur Laufzeit geprüft, um die Typsicherheit beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-212">It is checked at runtime in order to preserve type safety.</span></span>  

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c6c2e-213"><paramref name="T" /> enthält Verweise oder Zeiger.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-213"><paramref name="T" /> contains references or pointers.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c6c2e-214"><paramref name="source" /> ist kleiner als <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-214"><paramref name="source" /> is smaller than <paramref name="T" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToEnumerable&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; ToEnumerable&lt;T&gt; (ReadOnlyMemory&lt;T&gt;? memory);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; ToEnumerable&lt;T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToEnumerable(Of T) (memory As ReadOnlyMemory(Of T)) As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::Generic::IEnumerable&lt;T&gt; ^ ToEnumerable(ReadOnlyMemory&lt;T&gt; memory);" />
      <MemberSignature Language="F#" Value="static member ToEnumerable : ReadOnlyMemory&lt;'T&gt; -&gt; seq&lt;'T&gt;" Usage="System.Runtime.InteropServices.MemoryMarshal.ToEnumerable memory" />
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; ToEnumerable&lt;T&gt; (ReadOnlyMemory&lt;T&gt; memory);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-215">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-215">The type of the items in the read-only memory buffer.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="c6c2e-216">Ein schreibgeschützter Speicherpuffer.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-216">A read-only memory buffer.</span></span></param>
        <summary><span data-ttu-id="c6c2e-217">Erstellt eine <see cref="T:System.Collections.Generic.IEnumerable`1" />-Ansicht des angegebenen schreibgeschützten Speicherpuffers.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-217">Creates an <see cref="T:System.Collections.Generic.IEnumerable`1" /> view of the given read-only memory buffer.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-218">Eine aufzählbare Ansicht von <paramref name="memory" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-218">An enumerable view of <paramref name="memory" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-219">Mit dieser Methode kann ein Schreib geschützter Arbeitsspeicher Puffer in vorhandenen APIs verwendet werden, die einen Parameter vom Typ benötigen <xref:System.Collections.Generic.IEnumerable%601> .</span><span class="sxs-lookup"><span data-stu-id="c6c2e-219">This method allows a read-only memory buffer to be used in existing APIs that require a parameter of type <xref:System.Collections.Generic.IEnumerable%601>.</span></span> 

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetArray&lt;T&gt; (ReadOnlyMemory&lt;T&gt;? memory, out ArraySegment&lt;T&gt;? segment);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetArray&lt;T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, [out] valuetype System.ArraySegment`1&lt;!!T&gt;&amp; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetArray(Of T) (memory As ReadOnlyMemory(Of T), ByRef segment As ArraySegment(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TryGetArray(ReadOnlyMemory&lt;T&gt; memory, [Runtime::InteropServices::Out] ArraySegment&lt;T&gt; % segment);" />
      <MemberSignature Language="F#" Value="static member TryGetArray : ReadOnlyMemory&lt;'T&gt; * ArraySegment -&gt; bool" Usage="System.Runtime.InteropServices.MemoryMarshal.TryGetArray (memory, segment)" />
      <MemberSignature Language="C#" Value="public static bool TryGetArray&lt;T&gt; (ReadOnlyMemory&lt;T&gt; memory, out ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" />
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-220">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-220">The type of items in the read-only memory buffer.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="c6c2e-221">Ein schreibgeschützter Speicherpuffer.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-221">A read-only memory buffer.</span></span></param>
        <param name="segment"><span data-ttu-id="c6c2e-222">Wenn diese Methode ein Ergebnis zurückgibt, enthält sie das Arraysegment, das aus dem zugrunde liegenden schreibgeschützten Speicherpuffer abgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-222">When this method returns, contains the array segment retrieved from the underlying read-only memory buffer.</span></span> <span data-ttu-id="c6c2e-223">Wenn die Methode fehlschlägt, gibt die Methode ein Standardarraysegment zurück.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-223">If the method fails, the method returns a default array segment.</span></span></param>
        <summary><span data-ttu-id="c6c2e-224">Versucht, ein Arraysegment aus dem zugrunde liegenden Speicherpuffer abzurufen.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-224">Tries to get an array segment from the underlying memory buffer.</span></span> <span data-ttu-id="c6c2e-225">Der Rückgabewert gibt den Erfolg des Vorgangs an.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-225">The return value indicates the success of the operation.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-226"><see langword="true" />, wenn der Aufruf der Methode erfolgreich ist; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-226"><see langword="true" /> if the method call succeeds; <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMemoryManager&lt;T,TManager&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetMemoryManager&lt;T,TManager&gt; (ReadOnlyMemory&lt;T&gt;? memory, out TManager manager) where TManager : System.Buffers.MemoryManager&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetMemoryManager&lt;T, (class System.Buffers.MemoryManager`1&lt;!!T&gt;) TManager&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, [out] !!TManager&amp; manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetMemoryManager(Of T, TManager) (memory As ReadOnlyMemory(Of T), ByRef manager As TManager) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TManager&gt;&#xA; where TManager : System::Buffers::MemoryManager&lt;T&gt; static bool TryGetMemoryManager(ReadOnlyMemory&lt;T&gt; memory, [Runtime::InteropServices::Out] TManager % manager);" />
      <MemberSignature Language="F#" Value="static member TryGetMemoryManager : ReadOnlyMemory&lt;'T&gt; * 'Manager -&gt; bool (requires 'Manager :&gt; System.Buffers.MemoryManager&lt;'T&gt;)" Usage="System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager (memory, manager)" />
      <MemberSignature Language="C#" Value="public static bool TryGetMemoryManager&lt;T,TManager&gt; (ReadOnlyMemory&lt;T&gt; memory, out TManager manager) where TManager : System.Buffers.MemoryManager&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TManager">
          <Constraints>
            <BaseTypeName>System.Buffers.MemoryManager&lt;T&gt;</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" />
        <Parameter Name="manager" Type="TManager" RefType="out">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-227">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-227">The type of the items in the read-only memory buffer.</span></span></typeparam>
        <typeparam name="TManager"><span data-ttu-id="c6c2e-228">Der Typ des abzurufenden <see cref="T:System.Buffers.MemoryManager`1" /> .</span><span class="sxs-lookup"><span data-stu-id="c6c2e-228">The type of the <see cref="T:System.Buffers.MemoryManager`1" /> to retrieve.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="c6c2e-229">Der schreibgeschützten Speicherpuffer, für den der Speicher-Manager abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-229">The read-only memory buffer for which to get the memory manager.</span></span></param>
        <param name="manager"><span data-ttu-id="c6c2e-230">Wenn die Methode ein Ergebnis zurückgibt, der Manager von <paramref name="memory" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-230">When the method returns, the manager of <paramref name="memory" />.</span></span></param>
        <summary><span data-ttu-id="c6c2e-231">Versucht, den <see cref="T:System.Buffers.MemoryManager`1" /> aus dem zugrunde liegenden schreibgeschützten Speicherpuffer abzurufen.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-231">Tries to retrieve a <see cref="T:System.Buffers.MemoryManager`1" /> from the underlying read-only memory buffer.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-232"><see langword="true" />, wenn die Methode den Speicher-Manager abruft, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-232"><see langword="true" /> if the method retrieved the memory manager; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMemoryManager&lt;T,TManager&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetMemoryManager&lt;T,TManager&gt; (ReadOnlyMemory&lt;T&gt;? memory, out TManager manager, out int start, out int length) where TManager : System.Buffers.MemoryManager&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetMemoryManager&lt;T, (class System.Buffers.MemoryManager`1&lt;!!T&gt;) TManager&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, [out] !!TManager&amp; manager, [out] int32&amp; start, [out] int32&amp; length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetMemoryManager(Of T, TManager) (memory As ReadOnlyMemory(Of T), ByRef manager As TManager, ByRef start As Integer, ByRef length As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TManager&gt;&#xA; where TManager : System::Buffers::MemoryManager&lt;T&gt; static bool TryGetMemoryManager(ReadOnlyMemory&lt;T&gt; memory, [Runtime::InteropServices::Out] TManager % manager, [Runtime::InteropServices::Out] int % start, [Runtime::InteropServices::Out] int % length);" />
      <MemberSignature Language="F#" Value="static member TryGetMemoryManager : ReadOnlyMemory&lt;'T&gt; * 'Manager * int * int -&gt; bool (requires 'Manager :&gt; System.Buffers.MemoryManager&lt;'T&gt;)" Usage="System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager (memory, manager, start, length)" />
      <MemberSignature Language="C#" Value="public static bool TryGetMemoryManager&lt;T,TManager&gt; (ReadOnlyMemory&lt;T&gt; memory, out TManager manager, out int start, out int length) where TManager : System.Buffers.MemoryManager&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TManager">
          <Constraints>
            <BaseTypeName>System.Buffers.MemoryManager&lt;T&gt;</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" />
        <Parameter Name="manager" Type="TManager" RefType="out">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="start" Type="System.Int32" RefType="out" />
        <Parameter Name="length" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-233">Der Typ der Elemente im schreibgeschützten Speicherpuffer.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-233">The type of the items in the read-only memory buffer.</span></span></typeparam>
        <typeparam name="TManager"><span data-ttu-id="c6c2e-234">Der Typ des abzurufenden <see cref="T:System.Buffers.MemoryManager`1" /> .</span><span class="sxs-lookup"><span data-stu-id="c6c2e-234">The type of the <see cref="T:System.Buffers.MemoryManager`1" /> to retrieve.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="c6c2e-235">Der schreibgeschützten Speicherpuffer, für den der Speicher-Manager abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-235">The read-only memory buffer for which to get the memory manager.</span></span></param>
        <param name="manager"><span data-ttu-id="c6c2e-236">Wenn die Methode ein Ergebnis zurückgibt, der Manager von <paramref name="memory" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-236">When the method returns, the manager of <paramref name="memory" />.</span></span></param>
        <param name="start"><span data-ttu-id="c6c2e-237">Wenn die Methode ein Ergebnis zurückgibt, der Offset ab dem Beginn des <paramref name="manager" />, den der <paramref name="memory" /> darstellt.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-237">When the method returns, the offset from the start of the <paramref name="manager" /> that the <paramref name="memory" /> represents.</span></span></param>
        <param name="length"><span data-ttu-id="c6c2e-238">Wenn die Methode ein Ergebnis zurückgibt, der Länge des <paramref name="manager" />, den der <paramref name="memory" /> darstellt.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-238">When the method returns, the length of the <paramref name="manager" /> that the <paramref name="memory" /> represents.</span></span></param>
        <summary><span data-ttu-id="c6c2e-239">Versucht, den <see cref="T:System.Buffers.MemoryManager`1" />, den Startindex und die Länge aus dem zugrunde liegenden schreibgeschützten Speicherpuffer abzurufen.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-239">Tries to retrieve a <see cref="T:System.Buffers.MemoryManager`1" />, start index, and length from the underlying read-only memory buffer.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-240"><see langword="true" />, wenn die Methode erfolgreich ausgeführt wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-240"><see langword="true" /> if the method succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetString">
      <MemberSignature Language="C#" Value="public static bool TryGetString (ReadOnlyMemory&lt;char&gt; memory, out string? text, out int start, out int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetString(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory, [out] string&amp; text, [out] int32&amp; start, [out] int32&amp; length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetString (memory As ReadOnlyMemory(Of Char), ByRef text As String, ByRef start As Integer, ByRef length As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetString(ReadOnlyMemory&lt;char&gt; memory, [Runtime::InteropServices::Out] System::String ^ % text, [Runtime::InteropServices::Out] int % start, [Runtime::InteropServices::Out] int % length);" />
      <MemberSignature Language="F#" Value="static member TryGetString : ReadOnlyMemory&lt;char&gt; * string * int * int -&gt; bool" Usage="System.Runtime.InteropServices.MemoryMarshal.TryGetString (memory, text, start, length)" />
      <MemberSignature Language="C#" Value="public static bool TryGetString (ReadOnlyMemory&lt;char&gt; memory, out string text, out int start, out int length);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" />
        <Parameter Name="text" Type="System.String" RefType="out">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="start" Type="System.Int32" RefType="out" />
        <Parameter Name="length" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="c6c2e-241">Schreibgeschützter Speicher mit einem Block an Zeichen.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-241">Read-only memory containing a block of characters.</span></span></param>
        <param name="text"><span data-ttu-id="c6c2e-242">Wenn die Methode ein Ergebnis zurückgibt, die Zeichenfolge im Speicherpuffer.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-242">When the method returns, the string contained in the memory buffer.</span></span></param>
        <param name="start"><span data-ttu-id="c6c2e-243">Die Anfangsposition in <paramref name="text" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-243">The starting location in <paramref name="text" />.</span></span></param>
        <param name="length"><span data-ttu-id="c6c2e-244">Die Anzahl von Zeichen in <paramref name="text" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-244">The number of characters in <paramref name="text" />.</span></span></param>
        <summary><span data-ttu-id="c6c2e-245">Versucht, die zugrunde liegenden Zeichenfolge aus einem <see langword="System.ReadOnlyMemory&lt;Char&gt;" /> abzurufen.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-245">Tries to get the underlying string from a <see langword="System.ReadOnlyMemory&lt;Char&gt;" />.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-246"><see langword="true" />, wenn die Methode die zugrunde liegende Zeichenfolge erfolgreich abruft, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-246"><see langword="true" /> if the method successfully retrieves the underlying string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryRead&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryRead&lt;T&gt; (ReadOnlySpan&lt;byte&gt; source, out T value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryRead&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryRead(Of T As Structure) (source As ReadOnlySpan(Of Byte), ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool TryRead(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member TryRead : ReadOnlySpan&lt;byte&gt; * 'T -&gt; bool (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.TryRead (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-247">Der Typ der abzurufenden-Struktur.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-247">The type of the structure to retrieve.</span></span></typeparam>
        <param name="source"><span data-ttu-id="c6c2e-248">Ein schreibgeschützter Bytes-Span.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-248">A read-only span of bytes.</span></span></param>
        <param name="value"><span data-ttu-id="c6c2e-249">Wenn die Methode ein Ergebnis zurückgibt, eine Instanz von <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-249">When the method returns, an instance of <paramref name="T" />.</span></span></param>
        <summary><span data-ttu-id="c6c2e-250">Versucht, eine Struktur vom Typ <paramref name="T" /> aus einem schreibgeschützten Bereich von Bytes zu lesen.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-250">Tries to read a structure of type <paramref name="T" /> from a read-only span of bytes.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-251"><see langword="true" />, wenn die Methode erfolgreich eine Instanz der Struktur abruft, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-251"><see langword="true" /> if the method succeeds in retrieving an instance of the structure; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-252">`T` kann keine Zeiger oder Verweise enthalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-252">`T` cannot contain pointers or references.</span></span> <span data-ttu-id="c6c2e-253">Sie wird zur Laufzeit geprüft, um die Typsicherheit beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-253">It is checked at runtime in order to preserve type safety.</span></span>  

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c6c2e-254"><paramref name="T" /> enthält Verweise oder Zeiger.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-254"><paramref name="T" /> contains references or pointers.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryWrite&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryWrite&lt;T&gt; (Span&lt;byte&gt; destination, ref T value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWrite&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Span`1&lt;unsigned int8&gt; destination, !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWrite(Of T As Structure) (destination As Span(Of Byte), ByRef value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static bool TryWrite(Span&lt;System::Byte&gt; destination, T % value);" />
      <MemberSignature Language="F#" Value="static member TryWrite : Span&lt;byte&gt; * 'T -&gt; bool (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.TryWrite (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="T" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-255">Der Typ der Struktur.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-255">The type of the structure.</span></span></typeparam>
        <param name="destination"><span data-ttu-id="c6c2e-256">Der Bytes-Span, der die Struktur enthält.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-256">The span of bytes to contain the structure.</span></span></param>
        <param name="value"><span data-ttu-id="c6c2e-257">Die Struktur, die in den Span geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-257">The structure to be written to the span.</span></span></param>
        <summary><span data-ttu-id="c6c2e-258">Versucht, eine Struktur vom Typ <paramref name="T" /> in einen Bereich von Bytes zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-258">Tries to write a structure of type <paramref name="T" /> into a span of bytes.</span></span></summary>
        <returns><span data-ttu-id="c6c2e-259"><see langword="true" />, wenn der Schreibvorgang erfolgreich ausgeführt wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-259"><see langword="true" /> if the write operation succeeded; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c6c2e-260">Die Methode gibt <see langword="false" /> zurück, wenn der Bereich zu klein ist für den <paramref name="T" /> ist.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-260">The method returns <see langword="false" /> if the span is too small to contain <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-261">`T` kann keine Zeiger oder Verweise enthalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-261">`T` cannot contain pointers or references.</span></span> <span data-ttu-id="c6c2e-262">Sie wird zur Laufzeit geprüft, um die Typsicherheit beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-262">It is checked at runtime in order to preserve type safety.</span></span>  

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c6c2e-263"><paramref name="T" /> enthält Verweise oder Zeiger.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-263"><paramref name="T" /> contains references or pointers.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Write&lt;T&gt; (Span&lt;byte&gt; destination, ref T value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.Span`1&lt;unsigned int8&gt; destination, !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write(Of T As Structure) (destination As Span(Of Byte), ByRef value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static void Write(Span&lt;System::Byte&gt; destination, T % value);" />
      <MemberSignature Language="F#" Value="static member Write : Span&lt;byte&gt; * 'T -&gt; unit (requires 'T : struct)" Usage="System.Runtime.InteropServices.MemoryMarshal.Write (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="T" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="c6c2e-264">Der Typ der Struktur.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-264">The type of the structure.</span></span></typeparam>
        <param name="destination"><span data-ttu-id="c6c2e-265">Der Bytes-Span, der die Struktur enthält.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-265">The span of bytes to contain the structure.</span></span></param>
        <param name="value"><span data-ttu-id="c6c2e-266">Die Struktur, die in den Span geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-266">The structure to be written to the span.</span></span></param>
        <summary><span data-ttu-id="c6c2e-267">Schreibt eine Struktur vom Typ <paramref name="T" /> in einen Bereich von Bytes.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-267">Writes a structure of type <paramref name="T" /> into a span of bytes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="c6c2e-268">`T` kann keine Zeiger oder Verweise enthalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-268">`T` cannot contain pointers or references.</span></span> <span data-ttu-id="c6c2e-269">Sie wird zur Laufzeit geprüft, um die Typsicherheit beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-269">It is checked at runtime in order to preserve type safety.</span></span>  

       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c6c2e-270"><paramref name="T" /> enthält Verweise oder Zeiger.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-270"><paramref name="T" /> contains references or pointers.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c6c2e-271"><paramref name="destination" /> ist zu klein für <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="c6c2e-271"><paramref name="destination" /> is too small to contain <paramref name="value" />.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
