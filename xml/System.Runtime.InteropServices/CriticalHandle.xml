<Type Name="CriticalHandle" FullName="System.Runtime.InteropServices.CriticalHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="56d9d023a154981435b37666fa081861ca0100c2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.CriticalHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CriticalHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class CriticalHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="c95dd-101">Stellt eine Wrapperklasse für Handleressourcen dar.</span>
      <span class="sxs-lookup">
        <span data-stu-id="c95dd-101">Represents a wrapper class for handle resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c95dd-102">Die <xref:System.Runtime.InteropServices.CriticalHandle> -Klasse ähnelt der <xref:System.Runtime.InteropServices.SafeHandle> Klasse, außer dass <xref:System.Runtime.InteropServices.SafeHandle> verweiszählung implementiert.</span><span class="sxs-lookup"><span data-stu-id="c95dd-102">The <xref:System.Runtime.InteropServices.CriticalHandle> class is similar to the <xref:System.Runtime.InteropServices.SafeHandle> class, except that <xref:System.Runtime.InteropServices.SafeHandle> implements reference counting.</span></span> <span data-ttu-id="c95dd-103">Können Sie <xref:System.Runtime.InteropServices.CriticalHandle> anstelle von <xref:System.Runtime.InteropServices.SafeHandle> , Leistungsaspekte Adresse, wenn Sie der erforderlichen Synchronisierung mehr angeben können effizient selbst.</span><span class="sxs-lookup"><span data-stu-id="c95dd-103">You can use <xref:System.Runtime.InteropServices.CriticalHandle> instead of <xref:System.Runtime.InteropServices.SafeHandle> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.</span></span>  
  
 <span data-ttu-id="c95dd-104">Da die <xref:System.Runtime.InteropServices.CriticalHandle> Klasse führt keine verweiszählung, er bietet keinen Schutz vor Sicherheitsangriffen Wiederverwendung Handle.</span><span class="sxs-lookup"><span data-stu-id="c95dd-104">Because the <xref:System.Runtime.InteropServices.CriticalHandle> class does not perform reference counting, it does not provide protection from handle recycling security attacks.</span></span> <span data-ttu-id="c95dd-105">Da die verweiszählung Algorithmus implizit Vorgänge serialisiert, ist eine gewisse Threadsicherheit auch verloren.</span><span class="sxs-lookup"><span data-stu-id="c95dd-105">Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost.</span></span> <span data-ttu-id="c95dd-106">Beim Aufrufen der <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> oder <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> Methode während ein Vorgangs, der das Handle verwendet in einem anderen Thread aussteht, oder beim Aufrufen <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> oder <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> von zwei Threads gleichzeitig die Ergebnisse sind nicht deterministisch.</span><span class="sxs-lookup"><span data-stu-id="c95dd-106">If you call the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method while an operation that is using the handle is outstanding on another thread, or if you call <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> from two threads at the same time, the results are non-deterministic.</span></span> <span data-ttu-id="c95dd-107">Die <xref:System.Runtime.InteropServices.CriticalHandle> Klasse bietet weiterhin die garantierte Handleressourcen gebotenen der <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> Klasse.</span><span class="sxs-lookup"><span data-stu-id="c95dd-107">The <xref:System.Runtime.InteropServices.CriticalHandle> class still provides the guaranteed critical finalization provided by the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="c95dd-108">für volle Vertrauenswürdigkeit für erben.</span>
      <span class="sxs-lookup">
        <span data-stu-id="c95dd-108">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="c95dd-109">Dieser Member kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</span>
      <span class="sxs-lookup">
        <span data-stu-id="c95dd-109">This member cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">
      <span data-ttu-id="c95dd-110">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
      <span class="sxs-lookup">
        <span data-stu-id="c95dd-110">requires full trust for the immediate caller.</span>
      </span>
      <span data-ttu-id="c95dd-111">Diese Klasse kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
      <span class="sxs-lookup">
        <span data-stu-id="c95dd-111">This class cannot be used by partially trusted or transparent code.</span>
      </span>
    </permission>
    <altmember cref="T:System.Runtime.InteropServices.SafeHandle" />
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CriticalHandle (IntPtr invalidHandleValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CriticalHandle(IntPtr invalidHandleValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">
          <span data-ttu-id="c95dd-112">Der Wert eines ungültigen Handles (normalerweise 0 (null) oder -1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-112">The value of an invalid handle (usually 0 or -1).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c95dd-113">Initialisiert eine neue Instanz der <see cref="T:System.Runtime.InteropServices.CriticalHandle" />-Klasse mit dem angegebenen ungültigen Handlewert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-113">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class with the specified invalid handle value.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="c95dd-114">Die abgeleitete Klasse befindet sich in einer Assembly ohne Berechtigung für den Zugriff auf nicht verwalteten Code.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-114">The derived class resides in an assembly without unmanaged code access permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="c95dd-115">für volle Vertrauenswürdigkeit für erben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-115">for full trust for inheritors.</span>
          </span>
          <span data-ttu-id="c95dd-116">Dieser Member kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-116">This member cannot be inherited by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="c95dd-117">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-117">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="c95dd-118">Diese Klasse kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-118">This class cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c95dd-119">Markiert das Handle für das Freigeben und Verfügbarmachen von Ressourcen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-119">Marks the handle for releasing and freeing resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c95dd-120">Aufrufen der <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> Methode ermöglicht die Ressourcen freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="c95dd-120">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="c95dd-121">Im Gegensatz zu den <xref:System.Runtime.InteropServices.SafeHandle> -Klasse, dies geschieht immer dann sofort verwendet werden, da es ist keine Verweiszähler dieser Planergruppe, um anzugeben, dass andere Threads dieser Handle verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c95dd-121">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="c95dd-122">Deshalb müssen Sie einen Synchronisierungsmechanismus sicherzustellen, dass es sicher ist, rufen Sie verwenden die <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="c95dd-122">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method.</span></span> <span data-ttu-id="c95dd-123">Obwohl die meisten Klassen, die verwenden die <xref:System.Runtime.InteropServices.CriticalHandle> Klasse erübrigt sich einen Finalizer bereitstellen, dies ist manchmal erforderlich (z. B. zum leeren Dateipuffer oder Schreiben von Daten zurück in den Arbeitsspeicher).</span><span class="sxs-lookup"><span data-stu-id="c95dd-123">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="c95dd-124">In diesem Fall kann die Klasse einen Finalizer, der zum Ausführen vor unbedingt Bereitstellen der <xref:System.Runtime.InteropServices.CriticalHandle> kritischen Finalizer ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="c95dd-124">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="c95dd-125">Rufen Sie die <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> Methode, wenn Sie fertig sind mit den <xref:System.Runtime.InteropServices.CriticalHandle> Objekt.</span><span class="sxs-lookup"><span data-stu-id="c95dd-125">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="c95dd-126">Die <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> -Methode bewirkt, dass die <xref:System.Runtime.InteropServices.CriticalHandle> Objekt in einem nicht verwendbaren Zustand.</span><span class="sxs-lookup"><span data-stu-id="c95dd-126">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="c95dd-127">**Hinweis** immer Aufruf <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> , bevor Sie den letzten Verweis auf Freigeben der <xref:System.Runtime.InteropServices.CriticalHandle> Objekt.</span><span class="sxs-lookup"><span data-stu-id="c95dd-127">**Note** Always call <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="c95dd-128">Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Runtime.InteropServices.CriticalHandle>-Methode des <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A>-Objekts aufruft.</span><span class="sxs-lookup"><span data-stu-id="c95dd-128">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c95dd-129">Markiert das Handle für das Freigeben und Verfügbarmachen von Ressourcen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-129">Marks the handle for releasing and freeing resources.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c95dd-130">Gibt alle vom <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> verwendeten Ressourcen frei.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-130">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c95dd-131">Aufrufen der <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> Methode ermöglicht die Ressourcen freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="c95dd-131">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="c95dd-132">Im Gegensatz zu den <xref:System.Runtime.InteropServices.SafeHandle> -Klasse, dies geschieht immer dann sofort verwendet werden, da es ist keine Verweiszähler dieser Planergruppe, um anzugeben, dass andere Threads dieser Handle verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c95dd-132">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="c95dd-133">Deshalb müssen Sie einen Synchronisierungsmechanismus sicherzustellen, dass es sicher ist, rufen Sie verwenden die <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="c95dd-133">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method.</span></span> <span data-ttu-id="c95dd-134">Obwohl die meisten Klassen, die verwenden die <xref:System.Runtime.InteropServices.CriticalHandle> Klasse erübrigt sich einen Finalizer bereitstellen, dies ist manchmal erforderlich (z. B. zum leeren Dateipuffer oder Schreiben von Daten zurück in den Arbeitsspeicher).</span><span class="sxs-lookup"><span data-stu-id="c95dd-134">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="c95dd-135">In diesem Fall kann die Klasse einen Finalizer, der zum Ausführen vor unbedingt Bereitstellen der <xref:System.Runtime.InteropServices.CriticalHandle> kritischen Finalizer ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="c95dd-135">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="c95dd-136">Rufen Sie die <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> Methode, wenn Sie fertig sind mit den <xref:System.Runtime.InteropServices.CriticalHandle> Objekt.</span><span class="sxs-lookup"><span data-stu-id="c95dd-136">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="c95dd-137">Die <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> -Methode bewirkt, dass die <xref:System.Runtime.InteropServices.CriticalHandle> Objekt in einem nicht verwendbaren Zustand.</span><span class="sxs-lookup"><span data-stu-id="c95dd-137">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="c95dd-138">**Hinweis** immer Aufruf der <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> -Methode auf, bevor Sie den letzten Verweis auf Freigeben der <xref:System.Runtime.InteropServices.CriticalHandle> Objekt.</span><span class="sxs-lookup"><span data-stu-id="c95dd-138">**Note** Always call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="c95dd-139">Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Runtime.InteropServices.CriticalHandle>-Methode des <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A>-Objekts aufruft.</span><span class="sxs-lookup"><span data-stu-id="c95dd-139">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="c95dd-140">
            <see langword="true" /> für einen normalen Freigabevorgang, <see langword="false" />, um das Handle zu beenden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-140">
              <see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c95dd-141">Gibt die von der <see cref="T:System.Runtime.InteropServices.CriticalHandle" />-Klasse verwendeten, nicht verwalteten Ressourcen frei und gibt an, ob ein normaler Freigabevorgang ausgeführt werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-141">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class specifying whether to perform a normal dispose operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c95dd-142">Rufen Sie niemals explizit die <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> Methode mit der `disposing` Parametersatz auf `false`.</span><span class="sxs-lookup"><span data-stu-id="c95dd-142">You should never explicitly call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method with the `disposing` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CriticalHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!CriticalHandle ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c95dd-143">Gibt alle dem Handle zugeordneten Ressourcen frei.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-143">Frees all resources associated with the handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c95dd-144">Die <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> Methode ist der Destruktor für die <xref:System.Runtime.InteropServices.CriticalHandle> Klasse.</span><span class="sxs-lookup"><span data-stu-id="c95dd-144">The <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.CriticalHandle> class.</span></span> <span data-ttu-id="c95dd-145">Diese Methode sollte nicht direkt vom Anwendungscode aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="c95dd-145">Application code should not call this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c95dd-146">Gibt das zu umschließende Handle an.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-146">Specifies the handle to be wrapped.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c95dd-147">Das Handle nicht öffentlich verfügbar (d. h. außerhalb der abgeleiteten Klasse).</span><span class="sxs-lookup"><span data-stu-id="c95dd-147">Do not expose the handle publicly (that is, outside of the derived class).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c95dd-148">Ruft einen Wert ab, der angibt, ob das Handle geschlossen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-148">Gets a value indicating whether the handle is closed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c95dd-149">
            <see langword="true" />, wenn das Handle geschlossen ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-149">
              <see langword="true" /> if the handle is closed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c95dd-150">Die <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> Methodenrückgabe ein Wert, der angibt, ob die <xref:System.Runtime.InteropServices.CriticalHandle> Handle des Objekts ist nicht mehr eine systemeigene Ressource zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="c95dd-150">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.CriticalHandle> object's handle is no longer associated with a native resource.</span></span> <span data-ttu-id="c95dd-151">Dies unterscheidet sich von der Definition der <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> -Eigenschaft, die berechnet, ob ein bestimmtes Handle immer als ungültig betrachtet wird.</span><span class="sxs-lookup"><span data-stu-id="c95dd-151">This differs from the definition of the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid.</span></span> <span data-ttu-id="c95dd-152">Die <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> Methode gibt ein `true` Wert in den folgenden Fällen:</span><span class="sxs-lookup"><span data-stu-id="c95dd-152">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a `true` value in the following cases:</span></span>  
  
-   <span data-ttu-id="c95dd-153">Die <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> -Methode wurde aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="c95dd-153">The <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method was called.</span></span>  
  
-   <span data-ttu-id="c95dd-154">Die <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> Methode oder <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> Methode wurde aufgerufen, und es werden keine Verweise auf die <xref:System.Runtime.InteropServices.CriticalHandle> Objekt für andere Threads.</span><span class="sxs-lookup"><span data-stu-id="c95dd-154">The <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.CriticalHandle> object on other threads.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c95dd-155">Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob dieses Handle ungültig ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-155">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c95dd-156">
            <see langword="true" />, wenn das Handle gültig ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-156">
              <see langword="true" /> if the handle is valid; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c95dd-157">Abgeleitete Klassen müssen implementieren die <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> Eigenschaft, damit die common Language Runtime ermitteln kann, ob Handleressourcen erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="c95dd-157">Derived classes must implement the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required.</span></span> <span data-ttu-id="c95dd-158">Abgeleitete Klassen müssen eine Implementierung, die den allgemeinen Typ der Handle passt sie unterstützen bereitstellen (0 oder-1 ist ungültig).</span><span class="sxs-lookup"><span data-stu-id="c95dd-158">Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</span></span> <span data-ttu-id="c95dd-159">Diese Klassen können dann weitere für bestimmte SafeHandle-Typen abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="c95dd-159">These classes can then be further derived for specific safe handle types.</span></span>  
  
 <span data-ttu-id="c95dd-160">Im Gegensatz zu der <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> -Eigenschaft, die meldet, ob die <xref:System.Runtime.InteropServices.CriticalHandle> Objekt nicht mehr verwendet das zugrunde liegende Handle der <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> -Eigenschaft berechnet, ob der angegebene Handlewert immer als ungültig betrachtet wird.</span><span class="sxs-lookup"><span data-stu-id="c95dd-160">Unlike the <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.CriticalHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid.</span></span> <span data-ttu-id="c95dd-161">Aus diesem Grund die <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> Eigenschaft gibt immer den gleichen Wert für einen einzelnen Handlewert zurück.</span><span class="sxs-lookup"><span data-stu-id="c95dd-161">Therefore, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property always returns the same value for any one handle value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c95dd-162">Führt beim Überschreiben in einer abgeleiteten Klasse den Code aus, der für das Freigeben des Handles erforderlich ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-162">When overridden in a derived class, executes the code required to free the handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c95dd-163">
            <see langword="true" />, wenn das Handle erfolgreich freigegeben wurde, andernfalls im Fall eines schwerwiegenden Fehlers <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-163">
              <see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c95dd-164">In diesem Fall wird ein [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)-Assistent für verwaltetes Debuggen (Managed Debugging Assistant, MDA) generiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-164">In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c95dd-165">Die <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> -Methode wird garantiert nur einmal aufgerufen werden, vorausgesetzt, dass die Verwendung des richtigen Synchronisierungsmechanismen, um sicherzustellen, dass diese nur einen Aufruf von der <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> Methode erfolgt.</span><span class="sxs-lookup"><span data-stu-id="c95dd-165">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method is made.</span></span> <span data-ttu-id="c95dd-166">Die <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> Methode wird nicht aufgerufen werden, wenn die <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> oder <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> Eigenschaft ist `true`.</span><span class="sxs-lookup"><span data-stu-id="c95dd-166">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method will not be called if the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property is `true`.</span></span> <span data-ttu-id="c95dd-167">Implementieren Sie diese Methode in Ihrer <xref:System.Runtime.InteropServices.CriticalHandle> abgeleitete Klassen, um Code auszuführen, die zum Freigeben des Handles erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="c95dd-167">Implement this method in your <xref:System.Runtime.InteropServices.CriticalHandle> derived classes to execute any code that is required to free the handle.</span></span> <span data-ttu-id="c95dd-168">Da eine der Funktionen von <xref:System.Runtime.InteropServices.CriticalHandle> wird zum Gewährleisten der Vermeidung von Ressourcenverlusten, den Code in der Implementierung von <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> müssen nie ein Failover auf.</span><span class="sxs-lookup"><span data-stu-id="c95dd-168">Because one of the functions of <xref:System.Runtime.InteropServices.CriticalHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> must never fail.</span></span> <span data-ttu-id="c95dd-169">Der Garbage Collector ruft <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> nach normale Finalizer für Objekte, die Garbage collection gleichzeitig wurden ausgeführt wurden und die Garantien, die die Ressourcen, aufrufen und wird nicht unterbrochen werden dagegen es läuft.</span><span class="sxs-lookup"><span data-stu-id="c95dd-169">The garbage collector calls <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress.</span></span> <span data-ttu-id="c95dd-170">Diese Methode wird zur Entwurfszeit (sowie alle Methoden in seiner statisch bestimmbare Aufrufdiagramm) Instanz als einem eingeschränkten Ausführungsbereich (CER) vorbereitet werden.</span><span class="sxs-lookup"><span data-stu-id="c95dd-170">This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</span></span> <span data-ttu-id="c95dd-171">Obwohl dies verhindert, dass ein Thread Abort Interrupts, noch achten Sie nicht, um alle Fehler Pfade in der überschriebenen einzuführen <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="c95dd-171">Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method.</span></span> <span data-ttu-id="c95dd-172">Wenden Sie insbesondere die <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> -Attribut auf alle Methoden, die Sie von Aufrufen <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="c95dd-172">In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>.</span></span> <span data-ttu-id="c95dd-173">In den meisten Fällen sollte dieser Code sein:</span><span class="sxs-lookup"><span data-stu-id="c95dd-173">In most cases this code should be:</span></span>  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 <span data-ttu-id="c95dd-174">Darüber hinaus für eine einfache Bereinigung (z. B. durch Aufruf der Win32-API `CloseHandle` für ein Dateihandle) überprüfen Sie den Rückgabewert, für die einzelnen Plattformaufruf.</span><span class="sxs-lookup"><span data-stu-id="c95dd-174">Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call.</span></span> <span data-ttu-id="c95dd-175">Bei einer komplexen Bereinigung müssen Sie möglicherweise viel Programmlogik und viele Methodenaufrufe, von die einige möglicherweise fehlschlagen.</span><span class="sxs-lookup"><span data-stu-id="c95dd-175">For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</span></span> <span data-ttu-id="c95dd-176">Sie müssen sicherstellen, dass die Programmlogik für jeden dieser Fälle fallback Code verfügt.</span><span class="sxs-lookup"><span data-stu-id="c95dd-176">You must ensure that your program logic has fallback code for each of those cases.</span></span>  
  
 <span data-ttu-id="c95dd-177">Wenn die <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> -Methode zurückkehrt `false` aus irgendeinem Grund generiert eine [ReleaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) -Assistent für verwaltetes Debuggen.</span><span class="sxs-lookup"><span data-stu-id="c95dd-177">If the <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="c95dd-178">Das bereits vorhandene Handle, das verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-178">The pre-existing handle to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c95dd-179">Legt das Handle für das angegebene, bereits vorhandene Handle fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-179">Sets the handle to the specified pre-existing handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c95dd-180">Verwenden der <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> Methode nur, wenn Sie ein bereits vorhandenes Handle unterstützt werden (beispielsweise, wenn das Handle in einer Struktur zurückgegeben wird), weil die .NET Framework-COM-Interop-Infrastruktur keine Marshalling unterstützt müssen in einer Struktur verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="c95dd-180">Use the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c95dd-181">Markiert ein Handle als ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c95dd-181">Marks a handle as invalid.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c95dd-182">Rufen Sie die <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> Methode, nur, wenn Sie wissen, dass das Handle ungültig ist, und Sie es als solche markieren möchten.</span><span class="sxs-lookup"><span data-stu-id="c95dd-182">Call the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method only when you know that your handle is invalid and you want to mark it as such.</span></span> <span data-ttu-id="c95dd-183">Auf diese Weise ändert sich nicht auf den Wert, der die <xref:System.Runtime.InteropServices.CriticalHandle.handle> Feld; es wird nur das Handle als ungültig markiert.</span><span class="sxs-lookup"><span data-stu-id="c95dd-183">Doing so does not change the value of the <xref:System.Runtime.InteropServices.CriticalHandle.handle> field; it only marks the handle as invalid.</span></span> <span data-ttu-id="c95dd-184">Das Handle kann dann möglicherweise veralteten Wert enthalten.</span><span class="sxs-lookup"><span data-stu-id="c95dd-184">The handle might then contain a potentially stale value.</span></span> <span data-ttu-id="c95dd-185">Der Effekt dieses Aufrufs ist, dass kein Versuch unternommen wird, um die Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="c95dd-185">The effect of this call is that no attempt is made to free the resources.</span></span>  
  
 <span data-ttu-id="c95dd-186">Wie bei der <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> -Methode <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> nur, wenn Sie ein bereits vorhandenes Handle unterstützen müssen.</span><span class="sxs-lookup"><span data-stu-id="c95dd-186">As with the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>