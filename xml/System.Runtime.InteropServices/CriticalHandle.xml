<Type Name="CriticalHandle" FullName="System.Runtime.InteropServices.CriticalHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5ec9c5e6ad58460f444e43937ca686ab0c633ca6" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78816279" /></Metadata><TypeSignature Language="C#" Value="public abstract class CriticalHandle : IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalHandle extends System.Object implements class System.IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.CriticalHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CriticalHandle&#xA;Implements IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class CriticalHandle abstract : IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type CriticalHandle = class&#xA;    interface IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CriticalHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class CriticalHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type CriticalHandle = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime.InteropServices" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="4.0.20.0" To="System.Runtime.Handles" ToVersion="4.0.0.0" FrameworkAlternate="dotnet-uwp-10.0;netstandard-1.3;netstandard-1.4" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="4.1.0.0" To="System.Runtime.Handles" ToVersion="4.0.0.0" FrameworkAlternate="netcore-1.0;netstandard-1.5;netstandard-1.6" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="4.1.1.0" To="System.Runtime.Handles" ToVersion="4.0.0.0" FrameworkAlternate="netcore-1.1" />
    <TypeForwarding From="System.Runtime.Handles" FromVersion="4.1.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="4.2.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Runtime.Handles" FromVersion="4.1.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="4.2.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Runtime.Handles" FromVersion="4.1.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="4.2.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
    <TypeForwarding From="System.Runtime.Handles" FromVersion="4.0.0.0" To="mscorlib" ToVersion="4.0.0.0" FrameworkAlternate="netstandard-1.5" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;dotnet-uwp-10.0">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="d8928-101">Stellt eine Wrapperklasse für Handleressourcen dar.</span><span class="sxs-lookup"><span data-stu-id="d8928-101">Represents a wrapper class for handle resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8928-102">Die <xref:System.Runtime.InteropServices.CriticalHandle>-Klasse ähnelt der-Klasse <xref:System.Runtime.InteropServices.SafeHandle>, mit dem Unterschied, dass <xref:System.Runtime.InteropServices.SafeHandle> die Verweis Zählung implementiert.</span><span class="sxs-lookup"><span data-stu-id="d8928-102">The <xref:System.Runtime.InteropServices.CriticalHandle> class is similar to the <xref:System.Runtime.InteropServices.SafeHandle> class, except that <xref:System.Runtime.InteropServices.SafeHandle> implements reference counting.</span></span> <span data-ttu-id="d8928-103">Sie können <xref:System.Runtime.InteropServices.CriticalHandle> anstelle von <xref:System.Runtime.InteropServices.SafeHandle> verwenden, um Leistungsaspekte zu beheben, wenn Sie die erforderliche Synchronisierung effizienter bereitstellen können.</span><span class="sxs-lookup"><span data-stu-id="d8928-103">You can use <xref:System.Runtime.InteropServices.CriticalHandle> instead of <xref:System.Runtime.InteropServices.SafeHandle> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.</span></span>  
  
 <span data-ttu-id="d8928-104">Da die <xref:System.Runtime.InteropServices.CriticalHandle>-Klasse keine Verweis Zählung durchführt, bietet Sie keinen Schutz vor Sicherheitsangriffen für die Wiederverwendung.</span><span class="sxs-lookup"><span data-stu-id="d8928-104">Because the <xref:System.Runtime.InteropServices.CriticalHandle> class does not perform reference counting, it does not provide protection from handle recycling security attacks.</span></span> <span data-ttu-id="d8928-105">Da der Algorithmus für die Verweis Zählung implizit Vorgänge serialisiert, geht auch eine bestimmte Menge an Thread Sicherheit verloren.</span><span class="sxs-lookup"><span data-stu-id="d8928-105">Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost.</span></span> <span data-ttu-id="d8928-106">Wenn Sie die <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-oder <xref:System.Runtime.InteropServices.SafeHandle.Close%2A>-Methode aufzurufen, während ein Vorgang, der das Handle verwendet, in einem anderen Thread aussteht, oder wenn Sie <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> oder <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> von zwei Threads gleichzeitig aufzurufen, sind die Ergebnisse nicht deterministisch.</span><span class="sxs-lookup"><span data-stu-id="d8928-106">If you call the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method while an operation that is using the handle is outstanding on another thread, or if you call <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> from two threads at the same time, the results are non-deterministic.</span></span> <span data-ttu-id="d8928-107">Die <xref:System.Runtime.InteropServices.CriticalHandle>-Klasse bietet weiterhin die garantierte kritische Finalisierung, die von der <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d8928-107">The <xref:System.Runtime.InteropServices.CriticalHandle> class still provides the guaranteed critical finalization provided by the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.InteropServices.SafeHandle" />
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CriticalHandle (IntPtr invalidHandleValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CriticalHandle(IntPtr invalidHandleValue);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.CriticalHandle : nativeint -&gt; System.Runtime.InteropServices.CriticalHandle" Usage="new System.Runtime.InteropServices.CriticalHandle invalidHandleValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue"><span data-ttu-id="d8928-108">Der Wert eines ungültigen Handles (normalerweise 0 (null) oder -1).</span><span class="sxs-lookup"><span data-stu-id="d8928-108">The value of an invalid handle (usually 0 or -1).</span></span></param>
        <summary><span data-ttu-id="d8928-109">Initialisiert eine neue Instanz der <see cref="T:System.Runtime.InteropServices.CriticalHandle" />-Klasse mit dem angegebenen ungültigen Handlewert.</span><span class="sxs-lookup"><span data-stu-id="d8928-109">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class with the specified invalid handle value.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="d8928-110">Die abgeleitete Klasse befindet sich in einer Assembly ohne Berechtigung für den Zugriff auf nicht verwalteten Code.</span><span class="sxs-lookup"><span data-stu-id="d8928-110">The derived class resides in an assembly without unmanaged code access permission.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="criticalHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d8928-111">Markiert das Handle für das Freigeben und Verfügbarmachen von Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="d8928-111">Marks the handle for releasing and freeing resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8928-112">Wenn Sie die <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>-oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>-Methode aufrufen, können die Ressourcen freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d8928-112">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="d8928-113">Anders als bei der <xref:System.Runtime.InteropServices.SafeHandle>-Klasse wird dies immer sofort durchgeführt, da es keinen Verweis Zähler gibt, um anzugeben, dass dieses Handle von anderen Threads verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d8928-113">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="d8928-114">Daher müssen Sie einen Synchronisierungs Mechanismus verwenden, um sicherzustellen, dass die <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>-Methode sicher aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="d8928-114">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method.</span></span> <span data-ttu-id="d8928-115">Obwohl die meisten Klassen, die die <xref:System.Runtime.InteropServices.CriticalHandle>-Klasse verwenden, keinen Finalizer bereitstellen müssen, ist dies manchmal erforderlich (z. b. zum leeren von Datei Puffern oder zum Zurückschreiben von Daten in den Arbeitsspeicher).</span><span class="sxs-lookup"><span data-stu-id="d8928-115">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="d8928-116">In diesem Fall kann die Klasse einen Finalizer bereitstellen, der vor der Ausführung des <xref:System.Runtime.InteropServices.CriticalHandle> kritischen Finalizers garantiert ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d8928-116">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="d8928-117">Wenn Sie mit der Verwendung des <xref:System.Runtime.InteropServices.CriticalHandle>-Objekts fertig sind, können Sie die <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d8928-117">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="d8928-118">Die <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>-Methode lässt das <xref:System.Runtime.InteropServices.CriticalHandle>-Objekt in einem nicht verwendbaren Zustand.</span><span class="sxs-lookup"><span data-stu-id="d8928-118">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="d8928-119">**Hinweis** Immer <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> aufgerufen, bevor der letzte Verweis auf das <xref:System.Runtime.InteropServices.CriticalHandle> Objekt freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="d8928-119">**Note** Always call <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="d8928-120">Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Runtime.InteropServices.CriticalHandle>-Methode des <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A>-Objekts aufruft.</span><span class="sxs-lookup"><span data-stu-id="d8928-120">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d8928-121">Markiert das Handle für das Freigeben und Verfügbarmachen von Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="d8928-121">Marks the handle for releasing and freeing resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="criticalHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d8928-122">Gibt alle vom <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d8928-122">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8928-123">Wenn Sie die <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>-oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>-Methode aufrufen, können die Ressourcen freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d8928-123">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="d8928-124">Anders als bei der <xref:System.Runtime.InteropServices.SafeHandle>-Klasse wird dies immer sofort durchgeführt, da es keinen Verweis Zähler gibt, um anzugeben, dass dieses Handle von anderen Threads verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d8928-124">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="d8928-125">Daher müssen Sie einen Synchronisierungs Mechanismus verwenden, um sicherzustellen, dass die <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>-Methode sicher aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="d8928-125">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method.</span></span> <span data-ttu-id="d8928-126">Obwohl die meisten Klassen, die die <xref:System.Runtime.InteropServices.CriticalHandle>-Klasse verwenden, keinen Finalizer bereitstellen müssen, ist dies manchmal erforderlich (z. b. zum leeren von Datei Puffern oder zum Zurückschreiben von Daten in den Arbeitsspeicher).</span><span class="sxs-lookup"><span data-stu-id="d8928-126">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="d8928-127">In diesem Fall kann die Klasse einen Finalizer bereitstellen, der vor der Ausführung des <xref:System.Runtime.InteropServices.CriticalHandle> kritischen Finalizers garantiert ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d8928-127">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="d8928-128">Wenn Sie mit der Verwendung des <xref:System.Runtime.InteropServices.CriticalHandle>-Objekts fertig sind, können Sie die <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d8928-128">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="d8928-129">Die <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>-Methode lässt das <xref:System.Runtime.InteropServices.CriticalHandle>-Objekt in einem nicht verwendbaren Zustand.</span><span class="sxs-lookup"><span data-stu-id="d8928-129">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="d8928-130">**Hinweis** Ruft immer die <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>-oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>-Methode auf, bevor Sie den letzten Verweis auf das <xref:System.Runtime.InteropServices.CriticalHandle>-Objekt freigeben.</span><span class="sxs-lookup"><span data-stu-id="d8928-130">**Note** Always call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="d8928-131">Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Runtime.InteropServices.CriticalHandle>-Methode des <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A>-Objekts aufruft.</span><span class="sxs-lookup"><span data-stu-id="d8928-131">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="criticalHandle.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="d8928-132"><see langword="true" /> für einen normalen Freigabevorgang, <see langword="false" />, um das Handle zu beenden.</span><span class="sxs-lookup"><span data-stu-id="d8928-132"><see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span></span></param>
        <summary><span data-ttu-id="d8928-133">Gibt die von der <see cref="T:System.Runtime.InteropServices.CriticalHandle" />-Klasse verwendeten, nicht verwalteten Ressourcen frei und gibt an, ob ein normaler Freigabevorgang ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d8928-133">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class specifying whether to perform a normal dispose operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8928-134">Sie sollten die <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>-Methode niemals explizit aufrufen, wenn der `disposing`-Parameter auf `false`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="d8928-134">You should never explicitly call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method with the `disposing` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CriticalHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!CriticalHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="criticalHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d8928-135">Gibt alle dem Handle zugeordneten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d8928-135">Frees all resources associated with the handle.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8928-136">Die <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A>-Methode ist der Dekonstruktor für die <xref:System.Runtime.InteropServices.CriticalHandle>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d8928-136">The <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.CriticalHandle> class.</span></span> <span data-ttu-id="d8928-137">Der Anwendungscode sollte diese Methode nicht direkt aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d8928-137">Application code should not call this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberSignature Language="F#" Value="val mutable handle : nativeint" Usage="System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d8928-138">Gibt das zu umschließende Handle an.</span><span class="sxs-lookup"><span data-stu-id="d8928-138">Specifies the handle to be wrapped.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8928-139">Machen Sie das Handle nicht öffentlich verfügbar (d. h. außerhalb der abgeleiteten Klasse).</span><span class="sxs-lookup"><span data-stu-id="d8928-139">Do not expose the handle publicly (that is, outside of the derived class).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d8928-140">Ruft einen Wert ab, der angibt, ob das Handle geschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d8928-140">Gets a value indicating whether the handle is closed.</span></span></summary>
        <value><span data-ttu-id="d8928-141"><see langword="true" />, wenn das Handle geschlossen ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d8928-141"><see langword="true" /> if the handle is closed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8928-142">Die <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A>-Methode gibt einen Wert zurück, der angibt, ob das Handle des <xref:System.Runtime.InteropServices.CriticalHandle> Objekts nicht mehr einer nativen Ressource zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="d8928-142">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.CriticalHandle> object's handle is no longer associated with a native resource.</span></span> <span data-ttu-id="d8928-143">Dies unterscheidet sich von der Definition der <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>-Eigenschaft, die berechnet, ob ein angegebenes handle immer als ungültig eingestuft wird.</span><span class="sxs-lookup"><span data-stu-id="d8928-143">This differs from the definition of the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid.</span></span> <span data-ttu-id="d8928-144">Die <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A>-Methode gibt in den folgenden Fällen einen `true` Wert zurück:</span><span class="sxs-lookup"><span data-stu-id="d8928-144">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a `true` value in the following cases:</span></span>  
  
-   <span data-ttu-id="d8928-145">Die <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A>-Methode wurde aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d8928-145">The <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method was called.</span></span>  
  
-   <span data-ttu-id="d8928-146">Die <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>-Methode oder <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>-Methode wurde aufgerufen, und es sind keine Verweise auf das <xref:System.Runtime.InteropServices.CriticalHandle>-Objekt in anderen Threads vorhanden.</span><span class="sxs-lookup"><span data-stu-id="d8928-146">The <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.CriticalHandle> object on other threads.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d8928-147">Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob dieses Handle ungültig ist.</span><span class="sxs-lookup"><span data-stu-id="d8928-147">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span></span></summary>
        <value><span data-ttu-id="d8928-148"><see langword="true" />, wenn das Handle gültig ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d8928-148"><see langword="true" /> if the handle is valid; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8928-149">Abgeleitete Klassen müssen die <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>-Eigenschaft implementieren, damit die Common Language Runtime bestimmen kann, ob eine kritische Finalisierung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="d8928-149">Derived classes must implement the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required.</span></span> <span data-ttu-id="d8928-150">Abgeleitete Klassen müssen eine Implementierung bereitstellen, die dem allgemeinen Typ des von Ihnen unterstützten Handles entspricht (0 oder-1 ist ungültig).</span><span class="sxs-lookup"><span data-stu-id="d8928-150">Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</span></span> <span data-ttu-id="d8928-151">Diese Klassen können dann für bestimmte sichere Handlertypen weiter abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="d8928-151">These classes can then be further derived for specific safe handle types.</span></span>  
  
 <span data-ttu-id="d8928-152">Anders als bei der <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A>-Eigenschaft, die meldet, ob das <xref:System.Runtime.InteropServices.CriticalHandle> Objekt die Verwendung des zugrunde liegenden Handles abgeschlossen hat, berechnet die <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>-Eigenschaft, ob der angegebene Handle-Wert immer als ungültig eingestuft wird.</span><span class="sxs-lookup"><span data-stu-id="d8928-152">Unlike the <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.CriticalHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid.</span></span> <span data-ttu-id="d8928-153">Daher gibt die <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>-Eigenschaft immer den gleichen Wert für einen beliebigen Handle-Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="d8928-153">Therefore, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property always returns the same value for any one handle value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; bool" Usage="criticalHandle.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d8928-154">Führt beim Überschreiben in einer abgeleiteten Klasse den Code aus, der für das Freigeben des Handles erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="d8928-154">When overridden in a derived class, executes the code required to free the handle.</span></span></summary>
        <returns><span data-ttu-id="d8928-155"><see langword="true" />, wenn das Handle erfolgreich freigegeben wurde, andernfalls im Fall eines schwerwiegenden Fehlers <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d8928-155"><see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span></span> <span data-ttu-id="d8928-156">In diesem Fall wird ein <see href="https://docs.microsoft.com/dotnet/framework/debug-trace-profile/releasehandlefailed-mda">releaseHandleFailed</see>-Assistent für verwaltetes Debuggen (Managed Debugging Assistant, MDA) generiert.</span><span class="sxs-lookup"><span data-stu-id="d8928-156">In this case, it generates a <see href="https://docs.microsoft.com/dotnet/framework/debug-trace-profile/releasehandlefailed-mda">releaseHandleFailed</see> Managed Debugging Assistant.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8928-157">Es ist garantiert, dass die <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>-Methode nur einmal aufgerufen wird, vorausgesetzt, dass Sie geeignete Synchronisierungs Mechanismen verwenden, um sicherzustellen, dass nur ein Aufruf der <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>-oder <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>-Methode erfolgt.</span><span class="sxs-lookup"><span data-stu-id="d8928-157">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method is made.</span></span> <span data-ttu-id="d8928-158">Die <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>-Methode wird nicht aufgerufen, wenn die <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>-oder <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A>-Eigenschaft `true`ist.</span><span class="sxs-lookup"><span data-stu-id="d8928-158">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method will not be called if the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property is `true`.</span></span> <span data-ttu-id="d8928-159">Implementieren Sie diese Methode in den von <xref:System.Runtime.InteropServices.CriticalHandle> abgeleiteten Klassen, um Code auszuführen, der zum Freigeben des Handles erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="d8928-159">Implement this method in your <xref:System.Runtime.InteropServices.CriticalHandle> derived classes to execute any code that is required to free the handle.</span></span> <span data-ttu-id="d8928-160">Da eine der Funktionen von <xref:System.Runtime.InteropServices.CriticalHandle> darin besteht, die Verhinderung von Ressourcenverlusten zu gewährleisten, muss der Code in der Implementierung von <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> nie fehlschlagen.</span><span class="sxs-lookup"><span data-stu-id="d8928-160">Because one of the functions of <xref:System.Runtime.InteropServices.CriticalHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> must never fail.</span></span> <span data-ttu-id="d8928-161">Mit dem Garbage Collector werden <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> aufgerufen, nachdem normale Finalizer für Objekte ausgeführt wurden, für die gleichzeitig eine Garbage Collection durchgeführt wurde, und es wird sichergestellt, dass die Ressourcen Sie aufrufen und während der Ausführung nicht unterbrochen werden.</span><span class="sxs-lookup"><span data-stu-id="d8928-161">The garbage collector calls <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress.</span></span> <span data-ttu-id="d8928-162">Diese Methode wird während der Erstellung der Instanz als eingeschränkter Ausführungs Bereich (CER) vorbereitet (zusammen mit allen Methoden in Ihrem statisch determinier baren Aufruf Diagramm).</span><span class="sxs-lookup"><span data-stu-id="d8928-162">This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</span></span> <span data-ttu-id="d8928-163">Obwohl hierdurch Thread Abbruch Interrupts verhindert werden, müssen Sie dennoch darauf achten, keine Fehler Pfade in die überschriebene <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> Methode einzuführen.</span><span class="sxs-lookup"><span data-stu-id="d8928-163">Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method.</span></span> <span data-ttu-id="d8928-164">Wenden Sie insbesondere das <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>-Attribut auf alle Methoden an, die Sie von <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>abrufen.</span><span class="sxs-lookup"><span data-stu-id="d8928-164">In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>.</span></span> <span data-ttu-id="d8928-165">In den meisten Fällen sollte dieser Code wie folgt lauten:</span><span class="sxs-lookup"><span data-stu-id="d8928-165">In most cases this code should be:</span></span>  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 <span data-ttu-id="d8928-166">Darüber hinaus können Sie für die einfache Bereinigung (z. b. das Aufrufen der Windows-API-`CloseHandle` auf einem Datei Handle) den Rückgabewert des einzelnen Platt Form Aufrufs überprüfen.</span><span class="sxs-lookup"><span data-stu-id="d8928-166">Additionally, for simple cleanup (for example, calling the Windows API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call.</span></span> <span data-ttu-id="d8928-167">Bei der komplexen Bereinigung haben Sie möglicherweise viele Programmlogik und viele Methodenaufrufe, von denen einige möglicherweise fehlschlagen.</span><span class="sxs-lookup"><span data-stu-id="d8928-167">For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</span></span> <span data-ttu-id="d8928-168">Sie müssen sicherstellen, dass die Programmlogik für jeden dieser Fälle einen Fall Back-Code aufweist.</span><span class="sxs-lookup"><span data-stu-id="d8928-168">You must ensure that your program logic has fallback code for each of those cases.</span></span>  
  
 <span data-ttu-id="d8928-169">Wenn die <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>-Methode aus irgendeinem Grund `false` zurückgibt, wird ein [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) -Assistent für verwaltetes Debuggen generiert.</span><span class="sxs-lookup"><span data-stu-id="d8928-169">If the <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/76994ee6-9fa9-4059-b813-26578d24427c"><span data-ttu-id="d8928-170">Diagnostizieren von Laufzeitfehlern mit Assistenten für verwaltetes Debuggen</span><span class="sxs-lookup"><span data-stu-id="d8928-170">Diagnosing Run-time Errors with Managed Debugging Assistants</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/44cd98ba-95e5-40a1-874d-e8e163612c51"><span data-ttu-id="d8928-171">ReleaseHandleFailed</span><span class="sxs-lookup"><span data-stu-id="d8928-171">ReleaseHandleFailed</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.SetHandle : nativeint -&gt; unit" Usage="criticalHandle.SetHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="d8928-172">Das bereits vorhandene Handle, das verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d8928-172">The pre-existing handle to use.</span></span></param>
        <summary><span data-ttu-id="d8928-173">Legt das Handle für das angegebene, bereits vorhandene Handle fest.</span><span class="sxs-lookup"><span data-stu-id="d8928-173">Sets the handle to the specified pre-existing handle.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8928-174">Verwenden Sie die <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A>-Methode nur, wenn Sie ein bereits vorhandenes handle unterstützen müssen (z. b., wenn das Handle in einer Struktur zurückgegeben wird), da die .NET Framework COM-Interop-Infrastruktur keine Marshalling von Handles in einer Struktur unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d8928-174">Use the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberSignature Language="F#" Value="member this.SetHandleAsInvalid : unit -&gt; unit" Usage="criticalHandle.SetHandleAsInvalid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d8928-175">Markiert ein Handle als ungültig.</span><span class="sxs-lookup"><span data-stu-id="d8928-175">Marks a handle as invalid.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d8928-176">Ruft die <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A>-Methode nur auf, wenn Sie wissen, dass Ihr Handle ungültig ist, und Sie diese als solche kennzeichnen möchten.</span><span class="sxs-lookup"><span data-stu-id="d8928-176">Call the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method only when you know that your handle is invalid and you want to mark it as such.</span></span> <span data-ttu-id="d8928-177">Dadurch wird der Wert des <xref:System.Runtime.InteropServices.CriticalHandle.handle> Felds nicht geändert. das Handle wird nur als ungültig markiert.</span><span class="sxs-lookup"><span data-stu-id="d8928-177">Doing so does not change the value of the <xref:System.Runtime.InteropServices.CriticalHandle.handle> field; it only marks the handle as invalid.</span></span> <span data-ttu-id="d8928-178">Das Handle kann dann einen potenziell veralteten Wert enthalten.</span><span class="sxs-lookup"><span data-stu-id="d8928-178">The handle might then contain a potentially stale value.</span></span> <span data-ttu-id="d8928-179">Die Auswirkung dieses Aufrufens besteht darin, dass kein Versuch unternommen wird, die Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d8928-179">The effect of this call is that no attempt is made to free the resources.</span></span>  
  
 <span data-ttu-id="d8928-180">Verwenden Sie wie bei der <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A>-Methode nur <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A>, wenn Sie ein bereits vorhandenes handle unterstützen müssen.</span><span class="sxs-lookup"><span data-stu-id="d8928-180">As with the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
