<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CriticalHandle.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac556d9d023a154981435b37666fa081861ca0100c2.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">56d9d023a154981435b37666fa081861ca0100c2</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Represents a wrapper class for handle resources.</source>
          <target state="translated">Stellt eine Wrapperklasse für Handleressourcen dar.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class is similar to the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, except that <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> implements reference counting.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> -Klasse ähnelt der <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> Klasse, außer dass <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> verweiszählung implementiert.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.</source>
          <target state="translated">Können Sie <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> anstelle von <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> , Leistungsaspekte Adresse, wenn Sie der erforderlichen Synchronisierung mehr angeben können effizient selbst.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Because the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class does not perform reference counting, it does not provide protection from handle recycling security attacks.</source>
          <target state="translated">Da die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Klasse führt keine verweiszählung, er bietet keinen Schutz vor Sicherheitsangriffen Wiederverwendung Handle.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost.</source>
          <target state="translated">Da die verweiszählung Algorithmus implizit Vorgänge serialisiert, ist eine gewisse Threadsicherheit auch verloren.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>If you call the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> method while an operation that is using the handle is outstanding on another thread, or if you call <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph4">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> from two threads at the same time, the results are non-deterministic.</source>
          <target state="translated">Beim Aufrufen der <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> Methode während ein Vorgangs, der das Handle verwendet in einem anderen Thread aussteht, oder beim Aufrufen <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph4">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> von zwei Threads gleichzeitig die Ergebnisse sind nicht deterministisch.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class still provides the guaranteed critical finalization provided by the <ph id="ph2">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> class.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Klasse bietet weiterhin die garantierte Handleressourcen gebotenen der <ph id="ph2">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>for full trust for inheritors.</source>
          <target state="translated">für volle Vertrauenswürdigkeit für erben.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>This member cannot be inherited by partially trusted code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>This class cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Diese Klasse kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>The value of an invalid handle (usually 0 or -1).</source>
          <target state="translated">Der Wert eines ungültigen Handles (normalerweise 0 (null) oder -1).</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> class with the specified invalid handle value.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph>-Klasse mit dem angegebenen ungültigen Handlewert.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>The derived class resides in an assembly without unmanaged code access permission.</source>
          <target state="translated">Die abgeleitete Klasse befindet sich in einer Assembly ohne Berechtigung für den Zugriff auf nicht verwalteten Code.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>for full trust for inheritors.</source>
          <target state="translated">für volle Vertrauenswürdigkeit für erben.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>This member cannot be inherited by partially trusted code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>This class cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Diese Klasse kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Marks the handle for releasing and freeing resources.</source>
          <target state="translated">Markiert das Handle für das Freigeben und Verfügbarmachen von Ressourcen.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.</source>
          <target state="translated">Aufrufen der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> Methode ermöglicht die Ressourcen freigegeben werden.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</source>
          <target state="translated">Im Gegensatz zu den <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> -Klasse, dies geschieht immer dann sofort verwendet werden, da es ist keine Verweiszähler dieser Planergruppe, um anzugeben, dass andere Threads dieser Handle verwendet werden.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method.</source>
          <target state="translated">Deshalb müssen Sie einen Synchronisierungsmechanismus sicherzustellen, dass es sicher ist, rufen Sie verwenden die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Although most classes that use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</source>
          <target state="translated">Obwohl die meisten Klassen, die verwenden die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Klasse erübrigt sich einen Finalizer bereitstellen, dies ist manchmal erforderlich (z. B. zum leeren Dateipuffer oder Schreiben von Daten zurück in den Arbeitsspeicher).</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>In this case, the class can provide a finalizer that is guaranteed to run before the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> critical finalizer runs.</source>
          <target state="translated">In diesem Fall kann die Klasse einen Finalizer, der zum Ausführen vor unbedingt Bereitstellen der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> kritischen Finalizer ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> Methode, wenn Sie fertig sind mit den <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object in an unusable state.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> -Methode bewirkt, dass die <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Objekt in einem nicht verwendbaren Zustand.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> Always call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> before you release your last reference to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>Hinweis<ept id="p1">**</ept> immer Aufruf <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> , bevor Sie den letzten Verweis auf Freigeben der <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>-Methode des <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph>-Objekts aufruft.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Marks the handle for releasing and freeing resources.</source>
          <target state="translated">Markiert das Handle für das Freigeben und Verfügbarmachen von Ressourcen.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Releases all resources used by the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph>.</source>
          <target state="translated">Gibt alle vom <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> verwendeten Ressourcen frei.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.</source>
          <target state="translated">Aufrufen der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> Methode ermöglicht die Ressourcen freigegeben werden.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</source>
          <target state="translated">Im Gegensatz zu den <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> -Klasse, dies geschieht immer dann sofort verwendet werden, da es ist keine Verweiszähler dieser Planergruppe, um anzugeben, dass andere Threads dieser Handle verwendet werden.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">Deshalb müssen Sie einen Synchronisierungsmechanismus sicherzustellen, dass es sicher ist, rufen Sie verwenden die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Although most classes that use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</source>
          <target state="translated">Obwohl die meisten Klassen, die verwenden die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Klasse erübrigt sich einen Finalizer bereitstellen, dies ist manchmal erforderlich (z. B. zum leeren Dateipuffer oder Schreiben von Daten zurück in den Arbeitsspeicher).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>In this case, the class can provide a finalizer that is guaranteed to run before the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> critical finalizer runs.</source>
          <target state="translated">In diesem Fall kann die Klasse einen Finalizer, der zum Ausführen vor unbedingt Bereitstellen der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> kritischen Finalizer ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> Methode, wenn Sie fertig sind mit den <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object in an unusable state.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> -Methode bewirkt, dass die <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Objekt in einem nicht verwendbaren Zustand.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> Always call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method before you release your last reference to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>Hinweis<ept id="p1">**</ept> immer Aufruf der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> -Methode auf, bevor Sie den letzten Verweis auf Freigeben der <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>-Methode des <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph>-Objekts aufruft.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for a normal dispose operation; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to finalize the handle.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> für einen normalen Freigabevorgang, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, um das Handle zu beenden.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> class specifying whether to perform a normal dispose operation.</source>
          <target state="translated">Gibt die von der <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph>-Klasse verwendeten, nicht verwalteten Ressourcen frei und gibt an, ob ein normaler Freigabevorgang ausgeführt werden soll.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source>You should never explicitly call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method with the <ph id="ph2">`disposing`</ph> parameter set to <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Rufen Sie niemals explizit die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> Methode mit der <ph id="ph2">`disposing`</ph> Parametersatz auf <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>Frees all resources associated with the handle.</source>
          <target state="translated">Gibt alle dem Handle zugeordneten Ressourcen frei.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method is the destructor for the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> Methode ist der Destruktor für die <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>Application code should not call this method directly.</source>
          <target state="translated">Diese Methode sollte nicht direkt vom Anwendungscode aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.CriticalHandle.handle">
          <source>Specifies the handle to be wrapped.</source>
          <target state="translated">Gibt das zu umschließende Handle an.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.CriticalHandle.handle">
          <source>Do not expose the handle publicly (that is, outside of the derived class).</source>
          <target state="translated">Das Handle nicht öffentlich verfügbar (d. h. außerhalb der abgeleiteten Klasse).</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>Gets a value indicating whether the handle is closed.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob das Handle geschlossen ist.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das Handle geschlossen ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> method returns a value indicating whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's handle is no longer associated with a native resource.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> Methodenrückgabe ein Wert, der angibt, ob die <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Handle des Objekts ist nicht mehr eine systemeigene Ressource zugeordnet.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>This differs from the definition of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property, which computes whether a given handle is always considered invalid.</source>
          <target state="translated">Dies unterscheidet sich von der Definition der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> -Eigenschaft, die berechnet, ob ein bestimmtes Handle immer als ungültig betrachtet wird.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> method returns a <ph id="ph2">`true`</ph> value in the following cases:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> Methode gibt ein <ph id="ph2">`true`</ph> Wert in den folgenden Fällen:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> method was called.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> -Methode wurde aufgerufen.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method was called and there are no references to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object on other threads.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> Methode oder <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> Methode wurde aufgerufen, und es werden keine Verweise auf die <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Objekt für andere Threads.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>When overridden in a derived class, gets a value indicating whether the handle value is invalid.</source>
          <target state="translated">Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob dieses Handle ungültig ist.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is valid; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das Handle gültig ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Derived classes must implement the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property so that the common language runtime can determine whether critical finalization is required.</source>
          <target state="translated">Abgeleitete Klassen müssen implementieren die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> Eigenschaft, damit die common Language Runtime ermitteln kann, ob Handleressourcen erforderlich ist.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</source>
          <target state="translated">Abgeleitete Klassen müssen eine Implementierung, die den allgemeinen Typ der Handle passt sie unterstützen bereitstellen (0 oder-1 ist ungültig).</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>These classes can then be further derived for specific safe handle types.</source>
          <target state="translated">Diese Klassen können dann weitere für bestimmte SafeHandle-Typen abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> property, which reports whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object has finished using the underlying handle, the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property calculates whether the given handle value is always considered invalid.</source>
          <target state="translated">Im Gegensatz zu der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> -Eigenschaft, die meldet, ob die <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> Objekt nicht mehr verwendet das zugrunde liegende Handle der <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> -Eigenschaft berechnet, ob der angegebene Handlewert immer als ungültig betrachtet wird.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property always returns the same value for any one handle value.</source>
          <target state="translated">Aus diesem Grund die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> Eigenschaft gibt immer den gleichen Wert für einen einzelnen Handlewert zurück.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>When overridden in a derived class, executes the code required to free the handle.</source>
          <target state="translated">Führt beim Überschreiben in einer abgeleiteten Klasse den Code aus, der für das Freigeben des Handles erforderlich ist.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das Handle erfolgreich freigegeben wurde, andernfalls im Fall eines schwerwiegenden Fehlers <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In this case, it generates a <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.</source>
          <target state="translated">In diesem Fall wird ein <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept>-Assistent für verwaltetes Debuggen (Managed Debugging Assistant, MDA) generiert.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method is made.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> -Methode wird garantiert nur einmal aufgerufen werden, vorausgesetzt, dass die Verwendung des richtigen Synchronisierungsmechanismen, um sicherzustellen, dass diese nur einen Aufruf von der <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> Methode erfolgt.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method will not be called if the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> property is <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> Methode wird nicht aufgerufen werden, wenn die <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> Eigenschaft ist <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Implement this method in your <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> derived classes to execute any code that is required to free the handle.</source>
          <target state="translated">Implementieren Sie diese Methode in Ihrer <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> abgeleitete Klassen, um Code auszuführen, die zum Freigeben des Handles erforderlich ist.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Because one of the functions of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> is to guarantee prevention of resource leaks, the code in your implementation of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> must never fail.</source>
          <target state="translated">Da eine der Funktionen von <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> wird zum Gewährleisten der Vermeidung von Ressourcenverlusten, den Code in der Implementierung von <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> müssen nie ein Failover auf.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The garbage collector calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress.</source>
          <target state="translated">Der Garbage Collector ruft <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> nach normale Finalizer für Objekte, die Garbage collection gleichzeitig wurden ausgeführt wurden und die Garantien, die die Ressourcen, aufrufen und wird nicht unterbrochen werden dagegen es läuft.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</source>
          <target state="translated">Diese Methode wird zur Entwurfszeit (sowie alle Methoden in seiner statisch bestimmbare Aufrufdiagramm) Instanz als einem eingeschränkten Ausführungsbereich (CER) vorbereitet werden.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method.</source>
          <target state="translated">Obwohl dies verhindert, dass ein Thread Abort Interrupts, noch achten Sie nicht, um alle Fehler Pfade in der überschriebenen einzuführen <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In particular, apply the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute to any methods you call from <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>.</source>
          <target state="translated">Wenden Sie insbesondere die <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> -Attribut auf alle Methoden, die Sie von Aufrufen <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In most cases this code should be:</source>
          <target state="translated">In den meisten Fällen sollte dieser Code sein:</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Additionally, for simple cleanup (for example, calling the Win32 API <ph id="ph1">`CloseHandle`</ph> on a file handle) you can check the return value for the single platform invoke call.</source>
          <target state="translated">Darüber hinaus für eine einfache Bereinigung (z. B. durch Aufruf der Win32-API <ph id="ph1">`CloseHandle`</ph> für ein Dateihandle) überprüfen Sie den Rückgabewert, für die einzelnen Plattformaufruf.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</source>
          <target state="translated">Bei einer komplexen Bereinigung müssen Sie möglicherweise viel Programmlogik und viele Methodenaufrufe, von die einige möglicherweise fehlschlagen.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>You must ensure that your program logic has fallback code for each of those cases.</source>
          <target state="translated">Sie müssen sicherstellen, dass die Programmlogik für jeden dieser Fälle fallback Code verfügt.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method returns <ph id="ph2">`false`</ph> for any reason, it generates a <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> -Methode zurückkehrt <ph id="ph2">`false`</ph> aus irgendeinem Grund generiert eine <bpt id="p1">[</bpt>ReleaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> -Assistent für verwaltetes Debuggen.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>The pre-existing handle to use.</source>
          <target state="translated">Das bereits vorhandene Handle, das verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>Sets the handle to the specified pre-existing handle.</source>
          <target state="translated">Legt das Handle für das angegebene, bereits vorhandene Handle fest.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> Methode nur, wenn Sie ein bereits vorhandenes Handle unterstützt werden (beispielsweise, wenn das Handle in einer Struktur zurückgegeben wird), weil die .NET Framework-COM-Interop-Infrastruktur keine Marshalling unterstützt müssen in einer Struktur verarbeitet.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Marks a handle as invalid.</source>
          <target state="translated">Markiert ein Handle als ungültig.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> method only when you know that your handle is invalid and you want to mark it as such.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> Methode, nur, wenn Sie wissen, dass das Handle ungültig ist, und Sie es als solche markieren möchten.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Doing so does not change the value of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.handle&gt;</ph> field; it only marks the handle as invalid.</source>
          <target state="translated">Auf diese Weise ändert sich nicht auf den Wert, der die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.handle&gt;</ph> Feld; es wird nur das Handle als ungültig markiert.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>The handle might then contain a potentially stale value.</source>
          <target state="translated">Das Handle kann dann möglicherweise veralteten Wert enthalten.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>The effect of this call is that no attempt is made to free the resources.</source>
          <target state="translated">Der Effekt dieses Aufrufs ist, dass kein Versuch unternommen wird, um die Ressourcen freizugeben.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>As with the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> only if you need to support a pre-existing handle.</source>
          <target state="translated">Wie bei der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> -Methode <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> nur, wenn Sie ein bereits vorhandenes Handle unterstützen müssen.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>