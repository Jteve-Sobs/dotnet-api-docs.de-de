<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ad7545414a8b614fddcbaa418ec5c86f7f69a5bc" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73356204" /></Metadata><TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="F#" Value="type SafeHandle = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="79f3e-101">Stellt eine Wrapperklasse für Betriebssystemhandles dar.</span><span class="sxs-lookup"><span data-stu-id="79f3e-101">Represents a wrapper class for operating system handles.</span></span> <span data-ttu-id="79f3e-102">Die Klasse muss geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-102">This class must be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-103">Die <xref:System.Runtime.InteropServices.SafeHandle>-Klasse stellt eine kritische Finalisierung der Handle-Ressourcen bereit, wodurch verhindert wird, dass Handles vorzeitig durch Garbage Collection freigegeben werden und von Windows wieder verwendet werden, um auf unbeabsichtigte nicht verwaltete Objekte zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-103">The <xref:System.Runtime.InteropServices.SafeHandle> class provides critical finalization of handle resources, preventing handles from being reclaimed prematurely by garbage collection and from being recycled by Windows to reference unintended unmanaged objects.</span></span>  
  
 <span data-ttu-id="79f3e-104">Dieses Thema enthält die folgenden Abschnitte:</span><span class="sxs-lookup"><span data-stu-id="79f3e-104">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="79f3e-105">[Warum SafeHandle?](#Why) </span><span class="sxs-lookup"><span data-stu-id="79f3e-105">[Why SafeHandle?](#Why) </span></span>  
 <span data-ttu-id="79f3e-106">Funktionsweise von [SafeHandle](#Does) </span><span class="sxs-lookup"><span data-stu-id="79f3e-106">[What SafeHandle does](#Does) </span></span>  
 [<span data-ttu-id="79f3e-107">Von SafeHandle abgeleitete Klassen</span><span class="sxs-lookup"><span data-stu-id="79f3e-107">Classes derived from SafeHandle</span></span>](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a><span data-ttu-id="79f3e-108">Warum SafeHandle?</span><span class="sxs-lookup"><span data-stu-id="79f3e-108">Why SafeHandle?</span></span>  
 <span data-ttu-id="79f3e-109">Vor der .NET Framework Version 2,0 konnten alle Betriebssystem Handles nur im <xref:System.IntPtr> Managed Wrapper-Objekt gekapselt werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-109">Before the .NET Framework version 2.0, all operating system handles could only be encapsulated in the <xref:System.IntPtr> managed wrapper object.</span></span> <span data-ttu-id="79f3e-110">Obwohl dies eine bequeme Methode für die Interoperabilität mit System eigenem Code war, können Handles durch asynchrone Ausnahmen kompromittiert werden, z. b. ein unerwarteter Thread oder ein Stapelüberlauf.</span><span class="sxs-lookup"><span data-stu-id="79f3e-110">While this was a convenient way to interoperate with native code, handles could be leaked by asynchronous exceptions, such as a thread aborting unexpectedly or a stack overflow.</span></span> <span data-ttu-id="79f3e-111">Diese asynchronen Ausnahmen sind ein Hindernis für das Bereinigen von Betriebssystemressourcen und können fast überall in der app auftreten.</span><span class="sxs-lookup"><span data-stu-id="79f3e-111">These asynchronous exceptions are an obstacle to cleaning up operating system resources, and they can occur almost anywhere in your app.</span></span>  
  
 <span data-ttu-id="79f3e-112">Obwohl die außer Kraft setzung der <xref:System.Object.Finalize%2A?displayProperty=nameWithType> Methode das Bereinigen von nicht verwalteten Ressourcen zulässt, wenn ein Objekt in einer Garbage Collection erfasst wird, können finalisierbare Objekte in einigen Fällen durch Garbage Collection freigegeben werden, während eine Methode innerhalb eines Platt Form Aufrufs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-112">Although overrides to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method allow cleanup of unmanaged resources when an object is being garbage collected, in some circumstances, finalizable objects can be reclaimed by garbage collection while executing a method within a platform invoke call.</span></span> <span data-ttu-id="79f3e-113">Wenn ein Finalizer das an diesen Platt Form Aufruf-Aufruf über gegebene handle freigibt, kann dies zur Behandlung von Beschädigungen führen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-113">If a finalizer frees the handle passed to that platform invoke call, it could lead to handle corruption.</span></span> <span data-ttu-id="79f3e-114">Das Handle kann auch freigegeben werden, während die Methode während eines Platt Form Aufrufs blockiert wird, z. b. beim Lesen einer Datei.</span><span class="sxs-lookup"><span data-stu-id="79f3e-114">The handle could also be reclaimed while your method is blocked during a platform invoke call, such as while reading a file.</span></span>  
  
 <span data-ttu-id="79f3e-115">Kritischer, da Windows die Handles aggressiv wieder verwendet, könnte ein Handle wieder verwendet werden und auf eine andere Ressource zeigen, die vertrauliche Daten enthalten könnte.</span><span class="sxs-lookup"><span data-stu-id="79f3e-115">More critically, because Windows aggressively recycles handles, a handle could be recycled and point to another resource that might contain sensitive data.</span></span> <span data-ttu-id="79f3e-116">Dies wird als Wiederverwendungs Angriff bezeichnet und kann möglicherweise Daten beschädigen und eine Sicherheitsbedrohung darstellen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-116">This is known as a recycle attack and can potentially corrupt data and be a security threat.</span></span>  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a><span data-ttu-id="79f3e-117">Funktionsweise von SafeHandle</span><span class="sxs-lookup"><span data-stu-id="79f3e-117">What SafeHandle does</span></span>  
 <span data-ttu-id="79f3e-118">Die <xref:System.Runtime.InteropServices.SafeHandle>-Klasse vereinfacht einige dieser Probleme mit der Objekt Lebensdauer und ist in einen Platt Form Aufruf integriert, sodass Betriebssystemressourcen nicht verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-118">The <xref:System.Runtime.InteropServices.SafeHandle> class simplifies several of these object lifetime issues, and is integrated with platform invoke so that operating system resources are not leaked.</span></span> <span data-ttu-id="79f3e-119">Die <xref:System.Runtime.InteropServices.SafeHandle>-Klasse löst Probleme mit der Objekt Lebensdauer, indem Sie Handles ohne Unterbrechung zuweisen und freigeben.</span><span class="sxs-lookup"><span data-stu-id="79f3e-119">The <xref:System.Runtime.InteropServices.SafeHandle> class resolves object lifetime issues by assigning and releasing handles without interruption.</span></span> <span data-ttu-id="79f3e-120">Sie enthält einen kritischen Finalizer, mit dem sichergestellt wird, dass das Handle geschlossen wird und während unerwarteter <xref:System.AppDomain> entladen wird, auch wenn angenommen wird, dass der Platt Form Aufruf in einem beschädigten Zustand ist.</span><span class="sxs-lookup"><span data-stu-id="79f3e-120">It contains a critical finalizer that ensures that the handle is closed and is guaranteed to run during unexpected <xref:System.AppDomain> unloads, even in cases when the platform invoke call is assumed to be in a corrupted state.</span></span>  
  
 <span data-ttu-id="79f3e-121">Da <xref:System.Runtime.InteropServices.SafeHandle> von <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>erbt, werden alle nicht kritischen Finalizer vor den kritischen Finalizern aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-121">Because <xref:System.Runtime.InteropServices.SafeHandle> inherits from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, all the noncritical finalizers are called before any of the critical finalizers.</span></span> <span data-ttu-id="79f3e-122">Die Finalizer werden für Objekte aufgerufen, die nicht mehr Live während desselben Garbage Collection bestanden werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-122">The finalizers are called on objects that are no longer live during the same garbage collection pass.</span></span> <span data-ttu-id="79f3e-123">Beispielsweise kann ein <xref:System.IO.FileStream> Objekt einen normalen Finalizer ausführen, um vorhandene gepufferte Daten auszuleeren, ohne das Risiko zu haben, dass das Handle kompromittiert oder wieder verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-123">For example, a <xref:System.IO.FileStream> object can run a normal finalizer to flush out existing buffered data without the risk of the handle being leaked or recycled.</span></span> <span data-ttu-id="79f3e-124">Diese sehr schwache Reihenfolge zwischen kritischen und nicht kritischen Finalizern ist nicht für die allgemeine Verwendung vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-124">This very weak ordering between critical and noncritical finalizers is not intended for general use.</span></span> <span data-ttu-id="79f3e-125">Es ist hauptsächlich zur Unterstützung bei der Migration vorhandener Bibliotheken, da diese Bibliotheken <xref:System.Runtime.InteropServices.SafeHandle> verwenden können, ohne ihre Semantik zu ändern.</span><span class="sxs-lookup"><span data-stu-id="79f3e-125">It exists primarily to assist in the migration of existing libraries by allowing those libraries to use <xref:System.Runtime.InteropServices.SafeHandle> without altering their semantics.</span></span> <span data-ttu-id="79f3e-126">Außerdem müssen sich der kritische Finalizer und alles, was er aufruft, wie z. b. die <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType>-Methode, in einem eingeschränkten Ausführungs Bereich befinden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-126">Additionally, the critical finalizer and anything it calls, such as the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method, must be in a constrained execution region.</span></span> <span data-ttu-id="79f3e-127">Dies erzwingt Einschränkungen für den Code, der innerhalb des Aufruf Diagramms des Finalizers geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="79f3e-127">This imposes constraints on what code can be written within the finalizer's call graph.</span></span>  
  
 <span data-ttu-id="79f3e-128">Platt Form Aufrufe erhöhen automatisch den Verweis Zähler von Handles, die von einem <xref:System.Runtime.InteropServices.SafeHandle> gekapselt werden, und Dekrement bei Abschluss.</span><span class="sxs-lookup"><span data-stu-id="79f3e-128">Platform invoke operations automatically increment the reference count of handles encapsulated by a <xref:System.Runtime.InteropServices.SafeHandle> and decrement them upon completion.</span></span> <span data-ttu-id="79f3e-129">Dadurch wird sichergestellt, dass das Handle nicht unerwartet wieder verwendet oder geschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-129">This ensures that the handle will not be recycled or closed unexpectedly.</span></span>  
  
 <span data-ttu-id="79f3e-130">Sie können den Besitz des zugrunde liegenden Handles beim Erstellen von <xref:System.Runtime.InteropServices.SafeHandle> Objekten angeben, indem Sie einen Wert für das `ownsHandle`-Argument im <xref:System.Runtime.InteropServices.SafeHandle>-Klassenkonstruktor bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-130">You can specify ownership of the underlying handle when constructing <xref:System.Runtime.InteropServices.SafeHandle> objects by supplying a value to the `ownsHandle` argument in the <xref:System.Runtime.InteropServices.SafeHandle> class constructor.</span></span> <span data-ttu-id="79f3e-131">Dadurch wird gesteuert, ob das <xref:System.Runtime.InteropServices.SafeHandle> Objekt das Handle freigibt, nachdem das Objekt verworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="79f3e-131">This controls whether the <xref:System.Runtime.InteropServices.SafeHandle> object will release the handle after the object has been disposed.</span></span>  <span data-ttu-id="79f3e-132">Dies ist hilfreich bei Handles mit besonderen Anforderungen an die Lebensdauer oder der Verwendung eines Handles, dessen Lebensdauer von einem anderen Benutzer gesteuert wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-132">This is useful for handles with peculiar lifetime requirements or for consuming a handle whose lifetime is controlled by someone else.</span></span>  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a><span data-ttu-id="79f3e-133">Von SafeHandle abgeleitete Klassen</span><span class="sxs-lookup"><span data-stu-id="79f3e-133">Classes derived from SafeHandle</span></span>  
 <span data-ttu-id="79f3e-134"><xref:System.Runtime.InteropServices.SafeHandle> ist eine abstrakte Wrapper Klasse für Betriebssystem Handles.</span><span class="sxs-lookup"><span data-stu-id="79f3e-134"><xref:System.Runtime.InteropServices.SafeHandle> is an abstract wrapper class for operating system handles.</span></span> <span data-ttu-id="79f3e-135">Das Ableiten von dieser Klasse ist schwierig.</span><span class="sxs-lookup"><span data-stu-id="79f3e-135">Deriving from this class is difficult.</span></span> <span data-ttu-id="79f3e-136">Verwenden Sie stattdessen die abgeleiteten Klassen im <xref:Microsoft.Win32.SafeHandles>-Namespace, die sichere Handles für Folgendes bereitstellen:</span><span class="sxs-lookup"><span data-stu-id="79f3e-136">Instead, use the derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace that provide safe handles for the following:</span></span>  
  
-   <span data-ttu-id="79f3e-137">Dateien (die <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>-Klasse).</span><span class="sxs-lookup"><span data-stu-id="79f3e-137">Files (the <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> class).</span></span>  
  
-   <span data-ttu-id="79f3e-138">Im Speicher abgebildete Dateien (die <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>-Klasse).</span><span class="sxs-lookup"><span data-stu-id="79f3e-138">Memory mapped files (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> class).</span></span>  
  
-   <span data-ttu-id="79f3e-139">Pipes (die <xref:Microsoft.Win32.SafeHandles.SafePipeHandle>-Klasse).</span><span class="sxs-lookup"><span data-stu-id="79f3e-139">Pipes (the <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class).</span></span>  
  
-   <span data-ttu-id="79f3e-140">Speicher Sichten (die <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle>-Klasse).</span><span class="sxs-lookup"><span data-stu-id="79f3e-140">Memory views (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class).</span></span>  
  
-   <span data-ttu-id="79f3e-141">Kryptografiekonstrukte (die Klassen <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>und <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle>).</span><span class="sxs-lookup"><span data-stu-id="79f3e-141">Cryptography constructs (the <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes).</span></span>  
  
-   <span data-ttu-id="79f3e-142">Prozesse (die <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle>-Klasse).</span><span class="sxs-lookup"><span data-stu-id="79f3e-142">Processes (the <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> class).</span></span>  
  
-   <span data-ttu-id="79f3e-143">Registrierungsschlüssel (die <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>-Klasse).</span><span class="sxs-lookup"><span data-stu-id="79f3e-143">Registry keys (the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class).</span></span>  
  
-   <span data-ttu-id="79f3e-144">Wait-Handles (die <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>-Klasse).</span><span class="sxs-lookup"><span data-stu-id="79f3e-144">Wait handles (the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79f3e-145">Im folgenden Codebeispiel wird ein benutzerdefiniertes sicheres Handle für ein Datei Handle des Betriebssystems erstellt, das von <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>abgeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-145">The following code example creates a custom safe handle for an operating system file handle, deriving from <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>.</span></span> <span data-ttu-id="79f3e-146">Er liest Bytes aus einer Datei und zeigt deren hexadezimal Werte an.</span><span class="sxs-lookup"><span data-stu-id="79f3e-146">It reads bytes from a file and displays their hexadecimal values.</span></span> <span data-ttu-id="79f3e-147">Sie enthält auch eine fehlertestumgebung, die bewirkt, dass der Thread abgebrochen wird, der Handle-Wert jedoch freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-147">It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.</span></span>  <span data-ttu-id="79f3e-148">Wenn Sie einen <xref:System.IntPtr> zur Darstellung von Handles verwenden, wird das Handle aufgrund des asynchronen Thread Abbruchs gelegentlich nicht durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="79f3e-148">When using an <xref:System.IntPtr> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</span></span>  
  
 <span data-ttu-id="79f3e-149">Sie benötigen eine Textdatei im selben Ordner wie die kompilierte Anwendung.</span><span class="sxs-lookup"><span data-stu-id="79f3e-149">You will need a text file in the same folder as the compiled application.</span></span> <span data-ttu-id="79f3e-150">Wenn Sie die Anwendung "hexviewer" benennen, lautet die Befehlszeilen Syntax wie folgt:</span><span class="sxs-lookup"><span data-stu-id="79f3e-150">Assuming that you name the application "HexViewer", the command line usage is:</span></span>  
  
 `HexViewer <filename> -Fault`  
  
 <span data-ttu-id="79f3e-151">Geben Sie optional `-Fault` an, um absichtlich zu versuchen, das Handle zu durchbrechen, indem Sie den Thread in einem bestimmten Fenster abbrechen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-151">Optionally specify `-Fault` to intentionally attempt to leak the handle by aborting the thread in a certain window.</span></span> <span data-ttu-id="79f3e-152">Verwenden Sie das Windows Perfmon. exe-Tool, um die Anzahl der Handles beim Einfügen von Fehlern zu überwachen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-152">Use the Windows Perfmon.exe tool to monitor handle counts while injecting faults.</span></span>  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="79f3e-153">für vollständige Vertrauenswürdigkeit für Vererber.</span><span class="sxs-lookup"><span data-stu-id="79f3e-153">for full trust for inheritors.</span></span> <span data-ttu-id="79f3e-154">Dieser Member kann nicht von teilweise vertrauenswürdigem Code geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-154">This member cannot be inherited by partially trusted code.</span></span></permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="79f3e-155">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="79f3e-155">requires full trust for the immediate caller.</span></span> <span data-ttu-id="79f3e-156">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-156">This member cannot be used by partially trusted or transparent code.</span></span></permission>
    <block subset="none" type="overrides"><para><span data-ttu-id="79f3e-157">Zum Erstellen einer Klasse, die von <see cref="T:System.Runtime.InteropServices.SafeHandle" />abgeleitet ist, müssen Sie wissen, wie ein Betriebssystem Handle erstellt und freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-157">To create a class derived from <see cref="T:System.Runtime.InteropServices.SafeHandle" />, you must know how to create and free an operating system handle.</span></span> <span data-ttu-id="79f3e-158">Dieser Prozess unterscheidet sich für verschiedene handle-Typen, da einige die [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) -Funktion verwenden, während andere spezifischere Funktionen verwenden, z. b. [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) oder [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx).</span><span class="sxs-lookup"><span data-stu-id="79f3e-158">This process is different for different handle types because some use the [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) function, while others use more specific functions such as [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) or [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx).</span></span> <span data-ttu-id="79f3e-159">Aus diesem Grund müssen Sie eine abgeleitete Klasse von <see cref="T:System.Runtime.InteropServices.SafeHandle" /> für jeden Betriebssystem-Handle-Typ erstellen, den Sie in einem sicheren handle einschließen möchten.</span><span class="sxs-lookup"><span data-stu-id="79f3e-159">For this reason, you must create a derived class of <see cref="T:System.Runtime.InteropServices.SafeHandle" /> for each operating system handle type that you want to wrap in a safe handle.</span></span>  
  
<span data-ttu-id="79f3e-160">Wenn Sie von <see cref="T:System.Runtime.InteropServices.SafeHandle" /> erben, müssen die folgenden Member überschrieben werden: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> und <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-160">When you inherit from <see cref="T:System.Runtime.InteropServices.SafeHandle" />, you must override the following members: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> and <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.</span></span>  
  
<span data-ttu-id="79f3e-161">Sie sollten auch einen Parameter losen Konstruktor bereitstellen, der den Basiskonstruktor mit einem Wert aufruft, der einen ungültigen Handle-Wert darstellt, und einen <see cref="T:System.Boolean" /> Wert, der angibt, ob das systemeigene Handle im Besitz der <see cref="T:System.Runtime.InteropServices.SafeHandle" /> ist und daher freigegeben werden sollte, wenn dies <see cref="T:System.Runtime.InteropServices.SafeHandle" /> wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-161">You should also provide a parameterless constructor that calls the base constructor with a value that represent an invalid handle value, and a <see cref="T:System.Boolean" /> value indicating whether the native handle is owned by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> and consequently should be freed when that <see cref="T:System.Runtime.InteropServices.SafeHandle" /> has been disposed.</span></span></para></block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.SafeHandle : nativeint * bool -&gt; System.Runtime.InteropServices.SafeHandle" Usage="new System.Runtime.InteropServices.SafeHandle (invalidHandleValue, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue"><span data-ttu-id="79f3e-162">Der Wert eines ungültigen Handles (normalerweise 0 (null) oder -1).</span><span class="sxs-lookup"><span data-stu-id="79f3e-162">The value of an invalid handle (usually 0 or -1).</span></span>  <span data-ttu-id="79f3e-163">Die Implementierung von <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> muss <see langword="true" /> für diesen Wert zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="79f3e-163">Your implementation of <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> should return <see langword="true" /> for this value.</span></span></param>
        <param name="ownsHandle"><span data-ttu-id="79f3e-164"><see langword="true" />, wenn <see cref="T:System.Runtime.InteropServices.SafeHandle" /> das Handle während der Abschlussphase zuverlässig freigeben soll, andernfalls <see langword="false" /> (dies wird nicht empfohlen).</span><span class="sxs-lookup"><span data-stu-id="79f3e-164"><see langword="true" /> to reliably let <see cref="T:System.Runtime.InteropServices.SafeHandle" /> release the handle during the finalization phase; otherwise, <see langword="false" /> (not recommended).</span></span></param>
        <summary><span data-ttu-id="79f3e-165">Initialisiert eine neue Instanz der <see cref="T:System.Runtime.InteropServices.SafeHandle" />-Klasse mit dem angegebenen ungültigen Handlewert.</span><span class="sxs-lookup"><span data-stu-id="79f3e-165">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class with the specified invalid handle value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-166">Wenn der `ownsHandle`-Parameter `false`ist, wird <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nie aufgerufen. Daher wird empfohlen, diesen Parameterwert nicht zu verwenden, da Ihr Code möglicherweise Ressourcen abgibt.</span><span class="sxs-lookup"><span data-stu-id="79f3e-166">If the `ownsHandle` parameter is `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is never called; thus, it is not recommended to use this parameter value as your code may leak resources.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="79f3e-167">Die abgeleitete Klasse befindet sich in einer Assembly ohne Berechtigung für den Zugriff auf nicht verwalteten Code.</span><span class="sxs-lookup"><span data-stu-id="79f3e-167">The derived class resides in an assembly without unmanaged code access permission.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="79f3e-168">für vollständige Vertrauenswürdigkeit für Vererber.</span><span class="sxs-lookup"><span data-stu-id="79f3e-168">for full trust for inheritors.</span></span> <span data-ttu-id="79f3e-169">Dieser Member kann nicht von teilweise vertrauenswürdigem Code geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-169">This member cannot be inherited by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="79f3e-170">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="79f3e-170">requires full trust for the immediate caller.</span></span> <span data-ttu-id="79f3e-171">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-171">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="safeHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;netstandard-1.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79f3e-172">Markiert das Handle für das Freigeben und Verfügbarmachen von Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-172">Marks the handle for releasing and freeing resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-173">Wenn Sie die <xref:System.Runtime.InteropServices.SafeHandle.Close%2A>-oder <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A>-Methode aufrufen, können die Ressourcen freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-173">Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="79f3e-174">Dies geschieht möglicherweise nicht sofort, wenn andere Threads das gleiche SafeHandle-Objekt verwenden, aber sobald dies nicht mehr der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="79f3e-174">This might not happen immediately if other threads are using the same safe handle object, but will happen as soon as that is no longer the case.</span></span> <span data-ttu-id="79f3e-175">Obwohl die meisten Klassen, die die <xref:System.Runtime.InteropServices.SafeHandle>-Klasse verwenden, keinen Finalizer bereitstellen müssen, ist dies manchmal erforderlich (z. b. zum leeren von Datei Puffern oder zum Zurückschreiben von Daten in den Arbeitsspeicher).</span><span class="sxs-lookup"><span data-stu-id="79f3e-175">Although most classes that use the <xref:System.Runtime.InteropServices.SafeHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="79f3e-176">In diesem Fall kann die Klasse einen Finalizer bereitstellen, der vor der Ausführung des <xref:System.Runtime.InteropServices.SafeHandle> kritischen Finalizers garantiert ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-176">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="79f3e-177">Wenn Sie mit der Verwendung des <xref:System.Runtime.InteropServices.SafeHandle>-Objekts fertig sind, können Sie die <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> oder <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-177">Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79f3e-178">Immer <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> oder <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> aufgerufen, bevor der letzte Verweis auf das <xref:System.Runtime.InteropServices.SafeHandle> Objekt freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-178">Always call <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="79f3e-179">Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Runtime.InteropServices.SafeHandle>-Methode des <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>-Objekts aufruft.</span><span class="sxs-lookup"><span data-stu-id="79f3e-179">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="79f3e-180">für die Berechtigung zum Abrufen von nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="79f3e-180">for permission to call unmanaged code.</span></span> <span data-ttu-id="79f3e-181">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-181">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="79f3e-182">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="79f3e-182">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberSignature Language="F#" Value="member this.DangerousAddRef : bool -&gt; unit" Usage="safeHandle.DangerousAddRef success" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success"><span data-ttu-id="79f3e-183"><see langword="true" />, wenn der Verweiszähler erfolgreich inkrementiert wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-183"><see langword="true" /> if the reference counter was successfully incremented; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="79f3e-184">Inkrementiert manuell den Verweiszähler für <see cref="T:System.Runtime.InteropServices.SafeHandle" />-Instanzen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-184">Manually increments the reference counter on <see cref="T:System.Runtime.InteropServices.SafeHandle" /> instances.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-185">Die <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>-Methode verhindert, dass die Common Language Runtime von einem Handle verwendeter Arbeitsspeicher freigegeben wird (dieser tritt auf, wenn die Common Language Runtime die <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Methode aufruft).</span><span class="sxs-lookup"><span data-stu-id="79f3e-185">The <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method).</span></span> <span data-ttu-id="79f3e-186">Sie können diese Methode verwenden, um den Verweis Zähler für eine <xref:System.Runtime.InteropServices.SafeHandle> Instanz manuell zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-186">You can use this method to manually increment the reference count on a <xref:System.Runtime.InteropServices.SafeHandle> instance.</span></span> <span data-ttu-id="79f3e-187"><xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> gibt einen booleschen Wert zurück, indem ein `ref` Parameter (`success`) verwendet wird, der angibt, ob der Verweis Zähler erfolgreich inkrementiert wurde.</span><span class="sxs-lookup"><span data-stu-id="79f3e-187"><xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> returns a Boolean value using a `ref` parameter (`success`) that indicates whether the reference count was incremented successfully.</span></span> <span data-ttu-id="79f3e-188">Dies ermöglicht es ihrer Programmlogik, bei einem Fehler zurückzukehren.</span><span class="sxs-lookup"><span data-stu-id="79f3e-188">This allows your program logic to back out in case of failure.</span></span> <span data-ttu-id="79f3e-189">Vor dem Aufrufen von <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>sollten Sie `success` auf `false` festlegen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-189">You should set `success` to `false` before calling <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span> <span data-ttu-id="79f3e-190">Wenn `success` `true`ist, vermeiden Sie Ressourcen Lecks, indem Sie den-Aufruf<xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> mit einem entsprechenden-<xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-190">If `success` is `true`, avoid resource leaks by matching the call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> with a corresponding call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="79f3e-191">Diese Methode ist für fortgeschrittene Benutzer gedacht und muss immer sorgfältig verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-191">This method is intended for advanced users and must always be used carefully.</span></span> <span data-ttu-id="79f3e-192">Um das Verlust von handle-Ressourcen zu vermeiden, wird diese Methode immer in einem eingeschränkten Ausführungs Bereich (CER) aufgerufen, in dem ein Thread Abbruch die Verarbeitung nicht unterbrechen kann.</span><span class="sxs-lookup"><span data-stu-id="79f3e-192">To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="79f3e-193">für die Berechtigung zum Abrufen von nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="79f3e-193">for permission to call unmanaged code.</span></span> <span data-ttu-id="79f3e-194">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-194">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="79f3e-195">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="79f3e-195">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberSignature Language="F#" Value="member this.DangerousGetHandle : unit -&gt; nativeint" Usage="safeHandle.DangerousGetHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79f3e-196">Gibt den Wert des <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />-Felds zurück.</span><span class="sxs-lookup"><span data-stu-id="79f3e-196">Returns the value of the <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> field.</span></span></summary>
        <returns><span data-ttu-id="79f3e-197">Ein <see langword="IntPtr" />, der den Wert des <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />-Felds darstellt.</span><span class="sxs-lookup"><span data-stu-id="79f3e-197">An <see langword="IntPtr" /> representing the value of the <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> field.</span></span> <span data-ttu-id="79f3e-198">Wenn das Handle mit <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" /> als ungültig markiert ist, gibt diese Methode dennoch den ursprünglichen Handlewert zurück, bei dem es sich um einen veralteten Wert handeln kann.</span><span class="sxs-lookup"><span data-stu-id="79f3e-198">If the handle has been marked invalid with <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, this method still returns the original handle value, which can be a stale value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-199">Mit dieser Methode können Sie den tatsächlichen handle-Wert aus einer Instanz der abgeleiteten Klasse <xref:System.Runtime.InteropServices.SafeHandle> abrufen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-199">You can use this method to retrieve the actual handle value from an instance of the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span> <span data-ttu-id="79f3e-200">Diese Methode wird aus Gründen der Abwärtskompatibilität benötigt, da viele Eigenschaften im .NET Framework `IntPtr` handle-Typen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="79f3e-200">This method is needed for backwards compatibility because many properties in the .NET Framework return `IntPtr` handle types.</span></span> <span data-ttu-id="79f3e-201">`IntPtr` handle-Typen sind plattformspezifische Typen, die zur Darstellung eines Zeigers oder Handles verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-201">`IntPtr` handle types are platform-specific types used to represent a pointer or a handle.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="79f3e-202">Die Verwendung der <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A>-Methode kann Sicherheitsrisiken darstellen, denn wenn das Handle mit <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>als ungültig markiert wurde, gibt <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> weiterhin den ursprünglichen, potenziell veralteten handle-Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="79f3e-202">Using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method can pose security risks because, if the handle has been marked as invalid with <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> still returns the original, potentially stale handle value.</span></span> <span data-ttu-id="79f3e-203">Das zurückgegebene Handle kann auch zu einem beliebigen Zeitpunkt wieder verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-203">The returned handle can also be recycled at any point.</span></span> <span data-ttu-id="79f3e-204">Dies bedeutet, dass das Handle möglicherweise plötzlich nicht mehr funktioniert.</span><span class="sxs-lookup"><span data-stu-id="79f3e-204">At best, this means the handle might suddenly stop working.</span></span> <span data-ttu-id="79f3e-205">Wenn das Handle oder die Ressource, die das Handle darstellt, nicht vertrauenswürdigem Code verfügbar gemacht wird, kann dies schlimmstenfalls zu einem wiederverwendbaren Sicherheitsangriff auf das wiederverwendete oder zurückgegebene Handle führen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-205">At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle.</span></span> <span data-ttu-id="79f3e-206">Beispielsweise kann ein nicht vertrauenswürdiger Aufrufer Daten für das soeben zurückgegebene Handle Abfragen und Informationen für eine völlig nicht verknüpfte Ressource empfangen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-206">For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource.</span></span> <span data-ttu-id="79f3e-207">Weitere Informationen zur Verwendung der <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsicheres finden Sie in den <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>-und <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>-Methoden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-207">See the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods for more information about using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="79f3e-208">für die Berechtigung zum Abrufen von nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="79f3e-208">for permission to call unmanaged code.</span></span> <span data-ttu-id="79f3e-209">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-209">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="79f3e-210">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="79f3e-210">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberSignature Language="F#" Value="member this.DangerousRelease : unit -&gt; unit" Usage="safeHandle.DangerousRelease " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79f3e-211">Dekrementiert manuell den Verweiszähler für eine <see cref="T:System.Runtime.InteropServices.SafeHandle" />-Instanz.</span><span class="sxs-lookup"><span data-stu-id="79f3e-211">Manually decrements the reference counter on a <see cref="T:System.Runtime.InteropServices.SafeHandle" /> instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-212">Die <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>-Methode ist das Gegenstück zu <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span><span class="sxs-lookup"><span data-stu-id="79f3e-212">The <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method is the counterpart to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span> <span data-ttu-id="79f3e-213">Sie sollten immer einen aufzurufenden <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> Methode mit einem erfolgreichen <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>abrufen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-213">You should always match a call to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method with a successful call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="79f3e-214">Diese Methode ist für fortgeschrittene Benutzer gedacht und muss immer sorgfältig verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-214">This method is intended for advanced users and must always be used carefully.</span></span> <span data-ttu-id="79f3e-215">Um das Verlust von handle-Ressourcen zu vermeiden, wird diese Methode immer in einem eingeschränkten Ausführungs Bereich (CER) aufgerufen, in dem ein Thread Abbruch die Verarbeitung nicht unterbrechen kann.</span><span class="sxs-lookup"><span data-stu-id="79f3e-215">To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</span></span> <span data-ttu-id="79f3e-216">Auf dieselbe Weise, wie nicht übereinstimmende <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Aufrufe zu Ressourcenverlusten führen können, können nicht übereinstimmende <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> Aufrufe bewirken, dass ungültige handle-Zustände für andere Threads sichtbar werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-216">In the same way that unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> calls can cause resource leaks, unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls can cause invalid handle states to become visible to other threads.</span></span> <span data-ttu-id="79f3e-217">Machen Sie keine <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> oder <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> Aufrufe von nicht vertrauenswürdigem Code verfügbar.</span><span class="sxs-lookup"><span data-stu-id="79f3e-217">Do not expose <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> or <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls to untrusted code.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="79f3e-218">für die Berechtigung zum Abrufen von nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="79f3e-218">for permission to call unmanaged code.</span></span> <span data-ttu-id="79f3e-219">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-219">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="79f3e-220">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="79f3e-220">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79f3e-221">Gibt die von der <see cref="T:System.Runtime.InteropServices.SafeHandle" />-Klasse verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="79f3e-221">Releases the resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="safeHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79f3e-222">Gibt alle von der <see cref="T:System.Runtime.InteropServices.SafeHandle" />-Klasse verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="79f3e-222">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-223">Wenn Sie die <xref:System.Runtime.InteropServices.SafeHandle.Close%2A>-oder <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A>-Methode aufrufen, können die Ressourcen freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-223">Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="79f3e-224">Dies geschieht möglicherweise nicht sofort, wenn andere Threads dieselbe Instanz des sicheren Handles verwenden, aber so bald, wie dies nicht mehr der Fall ist.</span><span class="sxs-lookup"><span data-stu-id="79f3e-224">This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case.</span></span> <span data-ttu-id="79f3e-225">Obwohl die meisten Klassen, die <xref:System.Runtime.InteropServices.SafeHandle> verwenden, keinen Finalizer bereitstellen müssen, ist dies manchmal erforderlich (z. b. zum leeren der Datei Puffer oder zum Zurückschreiben von Daten in den Arbeitsspeicher).</span><span class="sxs-lookup"><span data-stu-id="79f3e-225">Although most classes using <xref:System.Runtime.InteropServices.SafeHandle> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="79f3e-226">In diesem Fall können Sie einen Finalizer bereitstellen, der vor der Ausführung des <xref:System.Runtime.InteropServices.SafeHandle> kritischen Finalizers garantiert ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-226">In this case, they can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="79f3e-227">Wenn Sie mit der Verwendung des <xref:System.Runtime.InteropServices.SafeHandle>-Objekts fertig sind, können Sie die <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> oder <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-227">Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="79f3e-228">Die <xref:System.Runtime.InteropServices.SafeHandle.Close%2A>-Methode lässt das <xref:System.Runtime.InteropServices.SafeHandle>-Objekt in einem nicht verwendbaren Zustand.</span><span class="sxs-lookup"><span data-stu-id="79f3e-228">The <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.SafeHandle> object in an unusable state.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79f3e-229">Ruft immer die <xref:System.Runtime.InteropServices.SafeHandle.Close%2A>-oder <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A>-Methode auf, bevor Sie den letzten Verweis auf das <xref:System.Runtime.InteropServices.SafeHandle>-Objekt freigeben.</span><span class="sxs-lookup"><span data-stu-id="79f3e-229">Always call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="79f3e-230">Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Runtime.InteropServices.SafeHandle>-Methode des <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>-Objekts aufruft.</span><span class="sxs-lookup"><span data-stu-id="79f3e-230">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="79f3e-231">für die Berechtigung zum Abrufen von nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="79f3e-231">for permission to call unmanaged code.</span></span> <span data-ttu-id="79f3e-232">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-232">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="79f3e-233">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="79f3e-233">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="safeHandle.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="79f3e-234"><see langword="true" /> für einen normalen Freigabevorgang, <see langword="false" />, um das Handle zu beenden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-234"><see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span></span></param>
        <summary><span data-ttu-id="79f3e-235">Gibt die von der <see cref="T:System.Runtime.InteropServices.SafeHandle" />-Klasse verwendeten, nicht verwalteten Ressourcen frei und gibt an, ob ein normaler Freigabevorgang ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="79f3e-235">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class specifying whether to perform a normal dispose operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-236">Sie sollten die <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A>-Methode niemals explizit aufrufen, wenn der `disposing`-Parameter auf `false`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="79f3e-236">You should never explicitly call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method with the `disposing` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="79f3e-237">für die Berechtigung zum Abrufen von nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="79f3e-237">for permission to call unmanaged code.</span></span> <span data-ttu-id="79f3e-238">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-238">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="79f3e-239">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="79f3e-239">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="safeHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79f3e-240">Gibt alle dem Handle zugeordneten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="79f3e-240">Frees all resources associated with the handle.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-241">Die <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>-Methode ist der Dekonstruktor für die <xref:System.Runtime.InteropServices.SafeHandle>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="79f3e-241">The <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span> <span data-ttu-id="79f3e-242">Der Anwendungscode sollte diese Methode nicht direkt aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-242">Application code should not call this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="79f3e-243">für die Berechtigung zum Abrufen von nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="79f3e-243">for permission to call unmanaged code.</span></span> <span data-ttu-id="79f3e-244">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-244">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="79f3e-245">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="79f3e-245">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberSignature Language="F#" Value="val mutable handle : nativeint" Usage="System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79f3e-246">Gibt das zu umschließende Handle an.</span><span class="sxs-lookup"><span data-stu-id="79f3e-246">Specifies the handle to be wrapped.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-247">Machen Sie das Handle nicht öffentlich verfügbar (d. h. außerhalb der abgeleiteten Klasse).</span><span class="sxs-lookup"><span data-stu-id="79f3e-247">Do not expose the handle publicly (that is, outside of the derived class).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79f3e-248">Ruft einen Wert ab, der angibt, ob das Handle geschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="79f3e-248">Gets a value indicating whether the handle is closed.</span></span></summary>
        <value><span data-ttu-id="79f3e-249"><see langword="true" />, wenn das Handle geschlossen ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-249"><see langword="true" /> if the handle is closed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-250">Die <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A>-Methode gibt einen Wert zurück, der angibt, ob das Handle des <xref:System.Runtime.InteropServices.SafeHandle> Objekts nicht mehr einer nativen Ressource zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="79f3e-250">The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.SafeHandle> object's handle is no longer associated with a native resource.</span></span> <span data-ttu-id="79f3e-251">Dies unterscheidet sich von der Definition der <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A>-Eigenschaft, die berechnet, ob ein angegebenes handle immer als ungültig eingestuft wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-251">This differs from the definition of the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid.</span></span> <span data-ttu-id="79f3e-252">Die <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A>-Methode gibt in den folgenden Fällen einen `true` Wert zurück:</span><span class="sxs-lookup"><span data-stu-id="79f3e-252">The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a `true` value in the following cases:</span></span>  
  
-   <span data-ttu-id="79f3e-253">Die <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>-Methode wurde aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-253">The <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method was called.</span></span>  
  
-   <span data-ttu-id="79f3e-254">Die <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A>-Methode oder <xref:System.Runtime.InteropServices.SafeHandle.Close%2A>-Methode wurde aufgerufen, und es sind keine Verweise auf das <xref:System.Runtime.InteropServices.SafeHandle>-Objekt in anderen Threads vorhanden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-254">The <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.SafeHandle> object on other threads.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="79f3e-255">für die Berechtigung zum Abrufen von nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="79f3e-255">for permission to call unmanaged code.</span></span> <span data-ttu-id="79f3e-256">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-256">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="79f3e-257">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="79f3e-257">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79f3e-258">Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob dieses Handle ungültig ist.</span><span class="sxs-lookup"><span data-stu-id="79f3e-258">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span></span></summary>
        <value><span data-ttu-id="79f3e-259"><see langword="true" />, wenn der Handlewert ungültig ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-259"><see langword="true" /> if the handle value is invalid; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-260">Abgeleitete Klassen müssen die <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A>-Eigenschaft implementieren, damit die Common Language Runtime bestimmen kann, ob eine kritische Finalisierung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="79f3e-260">Derived classes must implement the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required.</span></span> <span data-ttu-id="79f3e-261">Abgeleitete Klassen müssen eine Implementierung bereitstellen, die dem allgemeinen Typ des von Ihnen unterstützten Handles entspricht (0 oder-1 ist ungültig).</span><span class="sxs-lookup"><span data-stu-id="79f3e-261">Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</span></span> <span data-ttu-id="79f3e-262">Diese Klassen können dann für bestimmte sichere Handlertypen weiter abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-262">These classes can then be further derived for specific safe handle types.</span></span>  
  
 <span data-ttu-id="79f3e-263">Anders als bei der <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A>-Eigenschaft, die meldet, ob das <xref:System.Runtime.InteropServices.SafeHandle> Objekt die Verwendung des zugrunde liegenden Handles abgeschlossen hat, berechnet die <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A>-Eigenschaft, ob der angegebene Handle-Wert immer als ungültig eingestuft wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-263">Unlike the <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.SafeHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid.</span></span> <span data-ttu-id="79f3e-264">Daher gibt die <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A>-Eigenschaft immer den gleichen Wert für einen beliebigen Handle-Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="79f3e-264">Therefore, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property always returns the same value for any one handle value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79f3e-265">Im folgenden Beispiel wird überprüft, ob eine Datei erfolgreich geöffnet wurde.</span><span class="sxs-lookup"><span data-stu-id="79f3e-265">The following example checks if a file was opened successfully.</span></span> <span data-ttu-id="79f3e-266">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Runtime.InteropServices.SafeHandle>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-266">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="79f3e-267">für die Berechtigung zum Abrufen von nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="79f3e-267">for permission to call unmanaged code.</span></span> <span data-ttu-id="79f3e-268">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-268">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="79f3e-269">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="79f3e-269">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; bool" Usage="safeHandle.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79f3e-270">Führt beim Überschreiben in einer abgeleiteten Klasse den Code aus, der für das Freigeben des Handles erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="79f3e-270">When overridden in a derived class, executes the code required to free the handle.</span></span></summary>
        <returns><span data-ttu-id="79f3e-271"><see langword="true" />, wenn das Handle erfolgreich freigegeben wurde, andernfalls im Fall eines schwerwiegenden Fehlers <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-271"><see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span></span> <span data-ttu-id="79f3e-272">In diesem Fall wird ein <see href="https://docs.microsoft.com/dotnet/framework/debug-trace-profile/releasehandlefailed-mda">releaseHandleFailed</see>-Assistent für verwaltetes Debuggen (Managed Debugging Assistant, MDA) generiert.</span><span class="sxs-lookup"><span data-stu-id="79f3e-272">In this case, it generates a <see href="https://docs.microsoft.com/dotnet/framework/debug-trace-profile/releasehandlefailed-mda">releaseHandleFailed</see> Managed Debugging Assistant.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-273">Die <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Methode wird garantiert nur einmal und nur dann aufgerufen, wenn das Handle gemäß der Definition durch die <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A>-Eigenschaft gültig ist.</span><span class="sxs-lookup"><span data-stu-id="79f3e-273">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is guaranteed to be called only once and only if the handle is valid as defined by the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property.</span></span> <span data-ttu-id="79f3e-274">Implementieren Sie diese Methode in den von <xref:System.Runtime.InteropServices.SafeHandle> abgeleiteten Klassen, um Code auszuführen, der zum Freigeben des Handles erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="79f3e-274">Implement this method in your <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle.</span></span> <span data-ttu-id="79f3e-275">Da eine der Funktionen von <xref:System.Runtime.InteropServices.SafeHandle> darin besteht, die Verhinderung von Ressourcenverlusten zu gewährleisten, muss der Code in der Implementierung von <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nie fehlschlagen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-275">Because one of the functions of <xref:System.Runtime.InteropServices.SafeHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> must never fail.</span></span> <span data-ttu-id="79f3e-276">Mit dem Garbage Collector werden <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> aufgerufen, nachdem normale Finalizer für Objekte ausgeführt wurden, die gleichzeitig mit Garbage Collection bereinigt wurden.</span><span class="sxs-lookup"><span data-stu-id="79f3e-276">The garbage collector calls <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time.</span></span> <span data-ttu-id="79f3e-277">Der Garbage Collector gewährleistet, dass die Ressourcen diese Methode aufrufen und dass die Methode während der Ausführung nicht unterbrochen wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-277">The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress.</span></span> <span data-ttu-id="79f3e-278">Diese Methode wird während der Erstellung der Instanz als eingeschränkter Ausführungs Bereich (CER) vorbereitet (zusammen mit allen Methoden in Ihrem statisch determinier baren Aufruf Diagramm).</span><span class="sxs-lookup"><span data-stu-id="79f3e-278">This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</span></span> <span data-ttu-id="79f3e-279">Obwohl hierdurch Thread Abbruch Interrupts verhindert werden, müssen Sie dennoch darauf achten, keine Fehler Pfade in die überschriebene <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> Methode einzuführen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-279">Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method.</span></span> <span data-ttu-id="79f3e-280">Wenden Sie insbesondere das <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>-Attribut auf alle Methoden an, die Sie von <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>abrufen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-280">In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span></span> <span data-ttu-id="79f3e-281">In den meisten Fällen sollte dieser Code wie folgt lauten:</span><span class="sxs-lookup"><span data-stu-id="79f3e-281">In most cases this code should be:</span></span>  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 <span data-ttu-id="79f3e-282">Darüber hinaus können Sie für die einfache Bereinigung (z. b. das Aufrufen der Windows-API-`CloseHandle` auf einem Datei Handle) den Rückgabewert des einzelnen Platt Form Aufrufs überprüfen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-282">Additionally, for simple cleanup (for example, calling the Windows API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call.</span></span> <span data-ttu-id="79f3e-283">Bei der komplexen Bereinigung haben Sie möglicherweise viele Programmlogik und viele Methodenaufrufe, von denen einige möglicherweise fehlschlagen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-283">For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</span></span> <span data-ttu-id="79f3e-284">Sie müssen sicherstellen, dass die Programmlogik für jeden dieser Fälle einen Fall Back-Code aufweist.</span><span class="sxs-lookup"><span data-stu-id="79f3e-284">You must ensure that your program logic has fallback code for each of those cases.</span></span>  
  
 <span data-ttu-id="79f3e-285">Wenn <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> aus irgendeinem Grund `false` zurückgibt, wird ein [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) -Assistent für verwaltetes Debuggen generiert.</span><span class="sxs-lookup"><span data-stu-id="79f3e-285">If <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span></span>  <span data-ttu-id="79f3e-286">Dadurch können Sie Fälle erkennen, in denen der Versuch, Ressourcen freizugeben, fehlschlägt.</span><span class="sxs-lookup"><span data-stu-id="79f3e-286">This helps you detect cases where your attempt to release resources fails.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79f3e-287">Im folgenden Codebeispiel wird das Handle freigegeben, und es ist Teil eines größeren Beispiels, das für die <xref:System.Runtime.InteropServices.SafeHandle>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="79f3e-287">The following code example releases the handle and is part of a larger example provided for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="79f3e-288">für die Berechtigung zum Abrufen von nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="79f3e-288">for permission to call unmanaged code.</span></span> <span data-ttu-id="79f3e-289">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-289">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="79f3e-290">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="79f3e-290">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/76994ee6-9fa9-4059-b813-26578d24427c"><span data-ttu-id="79f3e-291">Diagnostizieren von Laufzeitfehlern mit Assistenten für verwaltetes Debuggen</span><span class="sxs-lookup"><span data-stu-id="79f3e-291">Diagnosing Run-time Errors with Managed Debugging Assistants</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/44cd98ba-95e5-40a1-874d-e8e163612c51"><span data-ttu-id="79f3e-292">ReleaseHandleFailed</span><span class="sxs-lookup"><span data-stu-id="79f3e-292">ReleaseHandleFailed</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.SetHandle : nativeint -&gt; unit" Usage="safeHandle.SetHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="79f3e-293">Das bereits vorhandene Handle, das verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="79f3e-293">The pre-existing handle to use.</span></span></param>
        <summary><span data-ttu-id="79f3e-294">Legt das Handle für das angegebene, bereits vorhandene Handle fest.</span><span class="sxs-lookup"><span data-stu-id="79f3e-294">Sets the handle to the specified pre-existing handle.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-295">Verwenden Sie die <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A>-Methode nur, wenn Sie ein bereits vorhandenes handle unterstützen müssen (z. b., wenn das Handle in einer-Struktur zurückgegeben wird), da die .NET Framework COM-Interop-Infrastruktur das Marshalling von Ausgabe Handles in einer-Struktur nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79f3e-295">Use the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="79f3e-296">für die Berechtigung zum Abrufen von nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="79f3e-296">for permission to call unmanaged code.</span></span> <span data-ttu-id="79f3e-297">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-297">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="79f3e-298">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="79f3e-298">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberSignature Language="F#" Value="member this.SetHandleAsInvalid : unit -&gt; unit" Usage="safeHandle.SetHandleAsInvalid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79f3e-299">Markiert ein Handle als nicht mehr verwendet.</span><span class="sxs-lookup"><span data-stu-id="79f3e-299">Marks a handle as no longer used.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79f3e-300">Ruft die <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>-Methode nur auf, wenn Sie wissen, dass Ihr Handle nicht mehr auf eine Ressource verweist.</span><span class="sxs-lookup"><span data-stu-id="79f3e-300">Call the <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method only when you know that your handle no longer references a resource.</span></span> <span data-ttu-id="79f3e-301">Dadurch wird der Wert des <xref:System.Runtime.InteropServices.SafeHandle.handle> Felds nicht geändert. das Handle wird nur als geschlossen markiert.</span><span class="sxs-lookup"><span data-stu-id="79f3e-301">Doing so does not change the value of the <xref:System.Runtime.InteropServices.SafeHandle.handle> field; it only marks the handle as closed.</span></span> <span data-ttu-id="79f3e-302">Das Handle kann dann einen potenziell veralteten Wert enthalten.</span><span class="sxs-lookup"><span data-stu-id="79f3e-302">The handle might then contain a potentially stale value.</span></span> <span data-ttu-id="79f3e-303">Die Auswirkung dieses Aufrufens besteht darin, dass kein Versuch unternommen wird, die Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="79f3e-303">The effect of this call is that no attempt is made to free the resources.</span></span>  
  
 <span data-ttu-id="79f3e-304">Verwenden Sie wie bei der <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A>-Methode nur <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, wenn Sie ein bereits vorhandenes handle unterstützen müssen.</span><span class="sxs-lookup"><span data-stu-id="79f3e-304">As with the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="79f3e-305">für die Berechtigung zum Abrufen von nicht verwaltetem Code.</span><span class="sxs-lookup"><span data-stu-id="79f3e-305">for permission to call unmanaged code.</span></span> <span data-ttu-id="79f3e-306">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="79f3e-306">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="79f3e-307">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="79f3e-307">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>
