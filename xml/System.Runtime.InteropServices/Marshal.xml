<Type Name="Marshal" FullName="System.Runtime.InteropServices.Marshal">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b582e89d8a536a45d26354652aab5d4e97b21f0f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480654" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Marshal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Marshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.Marshal" />
  <TypeSignature Language="VB.NET" Value="Public Class Marshal" />
  <TypeSignature Language="C++ CLI" Value="public ref class Marshal abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Bietet eine Auflistung von Methoden zum Belegen von nicht verwaltetem Speicher, zum Kopieren von nicht verwalteten Speicherblöcken und zum Konvertieren von verwalteten in nicht verwaltete Typen sowie sonstige Methoden, die bei der Interaktion mit nicht verwaltetem Code verwendet werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `static` definierten Methoden den <xref:System.Runtime.InteropServices.Marshal> Klasse sind unverzichtbar für die Arbeit mit nicht verwaltetem Code. Die meisten Methoden in dieser Klasse definiert werden normalerweise von Entwicklern verwendet, die eine Brücke zwischen verwaltetem und nicht verwalteten Programmiermodellen bereitstellen möchten. Z. B. die <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> Methode kopiert die ANSI-Zeichen aus einer angegebenen Zeichenfolge (im verwalteten Heap) in einen Puffer, in dem nicht verwalteten Heap. Außerdem wird die richtige Größe der Zielheap belegt.  
  
 Die common Language Runtime stellt spezifische Marshalling Funktionalitäten bereit. Weitere Informationen zum Marshalling von Verhalten, finden Sie unter [Interop-Marshalling](~/docs/framework/interop/interop-marshaling.md).  
  
 Die `Read` und `Write` Methoden in der <xref:System.Runtime.InteropServices.Marshal> Klasse sowohl bei ausgerichteten als auch bei nicht ausgerichteten Zugriff unterstützen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie mit verschiedenen Methoden, die definiert, indem die <xref:System.Runtime.InteropServices.Marshal> Klasse.  
  
 [!code-cpp[Marshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#1)]
 [!code-csharp[Marshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#1)]
 [!code-vb[Marshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddRef">
      <MemberSignature Language="C#" Value="public static int AddRef (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddRef(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddRef (pUnk As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddRef(IntPtr pUnk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">Der zu inkrementierende Verweiszähler für Schnittstellen.</param>
        <summary>Inkrementiert den Verweiszähler für die angegebene Schnittstelle.</summary>
        <returns>Der neue Wert des Verweiszählers für den <paramref name="pUnk" />-Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die common Language Runtime verwaltet den Verweiszähler eines COM-Objekts, so dass es nicht erforderlich ist, verwenden Sie diese Methode direkt Sie. In seltenen Fällen, z. B. Tests von einem benutzerdefinierten Marshaller möglicherweise finden Sie es erforderlich, um die Lebensdauer eines Objekts manuell zu bearbeiten. Nach dem Aufruf <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, müssen Sie den Verweiszähler dieser Planergruppe mithilfe einer Methode wie z. B. Dekrementieren <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>. Verlassen Sie sich nicht auf den Rückgabewert der <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, wie es instabil sein kann.  
  
 Sie erreichen <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, oder <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> zum Abrufen einer <xref:System.IntPtr> Wert, der darstellt ein [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) Schnittstellenzeiger auf. Sie können diese Methoden auch verwenden und die <xref:System.Runtime.InteropServices.Marshal.AddRef%2A> Methode für verwaltete Objekte zum Abrufen der COM-Schnittstellen, die das verwaltete Objekt COM callable Wrapper dargestellt. Wenn Sie nicht mit den Details dieses Typs Wrapper vertraut sind, finden Sie unter [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr AllocCoTaskMem (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocCoTaskMem(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocCoTaskMem (cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocCoTaskMem(int cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">Die Größe des zu belegenden Speicherblocks.</param>
        <summary>Belegt einen Speicherblock der angegebenen Größe aus der Speicherbelegungsfunktion für COM-Aufgaben.</summary>
        <returns>Eine ganze Zahl, die die Adresse des belegten Speicherblocks darstellt. Dieser Speicher muss mit <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /> freigegeben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> ist eine der beiden speicherbelegung API-Methoden in der <xref:System.Runtime.InteropServices.Marshal> Klasse. (<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> die andere ist.) Der erste Speicherinhalt zurückgegeben ist nicht definiert, und der belegte Arbeitsspeicher kann größer sein als die angeforderte Anzahl von Bytes. Diese Methode macht COM [CoTaskMemAlloc](http://go.microsoft.com/fwlink/?LinkId=148626) -Funktion, die so der Speicherbelegungsfunktion für COM-Aufgaben genannte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher zum Erfüllen der Anforderung vorhanden.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AllocHGlobal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Belegt Speicher aus dem nicht verwalteten Speicher des Prozesses.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocHGlobal (cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocHGlobal(int cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">Die erforderliche Anzahl der Bytes im Speicher.</param>
        <summary>Reserviert Speicher aus dem nicht verwalteten Arbeitsspeicher des Prozesses mit der angegebenen Anzahl von Bytes.</summary>
        <returns>Ein Zeiger auf den neu reservierten Speicher. Dieser Speicher muss unter Verwendung der <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />-Methode freigegeben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> ist einer von zwei Methoden der Speicher-Zuordnung in der <xref:System.Runtime.InteropServices.Marshal> Klasse. (<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> die andere ist.) Diese Methode macht die Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkId=148628) -Funktion von Kernel32.dll verwenden.  
  
 Wenn <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> Aufrufe `LocalAlloc`, übergibt ein `LMEM_FIXED` -Flag, das bewirkt, dass den zugeordneten Arbeitsspeicher gesperrt werden. Darüber hinaus ist der belegte Arbeitsspeicher nicht Nullen angefüllt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Aufrufen der <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>-Methode veranschaulicht. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Runtime.InteropServices.Marshal> Klasse.  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher zum Erfüllen der Anforderung vorhanden.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocHGlobal (cb As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocHGlobal(IntPtr cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="cb">Die erforderliche Anzahl der Bytes im Speicher.</param>
        <summary>Reserviert Speicher aus dem nicht verwalteten Arbeitsspeicher des Prozesses mithilfe des Zeigers auf die angegebene Anzahl von Bytes.</summary>
        <returns>Ein Zeiger auf den neu reservierten Speicher. Dieser Speicher muss unter Verwendung der <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />-Methode freigegeben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> ist einer von zwei Methoden der Speicher-Zuordnung in der <xref:System.Runtime.InteropServices.Marshal> Klasse. (<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> die andere ist.) Diese Methode macht die Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkID=148628) -Funktion von Kernel32.dll verwenden.  
  
 Wenn <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> Aufrufe `LocalAlloc`, übergibt ein `LMEM_FIXED` -Flag, das bewirkt, dass den zugeordneten Arbeitsspeicher gesperrt werden. Darüber hinaus ist der belegte Arbeitsspeicher nicht Nullen angefüllt.  
  
 Beispielcode hierzu finden Sie unter <xref:System.Runtime.InteropServices.Marshal> und <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher zum Erfüllen der Anforderung vorhanden.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="AreComObjectsAvailableForCleanup">
      <MemberSignature Language="C#" Value="public static bool AreComObjectsAvailableForCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool AreComObjectsAvailableForCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AreComObjectsAvailableForCleanup () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool AreComObjectsAvailableForCleanup();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob Runtime Callable Wrappers (RCWs) aus einem beliebigen Kontext zur Bereinigung verfügbar sind.</summary>
        <returns>
          <see langword="true" />, wenn RCWs zur Bereinigung verfügbar sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn es viele Verweise zwischen verwalteten und nativen Code mit umfassenden Abhängigkeitsdiagramme gibt kann es sehr lange für alle Objekte zum Bereinigen von dauern. Jedes Mal, wenn eine Garbage Collection ausgeführt wird wird es einer beliebigen Anzahl von RCWs, freigeben, die wiederum die zugrunde liegenden COM-Objekte freigegeben wird. Diese COM-Objekten werden dann ihre verwalteten Verweise freigegeben, und mehrere Objekte verfügbar machen für die Bereinigung das nächste Mal eine GC ausgeführt wird, wodurch den Prozess gestartet wird erneut.  
  
 Die <xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A> Methode bietet eine Möglichkeit für die Anwendung aus, um zu bestimmen, wie viele Zyklen von GC. Erfassen und globale Katalogdienste. WaitForPendingFinalizers müssen durchgeführt werden soll, um alles zu bereinigen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="BindToMoniker">
      <MemberSignature Language="C#" Value="public static object BindToMoniker (string monikerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object BindToMoniker(string monikerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindToMoniker (monikerName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ BindToMoniker(System::String ^ monikerName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="monikerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="monikerName">Der dem gewünschten Schnittstellenzeiger entsprechende Moniker.</param>
        <summary>Ruft einen vom angegebenen Moniker bezeichneten Schnittstellenzeiger ab.</summary>
        <returns>Ein Objekt mit einem Verweis auf den Schnittstellenzeiger, der durch den <paramref name="monikerName" />-Parameter angegeben wird. Ein Moniker stellt einen Namen dar, und in diesem Fall wird der Moniker durch eine Schnittstelle definiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A> macht COM `BindToMoniker` -Methode, die ein Objekt erzeugt, die Sie für jede COM-Schnittstelle umgewandelt werden können. Diese Methode bietet dieselbe Funktionalität wie die `GetObject` Methode in Visual Basic 6.0 und [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">Von der nicht verwalteten <see langword="BindToMoniker" />-Methode wurde ein nicht erkanntes HRESULT zurückgegeben.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="BufferToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr BufferToBSTR (Array ptr, int slen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int BufferToBSTR(class System.Array ptr, int32 slen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BufferToBSTR(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BufferToBSTR (ptr As Array, slen As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr BufferToBSTR(Array ^ ptr, int slen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Array" />
        <Parameter Name="slen" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="slen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeWrapperHandleStrength">
      <MemberSignature Language="C#" Value="public static void ChangeWrapperHandleStrength (object otp, bool fIsWeak);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangeWrapperHandleStrength(object otp, bool fIsWeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ChangeWrapperHandleStrength (otp As Object, fIsWeak As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChangeWrapperHandleStrength(System::Object ^ otp, bool fIsWeak);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otp" Type="System.Object" />
        <Parameter Name="fIsWeak" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="otp">Das Objekt, dessen CCW ein Handle mit Verweiszähler enthält. Das Handle ist stark, wenn der Verweiszähler für den COM Callable Wrapper größer als 0 ist, andernfalls ist er schwach.</param>
        <param name="fIsWeak">
          <see langword="true" />, um die Stärke des Handles für den <c>otp</c>-Parameter unabhängig von dessen Verweiszähler auf schwach zu ändern. <see langword="false" />, um die Stärke des Handles für <c>otp</c> auf das Ausführen einer Verweiszählung zurückzusetzen.</param>
        <summary>Ändert die Stärke des CCW-Handles ([COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md)) für ein Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A> wird für Objektpooling verwendet und sollte nie aufgerufen werden vom Benutzercode direkt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CleanupUnusedObjectsInCurrentContext">
      <MemberSignature Language="C#" Value="public static void CleanupUnusedObjectsInCurrentContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CleanupUnusedObjectsInCurrentContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CleanupUnusedObjectsInCurrentContext ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CleanupUnusedObjectsInCurrentContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt die Laufzeit, dass alle im aktuellen Kontext reservierten [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCWs) bereinigt werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Interop-System ruft Nachrichten aus, während er versucht, RCWs bereinigen. Dadurch wird sichergestellt, das die Bereinigung, RCWs Singlethread-Apartment (STA), was geschieht, in allen Anwendungen, einschließlich Anwendungen, die nicht oft genug weiterleiten. Allerdings sind einige Anwendungen, die entsprechend pump sehr empfindlich gegenüber Pumping fortgesetzt werden, in denen tritt auf. Wenn das Interop-System ruft Nachrichten in diesen Anwendungen an Orten, die unerwartete, sind, die Anwendung Reentranz Probleme, die schwer zu diagnostizieren sind auftreten kann. Daher müssen Anwendungen ihre eigenen Pumping fortgesetzt werden für einen bestimmten STA und Kontrolle der Bereinigung der RCWs steuern können.  
  
 Allerdings kontrollieren die Entwickler häufig nur eine Teilmenge der Threads in der Anwendung und können nicht so sicherstellen, dass alle Threads angemessen ausgeführt werden.  
  
 So beheben Sie dieses Problem  
  
1.  Verwenden der <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType> Methode, um die automatische Bereinigung von RCWs und die Meldung Pumping fortgesetzt werden, die regelmäßig pro Thread auftritt, deaktivieren. Dies ermöglicht Entwicklern das automatische Bereinigen und die entsprechenden meldungsverteilung abzuwählen.  
  
2.  Verwenden der <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A> Methode zum Benachrichtigen der Laufzeit alle RCWs bereinigen, die im aktuellen Kontext zugeordnet sind. Diese Methode Companion kann Entwickler genau zu steuern, wenn die Common Language Runtime Bereinigung im aktuellen Kontext ausführt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert Daten aus einem verwalteten Array in einen nicht verwalteten Speicherzeiger oder aus einem nicht verwalteten Speicherzeiger in ein verwaltetes Array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (byte[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(unsigned int8[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Byte(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;System::Byte&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Das eindimensionale Array, aus dem kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Quellarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="destination">Der Speicherzeiger, in den kopiert werden soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem eindimensionalen, verwalteten Array von 8-Bit-Ganzzahlen ohne Vorzeichen in einen nicht verwalteten Speicherzeiger.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, eine Teilmenge von einem eindimensionalen, verwalteten Array in ein nicht verwaltetes Array von C-Format zu kopieren.  
  
   
  
## Examples  
 Im folgenden Beispiel werden ein Array auf nicht verwalteten Speicher mithilfe der <xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29> überladen und kopiert dann das nicht verwaltete Array zurück in den verwalteten Speicher mithilfe der <xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> überladen.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> und <paramref name="length" /> sind nicht gültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (char[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(char[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Char(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;char&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Das eindimensionale Array, aus dem kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Quellarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="destination">Der Speicherzeiger, in den kopiert werden soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem eindimensionalen, verwalteten Zeichenarray in einen nicht verwalteten Speicherzeiger.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, eine Teilmenge von einem eindimensionalen, verwalteten Array in ein nicht verwaltetes Array von C-Format zu kopieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array auf nicht verwalteten Arbeitsspeicher kopiert und kopiert dann wieder in den verwalteten Speicher nicht verwaltete Array.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> und <paramref name="length" /> sind nicht gültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="startIndex" />, <paramref name="destination" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (double[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Double(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;double&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Das eindimensionale Array, aus dem kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Quellarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="destination">Der Speicherzeiger, in den kopiert werden soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem eindimensionalen, verwalteten Array von Gleitkommazahlen mit doppelter Genauigkeit in einen nicht verwalteten Speicherzeiger.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, eine Teilmenge von einem eindimensionalen, verwalteten Array in ein nicht verwaltetes Array von C-Format zu kopieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array auf nicht verwalteten Arbeitsspeicher kopiert und kopiert dann wieder in den verwalteten Speicher nicht verwaltete Array.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> und <paramref name="length" /> sind nicht gültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (short[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int16[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Short(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;short&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Das eindimensionale Array, aus dem kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Quellarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="destination">Der Speicherzeiger, in den kopiert werden soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem eindimensionalen, verwalteten Array von 16-Bit-Ganzzahlen mit Vorzeichen in einen nicht verwalteten Speicherzeiger.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, eine Teilmenge von einem eindimensionalen, verwalteten Array in ein nicht verwaltetes Array von C-Format zu kopieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array auf nicht verwalteten Arbeitsspeicher kopiert und kopiert dann wieder in den verwalteten Speicher nicht verwaltete Array.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> und <paramref name="length" /> sind nicht gültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (int[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Integer(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;int&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Das eindimensionale Array, aus dem kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Quellarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="destination">Der Speicherzeiger, in den kopiert werden soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem eindimensionalen, verwalteten Array von 32-Bit-Ganzzahlen mit Vorzeichen in einen nicht verwalteten Speicherzeiger.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, eine Teilmenge von einem eindimensionalen, verwalteten Array in ein nicht verwaltetes Array von C-Format zu kopieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array auf nicht verwalteten Arbeitsspeicher kopiert und kopiert dann wieder in den verwalteten Speicher nicht verwaltete Array.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> und <paramref name="length" /> sind nicht gültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="startIndex" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (long[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Long(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;long&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Das eindimensionale Array, aus dem kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Quellarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="destination">Der Speicherzeiger, in den kopiert werden soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem eindimensionalen, verwalteten Array von 64-Bit-Ganzzahlen mit Vorzeichen in einen nicht verwalteten Speicherzeiger.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, eine Teilmenge von einem eindimensionalen, verwalteten Array in ein nicht verwaltetes Array von C-Format zu kopieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array auf nicht verwalteten Arbeitsspeicher kopiert und kopiert dann wieder in den verwalteten Speicher nicht verwaltete Array.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> und <paramref name="length" /> sind nicht gültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, byte[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, unsigned int8[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Byte(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;System::Byte&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Der Speicherzeiger, aus dem kopiert werden soll.</param>
        <param name="destination">Das Array, in das kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Zielarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem nicht verwalteten Speicherzeiger in ein verwaltetes Array von 8-Bit-Ganzzahlen ohne Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht verwaltete Arrays im C-Format enthalten keine Informationen zu Grenzen, wird verhindert, dass die `startIndex` und `length` Parameter aus, die validiert wird. Folglich nicht verwalteten Daten entspricht der `source` -Parameter auffüllt, unabhängig von der des Nutzens verwalteten Arrays. Sie müssen die verwalteten Arrays mit einer geeigneten Größe initialisieren, vor dem Aufrufen dieser Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array auf nicht verwalteten Arbeitsspeicher kopiert und kopiert dann wieder in den verwalteten Speicher nicht verwaltete Array.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, char[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, char[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;char&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Der Speicherzeiger, aus dem kopiert werden soll.</param>
        <param name="destination">Das Array, in das kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Zielarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem nicht verwalteten Speicherzeiger in ein verwaltetes Zeichenarray.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht verwaltete Arrays im C-Format enthalten keine Informationen zu Grenzen, wird verhindert, dass die `startIndex` und `length` Parameter aus, die validiert wird. Folglich nicht verwalteten Daten entspricht der `source` -Parameter auffüllt, unabhängig von der des Nutzens verwalteten Arrays. Sie müssen die verwalteten Arrays mit einer geeigneten Größe initialisieren, vor dem Aufrufen dieser Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array auf nicht verwalteten Arbeitsspeicher kopiert und kopiert dann wieder in den verwalteten Speicher nicht verwaltete Array.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, double[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Double(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;double&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Der Speicherzeiger, aus dem kopiert werden soll.</param>
        <param name="destination">Das Array, in das kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Zielarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem nicht verwalteten Speicherzeiger in ein verwaltetes Array von Gleitkommazahlen mit doppelter Genauigkeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht verwaltete Arrays im C-Format enthalten keine Informationen zu Grenzen, wird verhindert, dass die `startIndex` und `length` Parameter aus, die validiert wird. Folglich nicht verwalteten Daten entspricht der `source` -Parameter auffüllt, unabhängig von der des Nutzens verwalteten Arrays. Sie müssen die verwalteten Arrays mit einer geeigneten Größe initialisieren, vor dem Aufrufen dieser Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array auf nicht verwalteten Arbeitsspeicher kopiert und kopiert dann wieder in den verwalteten Speicher nicht verwaltete Array.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, short[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int16[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Short(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;short&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Der Speicherzeiger, aus dem kopiert werden soll.</param>
        <param name="destination">Das Array, in das kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Zielarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem nicht verwalteten Speicherzeiger in ein verwaltetes Array von 16-Bit-Ganzzahlen mit Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht verwaltete Arrays im C-Format enthalten keine Informationen zu Grenzen, wird verhindert, dass die `startIndex` und `length` Parameter aus, die validiert wird. Folglich nicht verwalteten Daten entspricht der `source` -Parameter auffüllt, unabhängig von der des Nutzens verwalteten Arrays. Sie müssen die verwalteten Arrays mit einer geeigneten Größe initialisieren, vor dem Aufrufen dieser Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array auf nicht verwalteten Arbeitsspeicher kopiert und kopiert dann wieder in den verwalteten Speicher nicht verwaltete Array.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, int[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Integer(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;int&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Der Speicherzeiger, aus dem kopiert werden soll.</param>
        <param name="destination">Das Array, in das kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Zielarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem nicht verwalteten Speicherzeiger in ein verwaltetes Array von 32-Bit-Ganzzahlen mit Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht verwaltete Arrays im C-Format enthalten keine Informationen zu Grenzen, wird verhindert, dass die `startIndex` und `length` Parameter aus, die validiert wird. Folglich nicht verwalteten Daten entspricht der `source` -Parameter auffüllt, unabhängig von der des Nutzens verwalteten Arrays. Sie müssen die verwalteten Arrays mit einer geeigneten Größe initialisieren, vor dem Aufrufen dieser Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array auf nicht verwalteten Arbeitsspeicher kopiert und kopiert dann wieder in den verwalteten Speicher nicht verwaltete Array.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, long[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Long(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;long&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Der Speicherzeiger, aus dem kopiert werden soll.</param>
        <param name="destination">Das Array, in das kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Zielarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem nicht verwalteten Speicherzeiger in ein verwaltetes Array von 64-Bit-Ganzzahlen mit Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht verwaltete Arrays im C-Format enthalten keine Informationen zu Grenzen, wird verhindert, dass die `startIndex` und `length` Parameter aus, die validiert wird. Folglich nicht verwalteten Daten entspricht der`source` -Parameter auffüllt, unabhängig von der des Nutzens verwalteten Arrays. Sie müssen die verwalteten Arrays mit einer geeigneten Größe initialisieren, vor dem Aufrufen dieser Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array auf nicht verwalteten Arbeitsspeicher kopiert und kopiert dann wieder in den verwalteten Speicher nicht verwaltete Array.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, IntPtr[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, native int[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As IntPtr(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;IntPtr&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Der Speicherzeiger, aus dem kopiert werden soll.</param>
        <param name="destination">Das Array, in das kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Zielarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem nicht verwalteten Speicherzeiger in ein verwaltetes <see cref="T:System.IntPtr" />-Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht verwaltete Arrays im C-Format enthalten keine Informationen zu Grenzen, wird verhindert, dass die `startIndex` und `length` Parameter aus, die validiert wird. Aus diesem Grund, die nicht verwalteten Daten an, die `source` -Parameter auffüllt, unabhängig von der des Nutzens verwalteten Arrays. Müssen Sie mit der entsprechenden Größe vor dem Aufruf von verwalteten Arrays initialisieren die <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, float[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Single(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;float&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Der Speicherzeiger, aus dem kopiert werden soll.</param>
        <param name="destination">Das Array, in das kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Zielarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem nicht verwalteten Speicherzeiger in ein verwaltetes Array von Gleitkommazahlen mit einfacher Genauigkeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht verwaltete Arrays im C-Format enthalten keine Informationen zu Grenzen, wird verhindert, dass die `startIndex` und `length` Parameter aus, die validiert wird. Folglich nicht verwalteten Daten entspricht der `source` -Parameter auffüllt, unabhängig von der des Nutzens verwalteten Arrays. Sie müssen die verwalteten Arrays mit einer geeigneten Größe initialisieren, vor dem Aufrufen dieser Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;IntPtr&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Das eindimensionale Array, aus dem kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Quellarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="destination">Der Speicherzeiger, in den kopiert werden soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem eindimensionalen, verwalteten <see cref="T:System.IntPtr" />-Array in einen nicht verwalteten Speicherzeiger.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, um einen Teil aus einem eindimensionalen, verwalteten kopieren <xref:System.IntPtr> Array in ein nicht verwaltetes Array von C-Format.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (float[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Single(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;float&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Das eindimensionale Array, aus dem kopiert werden soll.</param>
        <param name="startIndex">Der nullbasierte Index im Quellarray, an dem der Kopiervorgang beginnen soll.</param>
        <param name="destination">Der Speicherzeiger, in den kopiert werden soll.</param>
        <param name="length">Die Anzahl der zu kopierenden Arrayelemente.</param>
        <summary>Kopiert Daten aus einem eindimensionalen, verwalteten Array von Gleitkommazahlen mit einfacher Genauigkeit in einen nicht verwalteten Speicherzeiger.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, eine Teilmenge von einem eindimensionalen, verwalteten Array in ein nicht verwaltetes Array von C-Format zu kopieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> und <paramref name="length" /> sind nicht gültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> oder <paramref name="length" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject (IntPtr pOuter, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject(native int pOuter, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAggregatedObject (pOuter As IntPtr, o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateAggregatedObject(IntPtr pOuter, System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="pOuter">Der äußere <see langword="IUnknown" />-Zeiger.</param>
        <param name="o">Ein zu aggregierendes Objekt.</param>
        <summary>Verbindet ein verwaltetes Objekt mit dem angegebenen COM-Objekt.</summary>
        <returns>Der innere <see langword="IUnknown" />-Zeiger des verwalteten Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> Methode aggregiert den inneren verwalteten Zeiger eines verwalteten Objekts mit dem angegebenen äußeren Zeiger und gibt dann eine innere [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) Zeiger des verwalteten Objekts.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="o" /> ist ein [!INCLUDE[wrt](~/includes/wrt-md.md)]-Objekt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject&lt;T&gt; (IntPtr pOuter, T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject&lt;T&gt;(native int pOuter, !!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAggregatedObject(Of T) (pOuter As IntPtr, o As T) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr CreateAggregatedObject(IntPtr pOuter, T o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des zu aggregierenden verwalteten Objekts.</typeparam>
        <param name="pOuter">Der äußere [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)-Zeiger.</param>
        <param name="o">Das zu aggregierende -Objekt.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Aggregiert ein verwaltetes Objekt des angegebenen Typs mit dem angegebenen COM-Objekt.</summary>
        <returns>Der innere [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)-Zeiger des verwalteten Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> Methode aggregiert den inneren verwalteten Zeiger von einem verwalteten Objekt eines angegebenen Typs mit dem angegebenen äußeren Zeiger und gibt eine innere [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) Zeiger des verwalteten Objekts.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="o" /> ist ein [!INCLUDE[wrt](~/includes/wrt-md.md)]-Objekt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType">
      <MemberSignature Language="C#" Value="public static object CreateWrapperOfType (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateWrapperOfType(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateWrapperOfType (o As Object, t As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateWrapperOfType(System::Object ^ o, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Das zu umschließende Objekt.</param>
        <param name="t">Der Typ des zu erstellenden Wrappers.</param>
        <summary>Umschließt das angegebene COM-Objekt mit einem Objekt des angegebenen Typs.</summary>
        <returns>Das neu umschlossene Objekt, das eine Instanz des gewünschten Typs darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A> Konvertiert einen COM-Klassentyp, in der Regel die Basis `__ComObject` Typ in einen anderen Typ von COM-Klasse. -Parameter dargestellte COM-Eingabeobjekt `o`, ist ein [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).  
  
 Sowohl die `t` und `o` Parameter sein, deren Signaturen zugeschrieben werden, Klassen <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>. Die [Tlbimp.exe (Type Library Importer-Tool)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) Tool wendet dieses Attribut, wenn es sich um eine Typbibliothek importiert. Wenn Sie den RCW manuell im Quellcode erstellen, sollten Sie dieses Attribut auf der verwalteten Signatur anwenden, die darstellt, dessen Ursprung COM kenntlich zu machen, die ursprünglichen Co-Klasse.  
  
 Tlbimp.exe importiert eine COM [Coclass](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) als eine verwaltete Klasse und einer Schnittstelle. Die Coclass-Schnittstelle hat den gleichen Namen wie die ursprüngliche Co-Klasse, und die verwaltete Klasse verfügt über den ursprünglichen Coclass-Namen mit "Class" angefügt. Angenommen, eine Co-Klasse namens `MyCoclass` wird eine Co-Schnittstelle mit dem Namen `MyCoclass` und eine verwaltete Klasse aufgerufen `MyCoclassClass`. Da `t` muss eine Klasse, die nicht für eine Schnittstelle, müssen Sie die verwaltete Klasse angeben (`MyCoclassClass`) und nicht die Co-Schnittstelle.  
  
> [!NOTE]
>  Sie verlieren die Identität der Eingabe, die COM-Objekte, da eine neue Instanz der RCW dient als Wrapper für die [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) Zeiger, die von der ursprünglichen RCW verfügbar gemacht werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" /> muss von <see langword="__ComObject" /> abgeleitet werden.  
  
 - oder -   
  
 <paramref name="t" /> ist ein [!INCLUDE[wrt](~/includes/wrt-md.md)]-Typ.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="t" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" /> kann nicht in den Zieltyp konvertiert werden, da es nicht alle erforderlichen Schnittstellen unterstützt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType&lt;T,TWrapper&gt;">
      <MemberSignature Language="C#" Value="public static TWrapper CreateWrapperOfType&lt;T,TWrapper&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TWrapper CreateWrapperOfType&lt;T, TWrapper&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateWrapperOfType(Of T, TWrapper) (o As T) As TWrapper" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TWrapper&gt;&#xA; static TWrapper CreateWrapperOfType(T o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TWrapper</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TWrapper" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des zurückzugebenden Umbruchs.</typeparam>
        <typeparam name="TWrapper">Der Typ des zurückzugebenden Objekts.</typeparam>
        <param name="o">Das zu umschließende Objekt.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Umschließt das angegebene COM-Objekt mit einem Objekt des angegebenen Typs.</summary>
        <returns>Das neu umschlossene Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29> Konvertiert ein COM-Objekt des Typs `T` auf die `TWrapper` Typ für COM-Klasse. -Parameter dargestellte COM-Eingabeobjekt `o`, ist ein [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).  
  
 Sowohl die `T` generischen Typparameter und die `o` Parameter muss Klassen, deren Signaturen zugeschrieben, werden die <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> Attribut. Die [Tlbimp.exe (Type Library Importer-Tool)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) Tool wendet dieses Attribut, wenn es sich um eine Typbibliothek importiert. Wenn Sie den RCW manuell im Quellcode erstellen, sollten Sie dieses Attribut auf der verwalteten Signatur anwenden, die darstellt, dessen Ursprung COM kenntlich zu machen, die ursprünglichen Co-Klasse.  
  
 Tlbimp.exe importiert eine COM [Coclass](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) als eine verwaltete Klasse und einer Schnittstelle. Die Coclass-Schnittstelle hat den gleichen Namen wie die ursprüngliche Co-Klasse, und die verwaltete Klasse verfügt über den ursprünglichen Coclass-Namen mit "Class" angefügt. Angenommen, eine Co-Klasse namens `MyCoclass` wird eine Co-Schnittstelle mit dem Namen `MyCoclass` und eine verwaltete Klasse aufgerufen `MyCoclassClass`. Da`T` muss eine Klasse, die nicht für eine Schnittstelle, müssen Sie die verwaltete Klasse angeben (`MyCoclassClass`) und nicht die `coclass` Schnittstelle.  
  
> [!NOTE]
>  Sie verlieren die Identität des COM-Eingabeobjekts, da eine neue Instanz der RCW dient als Wrapper für die [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) Zeiger, die von der ursprünglichen RCW verfügbar gemacht werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <typeparamref name="T" /> muss von <see langword="__ComObject" /> abgeleitet werden.  
  
 - oder -   
  
 <typeparamref name="T" /> ist ein [!INCLUDE[wrt](~/includes/wrt-md.md)]-Typ.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" /> kann nicht in <paramref name="TWrapper" /> konvertiert werden, da nicht alle erforderlichen Schnittstellen unterstützt werden.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure">
      <MemberSignature Language="C#" Value="public static void DestroyStructure (IntPtr ptr, Type structuretype);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure(native int ptr, class System.Type structuretype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DestroyStructure (ptr As IntPtr, structuretype As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DestroyStructure(IntPtr ptr, Type ^ structuretype);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structuretype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">Ein Zeiger auf einen nicht verwalteten Speicherblock.</param>
        <param name="structuretype">Typ einer formatierten Klasse. Damit werden die Layoutinformationen bereitgestellt, die zum Löschen des Puffers im <c>ptr</c>-Parameter benötigt werden.</param>
        <summary>Gibt alle Unterstrukturen frei, auf die der angegebene nicht verwaltete Speicherblock zeigt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, Verweistyp-Felder, z. B. Zeichenfolgen, in eine nicht verwaltete Struktur freizugeben. Im Gegensatz zu den zugehörigen Felder kann eine Struktur ein Werttyp oder ein Verweistyp sein. Werttyp-Strukturen, die Felder für Werttyp (alle blitfähig) enthalten haben keine Verweise, dessen Speicher freigegeben werden muss. Die <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> Methode verwendet diese Methode, um Speicherverluste zu verhindern, wenn von einer Struktur belegten Speicher wiederverwendet.  
  
 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> Ruft die COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) -Funktion auf, die wiederum eine reservierte Zeichenfolge freigibt.  
  
 Zusätzlich zu <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>, <xref:System.Runtime.InteropServices.Marshal> Klasse enthält zwei weitere Methoden zur Freigabe von belegtem Speicher: <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> und <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="structureType" /> weist ein automatisch angelegtes Layout auf. Verwenden Sie stattdessen sequenzielles oder explizites Layout.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DestroyStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DestroyStructure(Of T) (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void DestroyStructure(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der formatierten Struktur. Damit werden die Layoutinformationen bereitgestellt, die zum Löschen des Puffers im <c>ptr</c>-Parameter benötigt werden.</typeparam>
        <param name="ptr">Ein Zeiger auf einen nicht verwalteten Speicherblock.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Gibt alle Unterstrukturen eines angegebenen Typs frei, auf die der angegebene nicht verwaltete Speicherblock zeigt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, Verweistypfelder, z. B. Zeichenfolgen, einer nicht verwalteten Struktur freigeben. Im Gegensatz zu den zugehörigen Felder kann eine Struktur ein Werttyp oder ein Verweistyp sein. Wert Typ Strukturen, die Werttypfelder (alle blitfähig) enthalten, haben keine Verweise, dessen Speicher freigegeben werden muss. Die <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> Methode verwendet diese Methode, um Speicherverluste zu verhindern, wenn von einer Struktur belegten Speicher wiederverwendet.  
  
 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> Ruft die COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) -Funktion auf, die wiederum eine reservierte Zeichenfolge freigibt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <typeparamref name="T" /> weist ein automatisch angelegtes Layout auf. Verwenden Sie stattdessen sequenzielles oder explizites Layout.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="FinalReleaseComObject">
      <MemberSignature Language="C#" Value="public static int FinalReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FinalReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FinalReleaseComObject (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FinalReleaseComObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Der RCW, der freigegeben werden soll.</param>
        <summary>Gibt alle Verweise auf einen [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) durch Festlegen des Verweiszählers auf 0 frei.</summary>
        <returns>Der neue Wert des Verweiszählers des RCWs, der dem <paramref name="o" />-Parameter zugeordnet ist. Dieser ist bei erfolgreicher Freigabe 0 (null).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> Methode frei, die den verwalteten Verweis auf ein COM-Objekt. Beim Aufrufen dieser Methode entspricht dem Aufrufen der <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> Methode in einer Schleife, bis 0 (null) zurückgegeben.  
  
 Wenn der Verweiszähler für den COM-Objekt 0 ist, wird in der Regel das COM-Objekt freigegeben, obwohl dies hängt von der COM-Objekt-Implementierung und befindet sich außerhalb der Kontrolle der Laufzeit. Jedoch kann der RCW weiterhin vorhanden darauf warten, Garbage Collection übergeben werden.  
  
 Das COM-Objekt kann nicht verwendet werden, nachdem es vom zugrunde liegenden RCW getrennt wurde. Wenn Sie versuchen, eine Methode für den RCW aufzurufen, nachdem der entsprechende Verweiszähler 0 ist, wird eine <xref:System.Runtime.InteropServices.InvalidComObjectException> ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="o" /> ist kein gültiges COM-Objekt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
        <altmember cref="T:System.NullReferenceException" />
      </Docs>
    </Member>
    <Member MemberName="FreeBSTR">
      <MemberSignature Language="C#" Value="public static void FreeBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeBSTR (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeBSTR(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse des freizugebenden BSTR.</param>
        <summary>Gibt einen <see langword="BSTR" /> mithilfe der COM-[SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633)-Funktion frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wie <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType> und <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>, verwenden Sie diese Methode, um Arbeitsspeicher freizugeben. <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A> Ruft die COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633) -Funktion, die von einer der folgenden nicht verwalteten Methoden belegten Arbeitsspeicher frei: `SysAllocString`, `SysAllocStringByteLen`, `SysAllocStringLen`, `SysReAllocString`, `SysReAllocStringLen`. Sie können nicht verwaltete Methoden aufrufen, wie diese mit einem Plattformaufruf aufgerufen. Weitere Informationen finden Sie unter [nicht verwaltete DLL-Funktionen nutzen](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="FreeCoTaskMem">
      <MemberSignature Language="C#" Value="public static void FreeCoTaskMem (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeCoTaskMem(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeCoTaskMem (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeCoTaskMem(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse des freizugebenden Speichers.</param>
        <summary>Gibt einen Speicherblock frei, der von der nicht verwalteten Speicherbelegungsfunktion für COM-Aufgaben belegt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> auf alle von belegten Arbeitsspeicher freizugeben <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>, oder eine entsprechende nicht verwaltete Methode. Wenn die `ptr` Parameter ist `null`, die Methode hat keine Funktion.  
  
 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> macht COM [CoTaskMemFree](http://go.microsoft.com/fwlink/?LinkId=148638) -Funktion, die alle Bytes freigibt, sodass Sie den Speicher nicht mehr verwenden können, die die `ptr` -Parameter zeigt.  
  
 Zusätzlich zu <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal> Klasse enthält zwei weitere Methoden zur Freigabe von belegtem Speicher: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> und <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="FreeHGlobal">
      <MemberSignature Language="C#" Value="public static void FreeHGlobal (IntPtr hglobal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeHGlobal(native int hglobal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeHGlobal (hglobal As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeHGlobal(IntPtr hglobal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hglobal" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hglobal">Das Handle, das beim ursprünglichen übereinstimmenden Aufruf von <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /> zurückgegeben wurde.</param>
        <summary>Gibt Speicherplatz frei, der zuvor aus dem nicht verwalteten Speicher des Prozesses belegt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> zur Freigabe von Speicher aus dem globalen Heap durch <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>, oder einer gleichwertigen nicht verwalteten API-Methode. Wenn die `hglobal` Parameter ist <xref:System.IntPtr.Zero?displayProperty=nameWithType> die Methode hat keine Funktion.  
  
 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> macht die [LocalAlloc](http://go.microsoft.com/fwlink/?LinkId=148640) -Funktion von Kernel32.dll verwenden, die alle Bytes freigibt, damit Sie den Speicher nicht mehr verwenden, können verweist `hglobal`.  
  
 Zusätzlich zu <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>, <xref:System.Runtime.InteropServices.Marshal> Klasse bietet zwei andere Speicherfreigabe API-Methoden: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> und <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Aufrufen der <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>-Methode veranschaulicht. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Runtime.InteropServices.Marshal> Klasse.  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie der Inhalt eines verwalteten konvertiert <xref:System.String> -Klasse auf nicht verwalteten Speicher und dem nicht verwalteten Speicher, wenn Fertig klicken Sie dann löschen.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GenerateGuidForType">
      <MemberSignature Language="C#" Value="public static Guid GenerateGuidForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GenerateGuidForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GenerateGuidForType(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, für den eine GUID generiert werden soll.</param>
        <summary>Gibt die GUID (Globally Unique Identifier, globaler eindeutiger Bezeichner) für den angegebenen Typ zurück oder generiert eine GUID mithilfe des vom Type Library Exporter-Tool (TlbExp.exe) verwendeten Algorithmus.</summary>
        <returns>Ein Bezeichner für den angegebenen Typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ eine GUID in den Metadaten verfügt, wird es zurückgegeben. Andernfalls wird eine GUID automatisch generiert. Sie können diese Methode verwenden, können Sie um die COM-GUID für jeden verwalteten Typ, einschließlich COM nicht sichtbare Typen programmgesteuert zu ermitteln. Klassenschnittstellen sind die einzige Ausnahme aus, da sie nicht mit einem verwalteten Typ übereinstimmen. <xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A> bietet die gleiche Funktionalität wie die <xref:System.Type.GUID%2A?displayProperty=nameWithType> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.Type.GUID" />
      </Docs>
    </Member>
    <Member MemberName="GenerateProgIdForType">
      <MemberSignature Language="C#" Value="public static string GenerateProgIdForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GenerateProgIdForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GenerateProgIdForType(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, für den eine ProgID abgerufen werden soll.</param>
        <summary>Gibt eine ProgID (Programmbezeichner) für den angegebenen Typ zurück.</summary>
        <returns>Die ProgID für den angegebenen Typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ eine ProgID in den Metadaten, die ProgID zurückgegeben wird aufweist. Andernfalls wird eine ProgID generiert basierend auf den vollqualifizierten Namen des Typs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="type" />-Parameter ist keine Klasse, die von COM erstellt werden kann. Die Klasse muss öffentlich sein, einen öffentlichen Standardkonstruktor aufweisen und für COM sichtbar sein.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="type" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetActiveObject">
      <MemberSignature Language="C#" Value="public static object GetActiveObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetActiveObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActiveObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetActiveObject(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Der programmgesteuerte Bezeichner (ProgID) des Objekts, das angefordert wurde.</param>
        <summary>Ruft eine ausgeführte Instanz des angegebenen Objekts aus der ROT (Running Object Table) ab.</summary>
        <returns>Das Objekt, das angefordert wurde, andernfalls <see langword="null" />. Sie können dieses Objekt in eine beliebige unterstützte COM-Schnittstelle umwandeln.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> macht COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) Funktion aus OLEAUT32. DLL; der zweite Wert erwartet jedoch einen Klassenbezeichner (CLSID) anstelle der programmgesteuerte Bezeichner (`ProgID`) von dieser Methode erwartet. Zum Abrufen einer ausgeführten Instanz eines COM-Objekts ohne einen registrierten `ProgID`, verwenden eines Plattformaufrufs zum Definieren des erweiterten COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) Funktion. Eine Beschreibung der Plattform aufrufen, finden Sie unter [nicht verwaltete DLL-Funktionen nutzen](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
## <a name="progid-and-clsid"></a>ProgID und CLSID  
 Schlüssel in der Teilstruktur HKEY_CLASSES_ROOT der Registrierung enthalten eine Vielzahl von Unterschlüsseln. Die meisten der Unterschlüssel werden versionsabhängige Programm-IDs, die eine benutzerfreundliche Zeichenfolge CLSID zuordnen. Anwendungen verwenden häufig diese lesbare Zeichenfolgen, statt die numerischen CLSIDs. Eine Komponente verfügt häufig über eine versionsunabhängige ProgID, die auf die neueste Version der Komponente zugeordnet ist, die auf dem System installiert ist.  
  
 Anwendungen und Komponenten verwenden in erster Linie ProgIDs, um ihre entsprechenden CLSIDs abzurufen.  
  
   
  
## Examples  
 Im folgende Beispiel wurde auf einem Computer ausgeführt, die mit einer ausgeführten Instanz von Microsoft Word konfiguriert wurde. Es wurden keine Instanzen von Microsoft Excel ausgeführt.  
  
 Das Beispiel ruft <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> zweimal. Der erste Aufruf versucht, einen Verweis auf eine Instanz von Microsoft Word abzurufen (eine Instanz von der `Word.Application` Objekt). Der zweite Aufruf versucht, einen Verweis auf eine Instanz von Microsoft Excel abrufen (eine Instanz von einem `Excel.Application` Objekt).  
  
 Der Code Ruft einen Verweis auf eine Instanz von Microsoft Word erfolgreich ab. Da jedoch Microsoft Excel nicht ausgeführt wird, der Versuch, das zweite Objekt abzurufen löst eine <xref:System.Runtime.InteropServices.COMException>.  
  
 [!code-csharp[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/cs/marshal.getactiveobject.cs#1)]
 [!code-vb[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/vb/marshal.getactiveobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">Das Objekt wurde nicht gefunden.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetComInterfaceForObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Schnittstellenzeiger zurück, der eine Schnittstelle für ein Objekt darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject (o As Object, T As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObject(System::Object ^ o, Type ^ T);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, das die Schnittstelle bereitstellt.</param>
        <param name="T">Der Typ der angeforderten Schnittstelle.</param>
        <summary>Gibt einen Zeiger auf eine [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)-Schnittstelle zurück, die die angegebene Schnittstelle für das angegebene Objekt darstellt. Der benutzerdefinierte Zugriff auf Abfrageschnittstellen ist standardmäßig aktiviert.</summary>
        <returns>Der Schnittstellenzeiger, der die angegebene Schnittstelle für das Objekt darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt einen Schnittstellenzeiger, der die angeforderte Schnittstelle für das angegebene Objekt darstellt. Dies ist besonders nützlich, wenn Sie eine nicht verwaltete Methode verfügen, die davon ausgeht, einen Schnittstellenzeiger übergeben werden. Aufruf eines Objekts mit dieser Methode bewirkt, dass den Verweiszähler für den Schnittstellenzeiger inkrementiert werden soll, bevor der Zeiger zurückgegeben wird. Verwenden Sie immer <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> um den Verweiszähler zu verringern, sobald Sie den Mauszeiger abgeschlossen haben. Sie müssen den Regeln, die durch COM definiert, bei Verwendung der unformatierte COM-Schnittstellenzeigern entsprechen.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> ist nützlich, wenn einen COM-Objekt-Parameter als Aufrufen einer Methode, die verfügbar gemacht werden. ein <xref:System.IntPtr> Typ oder benutzerdefiniertes Marshalling geht. Obwohl weniger gebräuchlich, können Sie diese Methode für ein verwaltetes Objekt verwenden, um einen Zeiger auf das Objekt COM callable Wrapper. Beispielsweise können Sie <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> für ein verwaltetes Objekt, das für COM, erhalten einen Schnittstellenzeiger für exportiert wird <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>. Einen Zeiger auf eine Klassenschnittstelle kann nicht abgerufen werden, da eine Klassenschnittstelle verfügt nicht über die entsprechenden Typ für die Übergabe an den zweiten Parameter (`t`). Verwenden Sie stattdessen <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> aufzurufenden die Elemente auf die Standardschnittstelle des COM callable Wrapper, die in der Regel eine Klassenschnittstelle Auto-Verteilung ist.  
  
 Die <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> methodenüberladung ermöglicht das Anpassen der Benutzeroberfläche Abfrage standardmäßig. Verwenden, um anzugeben, ob beim Anwenden der Anpassung der Abfrage-Schnittstelle der <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> -methodenüberladung.  
  
 Weitere Informationen finden Sie unter der [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md), [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), und [Einführung in die Klassenschnittstelle](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) Themen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <typeparamref name="T" />-Parameter ist keine Schnittstelle.  
  
 - oder -   
  
 Der Typ ist für COM nicht sichtbar.  
  
 - oder -   
  
 Der <typeparamref name="T" />-Parameter ist eine generische Typdefinition.</exception>
        <exception cref="T:System.InvalidCastException">Der <paramref name="o" />-Parameter unterstützt die angeforderte Schnittstelle nicht.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="o" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <typeparamref name="T" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMIConnectionPointContainer" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T, System.Runtime.InteropServices.CustomQueryInterfaceMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T, valuetype System.Runtime.InteropServices.CustomQueryInterfaceMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject (o As Object, T As Type, mode As CustomQueryInterfaceMode) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObject(System::Object ^ o, Type ^ T, System::Runtime::InteropServices::CustomQueryInterfaceMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
        <Parameter Name="mode" Type="System.Runtime.InteropServices.CustomQueryInterfaceMode" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, das die Schnittstelle bereitstellt.</param>
        <param name="T">Der Typ der angeforderten Schnittstelle.</param>
        <param name="mode">Einer der Enumerationswerte, die angeben, ob eine <see langword="IUnknown::QueryInterface" />-Anpassung übernommen werden soll, die von einer <see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" /> angegeben wird.</param>
        <summary>Gibt einen Zeiger auf eine [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)-Schnittstelle zurück, die die angegebene Schnittstelle für das angegebene Objekt darstellt. Der benutzerdefinierte Zugriff auf die Abfrageschnittstelle wird vom angegebenen Anpassungsmodus gesteuert.</summary>
        <returns>Der Schnittstellenzeiger, der die Schnittstelle für das Objekt darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> Sie können angeben, ob beim Anwenden der Anpassung der Abfrage-Schnittstelle. Verwenden der <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> Überladung beim Anwenden der Anpassung der Abfrage-Schnittstelle in der Standardeinstellung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <typeparamref name="T" />-Parameter ist keine Schnittstelle.  
  
 - oder -   
  
 Der Typ ist für COM nicht sichtbar.  
  
 - oder -   
  
 Der <typeparamref name="T" />-Parameter ist eine generische Typdefinition.</exception>
        <exception cref="T:System.InvalidCastException">Das Objekt <paramref name="o" /> unterstützt die angeforderte Schnittstelle nicht.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="o" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <typeparamref name="T" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject&lt;T,TInterface&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject&lt;T,TInterface&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject&lt;T, TInterface&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject(Of T, TInterface) (o As T) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TInterface&gt;&#xA; static IntPtr GetComInterfaceForObject(T o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TInterface" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des <c>o</c>.</typeparam>
        <typeparam name="TInterface">Der Typ der zurückzugebenden Schnittstelle.</typeparam>
        <param name="o">Das Objekt, das die Schnittstelle bereitstellt.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Gibt einen Zeiger auf eine [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)-Schnittstelle zurück, die die angegebene Schnittstelle für das Objekt des angegebenen Typs darstellt. Der benutzerdefinierte Zugriff auf Abfrageschnittstellen ist standardmäßig aktiviert.</summary>
        <returns>Der Schnittstellenzeiger, der die <paramref name="TInterface" />-Schnittstelle darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt einen Schnittstellenzeiger, der darstellt die `TInterface` Schnittstelle für das angegebene Objekt. Dies ist besonders nützlich, wenn Sie eine nicht verwaltete Methode verfügen, die davon ausgeht, einen Schnittstellenzeiger übergeben werden. Aufruf eines Objekts mit dieser Methode bewirkt, dass den Verweiszähler für den Schnittstellenzeiger inkrementiert werden soll, bevor der Zeiger zurückgegeben wird. Verwenden Sie immer die <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> Methode, um den Verweiszähler zu verringern, wenn Sie den Zeiger abgeschlossen haben. Sie müssen den Regeln, die durch COM definiert, bei Verwendung der unformatierte COM-Schnittstellenzeigern entsprechen.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> ist nützlich, wenn einen COM-Objekt-Parameter als Aufrufen einer Methode, die verfügbar gemacht werden. ein <xref:System.IntPtr> Typ oder benutzerdefiniertes Marshalling geht. Auch können diese Methode für ein verwaltetes Objekt um einen Zeiger auf das Objekt COM callable Wrapper, obwohl dies ungewöhnlich ist. Beispielsweise können Sie <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> für ein verwaltetes Objekt, das für COM, erhalten einen Schnittstellenzeiger für exportiert wird <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.  
  
 Die <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> methodenüberladung ermöglicht das Anpassen der Benutzeroberfläche Abfrage standardmäßig. Verwenden, um anzugeben, ob beim Anwenden der Anpassung der Abfrage-Schnittstelle der <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> -methodenüberladung.  
  
 Weitere Informationen finden Sie unter der [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md), [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), und [Einführung in die Klassenschnittstelle](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) Themen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="TInterface" />-Parameter ist keine Schnittstelle.  
  
 - oder -   
  
 Der Typ ist für COM nicht sichtbar.  
  
 - oder -   
  
 Der <typeparamref name="T" />-Parameter ist ein offener generischer Typ.</exception>
        <exception cref="T:System.InvalidCastException">Der <paramref name="o" />-Parameter unterstützt die angeforderte <paramref name="TInterface" /> Schnittstelle nicht.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="o" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObjectInContext (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObjectInContext(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObjectInContext (o As Object, t As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObjectInContext(System::Object ^ o, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, das die Schnittstelle bereitstellt.</param>
        <param name="t">Der Typ der angeforderten Schnittstelle.</param>
        <summary>Gibt einen Schnittstellenzeiger zurück, der die angegebene Schnittstelle für ein Objekt zurückgibt, wenn sich der Aufrufer in demselben Kontext wie das betreffende Objekt befindet.</summary>
        <returns>Der von <paramref name="t" /> angegebene Schnittstellenzeiger, der die Schnittstelle für das angegebene Objekt darstellt, oder <see langword="null" />, wenn sich der Aufrufer nicht in demselben Kontext wie das Objekt befindet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist identisch mit <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A> mit dem Unterschied, dass zurückgegeben `null` , wenn der Aufrufer nicht in demselben Kontext wie das Objekt befindet. Dies ist besonders nützlich, wenn Sie eine nicht verwaltete Methode verfügen, die davon ausgeht, einen Schnittstellenzeiger übergeben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" /> ist keine Schnittstelle.  
  
 - oder -   
  
 Der Typ ist für COM nicht sichtbar.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" /> unterstützt die angeforderte Schnittstelle nicht.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="t" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMIConnectionPointContainer" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComObjectData">
      <MemberSignature Language="C#" Value="public static object GetComObjectData (object obj, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetComObjectData(object obj, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComObjectData (obj As Object, key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetComObjectData(System::Object ^ obj, System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das COM-Objekt, das die gewünschten Daten enthält.</param>
        <param name="key">Der Schlüssel in der internen Hashtabelle von <c>obj</c>, aus dem die Daten abgerufen werden sollen.</param>
        <summary>Ruft Daten ab, auf die durch den angegebenen Schlüssel im angegebenen COM-Objekt verwiesen wird.</summary>
        <returns>Die Daten, die in der internen Hashtabelle des <paramref name="key" />-Parameters durch den <paramref name="obj" />-Parameter dargestellt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle COM-Objekte eingebunden in eine [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) zugeordneten Hash-Tabelle, die <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A> abgerufen. <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType> die Hashtabelle hinzugefügt Daten. Sie müssen sich nie in einer dieser Methoden vom Code aufrufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> ist kein COM-Objekt.  
  
 - oder -   
  
 <paramref name="obj" /> ist ein [!INCLUDE[wrt](~/includes/wrt-md.md)]-Objekt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComSlotForMethodInfo">
      <MemberSignature Language="C#" Value="public static int GetComSlotForMethodInfo (System.Reflection.MemberInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetComSlotForMethodInfo(class System.Reflection.MemberInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComSlotForMethodInfo (m As MemberInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetComSlotForMethodInfo(System::Reflection::MemberInfo ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="m">Ein Objekt, das eine Schnittstellenmethode darstellt.</param>
        <summary>Ruft den VTBL-Slot (virtuelle Funktionstabelle, Vtable) für einen angegebenen <see cref="T:System.Reflection.MemberInfo" />-Typ ab, wenn dieser Typ für COM verfügbar gemacht wird.</summary>
        <returns>Der <paramref name="m" />-Bezeichner für den VTBL-Slot, wenn er für COM verfügbar gemacht wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die nullbasierte Slotnummer für drei von dieser Methode zurückgegebene [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) und möglicherweise vier [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) Methoden, die den Wert des ersten verfügbaren Einschubfach entweder 3 oder 7. <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> Stellt die Umkehrfunktion von <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>.  
  
 Sie können diese Methode verwenden, abzurufenden Steckplatznummern für Mitglieder von Schnittstellen, die nicht von COM sichtbar sind und für Mitglieder der privaten Schnittstellen. Slot zurückgegebenen Zahlen entsprechen den vtable-Zahlen, die reserviert werden würde, wenn der Typ für COM verfügbar gemacht wurde Für COM nicht sichtbare Elemente belegen tatsächlich einen Steckplatz in einer verfügbar gemachten vtable, obwohl der COM-Client den Slot verwenden kann. Sie können keine <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> auf eine Klassenschnittstelle durch Übergabe <xref:System.Reflection.MemberInfo> aus einer Klasse. Weitere Informationen finden Sie unter [Einführung in die Klassenschnittstelle](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="m" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="m" />-Parameter ist kein <see cref="T:System.Reflection.MemberInfo" />-Objekt.  
  
 - oder -   
  
 Der <paramref name="m" />-Parameter ist keine Schnittstellenmethode.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer">
      <MemberSignature Language="C#" Value="public static Delegate GetDelegateForFunctionPointer (IntPtr ptr, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate GetDelegateForFunctionPointer(native int ptr, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateForFunctionPointer (ptr As IntPtr, t As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ GetDelegateForFunctionPointer(IntPtr ptr, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">Der nicht verwaltete Funktionszeiger, der konvertiert werden soll.</param>
        <param name="t">Der Typ des zurückzugebenden Delegaten.</param>
        <summary>Konvertiert einen nicht verwalteten Funktionszeiger in einen Delegaten.</summary>
        <returns>Eine Delegatinstanz, die in den entsprechenden Delegattyp umgewandelt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Version 1.0 und 1.1 von .NET Framework war es möglich, einen Delegaten, die eine verwaltete Methode darstellt, zu nicht verwaltetem Code als Funktionszeiger, den nicht verwalteten Code aufrufen, die verwaltete Methode über den Funktionszeiger ermöglichen zu übergeben. War es auch möglich, für den nicht verwalteten Code mit diesem Funktionszeiger zurück an den verwalteten Code übergeben, und der Zeiger an die zugrunde liegende verwaltete Methode ordnungsgemäß aufgelöst wurde.  
  
 In der .NET Framework 2.0 und höher, können Sie die <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> und <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> Methoden zum Marshallen von Delegaten in beide Richtungen. Mit <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A>, `ptr` importiert eine <xref:System.IntPtr?displayProperty=nameWithType>. Ein <xref:System.IntPtr?displayProperty=nameWithType> für einen verwalteten Delegaten abgerufen werden kann, durch den Aufruf <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> und als ein Parameter übergeben, es kann dann von aufgerufen werden, in die nicht verwaltete Methode. Beachten Sie, dass der Parametermarshaller auch Funktionszeiger auf Delegaten in der .NET Framework 2.0 und höheren Versionen marshallen kann.  
  
 Die <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> Methode hat die folgenden Einschränkungen:  
  
-   Generika werden nicht in Interop-Szenarien unterstützt.  
  
-   Einen ungültiger Funktionszeiger kann nicht an diese Methode übergeben werden.  
  
-   Sie können diese Methode nur für reine nicht verwaltete Funktionszeiger verwenden.  
  
-   Mithilfe dieser Methode kann nicht mit Funktionszeigern, die über C++ bzw. von der <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> Methode.  
  
-   Diese Methode können Sie um einen Delegaten über einen Funktionszeiger auf einem anderen verwalteten Delegaten zu erstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="t" />-Parameter ist weder ein Delegat, noch ist er generisch.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="ptr" />-Parameter ist <see langword="null" />.  
  
 - oder -   
  
 Der <paramref name="t" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateForFunctionPointer(Of TDelegate) (ptr As IntPtr) As TDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Der Typ des zurückzugebenden Delegaten.</typeparam>
        <param name="ptr">Der nicht verwaltete Funktionszeiger, der konvertiert werden soll.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Konvertiert einen nicht verwalteten Funktionszeiger in einen Delegaten eines angegebenen Typs.</summary>
        <returns>Eine Instanz vom angegebenen Delegaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> und <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29> Methoden zum Marshallen von Delegaten in beide Richtungen.  
  
 Die <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> Methode hat die folgenden Einschränkungen:  
  
-   Einen ungültiger Funktionszeiger kann nicht an diese Methode übergeben werden.  
  
-   Sie können diese Methode nur für reine nicht verwaltete Funktionszeiger verwenden.  
  
-   Mithilfe dieser Methode kann nicht mit Funktionszeigern, die über C++ bzw. von der <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> Methode.  
  
-   Diese Methode können Sie um einen Delegaten über einen Funktionszeiger auf einem anderen verwalteten Delegaten zu erstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="TDelegate" /> generische Parameter ist kein Delegat, oder es ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="ptr" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetEndComSlot">
      <MemberSignature Language="C#" Value="public static int GetEndComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetEndComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEndComSlot (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetEndComSlot(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">Ein Typ, der eine Schnittstelle oder eine Klasse darstellt.</param>
        <summary>Ruft den letzten Slot in der virtuellen Funktionstabelle (Vtable oder VTBL) eines Typs ab, wenn dieser für COM verfügbar gemacht wird.</summary>
        <returns>Der letzte VTBL-Slot der Schnittstelle, wenn dies für COM verfügbar gemacht wird. Wenn der <paramref name="t" />-Parameter eine Klasse ist, handelt es sich bei dem zurückgegebenen VTBL-Slot um den letzten Slot der Schnittstelle, die aus der Klasse generiert wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt die nullbasierte, vtable-Nummer für eine Schnittstelle oder eine Klasse zurück. Wenn für eine Klasse verwendet wird, bezieht sich die Nummer des Steckplatzes zurückgegeben, auf die Klassenschnittstelle für die Klasse. Wenn die Klassenschnittstelle automatisch generiert und Dual ist, gibt diese Methode immer-1 zurück, um anzugeben, dass die Dispatch beschränkte Schnittstelle eine vtable an verwaltete Clients nicht zur Verfügung stellt. Sie können <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A> und <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> in Verbindung mit <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> Slots in einem angegebenen Bereich zu übergeben. Weitere Informationen finden Sie unter [Einführung in die Klassenschnittstelle](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionCode">
      <MemberSignature Language="C#" Value="public static int GetExceptionCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetExceptionCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetExceptionCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Code ab, der den Typ der aufgetretenen Ausnahme bezeichnet.</summary>
        <returns>Der Typ der Ausnahme.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A> wird für compilerunterstützung für die strukturierte Ausnahmebehandlung (SEH) nur verfügbar gemacht. Wenn diese Methode aufgerufen wird, bevor eine Ausnahme ausgelöst wird, wird 0 x 0 zurückgegeben.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetExceptionForHR">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert einen HRESULT-Fehlercode in ein entsprechendes <see cref="T:System.Exception" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionForHR (errorCode As Integer) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Exception ^ GetExceptionForHR(int errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode">Das zu konvertierende HRESULT.</param>
        <summary>Konvertiert den angegebenen HRESULT-Fehlercode in ein entsprechendes <see cref="T:System.Exception" />-Objekt.</summary>
        <returns>Ein Objekt, das das konvertierte HRESULT darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> Methode zum Abrufen einer <xref:System.Exception> basierend auf einem HRESULT ohne Aufruf der <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> -Methode und die Ausnahme abfangen.  
  
 Die aktuelle [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) Schnittstelle wird verwendet, um die Ausnahme zu erstellen.  
  
 Die Zuordnung von jedem HRESULT zu seiner vergleichbaren Ausnahmeklasse in .NET Framework, finden Sie unter [Vorgehensweise: Zuordnen von HRESULTs und Ausnahmen](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionForHR (errorCode As Integer, errorInfo As IntPtr) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Exception ^ GetExceptionForHR(int errorCode, IntPtr errorInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode">Das zu konvertierende HRESULT.</param>
        <param name="errorInfo">Ein Zeiger auf die <see langword="IErrorInfo" />-Schnittstelle, die weitere Informationen über den Fehler bereitstellt. Sie können <c>IntPtr(0)</c> angeben, um die aktuelle <see langword="IErrorInfo" />-Schnittstelle zu verwenden, oder <c>IntPtr(-1)</c>, um die aktuelle <see langword="IErrorInfo" />-Schnittstelle zu ignorieren und die Ausnahme direkt aus dem Fehlercode zu erstellen.</param>
        <summary>Konvertiert den angegebenen HRESULT-Fehlercode in ein entsprechendes <see cref="T:System.Exception" />-Objekt, wobei zusätzliche Fehlerinformationen für das Ausnahmeobjekt in eine [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447)-Schnittstelle übergeben werden.</summary>
        <returns>Ein Objekt, das das konvertierte HRESULT und die aus <paramref name="errorInfo" /> abgerufenen Informationen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> Methode zum Abrufen einer <xref:System.Exception> basierend auf einem HRESULT ohne Aufruf der <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> -Methode und Abfangen der Ausnahme (somit vermieden werden die entsprechenden Systemleistung). Die `errorInfo` Parameter liefert zusätzliche Informationen über den Fehler, z. B. die textbeschreibung und der global eindeutige Bezeichner (GUID) für die Schnittstelle, die den Fehler definiert.  
  
 Verwenden Sie diese methodenüberladung, wenn Sie benutzerdefinierten Fehlerinformationen verfügen, die Sie bei der Konvertierung angeben.  
  
 Die Zuordnung von jedem HRESULT zu seiner vergleichbaren Ausnahmeklasse in .NET Framework, finden Sie unter [Vorgehensweise: Zuordnen von HRESULTs und Ausnahmen](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionPointers">
      <MemberSignature Language="C#" Value="public static IntPtr GetExceptionPointers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetExceptionPointers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionPointers () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetExceptionPointers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine computerunabhängige Beschreibung einer Ausnahme und Informationen zu dem Zustand ab, der beim Auftreten der Ausnahme für den Thread vorlag.</summary>
        <returns>Ein Zeiger auf eine [EXCEPTION_POINTERS](http://go.microsoft.com/fwlink/?LinkId=148648)-Struktur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A> wird für compilerunterstützung für die strukturierte Ausnahmebehandlung (SEH) nur verfügbar gemacht.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFunctionPointerForDelegate (d As Delegate) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetFunctionPointerForDelegate(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">Der Delegat, der an nicht verwalteten Code übergeben werden soll.</param>
        <summary>Konvertiert einen Delegaten in einen Funktionszeiger, der aus nicht verwaltetem Code aufgerufen werden kann.</summary>
        <returns>Ein Wert, der an nicht verwalteten Code übergeben werden kann, der mit diesem Wert wiederum den zugrunde liegenden verwalteten Delegaten aufrufen kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `d` wird konvertiert in einen Funktionszeiger, der an nicht verwalteten Code übergeben werden kann die [__stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) Aufrufkonvention.  
  
 Sie müssen manuell verhindert, dass der Delegat vom Garbage Collector erfasst wird, die aus verwaltetem Code. Der Garbage Collector verfolgt keine Verweise auf nicht verwalteten Code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="d" />-Parameter ist eine generische Typdefinition.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="d" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate&lt;TDelegate&gt; (TDelegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate&lt;TDelegate&gt;(!!TDelegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFunctionPointerForDelegate(Of TDelegate) (d As TDelegate) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static IntPtr GetFunctionPointerForDelegate(TDelegate d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="d" Type="TDelegate" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Der Typ des zu konvertierenden Delegaten.</typeparam>
        <param name="d">Der Delegat, der an nicht verwalteten Code übergeben werden soll.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Konvertiert einen Delegaten eines angegebenen Typs in einen Funktionszeiger, der aus nicht verwaltetem Code aufgerufen werden kann.</summary>
        <returns>Ein Wert, der an nicht verwalteten Code übergeben werden kann, der mit diesem Wert wiederum den zugrunde liegenden verwalteten Delegaten aufrufen kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Delegat `d` wird konvertiert in einen Funktionszeiger, der an nicht verwalteten Code durch übergeben werden kann, mithilfe der [__stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) Aufrufkonvention.  
  
 Sie müssen manuell verhindert, dass der Delegat vom Garbage Collector erfasst wird, die aus verwaltetem Code. Der Garbage Collector verfolgt keine Verweise auf nicht verwalteten Code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="d" />-Parameter ist eine generische Typdefinition.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="d" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHINSTANCE">
      <MemberSignature Language="C#" Value="public static IntPtr GetHINSTANCE (System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHINSTANCE(class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHINSTANCE (m As Module) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetHINSTANCE(System::Reflection::Module ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="m">Das Modul mit dem gewünschten HINSTANCE.</param>
        <summary>Gibt das Instanzhandle (HINSTANCE) für das angegebene Modul zurück.</summary>
        <returns>Das HINSTANCE für <paramref name="m" /> oder -1, wenn das Modul über kein HINSTANCE verfügt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dynamische oder in-Memory-Module über kein HINSTANCE.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="m" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHRForException">
      <MemberSignature Language="C#" Value="public static int GetHRForException (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForException(class System.Exception e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHRForException (e As Exception) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHRForException(Exception ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="e">Die in ein HRESULT zu konvertierende Ausnahme.</param>
        <summary>Konvertiert die angegebene Ausnahme in ein HRESULT.</summary>
        <returns>Das HRESULT, das der bereitgestellten Ausnahme zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> Außerdem richtet eine [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) Schnittstelle für die Ausnahme, die durch Aufrufen der Funktion COM GetErrorInfoNEEDGUID abgerufen werden kann. Sie können diese Funktion verwenden, um einen HRESULT-Wert für die Implementierung einer verwalteten Klasse einer COM-Schnittstelle zurück, in dem Sie anwenden, der <xref:System.Runtime.InteropServices.PreserveSigAttribute> Attribut. Die attributierte Methode alle Ausnahmen abfangen und die <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> Methode, um den entsprechenden HRESULT-Wert zurückzugeben. Ermöglicht die Weitergabe außerhalb der Methode eine Ausnahme erzeugt Falsches Verhalten. (In der Tat kann die common Language Runtime eine Ausnahme an einem COM-Client übergeben, der eine solche Methode über eine vtable aufruft.)  
  
 Beachten Sie, dass die <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> Methode legt die [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) Schnittstelle des aktuellen Threads. Dies kann zu unerwarteten Ergebnissen führen, für die Methoden wie die <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> Methoden, die standardmäßig auf die Verwendung der [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) des aktuellen Threads ist die Eigenschaft festgelegt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetHRForLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetHRForLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHRForLastWin32Error () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHRForLastWin32Error();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das HRESULT für den letzten Fehler zurück, der durch einen mit <see cref="T:System.Runtime.InteropServices.Marshal" /> ausgeführten Win32-Code ausgelöst wurde.</summary>
        <returns>Das HRESULT für den letzten Win32-Fehlercode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zielfunktion muss hatten die `setLastError` Metadatenflag festgelegt. Z. B. die `SetLastError` Feld der <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> muss `true`. Der Vorgang zum Festlegen dieses Flags hängt von der Source-Sprache verwendet: c# und C++ sind `false` standardmäßig, aber die `Declare` in Visual Basic-Anweisung ist `true`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Win32-Fehler Code mit entsprechenden HRESULT Abrufen der <xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A> Methode.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIDispatchForObject (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIDispatchForObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, dessen <see langword="IDispatch" />-Schnittstelle angefordert wird.</param>
        <summary>Gibt eine [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)-Schnittstelle aus einem verwalteten Objekt zurück.</summary>
        <returns>Der <see langword="IDispatch" />-Zeiger für den <paramref name="o" />-Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In verwaltetem Code nur selten arbeiten Sie direkt mit der `IDispatch` Schnittstelle. Allerdings <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> ist nützlich, wenn einen COM-Objekt-Parameter als Aufrufen einer Methode, die verfügbar gemacht werden. ein <xref:System.IntPtr> Typ oder benutzerdefiniertes Marshalling geht. Aufruf eines Objekts mit dieser Methode bewirkt, dass den Verweiszähler für den Schnittstellenzeiger inkrementiert werden soll, bevor der Zeiger zurückgegeben wird. Verwenden Sie immer <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> um den Verweiszähler zu verringern, sobald Sie den Mauszeiger abgeschlossen haben.  
  
 Sie können diese Methode auch für ein verwaltetes Objekt verwenden, einen Schnittstellenzeiger auf den COM callable Wrapper für das Objekt abgerufen. Weitere Informationen finden Sie unter [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" /> unterstützt die angeforderte Schnittstelle nicht.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIDispatchForObjectInContext (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIDispatchForObjectInContext(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, dessen <see langword="IDispatch" />-Schnittstelle angefordert wird.</param>
        <summary>Gibt einen [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)-Schnittstellenzeiger aus einem verwalteten Objekt zurück, falls sich der Aufrufer in demselben Kontext wie das Objekt befindet.</summary>
        <returns>Der <see langword="IDispatch" />-Schnittstellenzeiger für das angegebene Objekt oder <see langword="null" />, falls sich der Aufrufer nicht in demselben Kontext wie das angegebene Objekt befindet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist identisch mit <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> mit dem Unterschied, dass zurückgegeben `null` , wenn der Aufrufer nicht in demselben Kontext wie das Objekt befindet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" /> unterstützt die angeforderte Schnittstelle nicht.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetITypeInfoForType">
      <MemberSignature Language="C#" Value="public static IntPtr GetITypeInfoForType (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetITypeInfoForType(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetITypeInfoForType (t As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetITypeInfoForType(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">Der Typ, dessen <see langword="ITypeInfo" />-Schnittstelle angefordert wird.</param>
        <summary>Gibt eine <see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" />-Schnittstelle aus einem verwalteten Typ zurück.</summary>
        <returns>Ein Zeiger auf die <see langword="ITypeInfo" />-Schnittstelle für den <paramref name="t" />-Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt einen Zeiger auf eine `ITypeInfo` Implementierung, die auf den ursprünglichen Typ basiert. Aufrufen eines Objekts mit <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> bewirkt, dass den Verweiszähler für den Schnittstellenzeiger inkrementiert werden soll, bevor der Zeiger zurückgegeben wird. Verwenden Sie immer <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> um den Verweiszähler zu verringern, sobald Sie den Mauszeiger abgeschlossen haben. Sie können Anwenden der <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> standard Interop-Marshalling-Verhalten mit diesem benutzerdefinierten Marshaller ersetzen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einen Zeiger zum Abrufen der `ITypeInfo` Schnittstelle für einen Typ mit dem <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> Methode.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" /> ist kein für COM sichtbarer Typ.  
  
 - oder -   
  
 <paramref name="t" /> ist ein [!INCLUDE[wrt](~/includes/wrt-md.md)]-Typ.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Für die Assembly ist eine Typbibliothek registriert, die den Typ enthält, aber die Typdefinition wurde nicht gefunden.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.MarshalAsAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIUnknownForObject (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIUnknownForObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, dessen <see langword="IUnknown" />-Schnittstelle angefordert wird.</param>
        <summary>Gibt eine [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)-Schnittstelle von einem verwalteten Objekt zurück.</summary>
        <returns>Der <see langword="IUnknown" />-Zeiger für den <paramref name="o" />-Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In verwaltetem Code nur selten arbeiten Sie direkt mit der `IUnknown` Schnittstelle. Allerdings <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> ist nützlich, wenn einen COM-Objekt-Parameter als Aufrufen einer Methode, die verfügbar gemacht werden. ein <xref:System.IntPtr> Typ oder benutzerdefiniertes Marshalling geht. Aufruf eines Objekts mit dieser Methode bewirkt, dass den Verweiszähler für den Schnittstellenzeiger inkrementiert werden soll, bevor der Zeiger zurückgegeben wird. Verwenden Sie immer <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> um den Verweiszähler zu verringern, sobald Sie den Mauszeiger abgeschlossen haben. Diese Methode stellt die Umkehrfunktion von der <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType> Methode.  
  
 Sie können auch diese Methode für ein verwaltetes Objekt erhalten einen Schnittstellenzeiger auf die [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) für das Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Abrufen einer [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) Schnittstelle für ein verwaltetes Objekt mit der <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> Methode.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIUnknownForObjectInContext (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIUnknownForObjectInContext(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, dessen <see langword="IUnknown" />-Schnittstelle angefordert wird.</param>
        <summary>Gibt eine [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)-Schnittstelle aus einem verwalteten Objekt zurück, wenn sich der Aufrufer im gleichen Kontext wie dieses Objekt befindet.</summary>
        <returns>Der <see langword="IUnknown" />-Zeiger für das angegebene Objekt oder <see langword="null" />, falls sich der Aufrufer nicht in demselben Kontext wie das angegebene Objekt befindet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist identisch mit <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> mit dem Unterschied, dass zurückgegeben `null` , wenn der Aufrufer nicht in demselben Kontext wie das Objekt befindet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Abrufen einer `IUnknown` Schnittstelle für ein verwaltetes Objekt mit der <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A> Methode.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWin32Error () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetLastWin32Error();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Fehlercode zurück, der durch die letzte nicht verwaltete Funktion zurückgegeben wurde, die mit einem Plattformaufruf aufgerufen wurde und bei der das <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />-Flag festgelegt wurde.</summary>
        <returns>Der letzte durch einen Aufruf der Win32-[SetLastError](http://go.microsoft.com/fwlink/?LinkId=148656)-Funktion festgelegte Fehlercode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> macht die Win32 [GetLastError](http://go.microsoft.com/fwlink/?LinkId=148657) -Funktion von Kernel32.dll verwenden. Diese Methode vorhanden ist, da sie nicht sicher ist, stellen eine direkte Plattformaufruf ist `GetLastError` auf diese Informationen zu erhalten. Wenn Sie mit diesem Fehlercode zugreifen möchten, müssen Sie aufrufen <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> anstelle des Schreibens von eigene Definition des Plattformaufrufs für `GetLastError` und Aufrufen dieser Komponente. Die common Language Runtime kann interne Aufrufe von APIs, die überschreiben stellen die `GetLastError` vom Betriebssystem verwaltet.  
  
 Verwenden Sie diese Methode, um Fehlercodes zu erhalten, nur, wenn Sie anwenden der <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> auf die Methodensignatur und die <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> Feld`true`. Dieser Prozess variiert in Abhängigkeit von der Quellsprache verwendet: c# und C++ sind `false` standardmäßig, aber die `Declare` in Visual Basic-Anweisung ist `true`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Aufrufen der <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>-Methode veranschaulicht. Im Beispiel veranschaulicht zunächst beim Aufrufen der Methode kein Fehler aufgetreten ist und klicken Sie dann beim Aufrufen der Methode ein Fehler aufgetreten ist.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetManagedThunkForUnmanagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetManagedThunkForUnmanagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetManagedThunkForUnmanagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetManagedThunkForUnmanagedMethodPtr (pfnMethodToWrap As IntPtr, pbSignature As IntPtr, cbSignature As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap">Ein Zeiger auf die Methode, die gemarshallt werden soll.</param>
        <param name="pbSignature">Ein Zeiger auf die Methodensignatur.</param>
        <param name="cbSignature">Die Anzahl der Bytes in <c>pbSignature</c>.</param>
        <summary>Ruft einen Zeiger auf eine zur Laufzeit generierte Funktion ab, die einen Aufruf aus verwaltetem zu nicht verwaltetem Code marshallt.</summary>
        <returns>Ein Zeiger auf die Funktion, die einen Aufruf aus dem <paramref name="pfnMethodToWrap" />-Parameter zu nicht verwaltetem Code marshallt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A> für die Unterstützung des Compilers nur wird verfügbar gemacht werden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodInfoForComSlot">
      <MemberSignature Language="C#" Value="public static System.Reflection.MemberInfo GetMethodInfoForComSlot (Type t, int slot, ref System.Runtime.InteropServices.ComMemberType memberType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MemberInfo GetMethodInfoForComSlot(class System.Type t, int32 slot, valuetype System.Runtime.InteropServices.ComMemberType&amp; memberType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodInfoForComSlot (t As Type, slot As Integer, ByRef memberType As ComMemberType) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MemberInfo ^ GetMethodInfoForComSlot(Type ^ t, int slot, System::Runtime::InteropServices::ComMemberType % memberType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="slot" Type="System.Int32" />
        <Parameter Name="memberType" Type="System.Runtime.InteropServices.ComMemberType&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="t">Der Typ, für den die <see cref="T:System.Reflection.MemberInfo" /> abgerufen werden soll.</param>
        <param name="slot">Der VTBL-Slot.</param>
        <param name="memberType">Bei erfolgreicher Rückgabe einer der Enumerationswerte, der den Typ des Members angibt.</param>
        <summary>Ruft ein <see cref="T:System.Reflection.MemberInfo" />-Objekt für den angegebenen Slot in der virtuellen Funktionstabelle (Vtable oder VTBL) ab.</summary>
        <returns>Das Objekt, das den Member an angegebenen VTBL-Slot darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert ist möglicherweise eine <xref:System.Reflection.FieldInfo>, <xref:System.Reflection.MethodInfo>, oder <xref:System.Reflection.PropertyInfo> Objekt. Der zurückgegebene Wert hängt vom Typ des verwalteten Members, der in der angegebenen COM-Slot vorhanden ist (also der verallgemeinerte Rückgabetyp <xref:System.Reflection.MemberInfo> von der alle drei abgeleitet werden).  
  
 Die nullbasierte, die von dieser Methode zurückgegebene Slotnummer für drei [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) und möglicherweise vier [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) Methoden, die den Wert des ersten verfügbaren Einschubfach entweder 3 oder 7. <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> Stellt die Umkehrfunktion von <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType>. Sie können <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> und <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> in Verbindung mit <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> Slots in einem angegebenen Bereich zu übergeben.  
  
 Die `memberType` Parameter ist nur bei der Rückgabe wichtig. Er enthält den Typ des COM-Members (eine normale Methode oder ein Eigenschaftenaccessor), der auf das zurückgegebene entspricht <xref:System.Reflection.MemberInfo> Objekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" /> ist für COM nicht sichtbar.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComMemberType" />
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject (object obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject(object obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetNativeVariantForObject (obj As Object, pDstNativeVariant As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetNativeVariantForObject(System::Object ^ obj, IntPtr pDstNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das ein COM-VARIANT abgerufen werden soll.</param>
        <param name="pDstNativeVariant">Ein Zeiger, der den VARIANT empfangen soll, der dem <c>obj</c>-Parameter entspricht.</param>
        <summary>Konvertiert ein Objekt in einen COM-VARIANT.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `pDstNativeVariant` Parameter muss auf ausreichend Arbeitsspeicher zum Speichern der resultierenden Variante zeigen. Die Implementierung dieser Methode ruft außerdem die [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) Funktion auf den unformatierten Speicher, der `pDstNativeVariant` -Parameter zeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="obj" />-Parameter ist eine Instanz eines generischen Typs.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject&lt;T&gt; (T obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject&lt;T&gt;(!!T obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetNativeVariantForObject(Of T) (obj As T, pDstNativeVariant As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="obj" Type="T" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ, des Objekts, das konvertiert werden soll.</typeparam>
        <param name="obj">Das Objekt, für das ein COM-VARIANT abgerufen werden soll.</param>
        <param name="pDstNativeVariant">Ein Zeiger, der den VARIANT empfangen soll, der dem <c>obj</c>-Parameter entspricht.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Konvertiert ein Objekt eines angegebenen Typs in eine COM VARIANTE.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `pDstNativeVariant` Parameter muss auf ausreichend Arbeitsspeicher zum Speichern der resultierenden Variante zeigen. Die Implementierung dieser Methode ruft außerdem [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) Funktion auf den unformatierten Speicher, der `pDstNativeVariant` -Parameter zeigt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetObjectForIUnknown (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForIUnknown(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForIUnknown (pUnk As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectForIUnknown(IntPtr pUnk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">Ein Zeiger auf die <see langword="IUnknown" />-Schnittstelle.</param>
        <summary>Gibt eine Instanz eines Typs zurück, der ein COM-Objekt mit einem Zeiger auf die [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)-Schnittstelle darstellt.</summary>
        <returns>Ein Objekt, das das angegebene nicht verwaltete COM-Objekt darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode umschließt `IUnknown` in ein verwaltetes Objekt. Dies hat den Effekt der Verweiszähler der COM-Komponente. Der Verweiszähler wird verringert werden, wenn die Common Language Runtime Garbagecollection auf das verwaltete Objekt durchführt, die die COM-Objekt darstellt.  
  
 Die `pUnk` Parameter darstellt ein `IUnknown` Schnittstellenzeiger, aber da alle COM-Schnittstellen direkt oder indirekt aus ableiten `IUnknown`, können Sie COM-Schnittstelle an diese Methode übergeben. Das zurückgegebene Objekt <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A> ist ein [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), die als es die common Language Runtime verwaltet ist eines anderes verwalteten Objekts. Der Typ eines solchen Wrappers ist häufig eine Basis `System.__ComObject` Typ, der ist ein ausgeblendeter Typ verwendet, wenn der Wrappertyp mehrdeutig ist. Sie können weiterhin spät gebundene Aufrufe auf solche einen Basistyp vornehmen, solange das COM-Objekt implementiert die [IDispatch](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5(vs.85)) Schnittstelle. Ebenso können Sie das zurückgegebene Objekt in eine entsprechende COM-Schnittstelle umwandeln.  
  
 Für ein Objekt umschlossen werden mit einer bestimmten verwalteten Klassentyps (und nicht für einen Wrappertyp generische) müssen Sie die folgenden Anforderungen entsprechen:  
  
-   Implementieren der [IProvideClassInfo](http://go.microsoft.com/fwlink/?LinkID=148012) Schnittstelle für COM-Objekts.  
  
-   Registrieren Sie die enthaltende Assembly mit dem [Regasm.exe (Assembly Registration-Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 Alternativ können Sie vermeiden diese Anforderungen und Abrufen trotzdem ein Objekt, das mit einem bestimmten verwalteten Klasse, mithilfe umschlossen wird der <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant">
      <MemberSignature Language="C#" Value="public static object GetObjectForNativeVariant (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForNativeVariant(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForNativeVariant (pSrcNativeVariant As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectForNativeVariant(IntPtr pSrcNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pSrcNativeVariant">Ein Zeiger auf ein COM-VARIANT.</param>
        <summary>Konvertiert einen COM-VARIANT in ein Objekt.</summary>
        <returns>Ein Objekt, das dem <paramref name="pSrcNativeVariant" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> Gibt ein verwaltetes Objekt, das entspricht, einen unformatierten Zeiger in einen nicht verwalteten Variantentyp zurück. Die Interopmarshaler führt identische Transformation aus, wenn Sie einen VARIANT-Datentyp an verwalteten Code verfügbar machen.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> Stellt die Umkehrfunktion von <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType>.  
  
 Wenn der VARIANT-Typ VT_ERROR ist <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> gibt ein Objekt vom Typ `Int32` anstelle von `UInt32`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException">
          <paramref name="pSrcNativeVariant" /> ist kein gültiger VARIANT-Typ.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pSrcNativeVariant" /> weist einen nicht unterstützten Typ auf.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetObjectForNativeVariant&lt;T&gt; (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetObjectForNativeVariant&lt;T&gt;(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForNativeVariant(Of T) (pSrcNativeVariant As IntPtr) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ, in den die COM VARIANTE konvertiert werden soll.</typeparam>
        <param name="pSrcNativeVariant">Ein Zeiger auf ein COM-VARIANT.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Konvertiert ein COM VARIANTE in ein Objekt eines angegebenen Typs .</summary>
        <returns>Ein Objekt des angegebenen Typs, der dem <paramref name="pSrcNativeVariant" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> Gibt ein verwaltetes Objekt des Typs `T` , einen unformatierten Zeiger in einen nicht verwalteten Variantentyp entspricht. Die Interopmarshaler führt identische Transformation aus, wenn Sie einen VARIANT-Datentyp an verwalteten Code verfügbar machen.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> Stellt die Umkehrfunktion von <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException">
          <paramref name="pSrcNativeVariant" /> ist kein gültiger VARIANT-Typ.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pSrcNativeVariant" /> weist einen nicht unterstützten Typ auf.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants">
      <MemberSignature Language="C#" Value="public static object[] GetObjectsForNativeVariants (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object[] GetObjectsForNativeVariants(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectsForNativeVariants (aSrcNativeVariant As IntPtr, cVars As Integer) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Object ^&gt; ^ GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="aSrcNativeVariant">Ein Zeiger auf das erste Element eines Arrays von COM-VARIANTs.</param>
        <param name="cVars">Die Zählung der COM-VARIANTs in <c>aSrcNativeVariant</c>.</param>
        <summary>Konvertiert ein Array mit COM-[VARIANTs](http://go.microsoft.com/fwlink/?LinkId=148670) in ein Array von Objekten.</summary>
        <returns>Ein Objektarray, das diesem <paramref name="aSrcNativeVariant" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A> Gibt ein Array von verwalteten Objekten, die entspricht in einen unformatierten Zeiger auf ein Array im C-Format von nicht verwalteten VARIANT-Datentypen zurück. Die Interopmarshaler führt identische Transformation aus, wenn Sie einen VARIANT-Datentyp an verwalteten Code verfügbar machen. Die Methode gibt ein leeres array, wenn die `cVars` Parameter gleich 0 ist.  
  
 Das Objektarray (Rückgabewert) Ruft die Garbage collection wie gewohnt ab. Die nicht verwaltete Eingabearray oder einzelne VARIANTs im Eingabearray werden nicht freigegeben. Es ist daher sicherstellen, dass Sie diese nach Bedarf freigibt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="cVars" /> ist eine negative Zahl.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] GetObjectsForNativeVariants&lt;T&gt; (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] GetObjectsForNativeVariants&lt;T&gt;(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectsForNativeVariants(Of T) (aSrcNativeVariant As IntPtr, cVars As Integer) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des zurückzugebenden Arrays.</typeparam>
        <param name="aSrcNativeVariant">Ein Zeiger auf das erste Element eines Arrays von COM-VARIANTs.</param>
        <param name="cVars">Die Zählung der COM-VARIANTs in <c>aSrcNativeVariant</c>.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Konvertiert ein Array mit COM-VARIANT in ein Array eines angegebenen Typs.</summary>
        <returns>Ein Array von <typeparamref name="T" />-Objekten, das <paramref name="aSrcNativeVariant" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29> Gibt ein Array von `T` , einen unformatierten Zeiger in ein Array im C-Format von nicht verwalteten VARIANT-Typen entspricht. Die Interopmarshaler führt identische Transformation aus, wenn Sie einen VARIANT-Datentyp an verwalteten Code verfügbar machen. Die Methode gibt ein leeres array, wenn die `cVars` Parameter gleich 0 ist.  
  
 Das zurückgegebene Array hat Garbage collection wie gewohnt. Die nicht verwaltete Eingabearray oder einzelne VARIANTs im Eingabearray werden nicht freigegeben. Daher ist es Ihrer Verantwortung, diese nach Bedarf freigibt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="cVars" /> ist eine negative Zahl.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStartComSlot">
      <MemberSignature Language="C#" Value="public static int GetStartComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetStartComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStartComSlot (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetStartComSlot(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">Ein Typ, der eine Schnittstelle darstellt.</param>
        <summary>Ruft den ersten Slot in der VTBL (Vtable oder virtuelle Funktionstabelle) ab, der benutzerdefinierte Methoden enthält.</summary>
        <returns>Der erste VTBL-Slot, der benutzerdefinierte Methoden enthält. Der erste Slot lautet 3, wenn die Schnittstelle auf [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) basiert. Er lautet 7, wenn die Schnittstelle auf [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) basiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt die nullbasierte Funktionstabelle für eine Schnittstelle oder eine Klasse zurück. Wenn für eine Klasse verwendet wird, bezieht sich die Nummer des Steckplatzes, die zurückgegeben wird, auf die Klassenschnittstelle für die Klasse. Wenn die Klassenschnittstelle Auto-Verteilung ist, gibt diese Methode immer-1 zurück, um anzugeben, dass die Dispatch beschränkte Schnittstelle eine vtable an verwaltete Clients nicht zur Verfügung stellt. Sie können <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A> und <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> in Verbindung mit <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> Slots in einem angegebenen Bereich zu übergeben. Weitere Informationen finden Sie unter [Einführung in die Klassenschnittstelle](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" /> ist für COM nicht sichtbar.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetThreadFromFiberCookie">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread GetThreadFromFiberCookie (int cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Thread GetThreadFromFiberCookie(int32 cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetThreadFromFiberCookie (cookie As Integer) As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Thread ^ GetThreadFromFiberCookie(int cookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cookie">Eine ganze Zahl, die ein Fibercookie darstellt.</param>
        <summary>Konvertiert ein Fibercookie in die entsprechende <see cref="T:System.Threading.Thread" />-Instanz.</summary>
        <returns>Ein Thread, der dem <paramref name="cookie" />-Parameter entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fiber-Cookies werden nicht transparenten Token, die vom Host verwendet werden, wenn die common Language Runtime die Fiber-Planung Entscheidungen Warnungen. Sie bestehen aus einem Stapel und Kontext zu registrieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="cookie" />-Parameter ist 0 (null).</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="GetTypedObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetTypedObjectForIUnknown (IntPtr pUnk, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetTypedObjectForIUnknown(native int pUnk, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypedObjectForIUnknown (pUnk As IntPtr, t As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetTypedObjectForIUnknown(IntPtr pUnk, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="pUnk">Ein Zeiger auf die <see langword="IUnknown" />-Schnittstelle des nicht verwalteten Objekts.</param>
        <param name="t">Der Typ der angeforderten verwalteten Klasse.</param>
        <summary>Gibt ein verwaltetes Objekt eines angegebenen Typs zurück, das ein COM-Objekt darstellt.</summary>
        <returns>Eine Instanz der Klasse , die dem <see cref="T:System.Type" />-Objekt entspricht, das das angeforderte nicht verwaltete COM-Objekt darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `t` Parameter muss ein COM-importierter Typ oder ein Untertyp von einem COM-importiert werden. Darüber hinaus `t` muss ein Typ, dessen Metadaten, durch importiert wurde, die [Tlbimp.exe (Type Library Importer-Tool)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) Tool. Dieser Typ muss eine Klasse und keine zugeordnete Co Klassenschnittstelle, die den Namen der COM-Klasse ausführt. Wenn Tlbimp.exe importiert z. B. `Myclass` als eine Klasse mit dem Namen `MyclassClass` und als Co-Schnittstelle aufgerufen `Myclass`, verwenden Sie `MyclassClass` (nicht `Myclass`) mit dieser Methode. Weitere Informationen zu importierten Klassen und Klassenschnittstellen, CO-, finden Sie unter [Typkonvertierung importiert](http://msdn.microsoft.com/library/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3).  
  
 Wenn ein Objekt für bereits abgerufen wurde die `pUnk` Parameter `t` wird ignoriert, und das vorhandene Objekt zurückgegeben. `pUnk` Stellt ein[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) Schnittstellenzeiger auf, aber da alle COM-Schnittstellen direkt oder indirekt von abgeleitet `IUnknown`, können Sie COM-Schnittstelle an diese Methode übergeben. Das zurückgegebene Objekt <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A> ist ein [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW), die als es die common Language Runtime verwaltet ist eines anderes verwalteten Objekts.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" /> ist nicht mit dem Attribut <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> versehen.  
  
 - oder -   
  
 <paramref name="t" /> ist ein [!INCLUDE[wrt](~/includes/wrt-md.md)]-Typ.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeForITypeInfo">
      <MemberSignature Language="C#" Value="public static Type GetTypeForITypeInfo (IntPtr piTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeForITypeInfo(native int piTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeForITypeInfo (piTypeInfo As IntPtr) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeForITypeInfo(IntPtr piTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="piTypeInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="piTypeInfo">Die <see langword="ITypeInfo" />-Schnittstelle, die gemarshallt werden soll.</param>
        <summary>Konvertiert ein nicht verwaltetes [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)-Objekt in ein verwaltetes <see cref="T:System.Type" />-Objekt.</summary>
        <returns>Ein verwalteter Typ, der das nicht verwaltete <see langword="ITypeInfo" />-Objekt darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> Gibt eine <xref:System.Type?displayProperty=nameWithType> -Instanz, die auf den ursprünglichen Typ basiert. Sie können Anwenden der <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> standard Interop-Marshalling-Verhalten mit diesem benutzerdefinierten Marshaller ersetzen. Die [Tlbimp.exe (Type Library Importer-Tool)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) Tool verwendet den benutzerdefinierten Marshaller übersetzen `ITypeInfo` Parameter <xref:System.Type?displayProperty=nameWithType> Parameter. Jedoch wenn Sie erhalten eine `ITypeInfo` Schnittstelle von einigen bedeutet außer Tlbimp.exe, können Sie <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> dieselbe Verschiebung manuell ausführen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.MarshalAsAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">Die CLSID des zurückzugebenden Typs.</param>
        <summary>Gibt den Typ zurück, dem die angegebene Klassen-ID (CLSID) zugeordnet ist.</summary>
        <returns>
          <see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeInfoName">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Namen des Typs ab, der durch ein [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)-Objekt dargestellt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeInfoName (typeInfo As ITypeInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeInfoName(System::Runtime::InteropServices::ComTypes::ITypeInfo ^ typeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Runtime.InteropServices.ComTypes.ITypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">Ein Objekt, das einen <see langword="ITypeInfo" />-Zeiger darstellt.</param>
        <summary>Ruft den Namen des Typs ab, der durch ein [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)-Objekt dargestellt wird.</summary>
        <returns>Der Name des Typs, auf den der <paramref name="typeInfo" />-Parameter zeigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch den Namen des Typs, dargestellt durch Abrufen einer `ITypeInfo` durch Aufrufen der <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> -Methode und-1 als ersten Parameter übergeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="typeInfo" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.UCOMITypeInfo pTI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.UCOMITypeInfo pTI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeInfoName (pTI As UCOMITypeInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeInfoName(System::Runtime::InteropServices::UCOMITypeInfo ^ pTI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTI" Type="System.Runtime.InteropServices.UCOMITypeInfo" />
      </Parameters>
      <Docs>
        <param name="pTI">Ein Objekt, das einen <see langword="ITypeInfo" />-Zeiger darstellt.</param>
        <summary>Ruft den Namen des Typs ab, der durch ein [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)-Objekt dargestellt wird.</summary>
        <returns>Der Name des Typs, auf den der <paramref name="pTI" />-Parameter zeigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch den Namen des Typs, dargestellt durch Abrufen eine `ITypeInfo` Objekt durch Aufrufen der <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> -Methode und-1 als ersten Parameter übergeben.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibGuid">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Bibliothek-ID (LIBID) einer Typbibliothek ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuid (typelib As ITypeLib) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuid(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib">Die Typbibliothek, deren LIBID abgerufen werden soll.</param>
        <summary>Ruft die Bibliothek-ID (LIBID) einer Typbibliothek ab.</summary>
        <returns>Die LIBID der angegebenen Typbibliothek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> extrahiert die LIBID direkt über eine vorhandene Typbibliothek. Dadurch unterscheidet sich von der <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> -Methode, die die LIBID berechnet anhand der aktuellen Assembly.  
  
 Weitere Informationen zu Library-IDs finden Sie unter [exportiert Assembly Konvertierung](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
        <altmember cref="T:System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuid (pTLB As UCOMITypeLib) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuid(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB">Die Typbibliothek, deren LIBID abgerufen werden soll.</param>
        <summary>Ruft die Bibliothek-ID (LIBID) einer Typbibliothek ab.</summary>
        <returns>Die LIBID der Typbibliothek, auf die der <paramref name="pTLB" />-Parameter zeigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> extrahiert die LIBID direkt über eine vorhandene Typbibliothek. Dadurch unterscheidet sich von der <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> -Methode, die die LIBID berechnet anhand der aktuellen Assembly.  
  
 Weitere Informationen zu Library-IDs finden Sie unter [exportiert Assembly Konvertierung](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMITypeLib" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuidForAssembly">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuidForAssembly (System.Reflection.Assembly asm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuidForAssembly(class System.Reflection.Assembly asm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuidForAssembly (asm As Assembly) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuidForAssembly(System::Reflection::Assembly ^ asm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asm" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="asm">Der Assembly, aus der die Typbibliothek exportiert wurde.</param>
        <summary>Ruft die Bibliothek-ID (LIBID) ab, die einer Typbibliothek beim Export aus der angegebenen Assembly zugewiesen wird.</summary>
        <returns>Die LIBID, die einer Typbibliothek beim Export aus der angegebenen Assembly zugewiesen wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assemblys in Typbibliotheken exportiert werden, wird die Typbibliothek eine LIBID zugewiesen. Sie können die LIBID explizit festlegen, durch Anwenden der <xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType> auf die Assembly auf, oder es kann automatisch generiert werden. Die [Tlbimp.exe (Type Library Importer-Tool)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) Tool berechnet einen LIBID-Wert, der auf Basis der Identität der Assembly. <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> Gibt die LIBID, die mit zugeordnetem der <xref:System.Runtime.InteropServices.GuidAttribute>, wenn das Attribut angewendet wird. Andernfalls <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A> gibt den berechneten Wert zurück. Alternativ können Sie die <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> Methode, um die tatsächliche LIBID aus einer vorhandenen Typbibliothek zu extrahieren.  
  
 Finden Sie unter der [exportiert Assembly Konvertierung](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86) Thema enthält weitere Informationen zu Library-IDs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asm" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.InteropServices.GuidAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibLcid">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die LCID einer Typbibliothek ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibLcid (typelib As ITypeLib) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetTypeLibLcid(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib">Die Typbibliothek, deren LCID abgerufen werden soll.</param>
        <summary>Ruft die LCID einer Typbibliothek ab.</summary>
        <returns>Die LCID der Typbibliothek, auf die der <paramref name="typelib" />-Parameter zeigt.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibLcid (pTLB As UCOMITypeLib) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetTypeLibLcid(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB">Die Typbibliothek, deren LCID abgerufen werden soll.</param>
        <summary>Ruft die LCID einer Typbibliothek ab.</summary>
        <returns>Die LCID der Typbibliothek, auf die der <paramref name="pTLB" />-Parameter zeigt.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Namen einer Typbibliothek ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibName (typelib As ITypeLib) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeLibName(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib">Die Typbibliothek, deren Name abgerufen werden soll.</param>
        <summary>Ruft den Namen einer Typbibliothek ab.</summary>
        <returns>Der Name der Typbibliothek, auf die der <paramref name="typelib" />-Parameter zeigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Methode zurückgegebene Name ist der Bezeichner, der mit der Bibliothek-Anweisung, wie z. B. ADODB für die Microsoft ADO-Typbibliothek verwendet. Der Name ist kein Dateiname.  
  
 Sie können auch den Namen der Typbibliothek abrufen, durch Aufrufen der <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> -Methode und-1 als ersten Parameter übergeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="typelib" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeLib.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibName (pTLB As UCOMITypeLib) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeLibName(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB">Die Typbibliothek, deren Name abgerufen werden soll.</param>
        <summary>Ruft den Namen einer Typbibliothek ab.</summary>
        <returns>Der Name der Typbibliothek, auf die der <paramref name="pTLB" />-Parameter zeigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Methode zurückgegebene Name ist der Bezeichner, der mit der Bibliothek-Anweisung, wie z. B. ADODB für die Microsoft ADO-Typbibliothek verwendet. Der Name ist kein Dateiname.  
  
 Sie können auch den Namen der Typbibliothek abrufen, durch Aufrufen der <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> -Methode und-1 als ersten Parameter übergeben.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeLib.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibVersionForAssembly">
      <MemberSignature Language="C#" Value="public static void GetTypeLibVersionForAssembly (System.Reflection.Assembly inputAssembly, out int majorVersion, out int minorVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetTypeLibVersionForAssembly(class System.Reflection.Assembly inputAssembly, [out] int32&amp; majorVersion, [out] int32&amp; minorVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetTypeLibVersionForAssembly (inputAssembly As Assembly, ByRef majorVersion As Integer, ByRef minorVersion As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetTypeLibVersionForAssembly(System::Reflection::Assembly ^ inputAssembly, [Runtime::InteropServices::Out] int % majorVersion, [Runtime::InteropServices::Out] int % minorVersion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="majorVersion" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="minorVersion" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="inputAssembly">Eine verwaltete Assembly.</param>
        <param name="majorVersion">Die Hauptversionsnummer.</param>
        <param name="minorVersion">Die Nebenversionsnummer.</param>
        <summary>Ruft die Versionsnummer einer Typbibliothek ab, die aus der angegebenen Assembly exportiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vor dem Exportieren einer Assembly mit <xref:System.Runtime.InteropServices.TypeLibExporterFlags> mit der `CallerResolvedReferences` Wert können Sie diese Methode verwenden, um die Version der Typbibliothek aus der Assembly abzurufen.  
  
 Wenn Sie nicht anwenden der <xref:System.Runtime.InteropServices.TypeLibVersionAttribute> -Attribut auf eine exportierte Assembly explizit steuern die Versionsnummer der generierten Typbibliothek, die Typbibliothek müssen die gleiche Versionsnummer wie die Assembly.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputAssembly" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.InteropServices.TypeLibExporterFlags" />
        <altmember cref="T:System.Runtime.InteropServices.TypeLibVersionAttribute" />
        <altmember cref="T:System.Runtime.InteropServices.ITypeLibConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetUniqueObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetUniqueObjectForIUnknown (IntPtr unknown);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUniqueObjectForIUnknown(native int unknown) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUniqueObjectForIUnknown (unknown As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetUniqueObjectForIUnknown(IntPtr unknown);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unknown" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="unknown">Ein verwalteter Zeiger auf eine <see langword="IUnknown" />-Schnittstelle.</param>
        <summary>Erstellt ein eindeutiges [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md)-Objekt (RCW) für eine angegebene [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)-Schnittstelle.</summary>
        <returns>Ein eindeutiger RCW für die angegebene <see langword="IUnknown" />-Schnittstelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A> Methode wird sichergestellt, dass Sie einen eindeutigen RCW erhalten, weil er nicht mit einem `IUnknown` Zeiger auf ein vorhandenes Objekt. Verwenden Sie diese Methode, wenn Sie einen eindeutigen RCW erstellen, die nicht von anderem Code beeinträchtigt wird, die Aufrufe der <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> Methode.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetUnmanagedThunkForManagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetUnmanagedThunkForManagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetUnmanagedThunkForManagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnmanagedThunkForManagedMethodPtr (pfnMethodToWrap As IntPtr, pbSignature As IntPtr, cbSignature As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetUnmanagedThunkForManagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap">Ein Zeiger auf die Methode, die gemarshallt werden soll.</param>
        <param name="pbSignature">Ein Zeiger auf die Methodensignatur.</param>
        <param name="cbSignature">Die Anzahl der Bytes in <c>pbSignature</c>.</param>
        <summary>Ruft einen Zeiger auf eine zur Laufzeit generierte Funktion ab, die einen Aufruf aus nicht verwaltetem zu verwaltetem Code marshallt.</summary>
        <returns>Ein Zeiger auf eine Funktion, die einen Aufruf aus <paramref name="pfnMethodToWrap" /> zu verwaltetem Code marshallt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A> für die Unterstützung des Compilers nur wird verfügbar gemacht werden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsComObject">
      <MemberSignature Language="C#" Value="public static bool IsComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsComObject (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsComObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das zu überprüfende Objekt.</param>
        <summary>Gibt an, ob ein angegebenes Objekt ein COM-Objekt darstellt.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="o" />-Parameter ein COM-Typ ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.IsComObject%2A> Gibt `true` , wenn der Klassentyp der Instanz zugewiesen ist <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> oder wenn sie direkt oder indirekt von einer Klasse mit dem abgeleitet wird <xref:System.Runtime.InteropServices.ComImportAttribute>. Die [Tlbimp.exe (Type Library Importer-Tool)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) Tool wendet dieses Attribut, wenn es sich um eine Typbibliothek importiert.  
  
 Zwei weitere Methoden auch bestimmen, ob ein angegebenes Objekt ein COM-Objekt, aber die Anforderungen für die Rückgabe darstellt `true` unterscheiden sich von dieser Methode Anforderungen. <xref:System.Type.IsImport%2A?displayProperty=nameWithType> Gibt `true` , wenn die Klassenmethoden (oder Schnittstellenmethoden) mit attributiert ist <xref:System.Runtime.InteropServices.ComImportAttribute> direkt; sie gibt keine zurück `true` für abgeleitete Typen. <xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType> Gibt `true` , wenn der Typ mit attributiert ist <xref:System.Runtime.InteropServices.ComImportAttribute> oder von einem Typ mit derselben GUID abgeleitet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="P:System.Type.IsImport" />
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsTypeVisibleFromCom">
      <MemberSignature Language="C#" Value="public static bool IsTypeVisibleFromCom (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTypeVisibleFromCom(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTypeVisibleFromCom (t As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTypeVisibleFromCom(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">Der Typ, der auf Sichtbarkeit für COM zu überprüfen ist.</param>
        <summary>Gibt an, ob ein Typ für COM-Clients sichtbar ist.</summary>
        <returns>
          <see langword="true" />, wenn der Typ für COM sichtbar ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A> ermöglicht es Ihnen, die COM-Sichtbarkeit in einem Schritt überprüfen. Typen, die nicht sichtbar sind, können nicht aus COM verwendet werden Ein Typ ist sichtbar, wenn er ist `public` und nicht mit der <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />
      </Docs>
    </Member>
    <Member MemberName="NumParamBytes">
      <MemberSignature Language="C#" Value="public static int NumParamBytes (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NumParamBytes(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NumParamBytes (m As MethodInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NumParamBytes(System::Reflection::MethodInfo ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="m">Die Methode, die überprüft werden soll.</param>
        <summary>Berechnet die Anzahl der Bytes im nicht verwalteten Speicher, die zum Speichern der Parameter für die angegebene Methode erforderlich ist.</summary>
        <returns>Die Anzahl der Bytes, die erforderlich ist, um die Methodenparameter im nicht verwalteten Speicher darzustellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A> Methode gibt die Stapelgröße (in Bytes) benötigt, um die Parameter der Signatur einer Methode im nicht verwalteten Speicher darzustellen.  
  
 Beachten Sie, dass der Rückgabewert dieser Methode plattformabhängige ist. Beispielsweise gibt eine Signatur mit einem einzelnen ganzzahligen Parameter einen Wert von 4 auf 32-Bit-Plattformen und einen Wert von 8 auf 64-Bit-Plattformen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="m" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="m" />-Parameter ist kein <see cref="T:System.Reflection.MethodInfo" />-Objekt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="OffsetOf">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf (Type t, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf(class System.Type t, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OffsetOf (t As Type, fieldName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr OffsetOf(Type ^ t, System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="t">Ein Werttyp oder formatierter Referenztyp, der die verwaltete Klasse angibt. Sie müssen das <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> auf die Klasse anwenden.</param>
        <param name="fieldName">Das Feld im <c>t</c>-Parameter.</param>
        <summary>Gibt den Feldoffset der nicht verwalteten Form der verwalteten Klasse zurück.</summary>
        <returns>Der Offset in Bytes für den <paramref name="fieldName" />-Parameter in der durch Plattformaufrufe deklarierten angegebenen Klasse.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> Stellt den Offset in Bezug auf das Layout nicht verwaltete Struktur, die nicht zwangsläufig den Offset des Layouts verwaltete Struktur entspricht. Marshalling der Struktur kann das Layout zu transformieren, und ändern Sie den Offset. Die `t` -Parameter kann ein Werttyp oder ein formatierter Verweistyp (mit sequenziellen oder explizitem Layout) sein. Sie können die Größe des gesamten Layouts abrufen, indem Sie mit der <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType> Methode. Weitere Informationen finden Sie unter [Standard Marshalling für Werttypen](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).  
  
> [!NOTE]
>  Ab .NET Framework, Version 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> private Felder kann ausgesetzt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Klasse kann nicht als Struktur exportiert werden, oder das Feld ist nicht öffentlich. Ab .NET Framework, Version 2.0, ist das Feld möglicherweise privat.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="t" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OffsetOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf&lt;T&gt; (string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf&lt;T&gt;(string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OffsetOf(Of T) (fieldName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr OffsetOf(System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">Ein verwalteter Wert- oder formatierter Verweistyp. Sie müssen das <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />-Attribut auf die Klasse anwenden.</typeparam>
        <param name="fieldName">Der Name des Felds im <c>T</c>-Typ.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Gibt den Feldoffset der nicht verwalteten Form einer festgelegten verwalteten Klasse zurück.</summary>
        <returns>Der Offset in Bytes für den <paramref name="fieldName" />-Parameter in der durch Plattformaufrufe deklarierten angegebenen Klasse.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29> Stellt den Offset in Bezug auf das Layout nicht verwaltete Struktur, die nicht zwangsläufig den Offset des Layouts verwaltete Struktur entspricht. Marshalling der Struktur kann das Layout zu transformieren, und ändern Sie den Offset. Die `T` generischer Typparameter kann ein Werttyp oder ein formatierter Verweistyp (mit sequenziellen oder explizitem Layout). Sie können die Größe des gesamten Layouts abrufen, indem Sie mit der <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> Methode. Weitere Informationen finden Sie unter [Standard Marshalling für Werttypen](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).  
  
> [!NOTE]
>  Ab .NET Framework, Version 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> private Felder kann ausgesetzt ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="Prelink">
      <MemberSignature Language="C#" Value="public static void Prelink (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Prelink(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Prelink (m As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Prelink(System::Reflection::MethodInfo ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="m">Die Methode, die überprüft werden soll.</param>
        <summary>Führt einmalige Aufgaben zur Methodeneinrichtung aus, ohne die Methode aufzurufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufgaben zur methodeneinrichtung Frühe Initialisierung bereitstellen und automatisch ausgeführt werden, wenn die Zielmethode aufgerufen wird. Einmalig auszuführende Aufgaben umfassen Folgendes:  
  
-   Überprüfen, dass die Metadaten der Plattformaufruf ist richtig formatiert.  
  
-   Überprüfen, dass alle verwalteten Typen gültige Parameter der Plattform sind Funktionen aufrufen.  
  
-   Suchen, und Laden von nicht verwalteten DLL in den Prozess.  
  
-   Suchen den Einstiegspunkt im Prozess an.  
  
 Aufrufen von <xref:System.Runtime.InteropServices.Marshal.Prelink%2A> Aufrufen einer Methode außerhalb von Plattform hat keine Auswirkungen. Aufrufen von Methoden in einen Typ verwenden zum Ausführen von Setup-Tasks auf allen Plattformen <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="m" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="m" />-Parameter ist kein <see cref="T:System.Reflection.MethodInfo" />-Objekt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="PrelinkAll">
      <MemberSignature Language="C#" Value="public static void PrelinkAll (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrelinkAll(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrelinkAll (c As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrelinkAll(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Die Klasse, deren Methoden überprüft werden sollen.</param>
        <summary>Führt eine Linkervorstufen-Prüfung für alle Methoden einer Klasse durch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> Methode ruft <xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType> für jede Methode eines angegebenen Typs. <xref:System.Runtime.InteropServices.Marshal.Prelink%2A> führt einmalige Aufgaben zur methodeneinrichtung ohne jede Methode aufzurufen. Sie können <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> nur für Plattformaufrufe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="c" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringAnsi">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reserviert einen verwalteten <see cref="T:System.String" /> und kopiert eine nicht verwaltete ANSI-Zeichenfolge ganz oder teilweise hinein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAnsi (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAnsi(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse des ersten Zeichens der nicht verwalteten Zeichenfolge.</param>
        <summary>Kopiert alle Zeichen bis zum ersten NULL-Zeichen aus einer nicht verwalteten ANSI-Zeichenfolge in einen verwalteten <see cref="T:System.String" /> und erweitert die einzelnen ANSI-Zeichen zu UNICODE-Zeichen.</summary>
        <returns>Eine verwaltete Zeichenfolge, die eine Kopie der nicht verwalteten ANSI-Zeichenfolge enthält. Wenn <paramref name="ptr" /> den Wert <see langword="null" /> aufweist, gibt die Methode eine NULL-Zeichenfolge zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> eignet sich für das Marshalling von benutzerdefinierten oder beim Kombinieren von verwaltetem und nicht verwaltetem Code. Da diese Methode eine Kopie des Inhalts der nicht verwalteten Zeichenfolge erstellt wird, müssen Sie die ursprüngliche Zeichenfolge nach Bedarf freigeben. Diese Methode stellt die Umkehrfunktion von der <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> und <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> Methoden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> Methode so erstellen Sie eine verwaltete Zeichenfolge aus einem nicht verwalteten `char` Array.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAnsi (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAnsi(IntPtr ptr, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse des ersten Zeichens der nicht verwalteten Zeichenfolge.</param>
        <param name="len">Die zu kopierende Anzahl von Bytes aus der Eingabezeichenfolge.</param>
        <summary>Reserviert einen verwalteten <see cref="T:System.String" />, kopiert eine angegebene Anzahl von Zeichen aus einer nicht verwalteten ANSI-Zeichenfolge hinein und erweitert jedes ANSI-Zeichen zu einem Unicode-Zeichen.</summary>
        <returns>Eine verwaltete Zeichenfolge, die eine Kopie der systemeigenen ANSI-Zeichenfolge enthält, wenn der Wert des <paramref name="ptr" />-Parameters nicht <see langword="null" /> ist. Andernfalls gibt diese Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> eignet sich für das Marshalling von benutzerdefinierten oder beim Kombinieren von verwaltetem und nicht verwaltetem Code. Da diese Methode eine Kopie des Inhalts der nicht verwalteten Zeichenfolge erstellt wird, müssen Sie die ursprüngliche Zeichenfolge nach Bedarf freigeben. Diese Methode stellt die Umkehrfunktion von der <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> und <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> Methoden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> Methode so erstellen Sie eine verwaltete Zeichenfolge aus einem nicht verwalteten`char` Array.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="len" /> ist kleiner als Null.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringAuto">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reserviert einen verwalteten <see cref="T:System.String" /> und kopiert eine nicht verwaltete Zeichenfolge ganz oder teilweise hinein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAuto (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAuto(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Für Unicode-Plattformen die Adresse des ersten Unicode-Zeichens.  
  
 - oder -   
  
 Für ANSI-Plattformen die Adresse des ersten ANSI-Zeichens.</param>
        <summary>Reserviert einen verwalteten <see cref="T:System.String" /> und kopiert alle Zeichen bis zum ersten NULL-Zeichen aus einer Zeichenfolge hinein, die im nicht verwalteten Speicher gespeichert ist.</summary>
        <returns>Eine verwaltete Zeichenfolge, die eine Kopie der nicht verwalteten Zeichenfolge enthält, wenn der Wert des <paramref name="ptr" />-Parameters nicht <see langword="null" /> ist. Andernfalls gibt diese Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle Plattform Unicode ist, jedes ANSI-Zeichen in eine Unicode-Zeichen erweitert wird, und diese Methode ruft <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>. Andernfalls ruft diese Methode <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.  
  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> eignet sich für das Marshalling von benutzerdefinierten oder beim Kombinieren von verwaltetem und nicht verwaltetem Code. Da diese Methode eine Kopie des Inhalts der nicht verwalteten Zeichenfolge erstellt wird, müssen Sie die ursprüngliche Zeichenfolge nach Bedarf freigeben. <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> Stellt die Umkehrfunktion von der <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> und <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType> Methoden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAuto (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAuto(IntPtr ptr, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Für Unicode-Plattformen die Adresse des ersten Unicode-Zeichens.  
  
 - oder -   
  
 Für ANSI-Plattformen die Adresse des ersten ANSI-Zeichens.</param>
        <param name="len">Die Anzahl der zu kopierenden Zeichen.</param>
        <summary>Reserviert einen verwalteten <see cref="T:System.String" /> und kopiert die angegebene Anzahl von Zeichen aus einer in nicht verwaltetem Speicher gespeicherten Zeichenfolge hinein.</summary>
        <returns>Eine verwaltete Zeichenfolge, die eine Kopie der systemeigenen Zeichenfolge enthält, wenn der Wert des <paramref name="ptr" />-Parameters nicht <see langword="null" /> ist. Andernfalls gibt diese Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf Unicode-Plattformen, die diese Methode ruft <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>; auf ANSI-Plattformen, ruft er <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>. Bevor Sie diese Methoden aufgerufen werden, werden keine Transformationen ausgeführt.  
  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> eignet sich für das Marshalling von benutzerdefinierten oder beim Kombinieren von verwaltetem und nicht verwaltetem Code. Da diese Methode eine Kopie des Inhalts der nicht verwalteten Zeichenfolge erstellt wird, müssen Sie die ursprüngliche Zeichenfolge nach Bedarf freigeben. <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> Stellt die Umkehrfunktion von <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> und <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="len" /> ist kleiner als Null.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringBSTR">
      <MemberSignature Language="C#" Value="public static string PtrToStringBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringBSTR (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringBSTR(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse des ersten Zeichens der nicht verwalteten Zeichenfolge.</param>
        <summary>Reserviert einen verwalteten <see cref="T:System.String" /> und kopiert eine [binäre Zeichenfolge (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) aus dem nicht verwalteten Speicher hinein.</summary>
        <returns>Eine verwaltete Zeichenfolge, die eine Kopie der nicht verwalteten Zeichenfolge enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode nur für Zeichenfolgen, die zugewiesen wurden mit der nicht verwalteten [SysAllocString](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx) und [SysAllocStringLen](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx) Funktionen.  
  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A> eignet sich für das Marshalling von benutzerdefinierten oder beim Kombinieren von verwaltetem und nicht verwaltetem Code. Da diese Methode eine Kopie des Inhalts der nicht verwalteten Zeichenfolge erstellt wird, müssen Sie die ursprüngliche Zeichenfolge nach Bedarf freigeben. Diese Methode stellt die Umkehrfunktion von der <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ptr" /> ist gleich <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringUni">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reserviert einen verwalteten <see cref="T:System.String" /> und kopiert eine nicht verwaltete Unicode-Zeichenfolge ganz oder teilweise hinein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUni (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUni(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse des ersten Zeichens der nicht verwalteten Zeichenfolge.</param>
        <summary>Reserviert einen verwalteten <see cref="T:System.String" /> und kopiert alle Zeichen bis zum ersten NULL-Zeichen aus einer nicht verwalteten Unicode-Zeichenfolge hinein.</summary>
        <returns>Eine verwaltete Zeichenfolge, die eine Kopie der nicht verwalteten Zeichenfolge enthält, wenn der Wert des <paramref name="ptr" />-Parameters nicht <see langword="null" /> ist. Andernfalls gibt diese Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> eignet sich für das Marshalling von benutzerdefinierten oder für die Verwendung beim Kombinieren von verwaltetem und nicht verwaltetem Code. Da diese Methode eine Kopie des Inhalts der nicht verwalteten Zeichenfolge erstellt wird, müssen Sie die ursprüngliche Zeichenfolge nach Bedarf freigeben. Diese Methode stellt die Umkehrfunktion von der <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> und <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> Methoden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUni (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUni(IntPtr ptr, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse des ersten Zeichens der nicht verwalteten Zeichenfolge.</param>
        <param name="len">Die Anzahl der zu kopierenden Unicode-Zeichen.</param>
        <summary>Reserviert einen verwalteten <see cref="T:System.String" /> und kopiert eine angegebene Anzahl von Zeichen aus einer nicht verwalteten Unicode-Zeichenfolge hinein.</summary>
        <returns>Eine verwaltete Zeichenfolge, die eine Kopie der nicht verwalteten Zeichenfolge enthält, wenn der Wert des <paramref name="ptr" />-Parameters nicht <see langword="null" /> ist. Andernfalls gibt diese Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> eignet sich für das Marshalling von benutzerdefinierten oder beim Kombinieren von verwaltetem und nicht verwaltetem Code. Da diese Methode eine Kopie des Inhalts der nicht verwalteten Zeichenfolge erstellt wird, müssen Sie die ursprüngliche Zeichenfolge nach Bedarf freigeben. Diese Methode stellt die Umkehrfunktion von der <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> und <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> Methoden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUTF8 (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUTF8(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr, int byteLen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr, int32 byteLen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUTF8 (ptr As IntPtr, byteLen As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUTF8(IntPtr ptr, int byteLen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="byteLen" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="byteLen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStructure">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Marshallt Daten aus einem nicht verwalteten Speicherblock zu einem verwalteten Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static void PtrToStructure (IntPtr ptr, object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure(native int ptr, object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PtrToStructure (ptr As IntPtr, structure As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PtrToStructure(IntPtr ptr, System::Object ^ structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="ptr">Ein Zeiger auf einen nicht verwalteten Speicherblock.</param>
        <param name="structure">Das Objekt, in das die Daten kopiert werden sollen. Dabei muss es sich um eine Instanz einer formatierten Klasse handeln.</param>
        <summary>Marshallt Daten aus einem nicht verwalteten Speicherblock zu einem verwalteten Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> wird häufig in COM-Interop und Plattformaufrufe aufgerufen wird, wenn die Struktur als dargestellt sind ein <xref:System.IntPtr?displayProperty=nameWithType> Wert. Sie können keine diese überladene Methode mit Werttypen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Strukturlayout ist weder sequenziell noch explizit.  
  
 - oder -   
  
 Die Struktur ist ein geschachtelter Werttyp.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static object PtrToStructure (IntPtr ptr, Type structureType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object PtrToStructure(native int ptr, class System.Type structureType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStructure (ptr As IntPtr, structureType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ PtrToStructure(IntPtr ptr, Type ^ structureType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structureType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">Ein Zeiger auf einen nicht verwalteten Speicherblock.</param>
        <param name="structureType">Der Typ des zu erstellenden Objekts. Dieses Objekt muss eine formatierte Klasse oder eine Struktur darstellen.</param>
        <summary>Marshallt Daten aus einem nicht verwalteten Speicherblock zu einem neu belegten, verwalteten Objekt des angegebenen Typs.</summary>
        <returns>Ein verwaltetes Objekt mit Daten, auf die der <paramref name="ptr" />-Parameter zeigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> wird häufig in COM-Interop und Plattformaufrufe aufgerufen wird, wenn die Struktur als dargestellt sind ein <xref:System.IntPtr?displayProperty=nameWithType> Wert. Sie können einen Werttyp an diese überladene Methode übergeben. In diesem Fall ist das zurückgegebene Objekt eine geschachtelte Instanz.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine verwaltete Struktur erstellt, werden in nicht verwalteten Speicher übertragen und dann wieder mit verwalteten Speicher werden übertragen die <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> Methode.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie für einen nicht verwalteten Speicherblock zu einem verwalteten Struktur mit Marshallen der <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> Methode.  
  
> [!IMPORTANT]
>  Dieser Code wird davon ausgegangen, 32-Bit-Kompilierung. Ersetzen Sie vor dem Verwenden eines 64-Bit-Compilers, <xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType> mit <xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType>.  
  
 [!code-cpp[PtrToStructure#1](~/samples/snippets/cpp/VS_Snippets_CLR/PtrToStructure/CPP/pts.cpp#1)]
 [!code-csharp[PtrToStructure#1](~/samples/snippets/csharp/VS_Snippets_CLR/PtrToStructure/CS/pts.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das <paramref name="structureType" />-Parameterlayout ist weder sequenziell noch explizit.  
  
 - oder -   
  
 Der <paramref name="structureType" />-Parameter ist eine generische Typdefinition.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="structureType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Die - Klasse, die von <paramref name="structureType" /> angegeben wird, hat keinen verwendbaren Standardkonstruktor.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetTypeAttr(System.IntPtr@)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T PtrToStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T PtrToStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStructure(Of T) (ptr As IntPtr) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T PtrToStructure(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des Objekts, in das die Daten kopiert werden sollen. Dies muss eine formatierte Klasse oder eine Struktur sein .</typeparam>
        <param name="ptr">Ein Zeiger auf einen nicht verwalteten Speicherblock.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Marshallt Daten aus einem nicht verwalteten Speicherblock zu einem neu belegten, verwalteten Objekt des von einem generischen Typparameter angegebenen Typs.</summary>
        <returns>Ein verwaltetes Objekt mit Daten, auf die der <paramref name="ptr" />-Parameter zeigt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29> wird häufig in COM-Interop und Plattformaufrufe aufgerufen wird, wenn als Strukturparameter dargestellt werden <xref:System.IntPtr?displayProperty=nameWithType> Werte. Sie können einen Werttyp an Überladung dieser Methode übergeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Layout von <typeparamref name="T" />ist weder sequenziell noch explizit.</exception>
        <exception cref="T:System.MissingMethodException">Die - Klasse, die von <typeparamref name="T" /> angegeben wird, hat keinen verwendbaren Standardkonstruktor.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void PtrToStructure&lt;T&gt; (IntPtr ptr, T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure&lt;T&gt;(native int ptr, !!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PtrToStructure(Of T) (ptr As IntPtr, structure As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void PtrToStructure(IntPtr ptr, T structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des <c>Struktur</c>. Muss eine formatierte Klasse sein.</typeparam>
        <param name="ptr">Ein Zeiger auf einen nicht verwalteten Speicherblock.</param>
        <param name="structure">Das Objekt, in das die Daten kopiert werden sollen.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Marshallt Daten aus einem nicht verwalteten Speicherblock zu einem verwalteten Objekt eines festgelegten Typs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29> wird häufig in COM-Interop und Plattformaufrufe aufgerufen wird, wenn als Strukturparameter dargestellt werden <xref:System.IntPtr> Werte. Sie können keine Überladung dieser Methode mit Werttypen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Strukturlayout ist weder sequenziell noch explizit.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="QueryInterface">
      <MemberSignature Language="C#" Value="public static int QueryInterface (IntPtr pUnk, ref Guid iid, out IntPtr ppv);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 QueryInterface(native int pUnk, valuetype System.Guid&amp; iid, [out] native int&amp; ppv) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueryInterface (pUnk As IntPtr, ByRef iid As Guid, ByRef ppv As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int QueryInterface(IntPtr pUnk, Guid % iid, [Runtime::InteropServices::Out] IntPtr % ppv);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="iid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="ppv" Type="System.IntPtr&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pUnk">Die abzufragende Schnittstelle.</param>
        <param name="iid">Der Schnittstellenbezeichner (Interface Identifier, IID) der angeforderten Schnittstelle.</param>
        <param name="ppv">Enthält nach dem Beenden der Methode einen Verweis auf die zurückgegebene Schnittstelle.</param>
        <summary>Fordert einen Zeiger auf eine angegebene Schnittstelle von einem COM-Objekt an.</summary>
        <returns>Ein HRESULT, das den Erfolg oder Fehler des Aufrufs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A> Methode macht die [IUnknown:: QueryInterface](http://go.microsoft.com/fwlink/?LinkID=144867) Methode von einem COM-Objekt, das versucht, einen bestimmten Schnittstellenzeiger abzurufen. Mithilfe von `QueryInterface` für ein COM-Objekt ist identisch mit der Ausführung eines Umwandlungsvorgangs in verwaltetem Code. Aufruf eines Objekts mit dieser Methode bewirkt, dass den Verweiszähler für den Schnittstellenzeiger inkrementiert werden soll, bevor der Zeiger zurückgegeben wird. Verwenden Sie immer <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> um den Verweiszähler zu verringern, sobald Sie den Mauszeiger abgeschlossen haben. Zum Abrufen einer <xref:System.IntPtr> Wert, der darstellt eine [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) Schnittstellenzeiger, rufen Sie <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, oder <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadByte">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest ein einzelnes Byte aus dem nicht verwalteten Speicher. Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As IntPtr) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse im nicht verwalteten Speicher, an der gelesen werden soll.</param>
        <summary>Liest ein einzelnes Byte aus dem nicht verwalteten Speicher.</summary>
        <returns>Das aus dem nicht verwalteten Arbeitsspeicher gelesene Byte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> hat einen impliziten Offset von 0. Diese Methode ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil Bytearray, der den entfallenden Aufwand für das Kopieren der eines nicht verwalteten Arrays (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgende Beispiel erstellt einen nicht verwalteten Speicherblock, schreibt ein Byte in den nicht verwalteten Speicher, das Byte wieder aus dem nicht verwalteten Arbeitsspeicher gelesen und dann den nicht verwalteten Arbeitsspeicher frei.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> Methode, um den Wert eines nicht verwalteten Zeichens lesen.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" /> ist kein erkanntes Format.  
  
 - oder -   
  
 <paramref name="ptr" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="ptr" /> ist ungültig.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As IntPtr, ofs As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher, an der gelesen werden soll.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Lesen hinzugefügt wird.</param>
        <summary>Liest ein einzelnes Byte an einem angegebenen Offset (oder Index) aus dem nicht verwalteten Speicher.</summary>
        <returns>Das aus dem nicht verwalteten Arbeitsspeicher am angegebenen Offset gelesene Byte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil Bytearray, der den entfallenden Aufwand für das Kopieren der eines nicht verwalteten Arrays (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> Methode, um den Wert eines nicht verwalteten Zeichens lesen.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As Object, ofs As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher des Quellobjekts.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Lesen hinzugefügt wird.</param>
        <summary>Liest ein einzelnes Byte an einem angegebenen Offset (oder Index) aus dem nicht verwalteten Speicher.</summary>
        <returns>Das aus dem nicht verwalteten Arbeitsspeicher am angegebenen Offset gelesene Byte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil Bytearray, der den entfallenden Aufwand für das Kopieren der eines nicht verwalteten Arrays (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> ist ein <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Objekt. Diese Methode akzeptiert keine <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Parameter.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt16">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest eine 16-Bit-Ganzzahl mit Vorzeichen aus dem nicht verwalteten Speicher. Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As IntPtr) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse im nicht verwalteten Speicher, an der gelesen werden soll.</param>
        <summary>Liest eine 16-Bit-Ganzzahl mit Vorzeichen aus dem nicht verwalteten Speicher.</summary>
        <returns>Die 16-Bit-Ganzzahl mit Vorzeichen, die aus dem nicht verwalteten Speicher gelesen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> hat einen impliziten Offset von 0. Diese Methode ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil `Int16` -Array, sodass ein nicht verwaltetes Array kopiert (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> Methode zum Lesen des Werts von einer nicht verwalteten `short` Variable.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" /> ist kein erkanntes Format.  
  
 - oder -   
  
 <paramref name="ptr" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="ptr" /> ist ungültig.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As IntPtr, ofs As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher, an der gelesen werden soll.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Lesen hinzugefügt wird.</param>
        <summary>Liest eine 16-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset aus dem nicht verwalteten Arbeitsspeicher.</summary>
        <returns>Die 16-Bit-Ganzzahl mit Vorzeichen, die am angegebenen Offset aus dem nicht verwalteten Arbeitsspeicher gelesen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 16-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> Methode zum Lesen des Werts von einer nicht verwalteten `short` Variable.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As Object, ofs As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher des Quellobjekts.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Lesen hinzugefügt wird.</param>
        <summary>Liest eine 16-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset aus dem nicht verwalteten Arbeitsspeicher.</summary>
        <returns>Die 16-Bit-Ganzzahl mit Vorzeichen, die am angegebenen Offset aus dem nicht verwalteten Arbeitsspeicher gelesen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 16-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> ist ein <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Objekt. Diese Methode akzeptiert keine <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Parameter.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest eine 32-Bit-Ganzzahl mit Vorzeichen aus dem nicht verwalteten Speicher. Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse im nicht verwalteten Speicher, an der gelesen werden soll.</param>
        <summary>Liest eine 32-Bit-Ganzzahl mit Vorzeichen aus dem nicht verwalteten Speicher.</summary>
        <returns>Die 32-Bit-Ganzzahl mit Vorzeichen, die aus dem nicht verwalteten Speicher gelesen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> hat einen impliziten Offset von 0. Diese Methode ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil `Int32` -Array, sodass ein nicht verwaltetes Array kopiert (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> Methode zum Lesen des Werts von einer nicht verwalteten `int` Variable.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" /> ist kein erkanntes Format.  
  
 - oder -   
  
 <paramref name="ptr" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="ptr" /> ist ungültig.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As IntPtr, ofs As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher, an der gelesen werden soll.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Lesen hinzugefügt wird.</param>
        <summary>Liest eine 32-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset aus dem nicht verwalteten Arbeitsspeicher.</summary>
        <returns>Die 32-Bit-Ganzzahl mit Vorzeichen, die aus dem nicht verwalteten Speicher gelesen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 32-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> Methode zum Lesen des Werts von einer nicht verwalteten `int` Variable.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As Object, ofs As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher des Quellobjekts.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Lesen hinzugefügt wird.</param>
        <summary>Liest eine 32-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset aus dem nicht verwalteten Arbeitsspeicher.</summary>
        <returns>Die 32-Bit-Ganzzahl mit Vorzeichen, die am angegebenen Offset aus dem nicht verwalteten Arbeitsspeicher gelesen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 32-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> ist ein <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Objekt. Diese Methode akzeptiert keine <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Parameter.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt64">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest eine 64-Bit-Ganzzahl mit Vorzeichen aus dem nicht verwalteten Speicher. Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As IntPtr) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse im nicht verwalteten Speicher, an der gelesen werden soll.</param>
        <summary>Liest eine 64-Bit-Ganzzahl mit Vorzeichen aus dem nicht verwalteten Speicher.</summary>
        <returns>Die 64-Bit-Ganzzahl mit Vorzeichen, die aus dem nicht verwalteten Speicher gelesen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> hat einen impliziten Offset von 0. Diese Methode ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil `Int64` -Array, sodass ein nicht verwaltetes Array kopiert (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> Methode zum Lesen des Werts von einer nicht verwalteten `__int64` Variable.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" /> ist kein erkanntes Format.  
  
 - oder -   
  
 <paramref name="ptr" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="ptr" /> ist ungültig.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As IntPtr, ofs As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher, an der gelesen werden soll.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Lesen hinzugefügt wird.</param>
        <summary>Liest eine 64-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset aus dem nicht verwalteten Arbeitsspeicher.</summary>
        <returns>Die 64-Bit-Ganzzahl mit Vorzeichen, die am angegebenen Offset aus dem nicht verwalteten Arbeitsspeicher gelesen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 64-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> Methode zum Lesen des Werts von einer nicht verwalteten `__int64` Variable.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As Object, ofs As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher des Quellobjekts.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Lesen hinzugefügt wird.</param>
        <summary>Liest eine 64-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset aus dem nicht verwalteten Arbeitsspeicher.</summary>
        <returns>Die 64-Bit-Ganzzahl mit Vorzeichen, die am angegebenen Offset aus dem nicht verwalteten Arbeitsspeicher gelesen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 64-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> ist ein <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Objekt. Diese Methode akzeptiert keine <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Parameter.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadIntPtr">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest eine ganze Zahl von prozessoreigener Größe aus dem nicht verwalteten Speicher. Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse im nicht verwalteten Speicher, an der gelesen werden soll.</param>
        <summary>Liest eine ganze Zahl von prozessoreigener Größe aus dem nicht verwalteten Speicher.</summary>
        <returns>Die aus dem nicht verwaltetem Arbeitsspeicher gelesene Ganzzahl. Auf 32-Bit-Computern wird eine 32-Bit-Ganzzahl zurückgegeben und auf 64-Bit-Computern eine 64-Bit-Ganzzahl.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> hat einen impliziten Offset von 0. Diese Methode ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil `IntPtr` -Array, sodass ein nicht verwaltetes Array kopiert (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" /> ist kein erkanntes Format.  
  
 - oder -   
  
 <paramref name="ptr" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="ptr" /> ist ungültig.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As IntPtr, ofs As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher, an der gelesen werden soll.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Lesen hinzugefügt wird.</param>
        <summary>Liest eine ganze Zahl von prozessoreigener Größe an einem angegebenen Offset aus dem nicht verwalteten Speicher.</summary>
        <returns>Die aus dem nicht verwalteten Arbeitsspeicher am angegebenen Offset gelesene ganze Zahl.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil `IntPtr` -Array, sodass ein nicht verwaltetes Array kopiert (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As Object, ofs As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher des Quellobjekts.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Lesen hinzugefügt wird.</param>
        <summary>Liest eine ganze Zahl von prozessoreigener Größe aus dem nicht verwalteten Speicher.</summary>
        <returns>Die aus dem nicht verwalteten Arbeitsspeicher am angegebenen Offset gelesene ganze Zahl.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil `IntPtr` -Array, sodass ein nicht verwaltetes Array kopiert (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem Lesen die Elementwerte.  
  
 Das Lesen aus nicht ausgerichteten Speicheradressen wird unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> ist ein <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Objekt. Diese Methode akzeptiert keine <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Parameter.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReAllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocCoTaskMem (IntPtr pv, int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocCoTaskMem(native int pv, int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReAllocCoTaskMem (pv As IntPtr, cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pv">Ein Zeiger auf den mit <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /> belegten Speicher.</param>
        <param name="cb">Die neue Größe des belegten Blocks.</param>
        <summary>Ändert die Größe eines bereits mit <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /> belegten Speicherblocks.</summary>
        <returns>Eine ganze Zahl, die die Adresse des neu belegten Speicherblocks darstellt. Dieser Speicher muss mit <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /> freigegeben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A> ist einer von zwei Speicher neuzuordnungen Methoden in der <xref:System.Runtime.InteropServices.Marshal> Klasse. (<xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> die andere ist.) Der Anfang des neu belegten Arbeitsspeicher Inhalts ist identisch mit den ursprünglichen Inhalt. der gesamte Speicherblock kann sich jedoch an einem anderen Speicherort. Diese Methode macht COM [CoTaskMemRealloc](http://go.microsoft.com/fwlink/?LinkId=148778) -Funktion, die so der Speicherbelegungsfunktion für COM-Aufgaben genannte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher zum Erfüllen der Anforderung vorhanden.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="ReAllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocHGlobal (IntPtr pv, IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocHGlobal(native int pv, native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReAllocHGlobal (pv As IntPtr, cb As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pv">Ein Zeiger auf den mit <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /> belegten Speicher.</param>
        <param name="cb">Die neue Größe des belegten Blocks. Dies ist kein Zeiger; es ist die Byteanzahl, die Sie anfordern, umgewandelt zum Typ <see cref="T:System.IntPtr" />. Wenn Sie einen Zeiger übergeben, wird er als Größe behandelt.</param>
        <summary>Ändert die Größe eines bereits mit <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /> belegten Speicherblocks.</summary>
        <returns>Ein Zeiger auf den neu reservierten Arbeitsspeicher. Dieser Speicher muss mit <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> freigegeben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> ist eine der zwei Speicher neuzuordnungen API-Methoden in der <xref:System.Runtime.InteropServices.Marshal> Klasse. (<xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType> die andere ist.)  
  
 Diese Methode macht die Win32 [GlobalReAlloc](http://go.microsoft.com/fwlink/?LinkId=148780) -Funktion von Kernel32.dll verwenden. Der zurückgegebene Zeiger kann sich vom Original unterscheiden. Falls es abweicht, den Inhalt der ursprüngliche Speicherblock auf den neuen Block kopiert wurden, und der ursprüngliche Speicherblock wurde freigegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher zum Erfüllen der Anforderung vorhanden.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public static int Release (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Release(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Release (pUnk As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Release(IntPtr pUnk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">Die freizugebende Schnittstelle.</param>
        <summary>Dekrementiert den Verweiszähler für die angegebene Schnittstelle.</summary>
        <returns>Der neue Wert des Verweiszählers für die Schnittstelle, die durch den <paramref name="pUnk" />-Parameter angegeben ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die common Language Runtime verwaltet den Verweiszähler eines COM-Objekts, so dass es nicht erforderlich ist, verwenden Sie diese Methode direkt Sie. Verwenden Sie diesen Wert nur für Testzwecke verwenden. In seltenen Fällen, z. B. Tests von einem benutzerdefinierten Marshaller möglicherweise finden Sie es erforderlich, um die Lebensdauer eines Objekts manuell zu bearbeiten. Dieser Aufruf nur Programme <xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType> sollten Aufrufen <xref:System.Runtime.InteropServices.Marshal.Release%2A>. Aufrufen von <xref:System.Runtime.InteropServices.Marshal.Release%2A> den Verweiszähler dieser Planergruppe erreicht ist 0 (null) bewirkt, dass nicht definiertem Verhalten.  
  
 Sie erreichen <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, oder <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> zum Abrufen einer <xref:System.IntPtr> Wert, der darstellt eine [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) -Schnittstellenzeiger. Sie können diese Methoden auch verwenden und die <xref:System.Runtime.InteropServices.Marshal.Release%2A> Methode für verwaltete Objekte, die COM-Schnittstellen, die des verwalteten Objekts dargestellte freizugeben [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Abrufen einer `IUnknown` Schnittstelle für ein verwaltetes Objekt mit der <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> Methode. Das Beispiel gibt dann den Schnittstellenzeiger frei, durch Aufrufen der <xref:System.Runtime.InteropServices.Marshal.Release%2A> Methode.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseComObject">
      <MemberSignature Language="C#" Value="public static int ReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReleaseComObject (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReleaseComObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das freizugebende COM-Objekt.</param>
        <summary>Dekrementiert den Verweiszähler des dem angegebenen COM-Objekt zugeordneten [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).</summary>
        <returns>Der neue Wert für den Verweiszähler des RCW, der <paramref name="o" /> zugeordnet ist. Dieser Wert ist in der Regel 0, da der RCW unabhängig von der Anzahl der aufrufenden verwalteten Clients genau einen Verweis auf das umschlossene COM-Objekt beibehält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um die Lebensdauer eines COM-Objekts, die in verwaltetem Code verwendet explizit zu steuern. Sie sollten diese Methode verwenden, um das zugrunde liegende COM-Objekt freizugeben, das Verweise auf Ressourcen enthält, in kürzester Zeit oder wenn Objekte in einer bestimmten Reihenfolge freigegeben werden müssen.  
  
 Jedes Mal, wenn eine COM-Schnittstellenzeiger auf die common Language Runtime (CLR) eingibt, wird er in einen RCW eingebunden.  
  
 Der RCW besitzt einen Verweiszähler, der inkrementiert wird jedes Mal, wenn ein COM-Schnittstellenzeiger zugeordnet ist. Die <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> Methode dekrementiert den Verweiszähler des RCW. Wenn der Verweiszähler auf 0 (null) erreicht, die Common Language Runtime alle Verweise auf das nicht verwaltete COM-Objekt frei, und löst eine <xref:System.NullReferenceException?displayProperty=nameWithType> , wenn Sie versuchen, das Objekt weiter zu verwenden. Wenn die gleiche COM-Schnittstelle mehr als ein Mal aus nicht verwaltetem zu verwaltetem Code übergeben wird, wird der Verweiszähler für den Wrapper jedes Mal inkrementiert, und ein Aufruf <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> gibt die Anzahl der verbleibenden Verweise.  
  
 Diese Methode können Sie eine RCW Verweis Count-Version erzwingen, damit es tritt genau wann soll. Allerdings unsachgemäßen Verwendung von <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> kann dazu führen, dass Ihre Anwendung ein Fehler auftritt, oder eine zugriffsverletzung verursachen.  
  
 Betrachten Sie ein Szenario in der verwalteter Code in einer Anwendungsdomäne einen RCW enthalten kann, der eine COM-Komponente darstellt. Beim Aufrufen der <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> Methode für den RCW, der verwaltete Code wird in der Lage, den RCW zugreifen und löst eine <xref:System.Runtime.InteropServices.InvalidComObjectException> Ausnahme.  
  
 Ein schwerwiegender Fehler kann auftreten, wenn ein Aufruf der RCW ausgeführt wird, wenn der RCW freigegeben wird. In diesem Fall besteht die Wahrscheinlichkeit, dass der Thread, die den Aufruf eine zugriffsverletzung verursacht. Allerdings Prozessspeicher beschädigt, und der Prozess kann fortgesetzt werden ausgeführt, bis dieser Gründe, die sehr schwer fehlschlägt zu beheben sind.  
  
 Dieses Risiko wird verschärft, wenn die COM-Komponente, die verwendet wird, ein Singleton aus folgendem Grund ist: die CLR aktiviert COM-Komponenten durch Aufrufen von COM [CoCreateInstance](http://go.microsoft.com/fwlink/?LinkID=142894) -Funktion, die den gleichen Schnittstellenzeiger gibt jede Uhrzeit, die sie für Singleton-COM-Komponenten aufgerufen wird. Folglich separate und unabhängige Teile von verwaltetem Code in einer Anwendungsdomäne können verwenden den gleichen RCW für eine Singleton-COM-Komponente, und wenn entweder ein Aufrufe der <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> -Methode für die COM-Komponente, die andere wird unterbrochen werden.  
  
 Verwenden Sie daher die <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> nur, wenn es absolut erforderlich ist. Wenn diese Methode, um sicherzustellen, dass eine COM-Komponente zu einem bestimmten Zeitpunkt aufgehoben ist aufgerufen werden soll, können Sie verwenden die <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> Methode stattdessen. <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> Gibt die zugrunde liegende COM-Komponente, unabhängig davon, wie oft frei, die es die CLR erneut eingegeben hat. Der interne Verweiszähler des RCW wird um eins erhöht, jedes Mal, wenn die COM-Komponente die CLR erneut eingegeben werden. Sie können daher Aufrufen der <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> -Methode in einer Schleife, bis der zurückgegebene Wert ist 0 (null). Dadurch wird das gleiche Ergebnis wie erreicht die <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="o" /> ist kein gültiges COM-Objekt.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="o" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
        <altmember cref="T:System.NullReferenceException" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseThreadCache">
      <MemberSignature Language="C#" Value="public static void ReleaseThreadCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReleaseThreadCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReleaseThreadCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReleaseThreadCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Threadcache frei.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToBSTR (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToBSTR(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToBSTR (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToBSTR(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">Das zu kopierende verwaltete Objekt.</param>
        <summary>Reserviert eine nicht verwaltete [binäre Zeichenfolge (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) und kopiert den Inhalt eines verwalteten <see cref="T:System.Security.SecureString" />-Objekts hinein.</summary>
        <returns>Die Adresse im nicht verwalteten Speicher, in die der <paramref name="s" />-Parameter kopiert wurde, oder 0, wenn ein NULL-Objekt bereitgestellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> Methode eignet sich für benutzerdefiniertes Marshalling geht oder wenn das Mischen von verwaltetem und nicht verwaltetem Code. Immer freigeben, da diese Methode belegt wird der nicht verwalteten Speicher für eine Zeichenfolge, die `BSTR` abschließend durch Aufrufen der <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="s" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Auf dem aktuellen Computer wird nicht Windows 2000 Service Pack 3 oder höher ausgeführt.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <block subset="none" type="usage">
          <para>Diese Methode ist nur auf Computern unter Windows 2000 Service Pack 3 oder höher unterstützt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToCoTaskMemAnsi (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToCoTaskMemAnsi(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">Das zu kopierende verwaltete Objekt.</param>
        <summary>Kopiert den Inhalt eines verwalteten <see cref="T:System.Security.SecureString" />-Objekts in einen Speicherblock, der von der nicht verwalteten Speicherbelegung für COM-Aufgaben reserviert wurde.</summary>
        <returns>Die Adresse im nicht verwalteten Speicher, in die der <paramref name="s" />-Parameter kopiert wurde, oder 0, wenn ein NULL-Objekt bereitgestellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> Methode eignet sich für benutzerdefiniertes Marshalling geht oder wenn das Mischen von verwaltetem und nicht verwaltetem Code. Da der nicht verwalteten Speicher für eine Zeichenfolge in dieser Methode belegt wird, müssen Sie den Speicher immer freigeben, durch den Aufruf <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>. Die Zeichen der Zeichenfolge werden als ANSI-Zeichen kopiert werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> gemarshallt und Entschlüsseln des Inhalts der Methode ein <xref:System.Security.SecureString> Objekt, das einen nicht verwalteten Speicherblock. Es verwendet dann die <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> Methode, die nicht verwaltete Block mit Nullen gefüllt und freigegeben.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="s" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Auf dem aktuellen Computer wird nicht Windows 2000 Service Pack 3 oder höher ausgeführt.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <block subset="none" type="usage">
          <para>Diese Methode ist nur auf Computern unter Windows 2000 Service Pack 3 oder höher unterstützt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToCoTaskMemUnicode (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToCoTaskMemUnicode(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">Das zu kopierende verwaltete Objekt.</param>
        <summary>Kopiert den Inhalt eines verwalteten <see cref="T:System.Security.SecureString" />-Objekts in einen Speicherblock, der von der nicht verwalteten Speicherbelegung für COM-Aufgaben reserviert wurde.</summary>
        <returns>Die Adresse im nicht verwalteten Speicher, in die der <paramref name="s" />-Parameter kopiert wurde, oder 0, wenn ein NULL-Objekt bereitgestellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> Methode eignet sich für benutzerdefiniertes Marshalling geht oder wenn das Mischen von verwaltetem und nicht verwaltetem Code. Da der nicht verwalteten Speicher für eine Zeichenfolge in dieser Methode belegt wird, müssen Sie den Speicher immer freigeben, durch Aufrufen der <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> Methode. Die Zeichen der Zeichenfolge werden als Unicode-Zeichen kopiert werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> gemarshallt und Entschlüsseln des Inhalts der Methode ein <xref:System.Security.SecureString> Objekt, das einen nicht verwalteten Speicherblock. Es verwendet dann die <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> Methode, die nicht verwaltete Block mit Nullen gefüllt und freigegeben.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="s" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Auf dem aktuellen Computer wird nicht Windows 2000 Service Pack 3 oder höher ausgeführt.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <block subset="none" type="usage">
          <para>Diese Methode ist nur auf Computern unter Windows 2000 Service Pack 3 oder höher unterstützt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToGlobalAllocAnsi (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToGlobalAllocAnsi(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">Das zu kopierende verwaltete Objekt.</param>
        <summary>Kopiert den Inhalt eines verwalteten <see cref="T:System.Security.SecureString" /> in den nicht verwalteten Speicher und konvertiert ihn beim Kopieren in das ANSI-Format.</summary>
        <returns>Die Adresse im nicht verwalteten Speicher, in die der <paramref name="s" />-Parameter kopiert wurde, oder 0, wenn ein NULL-Objekt bereitgestellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> Methode eignet sich für benutzerdefiniertes Marshalling geht oder wenn das Mischen von verwaltetem und nicht verwaltetem Code. Da der nicht verwalteten Speicher für eine Zeichenfolge in dieser Methode belegt wird, müssen Sie den Speicher immer freigeben, durch Aufrufen der <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> gemarshallt und Entschlüsseln des Inhalts der Methode ein <xref:System.Security.SecureString> Objekt, das einen nicht verwalteten Speicherblock. Es verwendet dann die <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> Methode, die nicht verwaltete Block mit Nullen gefüllt und freigegeben.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="s" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Auf dem aktuellen Computer wird nicht Windows 2000 Service Pack 3 oder höher ausgeführt.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <block subset="none" type="usage">
          <para>Diese Methode ist nur auf Computern unter Windows 2000 Service Pack 3 oder höher unterstützt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToGlobalAllocUnicode (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToGlobalAllocUnicode(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">Das zu kopierende verwaltete Objekt.</param>
        <summary>Kopiert den Inhalt eines verwalteten <see cref="T:System.Security.SecureString" />-Objekts in den nicht verwalteten Speicher.</summary>
        <returns>Die Adresse im nicht verwalteten Arbeitsspeicher, an die <paramref name="s" /> kopiert wurde, oder 0, wenn <paramref name="s" /> ein <see cref="T:System.Security.SecureString" />-Objekt mit der Länge 0 ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> Methode eignet sich für das Marshalling von benutzerdefinierten oder für die Verwendung beim Kombinieren von verwaltetem und nicht Code verwaltetem. Da der nicht verwalteten Speicher für eine Zeichenfolge in dieser Methode belegt wird, müssen Sie den Speicher immer freigeben, durch Aufrufen der <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> Methode mit dem nicht verwalteten `LogonUser` Funktion zum Ausführen der Identitätswechsel mit den <xref:System.Security.SecureString> Klasse. Anschließend wird die <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> Methode 0 (null) und des Verweis nicht verwalteten Zeichenfolge.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="s" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Auf dem aktuellen Computer wird nicht Windows 2000 Service Pack 3 oder höher ausgeführt.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <block subset="none" type="usage">
          <para>Diese Methode ist nur auf Computern unter Windows 2000 Service Pack 3 oder höher unterstützt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetComObjectData">
      <MemberSignature Language="C#" Value="public static bool SetComObjectData (object obj, object key, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetComObjectData(object obj, object key, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetComObjectData (obj As Object, key As Object, data As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetComObjectData(System::Object ^ obj, System::Object ^ key, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das COM-Objekt, in dem die Daten gespeichert werden sollen.</param>
        <param name="key">Der Schlüssel in der internen Hashtabelle des COM-Objekts, in dem die Daten gespeichert werden sollen.</param>
        <param name="data">Die festzulegenden Daten.</param>
        <summary>Legt Daten fest, auf die durch den angegebenen Schlüssel im angegebenen COM-Objekt verwiesen wird.</summary>
        <returns>
          <see langword="true" />, wenn die Daten erfolgreich festgelegt wurden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle COM-Objekte umschlossen eine [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) haben eine zugeordnete Hashtabelle, zu dem <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A> fügt Daten hinzu. <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType> Ruft Daten aus der Hashtabelle ab. Sie müssen sich nie in einer dieser Methoden vom Code aufrufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> ist kein COM-Objekt.  
  
 - oder -   
  
 <paramref name="obj" /> ist ein [!INCLUDE[wrt](~/includes/wrt-md.md)]-Objekt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SizeOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die nicht verwaltete Größe einer Klasse in Bytes zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf (structure As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int SizeOf(System::Object ^ structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="structure">Das Objekt, dessen Größe zurückgegeben werden soll.</param>
        <summary>Gibt die nicht verwaltete Größe eines Objekts in Bytes zurück.</summary>
        <returns>Die Größe des angegebenen Objekts in nicht verwaltetem Code.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode akzeptiert eine Instanz einer Struktur, die ein Verweistyp oder ein geschachtelter Werttyp sein kann. Das Layout muss sequenziell oder explizit sein.  
  
 Die zurückgegebene Größe ist die Größe des nicht verwalteten Objekts. Die verwalteten und nicht verwaltete Größe eines Objekts können sich unterscheiden. Für Zeichentypen entspricht, wird die Größe von beeinflusst die <xref:System.Runtime.InteropServices.CharSet> Wert für diese Klasse angewendet.  
  
 Können Sie die <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> Methode, um zu bestimmen, wie viel nicht verwalteten Speicher mithilfe der <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> und <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine verwaltete Struktur erstellt, werden in nicht verwalteten Speicher übertragen und dann wieder in den verwalteten Speicher werden übertragen. Dieses Beispiel verwendet die <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> Methode, um zu bestimmen, wie viel Speicher belegen.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="structure" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int SizeOf(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">Der Typ, dessen Größe zurückgegeben werden soll.</param>
        <summary>Gibt die Größe eines nicht verwalteten Typs in Bytes zurück.</summary>
        <returns>Die Größe des angegebenen Typs in nicht verwaltetem Code.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, wenn Sie nicht über eine Struktur verfügen. Das Layout muss sequenziell oder explizit sein.  
  
 Die zurückgegebene Größe ist die Größe des nicht verwalteten Typs an. Die verwalteten und nicht verwaltete Größe eines Objekts können sich unterscheiden. Für Zeichentypen entspricht, wird die Größe von beeinflusst die <xref:System.Runtime.InteropServices.CharSet> Wert für diese Klasse angewendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Aufrufen der <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A>-Methode veranschaulicht. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Runtime.InteropServices.Marshal> Klasse.  
  
 [!code-cpp[Marshal#3](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#3)]
 [!code-csharp[Marshal#3](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#3)]
 [!code-vb[Marshal#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="t" />-Parameter ist eine generische Typdefinition.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="t" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int SizeOf();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der Typ, dessen Größe zurückgegeben werden soll.</typeparam>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Gibt die Größe eines nicht verwalteten Typs in Bytes zurück.</summary>
        <returns>Die Größe, in Bytes, des Typs, der durch den <typeparamref name="T" /> generischen Typparameter angegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode verwenden, wenn Sie nicht über eine Struktur verfügen. Das Layout muss sequenziell oder explizit sein.  
  
 Die zurückgegebene Größe ist die Größe des nicht verwalteten Typs an. Die verwalteten und nicht verwaltete Größe eines Objekts können sich unterscheiden. Für Zeichentypen entspricht, wird die Größe von beeinflusst die <xref:System.Runtime.InteropServices.CharSet> Wert für diese Klasse angewendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; (T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;(!!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) (structure As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int SizeOf(T structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des der <c>Struktur</c> Parameter.</typeparam>
        <param name="structure">Das Objekt, dessen Größe zurückgegeben werden soll.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Gibt die nicht verwaltete Größe eines Objekts eines angegebenen Typs in Bytes zurück.</summary>
        <returns>Die Größe des angegebenen Objekts in nicht verwaltetem Code in Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode akzeptiert eine Instanz einer Struktur, die ein Verweistyp oder ein geschachtelter Werttyp sein kann. Das Layout muss sequenziell oder explizit sein.  
  
 Die zurückgegebene Größe ist die Größe des nicht verwalteten Objekts. Die verwalteten und nicht verwaltete Größe eines Objekts können sich unterscheiden. Für Zeichentypen entspricht, wird die Größe von beeinflusst die <xref:System.Runtime.InteropServices.CharSet> Wert für diese Klasse angewendet.  
  
 Sie können die <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> Methode, um zu bestimmen, wie viel Speicher mithilfe der <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> und <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> Methoden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="structure" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr StringToBSTR (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToBSTR(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToBSTR (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToBSTR(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die zu kopierende verwaltete Zeichenfolge.</param>
        <summary>Weist einen [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) zu und kopiert den Inhalt eines verwalteten <see cref="T:System.String" /> hinein.</summary>
        <returns>Ein nicht verwalteter Zeiger auf das <see langword="BSTR" /> oder 0, wenn <paramref name="s" /> NULL ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A> eignet sich für das Marshalling von benutzerdefinierten oder beim Kombinieren von verwaltetem und nicht verwaltetem Code. Immer freigeben, da diese Methode belegt wird der nicht verwalteten Speicher für eine Zeichenfolge, die `BSTR` abschließend durch Aufrufen von <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType>. Diese Methode stellt die Umkehrfunktionen der <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge für <paramref name="s" /> liegt außerhalb des gültigen Bereichs.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemAnsi (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemAnsi(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine zu kopierende verwaltete Zeichenfolge.</param>
        <summary>Kopiert den Inhalt eines verwalteten <see cref="T:System.String" /> in einen Speicherblock, der von der nicht verwalteten Speicherbelegung für COM-Aufgaben reserviert wurde.</summary>
        <returns>Eine ganze Zahl, die einen Zeiger auf den für die Zeichenfolge belegten Speicherblock darstellt, oder 0, wenn <paramref name="s" /> gleich <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A> eignet sich für das Marshalling von benutzerdefinierten oder beim Kombinieren von verwaltetem und nicht verwaltetem Code. Da der nicht verwalteten Speicher für eine Zeichenfolge in dieser Methode belegt wird, müssen Sie den Speicher immer freigeben, durch den Aufruf <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>. Diese Methode stellt die Umkehrfunktionen der <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>. Die Zeichen der Zeichenfolge werden als ANSI-Zeichen kopiert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="s" />-Parameter übersteigt die vom Betriebssystem zugelassene maximale Länge.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemAuto (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemAuto(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine zu kopierende verwaltete Zeichenfolge.</param>
        <summary>Kopiert den Inhalt eines verwalteten <see cref="T:System.String" /> in einen Speicherblock, der von der nicht verwalteten Speicherbelegung für COM-Aufgaben reserviert wurde.</summary>
        <returns>Der reservierte Speicherblock oder 0, wenn <paramref name="s" /> gleich <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A> eignet sich für das Marshalling von benutzerdefinierten oder für die Verwendung beim Kombinieren von verwaltetem und nicht verwaltetem Code. Da der nicht verwalteten Speicher für eine Zeichenfolge in dieser Methode belegt wird, müssen Sie den Speicher immer freigeben, durch den Aufruf <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>. Diese Methode stellt die Umkehrfunktionen der <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.  
  
 Die Zeichen der Zeichenfolge werden als ANSI oder Unicode-Zeichen, und je nach Betriebssystem kopiert, auf dem der Code ausgeführt wird. Unter Windows 98 werden die Zeichen als ANSI-Zeichen kopiert werden. Unter Windows NT 4.0, Windows 2000, Windows XP und Windows Server 2003-Produktfamilie werden die Zeichen als Unicode-Zeichen kopiert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge für <paramref name="s" /> liegt außerhalb des gültigen Bereichs.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemUni (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemUni(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine zu kopierende verwaltete Zeichenfolge.</param>
        <summary>Kopiert den Inhalt eines verwalteten <see cref="T:System.String" /> in einen Speicherblock, der von der nicht verwalteten Speicherbelegung für COM-Aufgaben reserviert wurde.</summary>
        <returns>Eine ganze Zahl, die einen Zeiger auf den für die Zeichenfolge belegten Speicherblock darstellt, oder 0, wenn s gleich <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A> eignet sich für das Marshalling von benutzerdefinierten oder für die Verwendung beim Kombinieren von verwaltetem und nicht verwaltetem Code. Da der nicht verwalteten Speicher für eine Zeichenfolge in dieser Methode belegt wird, müssen Sie den Speicher immer freigeben, durch den Aufruf <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>. Diese Methode stellt die Umkehrfunktionen der <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>. Die Zeichen der Zeichenfolge werden als Unicode-Zeichen kopiert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="s" />-Parameter übersteigt die vom Betriebssystem zugelassene maximale Länge.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUTF8 (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUTF8(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemUTF8 (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemUTF8(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalAnsi (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalAnsi(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine zu kopierende verwaltete Zeichenfolge.</param>
        <summary>Kopiert den Inhalt eines verwalteten <see cref="T:System.String" /> in den nicht verwalteten Speicher und konvertiert ihn beim Kopieren in das ANSI-Format.</summary>
        <returns>Die Adresse im nicht verwalteten Arbeitsspeicher, an die <paramref name="s" /> kopiert wurde, oder 0, wenn <paramref name="s" /> gleich <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> eignet sich für das Marshalling von benutzerdefinierten oder beim Kombinieren von verwaltetem und nicht verwaltetem Code. Da der nicht verwalteten Speicher für eine Zeichenfolge in dieser Methode belegt wird, müssen Sie den Speicher immer freigeben, durch den Aufruf <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>. <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> Stellt die Umkehrfunktion von <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.  
  
 Diese Methode kopiert eingebettete Null-Zeichen und enthält ein abschließendes Nullzeichen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie der Inhalt eines verwalteten konvertiert <xref:System.String> -Klasse auf nicht verwalteten Speicher und dem nicht verwalteten Speicher, wenn Fertig klicken Sie dann löschen.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="s" />-Parameter übersteigt die vom Betriebssystem zugelassene maximale Länge.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalAuto (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalAuto(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine zu kopierende verwaltete Zeichenfolge.</param>
        <summary>Kopiert den Inhalt eines verwalteten <see cref="T:System.String" /> in den nicht verwalteten Speicher und konvertiert ihn ggf. in das ANSI-Format.</summary>
        <returns>Die Adresse im nicht verwalteten Arbeitsspeicher, an die die Zeichenfolge kopiert wurde, oder 0, wenn <paramref name="s" /> gleich <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A> eignet sich für das Marshalling von benutzerdefinierten oder für die Verwendung beim Kombinieren von verwaltetem und nicht verwaltetem Code. Da der nicht verwalteten Speicher für eine Zeichenfolge in dieser Methode belegt wird, müssen Sie den Speicher immer freigeben, durch den Aufruf <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>. Diese Methode stellt die Umkehrfunktionen der <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.  
  
 Diese Methode kopiert eingebettete Null-Zeichen und enthält ein abschließendes Nullzeichen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie der Inhalt eines verwalteten konvertiert <xref:System.String> -Klasse auf nicht verwalteten Speicher und dem nicht verwalteten Speicher, wenn Fertig klicken Sie dann löschen.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAuto#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAuto/CPP/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalUni (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalUni(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine zu kopierende verwaltete Zeichenfolge.</param>
        <summary>Kopiert den Inhalt eines verwalteten <see cref="T:System.String" /> in den nicht verwalteten Speicher.</summary>
        <returns>Die Adresse im nicht verwalteten Arbeitsspeicher, an die <paramref name="s" /> kopiert wurde, oder 0, wenn <paramref name="s" /> gleich <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A> eignet sich für das Marshalling von benutzerdefinierten oder für die Verwendung beim Kombinieren von verwaltetem und nicht verwaltetem Code. Da der nicht verwalteten Speicher für eine Zeichenfolge in dieser Methode belegt wird, müssen Sie den Speicher immer freigeben, durch den Aufruf <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>. Diese Methode stellt die Umkehrfunktionen der <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.  
  
 Diese Methode kopiert eingebettete Null-Zeichen und enthält ein abschließendes Nullzeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Die Methode konnte nicht genügend Speicher für den systemeigenen Heap belegen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="s" />-Parameter übersteigt die vom Betriebssystem zugelassene maximale Länge.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr">
      <MemberSignature Language="C#" Value="public static void StructureToPtr (object structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr(object structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StructureToPtr (structure As Object, ptr As IntPtr, fDeleteOld As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void StructureToPtr(System::Object ^ structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="structure">Ein verwaltetes Objekt mit den zu marshallenden Daten. Dieses Objekt muss eine Struktur oder Instanz einer formatierten Klasse sein.</param>
        <param name="ptr">Ein Zeiger auf einen nicht verwalteten Speicherblock, der vor dem Aufruf der Methode belegt werden muss.</param>
        <param name="fDeleteOld">
          <see langword="true" />, wenn die <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />-Methode für den <c>ptr</c>-Parameter aufgerufen werden soll, bevor diese Methode die Daten kopiert. Der Block muss gültige Daten enthalten. Beachten Sie, dass das Übergeben von <see langword="false" />, wenn der Speicherblock bereits Daten enthält, zu einem Speicherverlust führen kann.</param>
        <summary>Marshallt Daten aus einem verwalteten Objekt zu einem nicht verwalteten Speicherblock.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `structure` ein Werttyp ist, wird er mittels Boxing konvertiert oder mittels Unboxing zurückkonvertiert werden kann. Wenn sie mittels Boxing konvertiert wird, wird es vor dem Kopieren mittels Unboxing konvertiert.  
  
 Eine formatierte Klasse ist ein Verweistyp, deren Layout, indem angegeben wird, die <xref:System.Runtime.InteropServices.StructLayoutAttribute> Attribut, entweder als <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> oder <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.  
  
 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> kopiert den Inhalt des `structure` zu den voraus belegten Speicherblock, der `ptr` -Parameter zeigt. Wenn `structure` Verweistypen, die in COM-Schnittstellenzeigern gemarshallt enthält (Schnittstellen, Klassen ohne Layout und <xref:System.Object?displayProperty=nameWithType>), werden die verwalteten Objekte mit Verweiszähler aufrechterhalten. Alle anderen Verweistypen (z. B. Zeichenfolgen und Arrays) werden Kopien gemarshallt. Um diese verwaltete oder nicht verwaltete Objekte freizugeben, rufen Sie die <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType> -Methode auf, bevor Sie den Speicherblock freizugeben.  
  
 Bei Verwendung der <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> Geben Sie die Methode, um eine andere Instanz auf den Speicherblock zu einem späteren Zeitpunkt kopieren `true` für `fDeleteOld` zählt Sie so entfernen Sie den Verweis für Verweistypen, die in der vorherigen Instanz. Andernfalls werden die verwaltete Verweise nicht verwaltete Typesand Kopien effektiv verloren.  
  
 Das allgemeine Muster für die Verwendung von <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> lautet wie folgt:  
  
1.  Beim ersten Aufruf von der <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> -Methode auf, nachdem Sie ein Speicherblock belegt wurde, `fDeleteOld` muss `false`, da es keine Inhalte sind gelöscht.  
  
    > [!IMPORTANT]
    >  Geben Sie `true` für `fDeleteOld` nur, wenn der Block gültige Daten enthält.  
  
2.  Wenn Sie eine andere Instanz, auf den Speicherblock kopieren und das Objekt enthält die Verweistypen, `fDeleteOld` muss `true` um Verweistypen in den alten Inhalt freizugeben.  
  
3.  Wenn das Objekt Verweistypen enthält, müssen Sie Aufrufen der <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> -Methode auf, bevor Sie den Speicherblock freizugeben.  
  
> [!NOTE]
>  Verwenden Sie zum Anheften einer vorhandenen Struktur, anstatt Sie zu kopieren, die <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> Typ ein fixiertes Handle für die Struktur zu erstellen. Weitere Informationen zum anheften, finden Sie unter [kopieren und fixieren](~/docs/framework/interop/copying-and-pinning.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine verwaltete Struktur erstellt, überträgt er an nicht verwalteten Speicher mithilfe der <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> -Methode, und klicken Sie dann wieder mit verwalteten Speicher überträgt die <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> Methode.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="structure" /> ist ein Verweistyp, der keine formatierte Klasse ist.  
  
 - oder -   
  
 <paramref name="structure" /> ist eine Instanz eines generischen Typs (nur in .NET Framework 4.5 und früheren Versionen). </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void StructureToPtr&lt;T&gt; (T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr&lt;T&gt;(!!T structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StructureToPtr(Of T) (structure As T, ptr As IntPtr, fDeleteOld As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des verwalteten Objekts.</typeparam>
        <param name="structure">Ein verwaltetes Objekt mit den zu marshallenden Daten. Dieses Objekt muss eine Struktur oder Instanz einer formatierten Klasse sein.</param>
        <param name="ptr">Ein Zeiger auf einen nicht verwalteten Speicherblock, der vor dem Aufruf der Methode belegt werden muss.</param>
        <param name="fDeleteOld">
          <see langword="true" />, wenn die <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />-Methode für den <c>ptr</c>-Parameter aufgerufen werden soll, bevor diese Methode die Daten kopiert. Der Block muss gültige Daten enthalten. Beachten Sie, dass das Übergeben von <see langword="false" />, wenn der Speicherblock bereits Daten enthält, zu einem Speicherverlust führen kann.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Marshallt Daten aus einem verwalteten Objekt eines festgelegten Typs zu einem nicht verwalteten Speicherblock.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine formatierte Klasse ist ein Verweistyp, deren Layout, indem angegeben wird, die <xref:System.Runtime.InteropServices.StructLayoutAttribute> Attribut, entweder als <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> oder <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.  
  
 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> kopiert den Inhalt des `structure` zu den voraus belegten Speicherblock, der `ptr` -Parameter zeigt. Wenn `structure` Verweistypen, die in COM-Schnittstellenzeigern gemarshallt enthält (Schnittstellen, Klassen ohne Layout und <xref:System.Object?displayProperty=nameWithType>), werden die verwalteten Objekte mit Verweiszähler aufrechterhalten. Alle anderen Verweistypen (z. B. Zeichenfolgen und Arrays) werden Kopien gemarshallt. Um diese verwaltete oder nicht verwaltete Objekte freizugeben, rufen Sie die <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29> -Methode auf, bevor Sie den Speicherblock freizugeben.  
  
 Bei Verwendung der <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> Geben Sie die Methode, um eine andere Instanz auf den Speicherblock zu einem späteren Zeitpunkt kopieren `true` für `fDeleteOld` zählt Sie so entfernen Sie den Verweis für Verweistypen, die in der vorherigen Instanz. Andernfalls sind die Verweistypen verwalteten und nicht verwalteten Kopien effektiv verloren.  
  
 Das allgemeine Muster für die Verwendung von <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> lautet wie folgt:  
  
1.  Beim ersten Aufruf von der <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> -Methode auf, nachdem Sie ein Speicherblock belegt wurde, `fDeleteOld` muss `false`, da es keine Inhalte sind gelöscht.  
  
    > [!IMPORTANT]
    >  Geben Sie `true` für `fDeleteOld` nur, wenn der Block gültige Daten enthält.  
  
2.  Wenn Sie eine andere Instanz, auf den Speicherblock kopieren und das Objekt enthält die Verweistypen, `fDeleteOld` muss `true` um Verweistypen in den alten Inhalt freizugeben.  
  
3.  Wenn das Objekt Verweistypen enthält, müssen Sie Aufrufen der <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> -Methode auf, bevor Sie den Speicherblock freizugeben.  
  
> [!NOTE]
>  Verwenden Sie zum Anheften einer vorhandenen Struktur, anstatt Sie zu kopieren, die <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> Typ ein fixiertes Handle für die Struktur zu erstellen. Weitere Informationen zum anheften, finden Sie unter [kopieren und fixieren](~/docs/framework/interop/copying-and-pinning.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="structure" /> ist ein Verweistyp, der keine formatierte Klasse ist.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="SystemDefaultCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemDefaultCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemDefaultCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SystemDefaultCharSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int SystemDefaultCharSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt die Standardzeichengröße für das System dar. Der Standardwert ist 2 für Unicode-Systeme und 1 für ANSI-Systeme. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> Feld. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Runtime.InteropServices.Marshal> Klasse.  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SystemMaxDBCSCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemMaxDBCSCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemMaxDBCSCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SystemMaxDBCSCharSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int SystemMaxDBCSCharSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt die maximale Größe eines DBCS (Double-Byte Character Set) für das aktuelle Betriebssystem in Bytes dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> Feld. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Runtime.InteropServices.Marshal> Klasse.  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ThrowExceptionForHR">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löst eine Ausnahme mit einem bestimmten HRESULT-Fehlerwert aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ThrowExceptionForHR (errorCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ThrowExceptionForHR(int errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode">Das der gewünschten Ausnahme entsprechende HRESULT.</param>
        <summary>Löst eine Ausnahme mit einem bestimmten HRESULT-Fehlerwert aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt ein Exception-Objekt für den angegebenen HRESULT-Fehler. Wenn das HRESULT 0 oder positiv ist (einen Erfolgscode) ist, erfolgt die Methodenrückgabe ohne erstellen oder eine Ausnahme auszulösen.  
  
 Beachten Sie, dass die <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29> Methodenrückgabe eine Ausnahme, die auf der Grundlage der [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) Schnittstelle des aktuellen Threads an, wenn diese festgelegt ist. In diesem Fall die `errorCode` Parameter wird ignoriert.  
  
 Einige Fehler-HRESULTs zuordnen definierten Ausnahmen aus, während andere nicht. Wenn ein HRESULT einer definierten Ausnahme zugeordnet <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> erstellt eine Instanz der Ausnahme und wird ausgelöst. Andernfalls, erstellt er eine Instanz des <xref:System.Runtime.InteropServices.COMException>das Codefeld Fehler mit HRESULT initialisiert und löst diese Ausnahme aus. Wenn <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> wird aufgerufen, um zusätzliche Informationen über den Fehler mithilfe der nicht verwalteten abzurufen versucht [GetErrorInfo](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx) Funktion.  
  
 Die Zuordnung von jedem HRESULT zu seiner vergleichbaren Ausnahmeklasse in .NET Framework, finden Sie unter [Vorgehensweise: Zuordnen von HRESULTs und Ausnahmen](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).  
  
 In einigen Fällen <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> möglicherweise eine Ausnahme von einem vorherigen COM-Methodenaufruf zurück. In diesem Fall können Sie die folgende problemumgehung verwenden und übergeben `IntPtr(-1)` als zweiten Parameter (`errorInfo`):  
  
```  
[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]  
public static void ThrowExceptionForHR(interrorCode,IntPtrerrorInfo)  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.InteropServices.COMException" />
      </Docs>
    </Member>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ThrowExceptionForHR (errorCode As Integer, errorInfo As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode">Das der gewünschten Ausnahme entsprechende HRESULT.</param>
        <param name="errorInfo">Ein Zeiger auf die [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)-Schnittstelle, die weitere Informationen über den Fehler bereitstellt. Sie können <c>IntPtr(0)</c> angeben, um die aktuelle [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)-Schnittstelle zu verwenden, oder <c>IntPtr(-1)</c>, um die aktuelle [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)-Schnittstelle zu ignorieren und die Ausnahme direkt aus dem Fehlercode zu erstellen.</param>
        <summary>Löst eine Ausnahme mit einem bestimmten Fehler-HRESULT auf Grundlage der angegebenen [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)-Schnittstelle aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt ein Exception-Objekt für den angegebenen HRESULT-Fehler. Wenn das HRESULT 0 oder positiv ist (einen Erfolgscode) ist, erfolgt die Methodenrückgabe ohne erstellen oder eine Ausnahme auszulösen.  
  
 Die <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> Methode Versionen der `errorInfo` -Parameter, verringert den COM-verweisen, die Anzahl der dem [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) Schnittstelle.  
  
 Beachten Sie, dass die <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> Methodenrückgabe eine Ausnahme, die auf der Grundlage der [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) Schnittstelle des aktuellen Threads an, wenn diese festgelegt ist. In diesem Fall die `errorCode` Parameter wird ignoriert.  
  
 Einige Fehler-HRESULTs zuordnen definierten Ausnahmen aus, während andere nicht. Wenn ein HRESULT einer definierten Ausnahme zugeordnet <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> erstellt eine Instanz der Ausnahme und wird ausgelöst. Andernfalls, erstellt er eine Instanz des <xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType>das Codefeld Fehler mit HRESULT initialisiert und löst diese Ausnahme aus. Die `errorInfo` Parameter wird verwendet, um zusätzliche Informationen über den Fehler abzurufen.  
  
 Die Zuordnung von jedem HRESULT zu seiner vergleichbaren Ausnahmeklasse in .NET Framework, finden Sie unter [Vorgehensweise: Zuordnen von HRESULTs und Ausnahmen](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.InteropServices.COMException" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeAddrOfPinnedArrayElement (arr As Array, index As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr UnsafeAddrOfPinnedArrayElement(Array ^ arr, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr">Das Array, das das gewünschte Element enthält.</param>
        <param name="index">Der Index im <c>arr</c>-Parameter des gewünschten Elements.</param>
        <summary>Ruft die Adresse des Elements am angegebenen Index des angegebenen Arrays ab.</summary>
        <returns>Die Adresse des <paramref name="index" /> im <paramref name="arr" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array muss angeheftet werden, mithilfe einer <xref:System.Runtime.InteropServices.GCHandle> vor der Übergabe an diese Methode. Um eine optimale Leistung überprüft diese Methode nicht das Array übergeben wird; Dies kann zu unerwartetem Verhalten führen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement&lt;T&gt; (T[] arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement&lt;T&gt;(!!T[] arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeAddrOfPinnedArrayElement(Of T) (arr As T(), index As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr UnsafeAddrOfPinnedArrayElement(cli::array &lt;T&gt; ^ arr, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arr" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des Arrays.</typeparam>
        <param name="arr">Das Array, das das gewünschte Element enthält.</param>
        <param name="index">Der Index des gewünschten Elements im <c>arr</c>-Array.</param>
        <summary>[Wird nur in .NET Framework 4.5.1 und neueren Versionen unterstützt]  
  
 Ruft die Adresse des Elements am angegebenen Index in einem Arrays des angegebenen Typs ab.</summary>
        <returns>Die Adresse des <paramref name="index" /> im <paramref name="arr" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array muss angeheftet werden, mithilfe einer <xref:System.Runtime.InteropServices.GCHandle> vor der Übergabe an diese Methode. Um eine optimale Leistung überprüft diese Methode nicht das Array übergeben wird; Dies kann zu unerwartetem Verhalten führen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteByte">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt einen einzelnen Bytewert in den nicht verwalteten Speicher.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As IntPtr, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(IntPtr ptr, System::Byte val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse im nicht verwalteten Speicher, in die geschrieben werden soll.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt einen einzelnen Bytewert in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil Bytearray, der den entfallenden Aufwand für das Kopieren der eines nicht verwalteten Arrays (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
   
  
## Examples  
 Im folgende Beispiel erstellt einen nicht verwalteten Speicherblock, schreibt ein Byte in den nicht verwalteten Speicher, das Byte wieder aus dem nicht verwalteten Arbeitsspeicher gelesen und dann den nicht verwalteten Arbeitsspeicher frei.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" /> ist kein erkanntes Format.  
  
 - oder -   
  
 <paramref name="ptr" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="ptr" /> ist ungültig.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As IntPtr, ofs As Integer, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(IntPtr ptr, int ofs, System::Byte val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher, in die geschrieben werden soll.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Schreiben hinzugefügt wird.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt einen einzelnen Bytewert an einem angegebenen Offset in den nicht verwalteten Arbeitsspeicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil Bytearray, der den entfallenden Aufwand für das Kopieren der eines nicht verwalteten Arrays (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (object ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte([out] object ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As Object, ofs As Integer, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(System::Object ^ ptr, int ofs, System::Byte val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher des Zielobjekts.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Schreiben hinzugefügt wird.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt einen einzelnen Bytewert an einem angegebenen Offset in den nicht verwalteten Arbeitsspeicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil Bytearray, der den entfallenden Aufwand für das Kopieren der eines nicht verwalteten Arrays (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> ist ein <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Objekt. Diese Methode akzeptiert keine <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Parameter.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt16">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt eine 16-Bit-Ganzzahl mit Vorzeichen in den nicht verwalteten Speicher. Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, char val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse im nicht verwalteten Speicher, in die geschrieben werden soll.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt ein Zeichen als 16-Bit-Ganzzahl in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 16-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" /> ist kein erkanntes Format.  
  
 - oder -   
  
 <paramref name="ptr" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="ptr" /> ist ungültig.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, short val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse im nicht verwalteten Speicher, in die geschrieben werden soll.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt eine 16-Bit-Ganzzahl in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 16-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" /> ist kein erkanntes Format.  
  
 - oder -   
  
 <paramref name="ptr" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="ptr" /> ist ungültig.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, ofs As Integer, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, int ofs, char val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im systemeigenen Heap, in die geschrieben werden soll.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Schreiben hinzugefügt wird.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt den Wert einer 16-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 16-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, ofs As Integer, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, int ofs, short val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher, in die geschrieben werden soll.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Schreiben hinzugefügt wird.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt den Wert einer 16-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 16-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As Object, ofs As Integer, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(System::Object ^ ptr, int ofs, char val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher des Zielobjekts.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Schreiben hinzugefügt wird.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt den Wert einer 16-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 16-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> ist ein <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Objekt. Diese Methode akzeptiert keine <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Parameter.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As Object, ofs As Integer, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(System::Object ^ ptr, int ofs, short val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher des Zielobjekts.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Schreiben hinzugefügt wird.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt den Wert einer 16-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 16-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> ist ein <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Objekt. Diese Methode akzeptiert keine <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Parameter.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt eine 32-Bit-Ganzzahl mit Vorzeichen in den nicht verwalteten Speicher. Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As IntPtr, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(IntPtr ptr, int val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse im nicht verwalteten Speicher, in die geschrieben werden soll.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt eine 32-Bit-Ganzzahl mit Vorzeichen in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 32-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" /> ist kein erkanntes Format.  
  
 - oder -   
  
 <paramref name="ptr" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="ptr" /> ist ungültig.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As IntPtr, ofs As Integer, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(IntPtr ptr, int ofs, int val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher, in die geschrieben werden soll.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Schreiben hinzugefügt wird.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt den Wert einer 32-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 32-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (object ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32([out] object ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As Object, ofs As Integer, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(System::Object ^ ptr, int ofs, int val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher des Zielobjekts.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Schreiben hinzugefügt wird.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt den Wert einer 32-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 32-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> ist ein <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Objekt. Diese Methode akzeptiert keine <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Parameter.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt64">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt eine 64-Bit-Ganzzahl mit Vorzeichen in den nicht verwalteten Speicher. Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As IntPtr, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(IntPtr ptr, long val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse im nicht verwalteten Speicher, in die geschrieben werden soll.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt eine 64-Bit-Ganzzahl mit Vorzeichen in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 64-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" /> ist kein erkanntes Format.  
  
 - oder -   
  
 <paramref name="ptr" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="ptr" /> ist ungültig.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As IntPtr, ofs As Integer, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(IntPtr ptr, int ofs, long val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">Die zu schreibende Basisadresse im nicht verwalteten Speicher.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Schreiben hinzugefügt wird.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt den Wert einer 64-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 64-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (object ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64([out] object ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As Object, ofs As Integer, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(System::Object ^ ptr, int ofs, long val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher des Zielobjekts.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Schreiben hinzugefügt wird.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt den Wert einer 64-Bit-Ganzzahl mit Vorzeichen an einem angegebenen Offset in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten 64-Bit mit Vorzeichen, ein nicht verwaltetes Array kopieren den entfallenden (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> ist ein <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Objekt. Diese Methode akzeptiert keine <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Parameter.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteIntPtr">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt einen Ganzzahlwert von prozessoreigener Größe in den nicht verwalteten Speicher. 32-Bit-Ganzzahlen werden auf 32-Bit-Systemen geschrieben, und 64-Bit-Ganzzahlen werden auf 64-Bit-Systemen geschrieben. Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As IntPtr, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(IntPtr ptr, IntPtr val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Adresse im nicht verwalteten Speicher, in die geschrieben werden soll.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Ganzzahlwert von prozessoreigener Größe in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil `IntPtr` -Array, sodass ein nicht verwaltetes Array kopiert (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" /> ist kein erkanntes Format.  
  
 - oder -   
  
 <paramref name="ptr" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="ptr" /> ist ungültig.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As IntPtr, ofs As Integer, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher, in die geschrieben werden soll.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Schreiben hinzugefügt wird.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Ganzzahlwert von prozessoreigener Größe am angegebenen Offset in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode schreibt eine 32-Bit-Ganzzahl auf 32-Bit-Systemen und eine 64-Bit-Ganzzahl in 64-Bit-Systemen.  
  
 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil `IntPtr` -Array, sodass ein nicht verwaltetes Array kopiert (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das Lesen und Schreiben in ein nicht verwaltetes Array mithilfe der <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> und <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> Methoden.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (object ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr([out] object ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As Object, ofs As Integer, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(System::Object ^ ptr, int ofs, IntPtr val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Die Basisadresse im nicht verwalteten Speicher des Zielobjekts.</param>
        <param name="ofs">Ein zusätzlicher Byteoffset, der dem <c>ptr</c>-Parameter vor dem Schreiben hinzugefügt wird.</param>
        <param name="val">Der zu schreibende Wert.</param>
        <summary>Schreibt einen Ganzzahlwert von prozessoreigener Größe in den nicht verwalteten Speicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> ermöglicht die direkte Interaktion mit einem nicht verwalteten C-Stil Bytearray, der den entfallenden Aufwand für das Kopieren der eines nicht verwalteten Arrays (mit <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) in ein separates verwaltetes Array vor dem die Elementwerte festlegen.  
  
 Das Schreiben in nicht ausgerichtete Speicheradressen wird unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">Die Basisadresse (<paramref name="ptr" />) und das Offsetbyte (<paramref name="ofs" />) erzeugen NULL oder eine ungültige Adresse.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> ist ein <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Objekt. Diese Methode akzeptiert keine <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />-Parameter.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeBSTR">
      <MemberSignature Language="C#" Value="public static void ZeroFreeBSTR (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeBSTR(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeBSTR (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeBSTR(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">Die Adresse des freizugebenden <see langword="BSTR" />.</param>
        <summary>Gibt einen [BSTR](https://msdn.microsoft.com/library/ms221069.aspx)-Zeiger frei, der mit der <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" />-Methode reserviert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> Methode legt zuerst den Inhalt des BSTR auf 0 (null), und dann freigegeben BSTR.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemAnsi (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemAnsi(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">Die Adresse der nicht verwalteten Zeichenfolge, die freigegeben werden soll.</param>
        <summary>Gibt einen nicht verwalteten Zeichenfolgenzeiger frei, der mit der <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" />-Methode reserviert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> Methode zuerst Nullen und dann freigegeben nicht verwalteten Speicher, der belegt wurde mithilfe der <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> gemarshallt und Entschlüsseln des Inhalts der Methode ein <xref:System.Security.SecureString> Objekt, das einen nicht verwalteten Speicherblock. Es verwendet dann die <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> Methode, die nicht verwaltete Block mit Nullen gefüllt und freigegeben.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemUnicode (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemUnicode(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">Die Adresse der nicht verwalteten Zeichenfolge, die freigegeben werden soll.</param>
        <summary>Gibt einen nicht verwalteten Zeichenfolgenzeiger frei, der mit der <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" />-Methode reserviert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> Methode zuerst Nullen und dann freigegeben nicht verwalteten Speicher, der belegt wurde mithilfe der <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> Methode.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUTF8 (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUTF8(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUTF8(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemUTF8 (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemUTF8(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeGlobalAllocAnsi (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeGlobalAllocAnsi(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">Die Adresse der nicht verwalteten Zeichenfolge, die freigegeben werden soll.</param>
        <summary>Gibt einen nicht verwalteten Zeichenfolgenzeiger frei, der mit der <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" />-Methode reserviert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> Methode zuerst Nullen und dann freigegeben nicht verwalteten Speicher, der belegt wurde mithilfe der <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> gemarshallt und Entschlüsseln des Inhalts der Methode ein <xref:System.Security.SecureString> Objekt, das einen nicht verwalteten Speicherblock. Es verwendet dann die <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> Methode, die nicht verwaltete Block mit Nullen gefüllt und freigegeben.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeGlobalAllocUnicode (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeGlobalAllocUnicode(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">Die Adresse der nicht verwalteten Zeichenfolge, die freigegeben werden soll.</param>
        <summary>Gibt einen nicht verwalteten Zeichenfolgenzeiger frei, der mit der <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" />-Methode reserviert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> Methode zuerst Nullen und dann freigegeben nicht verwalteten Speicher, der belegt wurde mithilfe der <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> Methode mit dem nicht verwalteten `LogonUser` Funktion zum Ausführen der Identitätswechsel mit den <xref:System.Security.SecureString> Klasse. Anschließend wird die <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> Methode 0 (null) und des Verweis nicht verwalteten Zeichenfolge.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
  </Members>
</Type>