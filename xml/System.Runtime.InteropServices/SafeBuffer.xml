<Type Name="SafeBuffer" FullName="System.Runtime.InteropServices.SafeBuffer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="225794429cd87e9d2c35a1c55228a52386a53296" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86763081" /></Metadata><TypeSignature Language="C#" Value="public abstract class SafeBuffer : System.Runtime.InteropServices.SafeHandle" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SafeBuffer extends System.Runtime.InteropServices.SafeHandle" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeBuffer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeBuffer&#xA;Inherits SafeHandle" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeBuffer abstract : System::Runtime::InteropServices::SafeHandle" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type SafeBuffer = class&#xA;    inherit SafeHandle" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class SafeBuffer : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SafeBuffer extends Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeBuffer&#xA;Inherits SafeHandleZeroOrMinusOneIsInvalid" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeBuffer abstract : Microsoft::Win32::SafeHandles::SafeHandleZeroOrMinusOneIsInvalid" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type SafeBuffer = class&#xA;    inherit SafeHandleZeroOrMinusOneIsInvalid" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SafeBuffer extends Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid implements class System.IDisposable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type SafeBuffer = class&#xA;    inherit SafeHandleZeroOrMinusOneIsInvalid&#xA;    interface IDisposable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime.InteropServices" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Runtime.InteropServices" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Runtime.InteropServices.SafeHandle</BaseTypeName>
    <BaseTypeName FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
      <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netstandard-1.2">
      <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netstandard-1.2">
      <AttributeName Language="C#">[System.Obsolete("SafeBuffer may be unavailable in future releases.")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Obsolete("SafeBuffer may be unavailable in future releases.")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="76e1a-101">Stellt einen gesteuerten Arbeitsspeicherpuffer bereit, der zum Lesen und Schreiben verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="76e1a-101">Provides a controlled memory buffer that can be used for reading and writing.</span></span> <span data-ttu-id="76e1a-102">Arbeitsspeicherzugriffe außerhalb des gesteuerten Puffers (Unterläufe und Überläufe) führen jeweils zu einer Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="76e1a-102">Attempts to access memory outside the controlled buffer (underruns and overruns) raise exceptions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76e1a-103">Sie müssen die- <xref:System.Runtime.InteropServices.SafeBuffer.Initialize%2A?displayProperty=nameWithType> Methode vor der Verwendung einer beliebigen Instanz von aufzurufen <xref:System.Runtime.InteropServices.SafeBuffer> .</span><span class="sxs-lookup"><span data-stu-id="76e1a-103">You must call the <xref:System.Runtime.InteropServices.SafeBuffer.Initialize%2A?displayProperty=nameWithType> method before you use any instance of <xref:System.Runtime.InteropServices.SafeBuffer>.</span></span> <span data-ttu-id="76e1a-104">Zum Vermeiden von Races, wenn Sie eine Instanz eines- <xref:System.Runtime.InteropServices.SafeBuffer> Objekts in einer statischen Variablen speichern, sollten Sie einen der folgenden Ansätze verwenden:</span><span class="sxs-lookup"><span data-stu-id="76e1a-104">To avoid races when you store an instance of a <xref:System.Runtime.InteropServices.SafeBuffer> object in a static variable, you should use one of the following approaches:</span></span>  
  
-   <span data-ttu-id="76e1a-105">Erstellen Sie eine Sperre, wenn Sie das Veröffentlichen <xref:System.Runtime.InteropServices.SafeBuffer> .</span><span class="sxs-lookup"><span data-stu-id="76e1a-105">Create a lock when publishing the <xref:System.Runtime.InteropServices.SafeBuffer>.</span></span>  
  
-   <span data-ttu-id="76e1a-106">Erstellen Sie eine lokale Variable, initialisieren <xref:System.Runtime.InteropServices.SafeBuffer> Sie, und weisen Sie dann der <xref:System.Runtime.InteropServices.SafeBuffer> statischen Variablen zu, z. b. mithilfe der- <xref:System.Threading.Interlocked.CompareExchange%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="76e1a-106">Create a local variable, initialize the <xref:System.Runtime.InteropServices.SafeBuffer>, and then assign the <xref:System.Runtime.InteropServices.SafeBuffer> to the static variable, for example, by using the <xref:System.Threading.Interlocked.CompareExchange%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="76e1a-107">Zuweisungen in einem statischen Klassenkonstruktor werden implizit gesperrt.</span><span class="sxs-lookup"><span data-stu-id="76e1a-107">Assignments in a static class constructor are implicitly locked.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeBuffer (bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeBuffer(bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.SafeBuffer : bool -&gt; System.Runtime.InteropServices.SafeBuffer" Usage="new System.Runtime.InteropServices.SafeBuffer ownsHandle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ownsHandle"><span data-ttu-id="76e1a-108"><see langword="true" />, um das Handle während der Abschlussphase zuverlässig freizugeben. <see langword="false" />, um eine zuverlässige Freigabe zu verhindern (dies wird nicht empfohlen).</span><span class="sxs-lookup"><span data-stu-id="76e1a-108"><see langword="true" /> to reliably release the handle during the finalization phase; <see langword="false" /> to prevent reliable release (not recommended).</span></span></param>
        <summary><span data-ttu-id="76e1a-109">Erstellt eine neue Instanz der <see cref="T:System.Runtime.InteropServices.SafeBuffer" />-Klasse und gibt an, ob das Pufferhandle zuverlässig freigegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="76e1a-109">Creates a new instance of the <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> class, and specifies whether the buffer handle is to be reliably released.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcquirePointer">
      <MemberSignature Language="C#" Value="public void AcquirePointer (ref byte* pointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquirePointer(unsigned int8*&amp; pointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.AcquirePointer(System.Byte*@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquirePointer(System::Byte* % pointer);" />
      <MemberSignature Language="F#" Value="member this.AcquirePointer : Byte* -&gt; unit" Usage="safeBuffer.AcquirePointer pointer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="76e1a-110">Ein als Verweis übergebener Bytezeiger zum Abrufen des Zeigers aus dem <see cref="T:System.Runtime.InteropServices.SafeBuffer" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="76e1a-110">A byte pointer, passed by reference, to receive the pointer from within the <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> object.</span></span> <span data-ttu-id="76e1a-111">Sie müssen diesen Zeiger auf <see langword="null" /> festlegen, bevor diese Methode aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="76e1a-111">You must set this pointer to <see langword="null" /> before you call this method.</span></span></param>
        <summary><span data-ttu-id="76e1a-112">Ruft einen Zeiger aus einem <see cref="T:System.Runtime.InteropServices.SafeBuffer" />-Objekt für einen Speicherblock ab.</span><span class="sxs-lookup"><span data-stu-id="76e1a-112">Obtains a pointer from a <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> object for a block of memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76e1a-113">Wenn <xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A> zurückgibt, sollten Sie die Überprüfung von Begrenzungen ausführen, indem Sie überprüfen, ob der- `pointer` Parameter `null`</span><span class="sxs-lookup"><span data-stu-id="76e1a-113">When <xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A> returns, you should perform bounds checking by verifying that the `pointer` parameter is `null`.</span></span> <span data-ttu-id="76e1a-114">Wenn dies nicht der Fall ist `null` , müssen Sie die- <xref:System.Runtime.InteropServices.SafeBuffer.ReleasePointer%2A?displayProperty=nameWithType> Methode in einem eingeschränkten Ausführungs Bereich (CER) aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="76e1a-114">If it is not `null`, you must call the <xref:System.Runtime.InteropServices.SafeBuffer.ReleasePointer%2A?displayProperty=nameWithType> method in a constrained execution region (CER).</span></span>  
  
 <span data-ttu-id="76e1a-115"><xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A> Ruft die <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A?displayProperty=nameWithType> -Methode auf und macht den-Zeiger verfügbar.</span><span class="sxs-lookup"><span data-stu-id="76e1a-115"><xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A> calls the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A?displayProperty=nameWithType> method and exposes the pointer.</span></span> <span data-ttu-id="76e1a-116">Anders als bei der- <xref:System.Runtime.InteropServices.SafeBuffer.Read%2A> Methode wird die aktuelle Position des Zeigers nicht geändert.</span><span class="sxs-lookup"><span data-stu-id="76e1a-116">Unlike the <xref:System.Runtime.InteropServices.SafeBuffer.Read%2A> method, it does not change the current position of the pointer.</span></span>  
  
 <span data-ttu-id="76e1a-117">Im folgenden Beispiel wird die Verwendung der- <xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A> Methode veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="76e1a-117">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.SafeBuffer.AcquirePointer%2A> method:</span></span>  
  
```  
byte* pointer = null;  
RuntimeHelpers.PrepareConstrainedRegions();  
try {  
    MySafeBuffer.AcquirePointer(ref pointer);  
    // Use pointer here, with your own bounds checking.  
    }  
finally {  
    if (pointer != null)  
        MySafeBuffer.ReleasePointer();  
    }  
```  
  
 <span data-ttu-id="76e1a-118">Wenn Sie `pointer` (einen Zeiger auf ein Byte) als Zeiger auf einen anderen Typ (T \*) umwandeln, haben Sie möglicherweise Zeiger Ausrichtungs Probleme.</span><span class="sxs-lookup"><span data-stu-id="76e1a-118">If you cast `pointer` (which is a pointer to a byte) as a pointer to a different type (T\*), you may have pointer alignment issues.</span></span>  
  
 <span data-ttu-id="76e1a-119">Sie müssen die Verantwortung für alle Begrenzungen überprüfen, die mit diesem Zeiger überprüft werden.</span><span class="sxs-lookup"><span data-stu-id="76e1a-119">You must take responsibility for all bounds checking with this pointer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="76e1a-120">Die <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" />-Methode wurde nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="76e1a-120">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ByteLength">
      <MemberSignature Language="C#" Value="public ulong ByteLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int64 ByteLength" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeBuffer.ByteLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ByteLength As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::UInt64 ByteLength { System::UInt64 get(); };" />
      <MemberSignature Language="F#" Value="member this.ByteLength : uint64" Usage="System.Runtime.InteropServices.SafeBuffer.ByteLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="76e1a-121">Ruft die Größe des Puffers in Bytes ab.</span><span class="sxs-lookup"><span data-stu-id="76e1a-121">Gets the size of the buffer, in bytes.</span></span></summary>
        <value><span data-ttu-id="76e1a-122">Die Anzahl der Bytes im Speicherpuffer.</span><span class="sxs-lookup"><span data-stu-id="76e1a-122">The number of bytes in the memory buffer.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="76e1a-123">Die <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" />-Methode wurde nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="76e1a-123">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Initialize">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="76e1a-124">Gibt die Größe des zuzuordnenden Arbeitsspeicherpuffers an.</span><span class="sxs-lookup"><span data-stu-id="76e1a-124">Specifies the size of the memory buffer to allocate.</span></span> <span data-ttu-id="76e1a-125">Diese Methode muss aufgerufen werden, bevor die <see cref="T:System.Runtime.InteropServices.SafeBuffer" />-Instanz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="76e1a-125">You must call this method before you use the <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize (ulong numBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize(unsigned int64 numBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Initialize(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize (numBytes As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize(System::UInt64 numBytes);" />
      <MemberSignature Language="F#" Value="member this.Initialize : uint64 -&gt; unit" Usage="safeBuffer.Initialize numBytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numBytes" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="numBytes"><span data-ttu-id="76e1a-126">Die Anzahl von Bytes im Puffer.</span><span class="sxs-lookup"><span data-stu-id="76e1a-126">The number of bytes in the buffer.</span></span></param>
        <summary><span data-ttu-id="76e1a-127">Definiert die Zuordnungsgröße des Arbeitsspeicherbereichs in Bytes.</span><span class="sxs-lookup"><span data-stu-id="76e1a-127">Defines the allocation size of the memory region in bytes.</span></span> <span data-ttu-id="76e1a-128">Diese Methode muss aufgerufen werden, bevor die <see cref="T:System.Runtime.InteropServices.SafeBuffer" />-Instanz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="76e1a-128">You must call this method before you use the <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> instance.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="76e1a-129"><paramref name="numBytes" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="76e1a-129"><paramref name="numBytes" /> is less than zero.</span></span>  
  
<span data-ttu-id="76e1a-130">- oder -</span><span class="sxs-lookup"><span data-stu-id="76e1a-130">-or-</span></span> 
 <span data-ttu-id="76e1a-131"><paramref name="numBytes" /> ist größer als der verfügbare Adressbereich.</span><span class="sxs-lookup"><span data-stu-id="76e1a-131"><paramref name="numBytes" /> is greater than the available address space.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize (uint numElements, uint sizeOfEachElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize(unsigned int32 numElements, unsigned int32 sizeOfEachElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Initialize(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize (numElements As UInteger, sizeOfEachElement As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize(System::UInt32 numElements, System::UInt32 sizeOfEachElement);" />
      <MemberSignature Language="F#" Value="member this.Initialize : uint32 * uint32 -&gt; unit" Usage="safeBuffer.Initialize (numElements, sizeOfEachElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numElements" Type="System.UInt32" />
        <Parameter Name="sizeOfEachElement" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="numElements"><span data-ttu-id="76e1a-132">Die Anzahl der Elemente im Puffer.</span><span class="sxs-lookup"><span data-stu-id="76e1a-132">The number of elements in the buffer.</span></span></param>
        <param name="sizeOfEachElement"><span data-ttu-id="76e1a-133">Die Größe der einzelnen Elemente im Puffer.</span><span class="sxs-lookup"><span data-stu-id="76e1a-133">The size of each element in the buffer.</span></span></param>
        <summary><span data-ttu-id="76e1a-134">Gibt die Zuordnungsgröße des Arbeitsspeicherpuffers mit der angegebenen Anzahl von Elementen und der Elementgröße an.</span><span class="sxs-lookup"><span data-stu-id="76e1a-134">Specifies the allocation size of the memory buffer by using the specified number of elements and element size.</span></span> <span data-ttu-id="76e1a-135">Diese Methode muss aufgerufen werden, bevor die <see cref="T:System.Runtime.InteropServices.SafeBuffer" />-Instanz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="76e1a-135">You must call this method before you use the <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76e1a-136">Diese Methode definiert die erforderliche Größe des Arbeitsspeicher Bereichs als Anzahl von Elementen in einem Array, multipliziert mit der Größe der einzelnen Elemente.</span><span class="sxs-lookup"><span data-stu-id="76e1a-136">This method defines the required size of the memory region as the number of elements in an array multiplied by the size of each element.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="76e1a-137"><paramref name="numElements" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="76e1a-137"><paramref name="numElements" /> is less than zero.</span></span>  
  
<span data-ttu-id="76e1a-138">- oder -</span><span class="sxs-lookup"><span data-stu-id="76e1a-138">-or-</span></span> 
 <span data-ttu-id="76e1a-139"><paramref name="sizeOfEachElement" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="76e1a-139"><paramref name="sizeOfEachElement" /> is less than zero.</span></span>  
  
<span data-ttu-id="76e1a-140">- oder -</span><span class="sxs-lookup"><span data-stu-id="76e1a-140">-or-</span></span> 
 <span data-ttu-id="76e1a-141"><paramref name="numElements" /> multipliziert mit <paramref name="sizeOfEachElement" /> ist größer als der verfügbare Adressbereich.</span><span class="sxs-lookup"><span data-stu-id="76e1a-141"><paramref name="numElements" /> multiplied by <paramref name="sizeOfEachElement" /> is greater than the available address space.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void Initialize&lt;T&gt; (uint numElements) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int32 numElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Initialize``1(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize(Of T As Structure) (numElements As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class void Initialize(System::UInt32 numElements);" />
      <MemberSignature Language="F#" Value="member this.Initialize : uint32 -&gt; unit (requires 'T : struct)" Usage="safeBuffer.Initialize numElements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="numElements" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="76e1a-142">Der Werttyp, für den Speicher belegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="76e1a-142">The value type to allocate memory for.</span></span></typeparam>
        <param name="numElements"><span data-ttu-id="76e1a-143">Die Anzahl von Elementen des Werttyps, für die Speicher belegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="76e1a-143">The number of elements of the value type to allocate memory for.</span></span></param>
        <summary><span data-ttu-id="76e1a-144">Definiert die Zuordnungsgröße des Arbeitsspeicherbereichs, indem die Anzahl der Werttypen angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="76e1a-144">Defines the allocation size of the memory region by specifying the number of value types.</span></span> <span data-ttu-id="76e1a-145">Diese Methode muss aufgerufen werden, bevor die <see cref="T:System.Runtime.InteropServices.SafeBuffer" />-Instanz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="76e1a-145">You must call this method before you use the <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> instance.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="76e1a-146"><paramref name="numElements" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="76e1a-146"><paramref name="numElements" /> is less than zero.</span></span>  
  
<span data-ttu-id="76e1a-147">- oder -</span><span class="sxs-lookup"><span data-stu-id="76e1a-147">-or-</span></span> 
 <span data-ttu-id="76e1a-148"><paramref name="numElements" /> multipliziert mit der Größe der einzelnen Elemente ist größer als der verfügbare Adressbereich.</span><span class="sxs-lookup"><span data-stu-id="76e1a-148"><paramref name="numElements" /> multiplied by the size of each element is greater than the available address space.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public override bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeBuffer.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.SafeBuffer.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="76e1a-149">Ruft einen Wert ab, der angibt, ob das Handle ungültig ist.</span><span class="sxs-lookup"><span data-stu-id="76e1a-149">Gets a value that indicates whether the handle is invalid.</span></span></summary>
        <value><span data-ttu-id="76e1a-150"><see langword="true" />, wenn das Handle ungültig ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="76e1a-150"><see langword="true" /> if the handle is not valid; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="76e1a-151">Der Common Language Runtime verwendet diese Eigenschaft, um zu bestimmen, ob eine kritische Beendigung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="76e1a-151">The common language runtime uses this property to determine whether critical finalization is required.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid.IsInvalid" />
        <altmember cref="T:Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="Read&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T Read&lt;T&gt; (ulong byteOffset) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T Read&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int64 byteOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Read``1(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read(Of T As Structure) (byteOffset As ULong) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class T Read(System::UInt64 byteOffset);" />
      <MemberSignature Language="F#" Value="member this.Read : uint64 -&gt; 'T (requires 'T : struct)" Usage="safeBuffer.Read byteOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="byteOffset" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="76e1a-152">Der zu lesende Werttyp.</span><span class="sxs-lookup"><span data-stu-id="76e1a-152">The value type to read.</span></span></typeparam>
        <param name="byteOffset"><span data-ttu-id="76e1a-153">Die Position, an der der Werttyp gelesen werden soll.</span><span class="sxs-lookup"><span data-stu-id="76e1a-153">The location from which to read the value type.</span></span> <span data-ttu-id="76e1a-154">Möglicherweise müssen Ausrichtungsprobleme berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="76e1a-154">You may have to consider alignment issues.</span></span></param>
        <summary><span data-ttu-id="76e1a-155">Liest einen Werttyp am angegebenen Offset aus dem Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="76e1a-155">Reads a value type from memory at the specified offset.</span></span></summary>
        <returns><span data-ttu-id="76e1a-156">Der Werttyp, der aus dem Arbeitsspeicher gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="76e1a-156">The value type that was read from memory.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="76e1a-157">Die <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" />-Methode wurde nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="76e1a-157">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeBuffer.Write``1(System.UInt64,``0)" />
      </Docs>
    </Member>
    <Member MemberName="ReadArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void ReadArray&lt;T&gt; (ulong byteOffset, T[] array, int index, int count) where T : struct;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadArray&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int64 byteOffset, !!T[] array, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.ReadArray``1(System.UInt64,``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadArray(Of T As Structure) (byteOffset As ULong, array As T(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class void ReadArray(System::UInt64 byteOffset, cli::array &lt;T&gt; ^ array, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.ReadArray : uint64 * 'T[] * int * int -&gt; unit (requires 'T : struct)" Usage="safeBuffer.ReadArray (byteOffset, array, index, count)" />
      <MemberSignature Language="C#" Value="public void ReadArray&lt;T&gt; (ulong byteOffset, T[]? array, int index, int count) where T : struct;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="byteOffset" Type="System.UInt64" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="76e1a-158">Der zu lesende Werttyp.</span><span class="sxs-lookup"><span data-stu-id="76e1a-158">The value type to read.</span></span></typeparam>
        <param name="byteOffset"><span data-ttu-id="76e1a-159">Die Position, an der der Lesevorgang begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="76e1a-159">The location from which to start reading.</span></span></param>
        <param name="array"><span data-ttu-id="76e1a-160">Das Ausgabearray, in das geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="76e1a-160">The output array to write to.</span></span></param>
        <param name="index"><span data-ttu-id="76e1a-161">Die Position im Ausgabearray, an der der Schreibvorgang begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="76e1a-161">The location in the output array to begin writing to.</span></span></param>
        <param name="count"><span data-ttu-id="76e1a-162">Die Anzahl der Werttypen, die aus dem Eingabearray gelesen und in das Ausgabearray geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="76e1a-162">The number of value types to read from the input array and to write to the output array.</span></span></param>
        <summary><span data-ttu-id="76e1a-163">Liest beginnend am Offset die angegebene Anzahl von Werttypen aus dem Arbeitsspeicher und schreibt sie beginnend am Index in ein Array.</span><span class="sxs-lookup"><span data-stu-id="76e1a-163">Reads the specified number of value types from memory starting at the offset, and writes them into an array starting at the index.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="76e1a-164"><paramref name="index" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="76e1a-164"><paramref name="index" /> is less than zero.</span></span>  
  
<span data-ttu-id="76e1a-165">- oder -</span><span class="sxs-lookup"><span data-stu-id="76e1a-165">-or-</span></span> 
 <span data-ttu-id="76e1a-166"><paramref name="count" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="76e1a-166"><paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="76e1a-167"><paramref name="array" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="76e1a-167"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="76e1a-168">Die Länge des Array minus Index ist kleiner als <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="76e1a-168">The length of the array minus the index is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="76e1a-169">Die <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" />-Methode wurde nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="76e1a-169">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeBuffer.WriteArray``1(System.UInt64,``0[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReleasePointer">
      <MemberSignature Language="C#" Value="public void ReleasePointer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleasePointer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.ReleasePointer" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleasePointer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleasePointer();" />
      <MemberSignature Language="F#" Value="member this.ReleasePointer : unit -&gt; unit" Usage="safeBuffer.ReleasePointer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="76e1a-170">Gibt einen Zeiger frei, der von der <see cref="M:System.Runtime.InteropServices.SafeBuffer.AcquirePointer(System.Byte*@)" />-Methode abgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="76e1a-170">Releases a pointer that was obtained by the <see cref="M:System.Runtime.InteropServices.SafeBuffer.AcquirePointer(System.Byte*@)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76e1a-171">Nachdem diese Methode zurückgegeben wurde, kann der Zeiger nicht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="76e1a-171">After this method returns, the pointer cannot be used.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="76e1a-172">Die <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" />-Methode wurde nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="76e1a-172">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void Write&lt;T&gt; (ulong byteOffset, T value) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int64 byteOffset, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.Write``1(System.UInt64,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write(Of T As Structure) (byteOffset As ULong, value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class void Write(System::UInt64 byteOffset, T value);" />
      <MemberSignature Language="F#" Value="member this.Write : uint64 * 'T -&gt; unit (requires 'T : struct)" Usage="safeBuffer.Write (byteOffset, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="byteOffset" Type="System.UInt64" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="76e1a-173">Der zu schreibende Werttyp.</span><span class="sxs-lookup"><span data-stu-id="76e1a-173">The value type to write.</span></span></typeparam>
        <param name="byteOffset"><span data-ttu-id="76e1a-174">Die Position, an der der Schreibvorgang begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="76e1a-174">The location at which to start writing.</span></span> <span data-ttu-id="76e1a-175">Möglicherweise müssen Ausrichtungsprobleme berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="76e1a-175">You may have to consider alignment issues.</span></span></param>
        <param name="value"><span data-ttu-id="76e1a-176">Der zu schreibende Wert.</span><span class="sxs-lookup"><span data-stu-id="76e1a-176">The value to write.</span></span></param>
        <summary><span data-ttu-id="76e1a-177">Schreibt einen Werttyp an der angegebenen Position in den Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="76e1a-177">Writes a value type to memory at the given location.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76e1a-178">Diese Methode entspricht dem folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="76e1a-178">This method is equivalent to the following code:</span></span>  
  
```  
*(T*)(bytePtr + byteOffset) = value;  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="76e1a-179">Die <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" />-Methode wurde nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="76e1a-179">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeBuffer.Read``1(System.UInt64)" />
      </Docs>
    </Member>
    <Member MemberName="WriteArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void WriteArray&lt;T&gt; (ulong byteOffset, T[] array, int index, int count) where T : struct;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteArray&lt;struct .ctor (class System.ValueType) T&gt;(unsigned int64 byteOffset, !!T[] array, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeBuffer.WriteArray``1(System.UInt64,``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteArray(Of T As Structure) (byteOffset As ULong, array As T(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class void WriteArray(System::UInt64 byteOffset, cli::array &lt;T&gt; ^ array, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.WriteArray : uint64 * 'T[] * int * int -&gt; unit (requires 'T : struct)" Usage="safeBuffer.WriteArray (byteOffset, array, index, count)" />
      <MemberSignature Language="C#" Value="public void WriteArray&lt;T&gt; (ulong byteOffset, T[]? array, int index, int count) where T : struct;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="byteOffset" Type="System.UInt64" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="76e1a-180">Der zu schreibende Werttyp.</span><span class="sxs-lookup"><span data-stu-id="76e1a-180">The value type to write.</span></span></typeparam>
        <param name="byteOffset"><span data-ttu-id="76e1a-181">Die Position im Arbeitsspeicher, in die geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="76e1a-181">The location in memory to write to.</span></span></param>
        <param name="array"><span data-ttu-id="76e1a-182">Das Eingabearray.</span><span class="sxs-lookup"><span data-stu-id="76e1a-182">The input array.</span></span></param>
        <param name="index"><span data-ttu-id="76e1a-183">Der Offset im Array, bei dem der Lesevorgang begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="76e1a-183">The offset in the array to start reading from.</span></span></param>
        <param name="count"><span data-ttu-id="76e1a-184">Die Anzahl der Werttypen, die geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="76e1a-184">The number of value types to write.</span></span></param>
        <summary><span data-ttu-id="76e1a-185">Schreibt die angegebene Anzahl von Werttypen an eine Speicheradresse, indem beginnend an der angegebenen Position im Eingabearray Bytes gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="76e1a-185">Writes the specified number of value types to a memory location by reading bytes starting from the specified location in the input array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="76e1a-186">Jedes Element im Eingabe Array besteht aus dem generischen Werttyp der Klasse.</span><span class="sxs-lookup"><span data-stu-id="76e1a-186">Each element in the input array consists of the generic value type of the class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="76e1a-187"><paramref name="array" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="76e1a-187"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="76e1a-188"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="76e1a-188"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="76e1a-189">Die Länge des Eingabearrays minus <paramref name="index" /> ist kleiner als <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="76e1a-189">The length of the input array minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="76e1a-190">Die <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" />-Methode wurde nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="76e1a-190">The <see cref="Overload:System.Runtime.InteropServices.SafeBuffer.Initialize" /> method has not been called.</span></span></exception>
        <altmember cref="M:System.Runtime.InteropServices.SafeBuffer.ReadArray``1(System.UInt64,``0[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>
