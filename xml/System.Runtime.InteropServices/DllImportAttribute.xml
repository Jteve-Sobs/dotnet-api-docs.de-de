<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c88c893bbcacbedffc6f6936c071741ed1dd6858" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48745061" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gibt an, dass die attributierte Methode durch eine nicht verwaltete Dynamic Link Library (DLL) als statischer Einstiegspunkt verfügbar gemacht wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können dieses Attribut auf Methoden anwenden.  
  
 Die <xref:System.Runtime.InteropServices.DllImportAttribute> Attribut enthält die erforderlichen Informationen zum Aufrufen einer Funktion, die aus einer nicht verwalteten DLL exportiert wurden. Als Mindestanforderung müssen Sie den Namen der DLL, die den Einstiegspunkt enthält angeben.  
  
 Sie können dieses Attribut anwenden, direkt mit c# und C++-Methodendefinitionen; Visual Basic-Compiler gibt dieses Attribut jedoch bei Verwendung der `Declare` Anweisung. Bei komplexen Methodendefinitionen, die enthalten <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, oder <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Felder Sie dieses Attribut direkt in Visual Basic-Methodendefinitionen anwenden.  
  
 **Beachten Sie** JScript dieses Attribut nicht unterstützt. Sie können C#- oder Visual Basic-Wrapperklassen verwenden, auf nicht verwaltete API-Methoden von JScript-Programme zugreifen.  
  
 Weitere Informationen zur Verwendung der plattformbasis-Dienst zugreifen auf Funktionen in nicht verwaltete DLLs aufrufen, finden Sie unter [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
> [!NOTE]
>  Die <xref:System.Runtime.InteropServices.DllImportAttribute> Marshalling von generischen Typen nicht unterstützt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Runtime.InteropServices.DllImportAttribute> Attribut zum Importieren der Win32- `MessageBox` Funktion.  Im Codebeispiel ruft dann die importierte-Methode.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">Der Name der DLL, die die nicht verwaltete Methode enthält. Dieser kann einen Assemblyanzeigenamen einschließen, wenn die DLL in einer Assembly enthalten ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.InteropServices.DllImportAttribute" />-Klasse mit dem Namen der DLL, die die zu importierende Methode enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine nicht verwaltete DLL-Datei in einer Assembly, z. B. enthalten ist mithilfe des Linkers oder `/linkresource` -Compileroption verwenden, können Sie den Anzeigenamen der Assembly angeben, als Teil des `dllName`. Wenn eine nicht verwaltete DLL, die mit dem Namen z. B. `unmanaged.dll` befindet sich in einer verwalteten Assembly, die mit dem Namen `MyAssembly`, das Attribut kann angegeben werden, wie im folgenden Code gezeigt.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Runtime.InteropServices.DllImportAttribute> Attribut zum Importieren der Win32- `MessageBox` Funktion.  Im Codebeispiel ruft dann die importierte-Methode.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aktiviert bzw. deaktiviert das Verhalten der optimalen Zuordnung bei der Konvertierung von Unicode-Zeichen in ANSI-Zeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `true`, Fallback mit ähnlichen Zuordnungsverhalten aktiviert ist; andernfalls, Fallback mit ähnlichen Zuordnung ist deaktiviert. Die <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> Feld `true` standardmäßig. Einstellungen für dieses Feld überschreiben, die alle Einstellungen für die <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> Attribut.  
  
 Die common Language Runtime konvertiert wird, in die ANSI-Zeichen, die alle Unicode-Zeichen verwalteten, die an eine nicht verwaltete Methode ausführen unter Windows 98 oder Windows Me enthalten. Zuordnung mit ähnlichen Zeichen ermöglicht den Interop-Marshaller, eine schließen-Zeichen angeben, wenn keine genaue Übereinstimmung vorhanden ist. Der Marshaller konvertiert z. B. copyright Unicode-Zeichen "c" für nicht verwaltete Methoden, die ANSI-Zeichen akzeptieren. Einige Zeichen ist keine optimale Darstellung; Diese Zeichen werden nicht zuzuordnenden bezeichnet. Nicht zuzuordnenden Zeichen werden normalerweise in der Standard '?' ANSI-Zeichen.  
  
> [!CAUTION]
>  Bestimmte Unicode-Zeichen werden in gefährlicher Zeichen, z. B. der umgekehrte Schrägstrich konvertiert "\\'-Zeichen, die versehentlich einen Pfad ändern können. Durch Festlegen der <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Feld `true`, können Sie das Vorhandensein von einem nicht zuzuordnenden Zeichen an den Aufrufer darauf hinweisen, durch Auslösen einer Ausnahme.  
  
> [!CAUTION]
>  Sie können nicht die Standardwerte, die durch Ändern der <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> und <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Felder, wenn einem verwalteten Array, dessen Elemente ANSI-Zeichen oder LPSTRs sind an eine nicht verwaltete sichere Array übergeben wird. Zuordnung mit ähnlichen Zeichen ist immer aktiviert und wird keine Ausnahme ausgelöst. Denken Sie daran, dass diese Kombination Ihrer Sicherheitsmodell gefährden kann.  
  
   
  
## Examples  
 In einigen Fällen Visual Basic-Entwickler verwenden die <xref:System.Runtime.InteropServices.DllImportAttribute>, statt die `Declare` -Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren. Festlegen der <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> Feld ist ein solcher Fall. Das folgende Beispiel zeigt, wie Sie die strengste Anforderung anwenden Zeichen Zuordnung Sicherheit auf einer Plattform aufrufen Methodendefinitionen ANSI-Zeichensatz angeben, deaktivieren die besten Seite der Zuordnung und eine Ausnahme auszulösen, auf nicht zugeordnete Unicode-Zeichen.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
        <related type="Article" href="http://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a">Interop-Marshalling</related>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Aufrufkonvention eines Einstiegspunkts an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie legen dieses Feld in eines der <xref:System.Runtime.InteropServices.CallingConvention> Enumerationsmember. Der Standardwert für die <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> Feld <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, die wiederum standardmäßig <xref:System.Runtime.InteropServices.CallingConvention.StdCall> Konvention.  
  
 Weitere Informationen finden Sie in der Aufrufkonvention in der MSDN Library.  
  
   
  
## Examples  
 In einigen Fällen Visual Basic-Entwickler verwenden die <xref:System.Runtime.InteropServices.DllImportAttribute>, statt die `Declare` -Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren. Festlegen der <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> Feld ist ein solcher Fall.  
  
 System.Runtime.InteropServices.DllImportAttribute#1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, wie Zeichenfolgenparameter an die Methode gemarshallt werden, und steuert die Namenszerlegung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie dieses Feld mit einem Member mit dem <xref:System.Runtime.InteropServices.CharSet> Enumeration, die das Marshalling-Verhalten der String-Parameter angeben und die Einstiegspunktfunktion mit dem Namen aufgerufen werden soll (der exakte Name oder einen Namen mit "A" oder "W" enden) angeben. Ist das Standardelement für die Enumeration für c# und Visual Basic `CharSet.Ansi` und ist das Standardelement für die Enumeration für C++ `CharSet.None`, dies entspricht dem `CharSet.Ansi`. In Visual Basic, die Sie verwenden die `Declare` -Anweisung zum Angeben der `CharSet` Feld.  
  
 Die <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Feld beeinflusst das Verhalten der `CharSet` Feld bei der Bestimmung der Namen des Einstiegspunkts aufrufen. Eine ausführliche Beschreibung und Beispiele für das Marshallen von Zeichenfolgen und namensübereinstimmung zugeordnete Verhalten der `CharSet` Feld, finden Sie unter [angeben eines Zeichensatzes](~/docs/framework/interop/specifying-a-character-set.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Runtime.InteropServices.DllImportAttribute> Attribut zum Importieren der Win32- `MessageBox` Funktion.  Im Codebeispiel ruft dann die importierte-Methode.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den Namen oder die Ordnungszahl des aufzurufenden DLL-Einstiegspunkts an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Namen des Einstiegspunkts angeben, indem eine Zeichenfolge, der angibt, der des Namens der DLL, die den Einstiegspunkt enthält bereitstellen, oder Sie können den Einstiegspunkt identifizieren, nach seiner Ordinalzahl. Ordnungszahlen werden das #-Zeichen, z. B. #1 vorangestellt. Wenn Sie dieses Feld weglassen, verwendet die common Language Runtime den Namen der.NET mit markierten Methode der <xref:System.Runtime.InteropServices.DllImportAttribute>.  
  
 Weitere Informationen finden Sie unter [Identifizieren von Funktionen in DLLs](~/docs/framework/interop/identifying-functions-in-dlls.md). Beispiele zur Verwendung der <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> Feld, finden Sie unter [angeben eines Einstiegspunktes](~/docs/framework/interop/specifying-an-entry-point.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Runtime.InteropServices.DllImportAttribute> Attribut zum Importieren der Win32- `MessageBox` Funktion.  Das Codebeispiel verwendet die <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> -Eigenschaft an die Funktion zum Importieren und ändert sich der Name, der dann `MyNewMessageBoxMethod`.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Steuert, ob das <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />-Feld die Common Language Runtime anweist, eine nicht verwaltete DLL nach anderen Einstiegspunktnamen als dem angegebenen zu durchsuchen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `false`, Einstiegspunktname, die mit dem Buchstaben A wird aufgerufen, bei der <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> Feld ist auf festgelegt `CharSet.Ansi`, und den Namen des Einstiegspunkts, mit dem Buchstaben W angefügt wird aufgerufen, bei der <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> Feld ist auf festgelegt die `CharSet.Unicode`. Verwaltete Compiler in der Regel legen Sie dieses Feld.  
  
 Die folgende Tabelle zeigt die Beziehung zwischen der <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> und <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Felder, die basierend auf Standardwerte, die durch die Programmiersprache auferlegt. Sie können die Standardeinstellung überschreiben, aber Sie können mit Vorsicht tun.  
  
|Sprache|ANSI|Unicode|Auto|  
|--------------|----------|-------------|----------|  
|Visual Basic|ExactSpelling: = True|ExactSpelling: = True|ExactSpelling: = "false"|  
|C#|ExactSpelling = "false"|ExactSpelling = "false"|ExactSpelling = "false"|  
|C++|ExactSpelling = "false"|ExactSpelling = "false"|ExactSpelling = "false"|  
  
   
  
## Examples  
 In einigen Fällen Visual Basic-Entwickler verwenden die <xref:System.Runtime.InteropServices.DllImportAttribute>, anstatt die `Declare` -Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren. Festlegen der <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Feld ist ein solcher Fall.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob nicht verwaltete Methoden, die über <see langword="HRESULT" />-Rückgabewerte oder <see langword="retval" />-Rückgabewerte verfügen, direkt übersetzt werden oder ob <see langword="HRESULT" />-Rückgabewerte oder <see langword="retval" />-Rückgabewerte automatisch in Ausnahmen konvertiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen der <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld `true` , direkt Umsetzen der nicht verwaltete Signaturen mit `HRESULT` oder `retval` Werte; legen Sie ihn auf `false` automatisch konvertieren `HRESULT` oder `retval` Werte für Ausnahmen. In der Standardeinstellung die <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld `true`.  
  
 Wenn `true`, die resultierende Methodensignatur gibt einen ganzzahligen-Wert, der enthält die `HRESULT` Wert.  In diesem Fall müssen manuell den Rückgabewert zu überprüfen und entsprechend reagieren in Ihrer Anwendung.  
  
 Beim Festlegen der <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld `false`, die resultierende Methodensignatur enthält einen void-Rückgabetyp anstelle einer ganzen Zahl (`HRESULT`) Typ zurückgeben.  Wenn die nicht verwaltete Methode erzeugt eine `HRESULT`, ignoriert die Laufzeit automatisch einen Rückgabewert von `S_OK` (oder 0) und löst keine Ausnahme.  Für `HRESULT`s außer `S_OK`, löst die Laufzeit automatisch eine Ausnahme, die die entspricht der `HRESULT`.  Beachten Sie, dass die <xref:System.Runtime.InteropServices.DllImportAttribute> Attribut führt nur die Konvertierung in den Methoden, die Zurückgeben einer `HRESULT`.  
  
 Sie können ggf. so ändern Sie die Verhalten von der standardmäßigen Fehlerberichtsfunktion `HRESULT`s, um Ausnahmen in Fällen, in denen Ausnahmen der Windows-Fehlerberichterstattung Struktur Ihrer Anwendung besser gerecht.  
  
 Dieses Feld ist ähnlich wie die <xref:System.Runtime.InteropServices.PreserveSigAttribute>; jedoch im Gegensatz zu den <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld den Standardwert für das Attribut ist `false`.  
  
 In einigen Fällen Visual Basic-Entwickler verwenden die <xref:System.Runtime.InteropServices.DllImportAttribute>, anstatt die `Declare` -Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren. Festlegen der <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld ist ein solcher Fall.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Runtime.InteropServices.DllImportAttribute> So importieren Sie die nicht verwaltete `SHAutoComplete` -Funktion einmal mit der <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld festgelegt, um `true` und anschließend mit der <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld festgelegt, um `false`.  Bewirkt, dass in diesem Codebeispiel wird die `SHAutoComplete` Funktion, die keine Fehler mit einer Ausnahme nur einmal generiert und ein `HRESULT` nächsten.  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Aufgerufene vor dem Zurückgeben aus der attributierten Methode die Win32-API <see langword="SetLastError" /> aufruft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` um anzugeben, dass der aufgerufene aufruft, `SetLastError`ist, andernfalls `false`. Der Standardwert ist `false`.  
  
 Ruft die Laufzeit-Marshaller `GetLastError` und speichert Sie zwischen den zurückgegebenen Wert mit der sie verhindern, dass Sie durch andere API-Aufrufe überschrieben werden. Sie können den Fehlercode abrufen, durch den Aufruf <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.  
  
   
  
## Examples  
 In einigen Fällen Visual Basic-Entwickler verwenden die <xref:System.Runtime.InteropServices.DllImportAttribute>, anstatt die `Declare` -Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren. Festlegen der <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> Feld ist ein solcher Fall.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aktiviert bzw. deaktiviert das Auslösen einer Ausnahme bei einem nicht zuzuordnenden Unicode-Zeichen, das in das ANSI-Zeichen „?“ konvertiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` um anzugeben, dass jedes Mal eine Ausnahme ausgelöst wird, wenn der interop-Marshaller ein nicht zuzuordnendes Zeichen konvertiert. `false` an, dass die <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Feld ist deaktiviert. Dieses Feld ist `false` standardmäßig.  
  
 Die common Language Runtime konvertiert wird, in die ANSI-Zeichen, die alle Unicode-Zeichen verwalteten, die an eine nicht verwaltete Methode ausführen unter Windows 98 oder Windows Me enthalten. Zuordnung mit ähnlichen Zeichen ermöglicht den Interop-Marshaller, eine schließen-Zeichen angeben, wenn keine genaue Übereinstimmung vorhanden ist. Der Marshaller konvertiert z. B. copyright Unicode-Zeichen "c" für nicht verwaltete Methoden, die ANSI-Zeichen akzeptieren. Einige Zeichen ist keine optimale Darstellung; Diese Zeichen werden nicht zuzuordnenden bezeichnet. Nicht zuzuordnenden Zeichen werden normalerweise in der Standard '?' ANSI-Zeichen.  
  
> [!CAUTION]
>  Bestimmte Unicode-Zeichen werden in gefährlicher Zeichen, z. B. der umgekehrte Schrägstrich konvertiert "\\'-Zeichen, die versehentlich einen Pfad ändern können. Durch Festlegen der <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Feld `true`, können Sie das Vorhandensein von einem nicht zuzuordnenden Zeichen an den Aufrufer darauf hinweisen, durch Auslösen einer Ausnahme.  
  
> [!CAUTION]
>  Sie können nicht die Standardwerte, die durch Ändern der <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> und <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Felder, wenn einem verwalteten Array, dessen Elemente ANSI-Zeichen oder LPSTRs sind an eine nicht verwaltete sichere Array übergeben wird. Zuordnung mit ähnlichen Zeichen ist immer aktiviert und wird keine Ausnahme ausgelöst. Denken Sie daran, dass diese Kombination Ihrer Sicherheitsmodell gefährden kann.  
  
   
  
## Examples  
 In einigen Fällen Visual Basic-Entwickler verwenden die <xref:System.Runtime.InteropServices.DllImportAttribute> zum Definieren einer DLL-Funktion in verwaltetem Code, anstatt die `Declare` Anweisung. Festlegen der <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Feld ist ein solcher Fall. Das folgende Beispiel zeigt, wie Sie die strengste Anforderung anwenden Zeichen Zuordnung Sicherheit auf einer Plattform aufrufen Methodendefinitionen ANSI-Zeichensatz angeben, deaktivieren die besten Seite der Zuordnung und eine Ausnahme auszulösen, auf nicht zugeordnete Unicode-Zeichen.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
        <related type="Article" href="http://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a">Interop-Marshalling</related>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der DLL-Datei ab, die den Einstiegspunkt enthält.</summary>
        <value>Der Name der DLL-Datei, die den Einstiegspunkt enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können einen vollständigen oder relativen Pfad angeben. Wenn Sie keinen Pfad angeben, muss die DLL im aktuellen Pfad zur Laufzeit sein, wenn andere Weise die DLL geladen wird. Denken Sie jedoch, dass mit einem vollständig qualifizierten Pfad Ungenauigkeit führen kann, wenn die DLL verschoben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>