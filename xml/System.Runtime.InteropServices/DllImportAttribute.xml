<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5b9ff9f9461d617448b3de46d168ff5f74c35ab9" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86764746" /></Metadata><TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime.InteropServices" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime.InteropServices" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gibt an, dass die attributierte Methode durch eine nicht verwaltete Dynamic Link Library (DLL) als statischer Einstiegspunkt verfügbar gemacht wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können dieses Attribut auf Methoden anwenden.  
  
 Das- <xref:System.Runtime.InteropServices.DllImportAttribute> Attribut stellt die Informationen bereit, die zum Abrufen einer aus einer nicht verwalteten DLL exportierten Funktion erforderlich sind. Als Mindestanforderung müssen Sie den Namen der DLL angeben, die den Einstiegspunkt enthält.  
  
 Sie wenden dieses Attribut direkt auf c#-und C++-Methoden Definitionen an. der Visual Basic Compiler gibt dieses Attribut jedoch aus, wenn Sie die- `Declare` Anweisung verwenden. Für komplexe Methoden Definitionen, die-,-,-,-,- <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> oder-Felder enthalten <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> , wenden Sie dieses Attribut direkt auf Visual Basic Methoden Definitionen an.  
  
 **Hinweis** JScript unterstützt dieses Attribut nicht. Mithilfe von c#-oder Visual Basic Wrapper Klassen können Sie von JScript-Programmen aus auf nicht verwaltete API-Methoden zugreifen.  
  
 Weitere Informationen zur Verwendung des Platt Form Aufruf Dienstanbieter für den Zugriff auf Funktionen in nicht verwalteten DLLs finden Sie unter verwenden [nicht verwalteter DLL-Funktionen](/dotnet/framework/interop/consuming-unmanaged-dll-functions).  
  
> [!NOTE]
>  Der <xref:System.Runtime.InteropServices.DllImportAttribute> unterstützt das Marshalling von generischen Typen nicht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie das-Attribut verwendet wird <xref:System.Runtime.InteropServices.DllImportAttribute> , um die Win32-Funktion zu importieren `MessageBox` .  Das Codebeispiel ruft dann die importierte Methode auf.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">Der Name der DLL, die die nicht verwaltete Methode enthält. Dieser kann einen Assemblyanzeigenamen einschließen, wenn die DLL in einer Assembly enthalten ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.InteropServices.DllImportAttribute" />-Klasse mit dem Namen der DLL, die die zu importierende Methode enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine nicht verwaltete DLL-Datei in einer Assembly enthalten ist, z. b. mit dem Linker oder der `/linkresource` Compileroption, können Sie den anzeigen amen der Assembly als Teil von angeben `dllName` . Wenn beispielsweise eine nicht verwaltete DLL `unmanaged.dll` mit dem Namen in eine verwaltete Assembly mit dem Namen eingeschlossen ist `MyAssembly` , kann das-Attribut wie im folgenden Code dargestellt angegeben werden.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie das-Attribut verwendet wird <xref:System.Runtime.InteropServices.DllImportAttribute> , um die Win32-Funktion zu importieren `MessageBox` .  Das Codebeispiel ruft dann die importierte Methode auf.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aktiviert bzw. deaktiviert das Verhalten der optimalen Zuordnung bei der Konvertierung von Unicode-Zeichen in ANSI-Zeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt an, dass das Verhalten mit der `true` optimalen Anpassung aktiviert ist, andernfalls ist die Zuordnung mit der optimalen Anpassung deaktiviert. Das <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> Feld ist `true` standardmäßig. Die Einstellungen für dieses Feld überschreiben alle Ebenen-Einstellungen für das <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> Attribut.  
  
 Der Common Language Runtime konvertiert alle verwalteten Unicode-Zeichen in ANSI-Zeichen, die an eine nicht verwaltete Methode weitergeleitet werden, die unter Windows 98 oder Windows Me ausgeführt wird. Die Zuordnung mit dem besten Zeichen ermöglicht dem Interop-Mars Haller, ein schließende Zeichen bereitzustellen, wenn keine genaue Übereinstimmung vorhanden ist. Der Mars Haller konvertiert z. b. das Unicode-Copyright Zeichen für nicht verwaltete Methoden, die ANSI-Zeichen akzeptieren, in "c". Bei manchen Zeichen fehlt eine Darstellung mit der optimalen Anpassung. Diese Zeichen werden als nicht mappbar bezeichnet. Nicht mappbare Zeichen werden in der Regel in den Standardwert "?" konvertiert. ANSI-Zeichen.  
  
> [!CAUTION]
>  Bestimmte Unicode-Zeichen werden in gefährliche Zeichen (z. b. den umgekehrten Schrägstrich ' ') konvertiert \\ , wodurch ein Pfad versehentlich geändert werden kann. Wenn Sie das- <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Feld auf festlegen `true` , können Sie dem Aufrufer das vorhanden sein eines nicht mappbaren Zeichens signalisieren, indem Sie eine Ausnahme auslösen.  
  
> [!CAUTION]
>  Sie können die Standardwerte, die von den Feldern und bereitgestellt werden, nicht ändern <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> , wenn Sie ein verwaltetes Array, dessen Elemente ANSI-Zeichen oder lpstrans sind, in ein nicht verwaltetes sicheres Array übergeben Die Zuordnung mit der optimalen Anpassung ist immer aktiviert, und es wird keine Ausnahme ausgelöst. Beachten Sie, dass diese Kombination Ihr Sicherheitsmodell gefährden kann.  
  
   
  
## Examples  
 In einigen Fällen verwenden Visual Basic Entwickler anstelle der- <xref:System.Runtime.InteropServices.DllImportAttribute> `Declare` Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren. Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> Felds ist einer dieser Fälle. Im folgenden Beispiel wird gezeigt, wie die strikte Sicherheit der Zeichen Zuordnung auf eine Platt Form Aufruf Methoden Definitionen angewendet wird, indem der ANSI-Zeichensatz angegeben wird, das Verhalten der optimalen Anpassung der Zuordnung deaktiviert und eine Ausnahme für nicht zugeordnete Unicode-Zeichen ausgelöst wird.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
        <related type="Article" href="/dotnet/framework/interop/interop-marshaling">Interop-Marshalling</related>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Aufrufkonvention eines Einstiegspunkts an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie legen dieses Feld auf einen der Enumerationsmember fest <xref:System.Runtime.InteropServices.CallingConvention> . Der Standardwert für das <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> Feld ist <xref:System.Runtime.InteropServices.CallingConvention.Winapi> , das wiederum standardmäßig auf Konvention festgelegt ist <xref:System.Runtime.InteropServices.CallingConvention.StdCall> .  
  
   
  
## Examples  
 In einigen Fällen verwenden Visual Basic Entwickler anstelle der- <xref:System.Runtime.InteropServices.DllImportAttribute> `Declare` Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren. Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> Felds ist einer dieser Fälle.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#1)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, wie Zeichenfolgenparameter an die Methode gemarshallt werden, und steuert die Namenszerlegung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie dieses Feld mit einem Member der- <xref:System.Runtime.InteropServices.CharSet> Enumeration, um das Marshallingverhalten von Zeichen folgen Parametern anzugeben, und um anzugeben, welcher Einstiegspunkt Name aufgerufen werden soll (der genaue Name, der angegeben wurde, oder ein Name, der mit "a" oder "W" endet). Der Standardenumerationsmember für c# und Visual Basic ist `CharSet.Ansi` , und der Standardenumerationsmember für C++ ist `CharSet.None` , was entspricht `CharSet.Ansi` . In Visual Basic verwenden Sie die- `Declare` Anweisung, um das `CharSet` Feld anzugeben.  
  
 Das- <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Feld wirkt sich auf das Verhalten des- `CharSet` Felds aus, um zu bestimmen, welcher Einstiegspunkt Name aufgerufen werden soll. Eine ausführliche Beschreibung und Beispiele für das Marshalling von Zeichen folgen und das namens Übereinstimmungs Verhalten, die dem Feld zugeordnet sind `CharSet` , finden Sie unter [Angeben eines Zeichensatzes](/dotnet/framework/interop/specifying-a-character-set).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie das-Attribut verwendet wird <xref:System.Runtime.InteropServices.DllImportAttribute> , um die Win32-Funktion zu importieren `MessageBox` .  Das Codebeispiel ruft dann die importierte Methode auf.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="C#" Value="public string? EntryPoint;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den Namen oder die Ordnungszahl des aufzurufenden DLL-Einstiegspunkts an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Namen des Einstiegs Punkts angeben, indem Sie eine Zeichenfolge angeben, die den Namen der DLL angibt, die den Einstiegspunkt enthält, oder Sie können den Einstiegspunkt anhand seiner Ordnungszahl identifizieren. Ordinalen wird das #-Zeichen als Präfix vorangestellt, z. b. #1. Wenn Sie dieses Feld weglassen, verwendet das Common Language Runtime den Namen der The.NET-Methode, die mit dem markiert ist <xref:System.Runtime.InteropServices.DllImportAttribute> .  
  
 Weitere Informationen finden Sie unter [Identifizieren von Funktionen in DLLs](/dotnet/framework/interop/identifying-functions-in-dlls). Beispiele zur Verwendung des- <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> Felds finden Sie unter [Angeben eines Einstiegs Punkts](/dotnet/framework/interop/specifying-an-entry-point).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie das-Attribut verwendet wird <xref:System.Runtime.InteropServices.DllImportAttribute> , um die Win32-Funktion zu importieren `MessageBox` .  Im Codebeispiel wird die <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> -Eigenschaft verwendet, um die zu importierende Funktion anzugeben, und anschließend wird der Name in geändert `MyNewMessageBoxMethod` .  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Steuert, ob das <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />-Feld die Common Language Runtime anweist, eine nicht verwaltete DLL nach anderen Einstiegspunktnamen als dem angegebenen zu durchsuchen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `false` , wird der mit dem Buchstaben A angefügte Einstiegspunkt Name aufgerufen <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> , wenn das Feld auf festgelegt ist `CharSet.Ansi` , und der mit dem Buchstaben W angefügte Einstiegspunkt Name wird aufgerufen, wenn das <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> Feld auf festgelegt ist `CharSet.Unicode` . In der Regel legen verwaltete Compiler dieses Feld fest.  
  
 In der folgenden Tabelle wird die Beziehung zwischen <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> den <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Feldern und basierend auf den von der Programmiersprache vorgegebenen Standardwerten angezeigt. Sie können die Standardeinstellung außer Kraft setzen, jedoch mit Vorsicht.  
  
|Sprache|ANSI|Unicode|Auto|  
|--------------|----------|-------------|----------|  
|Visual Basic|ExactSpelling: = true|ExactSpelling: = true|ExactSpelling: = false|  
|C#|ExactSpelling = false|ExactSpelling = false|ExactSpelling = false|  
|C++|ExactSpelling = false|ExactSpelling = false|ExactSpelling = false|  
  
   
  
## Examples  
 In einigen Fällen verwenden Visual Basic Entwickler anstelle der- <xref:System.Runtime.InteropServices.DllImportAttribute> `Declare` Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren. Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Felds ist einer dieser Fälle.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob nicht verwaltete Methoden, die über <see langword="HRESULT" />-Rückgabewerte oder <see langword="retval" />-Rückgabewerte verfügen, direkt übersetzt werden oder ob <see langword="HRESULT" />-Rückgabewerte oder <see langword="retval" />-Rückgabewerte automatisch in Ausnahmen konvertiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie das- <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld auf fest, `true` um nicht verwaltete Signaturen direkt mit-oder-Werten zu übersetzen `HRESULT` `retval` . Legen Sie es auf fest, `false` um die `HRESULT` Werte automatisch `retval` zu konvertieren Standardmäßig ist das- <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld `true` .  
  
 Wenn `true` der Wert ist, gibt die resultierende Methoden Signatur einen ganzzahligen Wert zurück, der den `HRESULT` Wert enthält.  In diesem Fall müssen Sie den Rückgabewert manuell überprüfen und in Ihrer Anwendung entsprechend antworten.  
  
 Wenn Sie das- <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld auf festlegen `false` , enthält die resultierende Methoden Signatur einen void-Rückgabetyp anstelle eines Integer ( `HRESULT` )-Rückgabe Typs.  Wenn die nicht verwaltete Methode einen erzeugt `HRESULT` , ignoriert die Runtime automatisch einen Rückgabewert von `S_OK` (oder 0) und löst keine Ausnahme aus.  Bei `HRESULT` anderen Ausnahmen als löst die Common Language `S_OK` Runtime automatisch eine Ausnahme aus, die dem entspricht `HRESULT` .  Beachten Sie, dass das- <xref:System.Runtime.InteropServices.DllImportAttribute> Attribut diese Konvertierung nur in Methoden durchführt, die zurückgeben `HRESULT` .  
  
 `HRESULT`In Fällen, in denen Ausnahmen besser zur Fehler Berichterstattungs Struktur der Anwendung passen, können Sie das Standardverhalten der Fehlerberichterstattung von s in "Ausnahmen" ändern.  
  
 Dieses Feld ähnelt dem, <xref:System.Runtime.InteropServices.PreserveSigAttribute> aber im Gegensatz zum- <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld ist der Standardwert für das-Attribut `false` .  
  
 In einigen Fällen verwenden Visual Basic Entwickler anstelle der- <xref:System.Runtime.InteropServices.DllImportAttribute> `Declare` Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren. Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Felds ist einer dieser Fälle.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird verwendet <xref:System.Runtime.InteropServices.DllImportAttribute> , um die nicht verwaltete `SHAutoComplete` Funktion einmal zu importieren, wobei das <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> -Feld auf festgelegt ist `true` und das- <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld wieder `false` auf festgelegt ist.  Dieses Codebeispiel bewirkt `SHAutoComplete` , dass die-Funktion alle Fehler mit einer-Ausnahme einmalig und als `HRESULT` nächstes generiert.  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Aufgerufene vor dem Zurückgeben aus der attributierten Methode die Windows-API <see langword="SetLastError" /> aufruft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` , um anzugeben, dass der aufgerufene aufruft, `SetLastError` andernfalls `false` . Der Standardwert ist `false`.  
  
 Der Laufzeitmarshaller ruft `GetLastError` auf und speichert den zurückgegebenen Wert, um zu verhindern, dass er durch andere API-Aufrufe überschrieben wird. Sie können den Fehlercode abrufen, indem Sie aufrufen <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> .  
  
   
  
## Examples  
 In einigen Fällen verwenden Visual Basic Entwickler anstelle der- <xref:System.Runtime.InteropServices.DllImportAttribute> `Declare` Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren. Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> Felds ist einer dieser Fälle.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aktiviert bzw. deaktiviert das Auslösen einer Ausnahme bei einem nicht zuzuordnenden Unicode-Zeichen, das in das ANSI-Zeichen „?“ konvertiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` , um anzugeben, dass eine Ausnahme immer ausgelöst wird, wenn der Interop-Mars Haller ein nicht mappbares Zeichen konvertiert. `false` , um anzugeben, dass das <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Feld deaktiviert ist. Dieses Feld ist standardmäßig auf `false` festgelegt.  
  
 Der Common Language Runtime konvertiert alle verwalteten Unicode-Zeichen in ANSI-Zeichen, die an eine nicht verwaltete Methode weitergeleitet werden, die unter Windows 98 oder Windows Me ausgeführt wird. Die Zuordnung mit dem besten Zeichen ermöglicht dem Interop-Mars Haller, ein schließende Zeichen bereitzustellen, wenn keine genaue Übereinstimmung vorhanden ist. Der Mars Haller konvertiert z. b. das Unicode-Copyright Zeichen für nicht verwaltete Methoden, die ANSI-Zeichen akzeptieren, in "c". Bei manchen Zeichen fehlt eine Darstellung mit der optimalen Anpassung. Diese Zeichen werden als nicht mappbar bezeichnet. Nicht mappbare Zeichen werden in der Regel in den Standardwert "?" konvertiert. ANSI-Zeichen.  
  
> [!CAUTION]
>  Bestimmte Unicode-Zeichen werden in gefährliche Zeichen (z. b. den umgekehrten Schrägstrich ' ') konvertiert \\ , wodurch ein Pfad versehentlich geändert werden kann. Wenn Sie das- <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Feld auf festlegen `true` , können Sie dem Aufrufer das vorhanden sein eines nicht mappbaren Zeichens signalisieren, indem Sie eine Ausnahme auslösen.  
  
> [!CAUTION]
>  Sie können die Standardwerte, die von den Feldern und bereitgestellt werden, nicht ändern <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> , wenn Sie ein verwaltetes Array, dessen Elemente ANSI-Zeichen oder lpstrans sind, in ein nicht verwaltetes sicheres Array übergeben Die Zuordnung mit der optimalen Anpassung ist immer aktiviert, und es wird keine Ausnahme ausgelöst. Beachten Sie, dass diese Kombination Ihr Sicherheitsmodell gefährden kann.  
  
   
  
## Examples  
 In einigen Fällen verwenden Visual Basic Entwickler zum <xref:System.Runtime.InteropServices.DllImportAttribute> Definieren einer DLL-Funktion in verwaltetem Code anstelle der- `Declare` Anweisung. Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Felds ist einer dieser Fälle. Im folgenden Beispiel wird gezeigt, wie die strikte Sicherheit der Zeichen Zuordnung auf eine Platt Form Aufruf Methoden Definitionen angewendet wird, indem der ANSI-Zeichensatz angegeben wird, das Verhalten der optimalen Anpassung der Zuordnung deaktiviert und eine Ausnahme für nicht zugeordnete Unicode-Zeichen ausgelöst wird.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
        <related type="Article" href="/dotnet/framework/interop/interop-marshaling">Interop-Marshalling</related>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der DLL-Datei ab, die den Einstiegspunkt enthält.</summary>
        <value>Der Name der DLL-Datei, die den Einstiegspunkt enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können einen vollständigen oder relativen Pfad angeben. Wenn Sie keinen Pfad angeben, muss sich die dll zur Laufzeit im aktuellen Pfad befinden, es sei denn, die dll wird auf andere Weise geladen. Beachten Sie jedoch, dass die Verwendung eines voll qualifizierten Pfads zu einer Ungenauigkeit führen kann, wenn die dll verschoben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
