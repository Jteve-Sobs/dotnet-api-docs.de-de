<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2ea03f3bce7908bcc35f30b8aa2567f6909f8004" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75087016" /></Metadata><TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gibt an, dass die attributierte Methode durch eine nicht verwaltete Dynamic Link Library (DLL) als statischer Einstiegspunkt verfügbar gemacht wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können dieses Attribut auf Methoden anwenden.  
  
 Das <xref:System.Runtime.InteropServices.DllImportAttribute>-Attribut stellt die Informationen bereit, die zum Abrufen einer aus einer nicht verwalteten DLL exportierten Funktion erforderlich sind. Als Mindestanforderung müssen Sie den Namen der DLL angeben, die den Einstiegspunkt enthält.  
  
 Sie wenden dieses Attribut direkt auf C# - C++ und-Methoden Definitionen an. der Visual Basic Compiler gibt dieses Attribut jedoch aus, wenn Sie die `Declare`-Anweisung verwenden. Für komplexe Methoden Definitionen, die <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>-, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>-, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>-, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>-, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>-oder <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar>-Felder einschließen, wenden Sie dieses Attribut direkt auf Visual Basic Methoden Definitionen an.  
  
 **Hinweis** JScript unterstützt dieses Attribut nicht. Sie können- C# oder-Visual Basic Wrapper Klassen verwenden, um über JScript-Programme auf nicht verwaltete API-Methoden zuzugreifen.  
  
 Weitere Informationen zur Verwendung des Platt Form Aufruf Dienstanbieter für den Zugriff auf Funktionen in nicht verwalteten DLLs finden Sie unter verwenden [nicht verwalteter DLL-Funktionen](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
> [!NOTE]
>  Der <xref:System.Runtime.InteropServices.DllImportAttribute> unterstützt das Marshalling von generischen Typen nicht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie das <xref:System.Runtime.InteropServices.DllImportAttribute>-Attribut verwendet wird, um die Win32-`MessageBox`-Funktion zu importieren.  Das Codebeispiel ruft dann die importierte Methode auf.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">Der Name der DLL, die die nicht verwaltete Methode enthält. Dieser kann einen Assemblyanzeigenamen einschließen, wenn die DLL in einer Assembly enthalten ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.InteropServices.DllImportAttribute" />-Klasse mit dem Namen der DLL, die die zu importierende Methode enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine nicht verwaltete DLL-Datei in einer Assembly enthalten ist, z. b. mit dem Linker oder der `/linkresource`-Compileroption, können Sie den anzeigen amen der Assembly als Teil `dllName`angeben. Wenn beispielsweise eine nicht verwaltete DLL mit dem Namen `unmanaged.dll` in einer verwalteten Assembly namens `MyAssembly`enthalten ist, kann das-Attribut wie im folgenden Code dargestellt angegeben werden.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie das <xref:System.Runtime.InteropServices.DllImportAttribute>-Attribut verwendet wird, um die Win32-`MessageBox`-Funktion zu importieren.  Das Codebeispiel ruft dann die importierte Methode auf.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aktiviert bzw. deaktiviert das Verhalten der optimalen Zuordnung bei der Konvertierung von Unicode-Zeichen in ANSI-Zeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `true`, ist das Mapping-Verhalten mit der optimalen Anpassung aktiviert. Andernfalls ist die Zuordnung mit der optimalen Anpassung deaktiviert. Das <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> Feld ist standardmäßig `true`. Die Einstellungen für dieses Feld überschreiben alle Ebenen-Einstellungen für das <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> Attribut.  
  
 Der Common Language Runtime konvertiert alle verwalteten Unicode-Zeichen in ANSI-Zeichen, die an eine nicht verwaltete Methode weitergeleitet werden, die unter Windows 98 oder Windows Me ausgeführt wird. Die Zuordnung mit dem besten Zeichen ermöglicht dem Interop-Mars Haller, ein schließende Zeichen bereitzustellen, wenn keine genaue Übereinstimmung vorhanden ist. Der Mars Haller konvertiert z. b. das Unicode-Copyright Zeichen für nicht verwaltete Methoden, die ANSI-Zeichen akzeptieren, in "c". Bei manchen Zeichen fehlt eine Darstellung mit der optimalen Anpassung. Diese Zeichen werden als nicht mappbar bezeichnet. Nicht mappbare Zeichen werden in der Regel in den Standardwert "?" konvertiert. ANSI-Zeichen.  
  
> [!CAUTION]
>  Bestimmte Unicode-Zeichen werden in gefährliche Zeichen (z. b. den umgekehrten Schrägstrich '\\') konvertiert, wodurch ein Pfad versehentlich geändert werden kann. Durch Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Felds auf `true`können Sie dem Aufrufer das vorhanden sein eines nicht mappbaren Zeichens signalisieren, indem Sie eine Ausnahme auslösen.  
  
> [!CAUTION]
>  Sie können die Standardwerte, die von den Feldern <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> und <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> bereitgestellt werden, nicht ändern, wenn Sie ein verwaltetes Array, dessen Elemente ANSI-Zeichen oder lpstrinsind, in ein nicht verwaltetes sicheres Array übergeben. Die Zuordnung mit der optimalen Anpassung ist immer aktiviert, und es wird keine Ausnahme ausgelöst. Beachten Sie, dass diese Kombination Ihr Sicherheitsmodell gefährden kann.  
  
   
  
## Examples  
 In einigen Fällen können Visual Basic Entwickler die <xref:System.Runtime.InteropServices.DllImportAttribute>anstelle der `Declare`-Anweisung verwenden, um eine DLL-Funktion in verwaltetem Code zu definieren. Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> Felds ist einer dieser Fälle. Im folgenden Beispiel wird gezeigt, wie die strikte Sicherheit der Zeichen Zuordnung auf eine Platt Form Aufruf Methoden Definitionen angewendet wird, indem der ANSI-Zeichensatz angegeben wird, das Verhalten der optimalen Anpassung der Zuordnung deaktiviert und eine Ausnahme für nicht zugeordnete Unicode-Zeichen ausgelöst wird.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
        <related type="Article" href="https://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a">Interop-Marshalling</related>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Aufrufkonvention eines Einstiegspunkts an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie legen dieses Feld auf einen der <xref:System.Runtime.InteropServices.CallingConvention> Enumerationsmember fest. Der Standardwert für das Feld <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> ist <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, das wiederum standardmäßig <xref:System.Runtime.InteropServices.CallingConvention.StdCall> Konvention verwendet.  
  
   
  
## Examples  
 In einigen Fällen können Visual Basic Entwickler die <xref:System.Runtime.InteropServices.DllImportAttribute>anstelle der `Declare`-Anweisung verwenden, um eine DLL-Funktion in verwaltetem Code zu definieren. Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> Felds ist einer dieser Fälle.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#1)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, wie Zeichenfolgenparameter an die Methode gemarshallt werden, und steuert die Namenszerlegung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie dieses Feld mit einem Member der <xref:System.Runtime.InteropServices.CharSet>-Enumeration, um das Marshallingverhalten von Zeichen folgen Parametern anzugeben, und um anzugeben, welcher Einstiegspunkt Name aufgerufen werden soll (der genaue Name, der angegeben wurde, oder ein Name, der mit "a" oder "W" endet). Der Standardenumerationsmember für C# und Visual Basic ist `CharSet.Ansi`, und der Standardenumerationsmember für C++ ist `CharSet.None`. Dies entspricht `CharSet.Ansi`. In Visual Basic verwenden Sie die `Declare`-Anweisung, um das `CharSet` Feld anzugeben.  
  
 Das <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Feld wirkt sich auf das Verhalten des `CharSet` Felds aus, um zu bestimmen, welcher Einstiegspunkt Name aufgerufen werden soll. Eine ausführliche Beschreibung und Beispiele für das Marshalling von Zeichen folgen und das namens Übereinstimmungs Verhalten, das dem `CharSet`-Feld zugeordnet ist, finden Sie unter [Angeben eines Zeichensatzes](~/docs/framework/interop/specifying-a-character-set.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie das <xref:System.Runtime.InteropServices.DllImportAttribute>-Attribut verwendet wird, um die Win32-`MessageBox`-Funktion zu importieren.  Das Codebeispiel ruft dann die importierte Methode auf.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den Namen oder die Ordnungszahl des aufzurufenden DLL-Einstiegspunkts an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Namen des Einstiegs Punkts angeben, indem Sie eine Zeichenfolge angeben, die den Namen der DLL angibt, die den Einstiegspunkt enthält, oder Sie können den Einstiegspunkt anhand seiner Ordnungszahl identifizieren. Ordinalen wird das #-Zeichen als Präfix vorangestellt, z. b. #1. Wenn Sie dieses Feld weglassen, verwendet das Common Language Runtime den Namen der The.NET-Methode, die mit dem <xref:System.Runtime.InteropServices.DllImportAttribute>markiert ist.  
  
 Weitere Informationen finden Sie unter [Identifizieren von Funktionen in DLLs](~/docs/framework/interop/identifying-functions-in-dlls.md). Beispiele für die Verwendung des Felds <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> finden Sie unter [Angeben eines Einstiegs Punkts](~/docs/framework/interop/specifying-an-entry-point.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie das <xref:System.Runtime.InteropServices.DllImportAttribute>-Attribut verwendet wird, um die Win32-`MessageBox`-Funktion zu importieren.  Im Codebeispiel wird die <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint>-Eigenschaft verwendet, um die zu importierende Funktion anzugeben, und anschließend wird der Name in `MyNewMessageBoxMethod`geändert.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Steuert, ob das <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />-Feld die Common Language Runtime anweist, eine nicht verwaltete DLL nach anderen Einstiegspunktnamen als dem angegebenen zu durchsuchen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `false`, wird der Name des Einstiegs Punkts, der mit dem Buchstaben A angehängt wird, aufgerufen, wenn das <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> Feld auf `CharSet.Ansi`festgelegt ist, und der mit dem Buchstaben W angefügte Einstiegspunkt Name wird aufgerufen, wenn das <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> Feld auf den `CharSet.Unicode`festgelegt ist. In der Regel legen verwaltete Compiler dieses Feld fest.  
  
 In der folgenden Tabelle wird die Beziehung zwischen den Feldern <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> und <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> auf der Grundlage von Standardwerten, die von der Programmiersprache festgelegt werden, angezeigt. Sie können die Standardeinstellung außer Kraft setzen, jedoch mit Vorsicht.  
  
|Sprache|ANSI|Unicode|Automatisch|  
|--------------|----------|-------------|----------|  
|Visual Basic|ExactSpelling: = true|ExactSpelling: = true|ExactSpelling: = false|  
|C#|ExactSpelling = false|ExactSpelling = false|ExactSpelling = false|  
|C++|ExactSpelling = false|ExactSpelling = false|ExactSpelling = false|  
  
   
  
## Examples  
 In einigen Fällen Visual Basic Entwickler die <xref:System.Runtime.InteropServices.DllImportAttribute>verwenden, anstatt die `Declare`-Anweisung zu verwenden, um eine DLL-Funktion in verwaltetem Code zu definieren. Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Felds ist einer dieser Fälle.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob nicht verwaltete Methoden, die über <see langword="HRESULT" />-Rückgabewerte oder <see langword="retval" />-Rückgabewerte verfügen, direkt übersetzt werden oder ob <see langword="HRESULT" />-Rückgabewerte oder <see langword="retval" />-Rückgabewerte automatisch in Ausnahmen konvertiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie das <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>-Feld auf `true` fest, um nicht verwaltete Signaturen direkt mit `HRESULT` oder `retval` Werten zu übersetzen. Legen Sie Sie auf `false`, um `HRESULT`-oder `retval`-Werte automatisch in Ausnahmen zu konvertieren. Standardmäßig ist das <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld `true`.  
  
 Wenn `true`, gibt die resultierende Methoden Signatur einen ganzzahligen Wert zurück, der den `HRESULT` Wert enthält.  In diesem Fall müssen Sie den Rückgabewert manuell überprüfen und in Ihrer Anwendung entsprechend antworten.  
  
 Wenn Sie das <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>-Feld auf `false`festlegen, enthält die resultierende Methoden Signatur einen void-Rückgabetyp anstelle eines ganzzahligen (`HRESULT`) Rückgabe Typs.  Wenn die nicht verwaltete Methode eine `HRESULT`erstellt, ignoriert die Runtime automatisch den Rückgabewert `S_OK` (oder 0) und löst keine Ausnahme aus.  Bei anderen `HRESULT`s als `S_OK`löst die Laufzeit automatisch eine Ausnahme aus, die dem `HRESULT`entspricht.  Beachten Sie, dass das <xref:System.Runtime.InteropServices.DllImportAttribute>-Attribut diese Konvertierung nur in Methoden durchführt, die einen `HRESULT`zurückgeben.  
  
 Sie können das Standardverhalten der Fehlerberichterstattung von `HRESULT`s in "Ausnahmen" ändern, wenn Ausnahmen für die Fehler Berichterstattungs Struktur der Anwendung besser geeignet sind.  
  
 Dieses Feld ähnelt dem <xref:System.Runtime.InteropServices.PreserveSigAttribute>. im Gegensatz zum <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>-Feld ist der Standardwert für das-Attribut jedoch `false`.  
  
 In einigen Fällen Visual Basic Entwickler die <xref:System.Runtime.InteropServices.DllImportAttribute>verwenden, anstatt die `Declare`-Anweisung zu verwenden, um eine DLL-Funktion in verwaltetem Code zu definieren. Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Felds ist einer dieser Fälle.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die-<xref:System.Runtime.InteropServices.DllImportAttribute> verwendet, um die nicht verwaltete `SHAutoComplete`-Funktion einmal zu importieren, wobei das <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>-Feld auf `true` festgelegt ist und das <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld wieder auf `false`festgelegt ist.  Dieses Codebeispiel bewirkt, dass die `SHAutoComplete`-Funktion alle Fehler mit einer-Ausnahme einmal generiert und `HRESULT` der nächsten.  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Aufgerufene vor dem Zurückgeben aus der attributierten Methode die Windows-API <see langword="SetLastError" /> aufruft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true`, um anzugeben, dass der aufgerufene `SetLastError`aufruft. Andernfalls `false`. Der Standardwert ist `false`.  
  
 Der laufzeitmars Haller ruft `GetLastError` auf und speichert den zurückgegebenen Wert, um zu verhindern, dass er durch andere API-Aufrufe überschrieben wird. Sie können den Fehlercode abrufen, indem Sie <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>aufrufen.  
  
   
  
## Examples  
 In einigen Fällen Visual Basic Entwickler die <xref:System.Runtime.InteropServices.DllImportAttribute>verwenden, anstatt die `Declare`-Anweisung zu verwenden, um eine DLL-Funktion in verwaltetem Code zu definieren. Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> Felds ist einer dieser Fälle.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aktiviert bzw. deaktiviert das Auslösen einer Ausnahme bei einem nicht zuzuordnenden Unicode-Zeichen, das in das ANSI-Zeichen „?“ konvertiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true`, um anzugeben, dass eine Ausnahme ausgelöst wird, wenn der Interop-Mars Haller ein nicht mappbares Zeichen konvertiert. `false`, um anzugeben, dass das <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Feld deaktiviert ist. Dieses Feld ist standardmäßig `false`.  
  
 Der Common Language Runtime konvertiert alle verwalteten Unicode-Zeichen in ANSI-Zeichen, die an eine nicht verwaltete Methode weitergeleitet werden, die unter Windows 98 oder Windows Me ausgeführt wird. Die Zuordnung mit dem besten Zeichen ermöglicht dem Interop-Mars Haller, ein schließende Zeichen bereitzustellen, wenn keine genaue Übereinstimmung vorhanden ist. Der Mars Haller konvertiert z. b. das Unicode-Copyright Zeichen für nicht verwaltete Methoden, die ANSI-Zeichen akzeptieren, in "c". Bei manchen Zeichen fehlt eine Darstellung mit der optimalen Anpassung. Diese Zeichen werden als nicht mappbar bezeichnet. Nicht mappbare Zeichen werden in der Regel in den Standardwert "?" konvertiert. ANSI-Zeichen.  
  
> [!CAUTION]
>  Bestimmte Unicode-Zeichen werden in gefährliche Zeichen (z. b. den umgekehrten Schrägstrich '\\') konvertiert, wodurch ein Pfad versehentlich geändert werden kann. Durch Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Felds auf `true`können Sie dem Aufrufer das vorhanden sein eines nicht mappbaren Zeichens signalisieren, indem Sie eine Ausnahme auslösen.  
  
> [!CAUTION]
>  Sie können die Standardwerte, die von den Feldern <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> und <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> bereitgestellt werden, nicht ändern, wenn Sie ein verwaltetes Array, dessen Elemente ANSI-Zeichen oder lpstrinsind, in ein nicht verwaltetes sicheres Array übergeben. Die Zuordnung mit der optimalen Anpassung ist immer aktiviert, und es wird keine Ausnahme ausgelöst. Beachten Sie, dass diese Kombination Ihr Sicherheitsmodell gefährden kann.  
  
   
  
## Examples  
 In einigen Fällen verwenden Visual Basic Entwickler die <xref:System.Runtime.InteropServices.DllImportAttribute>, um eine DLL-Funktion in verwaltetem Code zu definieren, anstatt die `Declare`-Anweisung zu verwenden. Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Felds ist einer dieser Fälle. Im folgenden Beispiel wird gezeigt, wie die strikte Sicherheit der Zeichen Zuordnung auf eine Platt Form Aufruf Methoden Definitionen angewendet wird, indem der ANSI-Zeichensatz angegeben wird, das Verhalten der optimalen Anpassung der Zuordnung deaktiviert und eine Ausnahme für nicht zugeordnete Unicode-Zeichen ausgelöst wird.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
        <related type="Article" href="https://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a">Interop-Marshalling</related>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der DLL-Datei ab, die den Einstiegspunkt enthält.</summary>
        <value>Der Name der DLL-Datei, die den Einstiegspunkt enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können einen vollständigen oder relativen Pfad angeben. Wenn Sie keinen Pfad angeben, muss sich die dll zur Laufzeit im aktuellen Pfad befinden, es sei denn, die dll wird auf andere Weise geladen. Beachten Sie jedoch, dass die Verwendung eines voll qualifizierten Pfads zu einer Ungenauigkeit führen kann, wenn die dll verschoben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
