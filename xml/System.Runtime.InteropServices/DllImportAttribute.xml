<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5b9ff9f9461d617448b3de46d168ff5f74c35ab9" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86764746" /></Metadata><TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime.InteropServices" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime.InteropServices" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="00af1-101">Gibt an, dass die attributierte Methode durch eine nicht verwaltete Dynamic Link Library (DLL) als statischer Einstiegspunkt verfügbar gemacht wird.</span><span class="sxs-lookup"><span data-stu-id="00af1-101">Indicates that the attributed method is exposed by an unmanaged dynamic-link library (DLL) as a static entry point.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00af1-102">Sie können dieses Attribut auf Methoden anwenden.</span><span class="sxs-lookup"><span data-stu-id="00af1-102">You can apply this attribute to methods.</span></span>  
  
 <span data-ttu-id="00af1-103">Das- <xref:System.Runtime.InteropServices.DllImportAttribute> Attribut stellt die Informationen bereit, die zum Abrufen einer aus einer nicht verwalteten DLL exportierten Funktion erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="00af1-103">The <xref:System.Runtime.InteropServices.DllImportAttribute> attribute provides the information needed to call a function exported from an unmanaged DLL.</span></span> <span data-ttu-id="00af1-104">Als Mindestanforderung müssen Sie den Namen der DLL angeben, die den Einstiegspunkt enthält.</span><span class="sxs-lookup"><span data-stu-id="00af1-104">As a minimum requirement, you must supply the name of the DLL containing the entry point.</span></span>  
  
 <span data-ttu-id="00af1-105">Sie wenden dieses Attribut direkt auf c#-und C++-Methoden Definitionen an. der Visual Basic Compiler gibt dieses Attribut jedoch aus, wenn Sie die- `Declare` Anweisung verwenden.</span><span class="sxs-lookup"><span data-stu-id="00af1-105">You apply this attribute directly to C# and C++ method definitions; however, the Visual Basic compiler emits this attribute when you use the `Declare` statement.</span></span> <span data-ttu-id="00af1-106">Für komplexe Methoden Definitionen, die-,-,-,-,- <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> oder-Felder enthalten <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> , wenden Sie dieses Attribut direkt auf Visual Basic Methoden Definitionen an.</span><span class="sxs-lookup"><span data-stu-id="00af1-106">For complex method definitions that include <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, or <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> fields, you apply this attribute directly to Visual Basic method definitions.</span></span>  
  
 <span data-ttu-id="00af1-107">**Hinweis** JScript unterstützt dieses Attribut nicht.</span><span class="sxs-lookup"><span data-stu-id="00af1-107">**Note** JScript does not support this attribute.</span></span> <span data-ttu-id="00af1-108">Mithilfe von c#-oder Visual Basic Wrapper Klassen können Sie von JScript-Programmen aus auf nicht verwaltete API-Methoden zugreifen.</span><span class="sxs-lookup"><span data-stu-id="00af1-108">You can use C# or Visual Basic wrapper classes to access unmanaged API methods from JScript programs.</span></span>  
  
 <span data-ttu-id="00af1-109">Weitere Informationen zur Verwendung des Platt Form Aufruf Dienstanbieter für den Zugriff auf Funktionen in nicht verwalteten DLLs finden Sie unter verwenden [nicht verwalteter DLL-Funktionen](/dotnet/framework/interop/consuming-unmanaged-dll-functions).</span><span class="sxs-lookup"><span data-stu-id="00af1-109">For additional information about using the platform invoke service to access functions in unmanaged DLLs, see [Consuming Unmanaged DLL Functions](/dotnet/framework/interop/consuming-unmanaged-dll-functions).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="00af1-110">Der <xref:System.Runtime.InteropServices.DllImportAttribute> unterstützt das Marshalling von generischen Typen nicht.</span><span class="sxs-lookup"><span data-stu-id="00af1-110">The <xref:System.Runtime.InteropServices.DllImportAttribute> does not support marshaling of generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00af1-111">Im folgenden Codebeispiel wird gezeigt, wie das-Attribut verwendet wird <xref:System.Runtime.InteropServices.DllImportAttribute> , um die Win32-Funktion zu importieren `MessageBox` .</span><span class="sxs-lookup"><span data-stu-id="00af1-111">The following code example shows how to use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to import the Win32 `MessageBox` function.</span></span>  <span data-ttu-id="00af1-112">Das Codebeispiel ruft dann die importierte Methode auf.</span><span class="sxs-lookup"><span data-stu-id="00af1-112">The code example then calls the imported method.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName"><span data-ttu-id="00af1-113">Der Name der DLL, die die nicht verwaltete Methode enthält.</span><span class="sxs-lookup"><span data-stu-id="00af1-113">The name of the DLL that contains the unmanaged method.</span></span> <span data-ttu-id="00af1-114">Dieser kann einen Assemblyanzeigenamen einschließen, wenn die DLL in einer Assembly enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="00af1-114">This can include an assembly display name, if the DLL is included in an assembly.</span></span></param>
        <summary><span data-ttu-id="00af1-115">Initialisiert eine neue Instanz der <see cref="T:System.Runtime.InteropServices.DllImportAttribute" />-Klasse mit dem Namen der DLL, die die zu importierende Methode enthält.</span><span class="sxs-lookup"><span data-stu-id="00af1-115">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> class with the name of the DLL containing the method to import.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00af1-116">Wenn eine nicht verwaltete DLL-Datei in einer Assembly enthalten ist, z. b. mit dem Linker oder der `/linkresource` Compileroption, können Sie den anzeigen amen der Assembly als Teil von angeben `dllName` .</span><span class="sxs-lookup"><span data-stu-id="00af1-116">If an unmanaged DLL file is included in an assembly, for example, by using the linker or the `/linkresource` compiler option, you can specify the assembly display name as part of `dllName`.</span></span> <span data-ttu-id="00af1-117">Wenn beispielsweise eine nicht verwaltete DLL `unmanaged.dll` mit dem Namen in eine verwaltete Assembly mit dem Namen eingeschlossen ist `MyAssembly` , kann das-Attribut wie im folgenden Code dargestellt angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="00af1-117">For example, if an unmanaged DLL named `unmanaged.dll` is included in a managed assembly named `MyAssembly`, the attribute might be specified as shown in the following code.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="00af1-118">Im folgenden Codebeispiel wird gezeigt, wie das-Attribut verwendet wird <xref:System.Runtime.InteropServices.DllImportAttribute> , um die Win32-Funktion zu importieren `MessageBox` .</span><span class="sxs-lookup"><span data-stu-id="00af1-118">The following code example shows how to use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to import the Win32 `MessageBox` function.</span></span>  <span data-ttu-id="00af1-119">Das Codebeispiel ruft dann die importierte Methode auf.</span><span class="sxs-lookup"><span data-stu-id="00af1-119">The code example then calls the imported method.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="00af1-120">Aktiviert bzw. deaktiviert das Verhalten der optimalen Zuordnung bei der Konvertierung von Unicode-Zeichen in ANSI-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="00af1-120">Enables or disables best-fit mapping behavior when converting Unicode characters to ANSI characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00af1-121">Gibt an, dass das Verhalten mit der `true` optimalen Anpassung aktiviert ist, andernfalls ist die Zuordnung mit der optimalen Anpassung deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="00af1-121">If `true`, best-fit mapping behavior is enabled; otherwise, best-fit mapping is disabled.</span></span> <span data-ttu-id="00af1-122">Das <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> Feld ist `true` standardmäßig.</span><span class="sxs-lookup"><span data-stu-id="00af1-122">The <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> field is `true` by default.</span></span> <span data-ttu-id="00af1-123">Die Einstellungen für dieses Feld überschreiben alle Ebenen-Einstellungen für das <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> Attribut.</span><span class="sxs-lookup"><span data-stu-id="00af1-123">Settings for this field override the any level settings for the <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> attribute.</span></span>  
  
 <span data-ttu-id="00af1-124">Der Common Language Runtime konvertiert alle verwalteten Unicode-Zeichen in ANSI-Zeichen, die an eine nicht verwaltete Methode weitergeleitet werden, die unter Windows 98 oder Windows Me ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="00af1-124">The common language runtime converts to ANSI characters any managed Unicode characters passed to an unmanaged method executing on Windows 98 or Windows Me.</span></span> <span data-ttu-id="00af1-125">Die Zuordnung mit dem besten Zeichen ermöglicht dem Interop-Mars Haller, ein schließende Zeichen bereitzustellen, wenn keine genaue Übereinstimmung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="00af1-125">Best-fit mapping enables the interop marshaler to provide a close-matching character when no exact match exists.</span></span> <span data-ttu-id="00af1-126">Der Mars Haller konvertiert z. b. das Unicode-Copyright Zeichen für nicht verwaltete Methoden, die ANSI-Zeichen akzeptieren, in "c".</span><span class="sxs-lookup"><span data-stu-id="00af1-126">For example, the marshaler converts the Unicode copyright character to 'c' for unmanaged methods that accept ANSI characters.</span></span> <span data-ttu-id="00af1-127">Bei manchen Zeichen fehlt eine Darstellung mit der optimalen Anpassung. Diese Zeichen werden als nicht mappbar bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="00af1-127">Some characters lack a best-fit representation; these characters are called unmappable.</span></span> <span data-ttu-id="00af1-128">Nicht mappbare Zeichen werden in der Regel in den Standardwert "?" konvertiert. ANSI-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="00af1-128">Unmappable characters are usually converted to the default '?' ANSI character.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="00af1-129">Bestimmte Unicode-Zeichen werden in gefährliche Zeichen (z. b. den umgekehrten Schrägstrich ' ') konvertiert \\ , wodurch ein Pfad versehentlich geändert werden kann.</span><span class="sxs-lookup"><span data-stu-id="00af1-129">Certain Unicode characters are converted to dangerous characters, such as the backslash '\\' character, which can inadvertently change a path.</span></span> <span data-ttu-id="00af1-130">Wenn Sie das- <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Feld auf festlegen `true` , können Sie dem Aufrufer das vorhanden sein eines nicht mappbaren Zeichens signalisieren, indem Sie eine Ausnahme auslösen.</span><span class="sxs-lookup"><span data-stu-id="00af1-130">By setting the <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> field to `true`, you can signal the presence of an unmappable character to the caller by throwing an exception.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="00af1-131">Sie können die Standardwerte, die von den Feldern und bereitgestellt werden, nicht ändern <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> , wenn Sie ein verwaltetes Array, dessen Elemente ANSI-Zeichen oder lpstrans sind, in ein nicht verwaltetes sicheres Array übergeben</span><span class="sxs-lookup"><span data-stu-id="00af1-131">You cannot change the default values provided by the <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> and <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> fields when passing a managed array whose elements are ANSI Chars or LPSTRs to an unmanaged safe array.</span></span> <span data-ttu-id="00af1-132">Die Zuordnung mit der optimalen Anpassung ist immer aktiviert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="00af1-132">Best-fit mapping is always enabled and no exception is thrown.</span></span> <span data-ttu-id="00af1-133">Beachten Sie, dass diese Kombination Ihr Sicherheitsmodell gefährden kann.</span><span class="sxs-lookup"><span data-stu-id="00af1-133">Be aware that this combination can compromise your security model.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00af1-134">In einigen Fällen verwenden Visual Basic Entwickler anstelle der- <xref:System.Runtime.InteropServices.DllImportAttribute> `Declare` Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren.</span><span class="sxs-lookup"><span data-stu-id="00af1-134">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="00af1-135">Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> Felds ist einer dieser Fälle.</span><span class="sxs-lookup"><span data-stu-id="00af1-135">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> field is one of those cases.</span></span> <span data-ttu-id="00af1-136">Im folgenden Beispiel wird gezeigt, wie die strikte Sicherheit der Zeichen Zuordnung auf eine Platt Form Aufruf Methoden Definitionen angewendet wird, indem der ANSI-Zeichensatz angegeben wird, das Verhalten der optimalen Anpassung der Zuordnung deaktiviert und eine Ausnahme für nicht zugeordnete Unicode-Zeichen ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="00af1-136">The following example shows how to apply the strictest character mapping security to a platform invoke method definitions by specifying the ANSI character set, disabling best fit mapping behavior, and throwing an exception on unmapped Unicode characters.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
        <related type="Article" href="/dotnet/framework/interop/interop-marshaling"><span data-ttu-id="00af1-137">Interop-Marshalling</span><span class="sxs-lookup"><span data-stu-id="00af1-137">Interop Marshaling</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="00af1-138">Gibt die Aufrufkonvention eines Einstiegspunkts an.</span><span class="sxs-lookup"><span data-stu-id="00af1-138">Indicates the calling convention of an entry point.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00af1-139">Sie legen dieses Feld auf einen der Enumerationsmember fest <xref:System.Runtime.InteropServices.CallingConvention> .</span><span class="sxs-lookup"><span data-stu-id="00af1-139">You set this field to one of the <xref:System.Runtime.InteropServices.CallingConvention> enumeration members.</span></span> <span data-ttu-id="00af1-140">Der Standardwert für das <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> Feld ist <xref:System.Runtime.InteropServices.CallingConvention.Winapi> , das wiederum standardmäßig auf Konvention festgelegt ist <xref:System.Runtime.InteropServices.CallingConvention.StdCall> .</span><span class="sxs-lookup"><span data-stu-id="00af1-140">The default value for the <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> field is <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, which in turn defaults to <xref:System.Runtime.InteropServices.CallingConvention.StdCall> convention.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00af1-141">In einigen Fällen verwenden Visual Basic Entwickler anstelle der- <xref:System.Runtime.InteropServices.DllImportAttribute> `Declare` Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren.</span><span class="sxs-lookup"><span data-stu-id="00af1-141">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="00af1-142">Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> Felds ist einer dieser Fälle.</span><span class="sxs-lookup"><span data-stu-id="00af1-142">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> field is one of those cases.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#1)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="00af1-143">Gibt an, wie Zeichenfolgenparameter an die Methode gemarshallt werden, und steuert die Namenszerlegung.</span><span class="sxs-lookup"><span data-stu-id="00af1-143">Indicates how to marshal string parameters to the method and controls name mangling.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00af1-144">Verwenden Sie dieses Feld mit einem Member der- <xref:System.Runtime.InteropServices.CharSet> Enumeration, um das Marshallingverhalten von Zeichen folgen Parametern anzugeben, und um anzugeben, welcher Einstiegspunkt Name aufgerufen werden soll (der genaue Name, der angegeben wurde, oder ein Name, der mit "a" oder "W" endet).</span><span class="sxs-lookup"><span data-stu-id="00af1-144">Use this field with a member of the <xref:System.Runtime.InteropServices.CharSet> enumeration to specify the marshaling behavior of string parameters and to specify which entry-point name to invoke (the exact name given or a name ending with "A" or "W").</span></span> <span data-ttu-id="00af1-145">Der Standardenumerationsmember für c# und Visual Basic ist `CharSet.Ansi` , und der Standardenumerationsmember für C++ ist `CharSet.None` , was entspricht `CharSet.Ansi` .</span><span class="sxs-lookup"><span data-stu-id="00af1-145">The default enumeration member for C# and Visual Basic is `CharSet.Ansi` and the default enumeration member for C++ is `CharSet.None`, which is equivalent to `CharSet.Ansi`.</span></span> <span data-ttu-id="00af1-146">In Visual Basic verwenden Sie die- `Declare` Anweisung, um das `CharSet` Feld anzugeben.</span><span class="sxs-lookup"><span data-stu-id="00af1-146">In Visual Basic, you use the `Declare` statement to specify the `CharSet` field.</span></span>  
  
 <span data-ttu-id="00af1-147">Das- <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Feld wirkt sich auf das Verhalten des- `CharSet` Felds aus, um zu bestimmen, welcher Einstiegspunkt Name aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="00af1-147">The <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> field influences the behavior of the `CharSet` field in determining which entry-point name to invoke.</span></span> <span data-ttu-id="00af1-148">Eine ausführliche Beschreibung und Beispiele für das Marshalling von Zeichen folgen und das namens Übereinstimmungs Verhalten, die dem Feld zugeordnet sind `CharSet` , finden Sie unter [Angeben eines Zeichensatzes](/dotnet/framework/interop/specifying-a-character-set).</span><span class="sxs-lookup"><span data-stu-id="00af1-148">For a detailed description and examples of the string marshaling and name matching behavior associated with the `CharSet` field, see [Specifying a Character Set](/dotnet/framework/interop/specifying-a-character-set).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00af1-149">Im folgenden Codebeispiel wird gezeigt, wie das-Attribut verwendet wird <xref:System.Runtime.InteropServices.DllImportAttribute> , um die Win32-Funktion zu importieren `MessageBox` .</span><span class="sxs-lookup"><span data-stu-id="00af1-149">The following code example shows how to use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to import the Win32 `MessageBox` function.</span></span>  <span data-ttu-id="00af1-150">Das Codebeispiel ruft dann die importierte Methode auf.</span><span class="sxs-lookup"><span data-stu-id="00af1-150">The code example then calls the imported method.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="C#" Value="public string? EntryPoint;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="00af1-151">Gibt den Namen oder die Ordnungszahl des aufzurufenden DLL-Einstiegspunkts an.</span><span class="sxs-lookup"><span data-stu-id="00af1-151">Indicates the name or ordinal of the DLL entry point to be called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00af1-152">Sie können den Namen des Einstiegs Punkts angeben, indem Sie eine Zeichenfolge angeben, die den Namen der DLL angibt, die den Einstiegspunkt enthält, oder Sie können den Einstiegspunkt anhand seiner Ordnungszahl identifizieren.</span><span class="sxs-lookup"><span data-stu-id="00af1-152">You can specify the entry-point name by supplying a string indicating the name of the DLL containing the entry point, or you can identify the entry point by its ordinal.</span></span> <span data-ttu-id="00af1-153">Ordinalen wird das #-Zeichen als Präfix vorangestellt, z. b. #1.</span><span class="sxs-lookup"><span data-stu-id="00af1-153">Ordinals are prefixed with the # sign, for example, #1.</span></span> <span data-ttu-id="00af1-154">Wenn Sie dieses Feld weglassen, verwendet das Common Language Runtime den Namen der The.NET-Methode, die mit dem markiert ist <xref:System.Runtime.InteropServices.DllImportAttribute> .</span><span class="sxs-lookup"><span data-stu-id="00af1-154">If you omit this field, the common language runtime uses the name of the.NET method marked with the <xref:System.Runtime.InteropServices.DllImportAttribute>.</span></span>  
  
 <span data-ttu-id="00af1-155">Weitere Informationen finden Sie unter [Identifizieren von Funktionen in DLLs](/dotnet/framework/interop/identifying-functions-in-dlls).</span><span class="sxs-lookup"><span data-stu-id="00af1-155">For additional information, see [Identifying Functions in DLLs](/dotnet/framework/interop/identifying-functions-in-dlls).</span></span> <span data-ttu-id="00af1-156">Beispiele zur Verwendung des- <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> Felds finden Sie unter [Angeben eines Einstiegs Punkts](/dotnet/framework/interop/specifying-an-entry-point).</span><span class="sxs-lookup"><span data-stu-id="00af1-156">For examples showing how to use the <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> field, see [Specifying an Entry Point](/dotnet/framework/interop/specifying-an-entry-point).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00af1-157">Im folgenden Codebeispiel wird gezeigt, wie das-Attribut verwendet wird <xref:System.Runtime.InteropServices.DllImportAttribute> , um die Win32-Funktion zu importieren `MessageBox` .</span><span class="sxs-lookup"><span data-stu-id="00af1-157">The following code example shows how to use the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute to import the Win32 `MessageBox` function.</span></span>  <span data-ttu-id="00af1-158">Im Codebeispiel wird die <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> -Eigenschaft verwendet, um die zu importierende Funktion anzugeben, und anschließend wird der Name in geändert `MyNewMessageBoxMethod` .</span><span class="sxs-lookup"><span data-stu-id="00af1-158">The code example uses the <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> property to specify the function to import and then changes the name to `MyNewMessageBoxMethod`.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="00af1-159">Steuert, ob das <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />-Feld die Common Language Runtime anweist, eine nicht verwaltete DLL nach anderen Einstiegspunktnamen als dem angegebenen zu durchsuchen.</span><span class="sxs-lookup"><span data-stu-id="00af1-159">Controls whether the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> field causes the common language runtime to search an unmanaged DLL for entry-point names other than the one specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00af1-160">Wenn `false` , wird der mit dem Buchstaben A angefügte Einstiegspunkt Name aufgerufen <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> , wenn das Feld auf festgelegt ist `CharSet.Ansi` , und der mit dem Buchstaben W angefügte Einstiegspunkt Name wird aufgerufen, wenn das <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> Feld auf festgelegt ist `CharSet.Unicode` .</span><span class="sxs-lookup"><span data-stu-id="00af1-160">If `false`, the entry point name appended with the letter A is invoked when the <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> field is set to `CharSet.Ansi`, and the entry-point name appended with the letter W is invoked when the <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> field is set to the `CharSet.Unicode`.</span></span> <span data-ttu-id="00af1-161">In der Regel legen verwaltete Compiler dieses Feld fest.</span><span class="sxs-lookup"><span data-stu-id="00af1-161">Typically, managed compilers set this field.</span></span>  
  
 <span data-ttu-id="00af1-162">In der folgenden Tabelle wird die Beziehung zwischen <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> den <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Feldern und basierend auf den von der Programmiersprache vorgegebenen Standardwerten angezeigt.</span><span class="sxs-lookup"><span data-stu-id="00af1-162">The following table shows the relationship between the <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> and <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> fields, based on default values imposed by the programming language.</span></span> <span data-ttu-id="00af1-163">Sie können die Standardeinstellung außer Kraft setzen, jedoch mit Vorsicht.</span><span class="sxs-lookup"><span data-stu-id="00af1-163">You can override the default setting, but do so with caution.</span></span>  
  
|<span data-ttu-id="00af1-164">Sprache</span><span class="sxs-lookup"><span data-stu-id="00af1-164">Language</span></span>|<span data-ttu-id="00af1-165">ANSI</span><span class="sxs-lookup"><span data-stu-id="00af1-165">ANSI</span></span>|<span data-ttu-id="00af1-166">Unicode</span><span class="sxs-lookup"><span data-stu-id="00af1-166">Unicode</span></span>|<span data-ttu-id="00af1-167">Auto</span><span class="sxs-lookup"><span data-stu-id="00af1-167">Auto</span></span>|  
|--------------|----------|-------------|----------|  
|<span data-ttu-id="00af1-168">Visual Basic</span><span class="sxs-lookup"><span data-stu-id="00af1-168">Visual Basic</span></span>|<span data-ttu-id="00af1-169">ExactSpelling: = true</span><span class="sxs-lookup"><span data-stu-id="00af1-169">ExactSpelling:=True</span></span>|<span data-ttu-id="00af1-170">ExactSpelling: = true</span><span class="sxs-lookup"><span data-stu-id="00af1-170">ExactSpelling:=True</span></span>|<span data-ttu-id="00af1-171">ExactSpelling: = false</span><span class="sxs-lookup"><span data-stu-id="00af1-171">ExactSpelling:=False</span></span>|  
|<span data-ttu-id="00af1-172">C#</span><span class="sxs-lookup"><span data-stu-id="00af1-172">C#</span></span>|<span data-ttu-id="00af1-173">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="00af1-173">ExactSpelling=false</span></span>|<span data-ttu-id="00af1-174">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="00af1-174">ExactSpelling=false</span></span>|<span data-ttu-id="00af1-175">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="00af1-175">ExactSpelling=false</span></span>|  
|<span data-ttu-id="00af1-176">C++</span><span class="sxs-lookup"><span data-stu-id="00af1-176">C++</span></span>|<span data-ttu-id="00af1-177">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="00af1-177">ExactSpelling=false</span></span>|<span data-ttu-id="00af1-178">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="00af1-178">ExactSpelling=false</span></span>|<span data-ttu-id="00af1-179">ExactSpelling = false</span><span class="sxs-lookup"><span data-stu-id="00af1-179">ExactSpelling=false</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="00af1-180">In einigen Fällen verwenden Visual Basic Entwickler anstelle der- <xref:System.Runtime.InteropServices.DllImportAttribute> `Declare` Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren.</span><span class="sxs-lookup"><span data-stu-id="00af1-180">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of using the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="00af1-181">Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> Felds ist einer dieser Fälle.</span><span class="sxs-lookup"><span data-stu-id="00af1-181">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> field is one of those cases.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="00af1-182">Gibt an, ob nicht verwaltete Methoden, die über <see langword="HRESULT" />-Rückgabewerte oder <see langword="retval" />-Rückgabewerte verfügen, direkt übersetzt werden oder ob <see langword="HRESULT" />-Rückgabewerte oder <see langword="retval" />-Rückgabewerte automatisch in Ausnahmen konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="00af1-182">Indicates whether unmanaged methods that have <see langword="HRESULT" /> or <see langword="retval" /> return values are directly translated or whether <see langword="HRESULT" /> or <see langword="retval" /> return values are automatically converted to exceptions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00af1-183">Legen Sie das- <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld auf fest, `true` um nicht verwaltete Signaturen direkt mit-oder-Werten zu übersetzen `HRESULT` `retval` . Legen Sie es auf fest, `false` um die `HRESULT` Werte automatisch `retval` zu konvertieren</span><span class="sxs-lookup"><span data-stu-id="00af1-183">Set the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field to `true` to directly translate unmanaged signatures with `HRESULT` or `retval` values; set it to `false` to automatically convert `HRESULT` or `retval` values to exceptions.</span></span> <span data-ttu-id="00af1-184">Standardmäßig ist das- <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld `true` .</span><span class="sxs-lookup"><span data-stu-id="00af1-184">By default, the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field is `true`.</span></span>  
  
 <span data-ttu-id="00af1-185">Wenn `true` der Wert ist, gibt die resultierende Methoden Signatur einen ganzzahligen Wert zurück, der den `HRESULT` Wert enthält.</span><span class="sxs-lookup"><span data-stu-id="00af1-185">When `true`, the resulting method signature returns an integer value that contains the `HRESULT` value.</span></span>  <span data-ttu-id="00af1-186">In diesem Fall müssen Sie den Rückgabewert manuell überprüfen und in Ihrer Anwendung entsprechend antworten.</span><span class="sxs-lookup"><span data-stu-id="00af1-186">In this case, you must manually inspect the return value and respond accordingly in your application.</span></span>  
  
 <span data-ttu-id="00af1-187">Wenn Sie das- <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld auf festlegen `false` , enthält die resultierende Methoden Signatur einen void-Rückgabetyp anstelle eines Integer ( `HRESULT` )-Rückgabe Typs.</span><span class="sxs-lookup"><span data-stu-id="00af1-187">When you set the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field to `false`, the resulting method signature contains a void return type instead of an integer (`HRESULT`) return type.</span></span>  <span data-ttu-id="00af1-188">Wenn die nicht verwaltete Methode einen erzeugt `HRESULT` , ignoriert die Runtime automatisch einen Rückgabewert von `S_OK` (oder 0) und löst keine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="00af1-188">When the unmanaged method produces an `HRESULT`, the runtime automatically ignores a return value of `S_OK` (or 0) and does not throw an exception.</span></span>  <span data-ttu-id="00af1-189">Bei `HRESULT` anderen Ausnahmen als löst die Common Language `S_OK` Runtime automatisch eine Ausnahme aus, die dem entspricht `HRESULT` .</span><span class="sxs-lookup"><span data-stu-id="00af1-189">For `HRESULT`s other than `S_OK`, the runtime automatically throws an exception that corresponds to the `HRESULT`.</span></span>  <span data-ttu-id="00af1-190">Beachten Sie, dass das- <xref:System.Runtime.InteropServices.DllImportAttribute> Attribut diese Konvertierung nur in Methoden durchführt, die zurückgeben `HRESULT` .</span><span class="sxs-lookup"><span data-stu-id="00af1-190">Note that the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute only performs this conversion to methods that return an `HRESULT`.</span></span>  
  
 <span data-ttu-id="00af1-191">`HRESULT`In Fällen, in denen Ausnahmen besser zur Fehler Berichterstattungs Struktur der Anwendung passen, können Sie das Standardverhalten der Fehlerberichterstattung von s in "Ausnahmen" ändern.</span><span class="sxs-lookup"><span data-stu-id="00af1-191">You might decide to change the default error reporting behavior from `HRESULT`s to exceptions in cases where exceptions better fit the error reporting structure of your application.</span></span>  
  
 <span data-ttu-id="00af1-192">Dieses Feld ähnelt dem, <xref:System.Runtime.InteropServices.PreserveSigAttribute> aber im Gegensatz zum- <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld ist der Standardwert für das-Attribut `false` .</span><span class="sxs-lookup"><span data-stu-id="00af1-192">This field is similar to the <xref:System.Runtime.InteropServices.PreserveSigAttribute>; however, in contrast to the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field, the default value for the attribute is `false`.</span></span>  
  
 <span data-ttu-id="00af1-193">In einigen Fällen verwenden Visual Basic Entwickler anstelle der- <xref:System.Runtime.InteropServices.DllImportAttribute> `Declare` Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren.</span><span class="sxs-lookup"><span data-stu-id="00af1-193">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of using the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="00af1-194">Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Felds ist einer dieser Fälle.</span><span class="sxs-lookup"><span data-stu-id="00af1-194">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field is one of those cases.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00af1-195">Im folgenden Codebeispiel wird verwendet <xref:System.Runtime.InteropServices.DllImportAttribute> , um die nicht verwaltete `SHAutoComplete` Funktion einmal zu importieren, wobei das <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> -Feld auf festgelegt ist `true` und das- <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> Feld wieder `false` auf festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="00af1-195">The following code example uses the <xref:System.Runtime.InteropServices.DllImportAttribute> to import the unmanaged `SHAutoComplete` function once with the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field set to `true` and again with the <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> field set to `false`.</span></span>  <span data-ttu-id="00af1-196">Dieses Codebeispiel bewirkt `SHAutoComplete` , dass die-Funktion alle Fehler mit einer-Ausnahme einmalig und als `HRESULT` nächstes generiert.</span><span class="sxs-lookup"><span data-stu-id="00af1-196">This code example causes the `SHAutoComplete` function to generate any errors with an exception one time and an `HRESULT` the next.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="00af1-197">Gibt an, ob der Aufgerufene vor dem Zurückgeben aus der attributierten Methode die Windows-API <see langword="SetLastError" /> aufruft.</span><span class="sxs-lookup"><span data-stu-id="00af1-197">Indicates whether the callee calls the <see langword="SetLastError" /> Windows API function before returning from the attributed method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00af1-198">`true` , um anzugeben, dass der aufgerufene aufruft, `SetLastError` andernfalls `false` .</span><span class="sxs-lookup"><span data-stu-id="00af1-198">`true` to indicate that the callee will call `SetLastError`; otherwise, `false`.</span></span> <span data-ttu-id="00af1-199">Der Standardwert ist `false`.</span><span class="sxs-lookup"><span data-stu-id="00af1-199">The default is `false`.</span></span>  
  
 <span data-ttu-id="00af1-200">Der Laufzeitmarshaller ruft `GetLastError` auf und speichert den zurückgegebenen Wert, um zu verhindern, dass er durch andere API-Aufrufe überschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="00af1-200">The runtime marshaler calls `GetLastError` and caches the value returned to prevent it from being overwritten by other API calls.</span></span> <span data-ttu-id="00af1-201">Sie können den Fehlercode abrufen, indem Sie aufrufen <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> .</span><span class="sxs-lookup"><span data-stu-id="00af1-201">You can retrieve the error code by calling <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00af1-202">In einigen Fällen verwenden Visual Basic Entwickler anstelle der- <xref:System.Runtime.InteropServices.DllImportAttribute> `Declare` Anweisung, um eine DLL-Funktion in verwaltetem Code zu definieren.</span><span class="sxs-lookup"><span data-stu-id="00af1-202">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute>, instead of using the `Declare` statement, to define a DLL function in managed code.</span></span> <span data-ttu-id="00af1-203">Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> Felds ist einer dieser Fälle.</span><span class="sxs-lookup"><span data-stu-id="00af1-203">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> field is one of those cases.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="00af1-204">Aktiviert bzw. deaktiviert das Auslösen einer Ausnahme bei einem nicht zuzuordnenden Unicode-Zeichen, das in das ANSI-Zeichen „?“ konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="00af1-204">Enables or disables the throwing of an exception on an unmappable Unicode character that is converted to an ANSI "?" character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00af1-205">`true` , um anzugeben, dass eine Ausnahme immer ausgelöst wird, wenn der Interop-Mars Haller ein nicht mappbares Zeichen konvertiert. `false` , um anzugeben, dass das <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Feld deaktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="00af1-205">`true` to indicate that an exception is thrown each time the interop marshaler converts an unmappable character; `false` to indicate that the <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> field is disabled.</span></span> <span data-ttu-id="00af1-206">Dieses Feld ist standardmäßig auf `false` festgelegt.</span><span class="sxs-lookup"><span data-stu-id="00af1-206">This field is `false` by default.</span></span>  
  
 <span data-ttu-id="00af1-207">Der Common Language Runtime konvertiert alle verwalteten Unicode-Zeichen in ANSI-Zeichen, die an eine nicht verwaltete Methode weitergeleitet werden, die unter Windows 98 oder Windows Me ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="00af1-207">The common language runtime converts to ANSI characters any managed Unicode characters passed to an unmanaged method executing on Windows 98 or Windows Me.</span></span> <span data-ttu-id="00af1-208">Die Zuordnung mit dem besten Zeichen ermöglicht dem Interop-Mars Haller, ein schließende Zeichen bereitzustellen, wenn keine genaue Übereinstimmung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="00af1-208">Best-fit mapping enables the interop marshaler to provide a close-matching character when no exact match exists.</span></span> <span data-ttu-id="00af1-209">Der Mars Haller konvertiert z. b. das Unicode-Copyright Zeichen für nicht verwaltete Methoden, die ANSI-Zeichen akzeptieren, in "c".</span><span class="sxs-lookup"><span data-stu-id="00af1-209">For example, the marshaler converts the Unicode copyright character to 'c' for unmanaged methods that accept ANSI characters.</span></span> <span data-ttu-id="00af1-210">Bei manchen Zeichen fehlt eine Darstellung mit der optimalen Anpassung. Diese Zeichen werden als nicht mappbar bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="00af1-210">Some characters lack a best-fit representation; these characters are called unmappable.</span></span> <span data-ttu-id="00af1-211">Nicht mappbare Zeichen werden in der Regel in den Standardwert "?" konvertiert. ANSI-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="00af1-211">Unmappable characters are usually converted to the default '?' ANSI character.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="00af1-212">Bestimmte Unicode-Zeichen werden in gefährliche Zeichen (z. b. den umgekehrten Schrägstrich ' ') konvertiert \\ , wodurch ein Pfad versehentlich geändert werden kann.</span><span class="sxs-lookup"><span data-stu-id="00af1-212">Certain Unicode characters are converted to dangerous characters, such as the backslash '\\' character, which can inadvertently change a path.</span></span> <span data-ttu-id="00af1-213">Wenn Sie das- <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Feld auf festlegen `true` , können Sie dem Aufrufer das vorhanden sein eines nicht mappbaren Zeichens signalisieren, indem Sie eine Ausnahme auslösen.</span><span class="sxs-lookup"><span data-stu-id="00af1-213">By setting the <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> field to `true`, you can signal the presence of an unmappable character to the caller by throwing an exception.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="00af1-214">Sie können die Standardwerte, die von den Feldern und bereitgestellt werden, nicht ändern <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> , wenn Sie ein verwaltetes Array, dessen Elemente ANSI-Zeichen oder lpstrans sind, in ein nicht verwaltetes sicheres Array übergeben</span><span class="sxs-lookup"><span data-stu-id="00af1-214">You cannot change the default values provided by the <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> and <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> fields when passing a managed array whose elements are ANSI Chars or LPSTRs to an unmanaged safe array.</span></span> <span data-ttu-id="00af1-215">Die Zuordnung mit der optimalen Anpassung ist immer aktiviert, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="00af1-215">Best-fit mapping is always enabled and no exception is thrown.</span></span> <span data-ttu-id="00af1-216">Beachten Sie, dass diese Kombination Ihr Sicherheitsmodell gefährden kann.</span><span class="sxs-lookup"><span data-stu-id="00af1-216">Be aware that this combination can compromise your security model.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="00af1-217">In einigen Fällen verwenden Visual Basic Entwickler zum <xref:System.Runtime.InteropServices.DllImportAttribute> Definieren einer DLL-Funktion in verwaltetem Code anstelle der- `Declare` Anweisung.</span><span class="sxs-lookup"><span data-stu-id="00af1-217">In some cases, Visual Basic developers use the <xref:System.Runtime.InteropServices.DllImportAttribute> to define a DLL function in managed code, instead of using the `Declare` statement.</span></span> <span data-ttu-id="00af1-218">Das Festlegen des <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> Felds ist einer dieser Fälle.</span><span class="sxs-lookup"><span data-stu-id="00af1-218">Setting the <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> field is one of those cases.</span></span> <span data-ttu-id="00af1-219">Im folgenden Beispiel wird gezeigt, wie die strikte Sicherheit der Zeichen Zuordnung auf eine Platt Form Aufruf Methoden Definitionen angewendet wird, indem der ANSI-Zeichensatz angegeben wird, das Verhalten der optimalen Anpassung der Zuordnung deaktiviert und eine Ausnahme für nicht zugeordnete Unicode-Zeichen ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="00af1-219">The following example shows how to apply the strictest character mapping security to a platform invoke method definitions by specifying the ANSI character set, disabling best fit mapping behavior, and throwing an exception on unmapped Unicode characters.</span></span>  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
        <related type="Article" href="/dotnet/framework/interop/interop-marshaling"><span data-ttu-id="00af1-220">Interop-Marshalling</span><span class="sxs-lookup"><span data-stu-id="00af1-220">Interop Marshaling</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="00af1-221">Ruft den Namen der DLL-Datei ab, die den Einstiegspunkt enthält.</span><span class="sxs-lookup"><span data-stu-id="00af1-221">Gets the name of the DLL file that contains the entry point.</span></span></summary>
        <value><span data-ttu-id="00af1-222">Der Name der DLL-Datei, die den Einstiegspunkt enthält.</span><span class="sxs-lookup"><span data-stu-id="00af1-222">The name of the DLL file that contains the entry point.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="00af1-223">Sie können einen vollständigen oder relativen Pfad angeben.</span><span class="sxs-lookup"><span data-stu-id="00af1-223">You can provide a full or relative path.</span></span> <span data-ttu-id="00af1-224">Wenn Sie keinen Pfad angeben, muss sich die dll zur Laufzeit im aktuellen Pfad befinden, es sei denn, die dll wird auf andere Weise geladen.</span><span class="sxs-lookup"><span data-stu-id="00af1-224">If you provide no path, the DLL must be in the current path at run time, unless the DLL is loaded by some other means.</span></span> <span data-ttu-id="00af1-225">Beachten Sie jedoch, dass die Verwendung eines voll qualifizierten Pfads zu einer Ungenauigkeit führen kann, wenn die dll verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="00af1-225">Be aware, however, that using a fully qualified path can introduce inaccuracy if the DLL is moved.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
