<Type Name="PeerName" FullName="System.Net.PeerToPeer.PeerName">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8fd9ef4ba35fbf407d4e0305280fa1ac0ccde172" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460874" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PeerName : IEquatable&lt;System.Net.PeerToPeer.PeerName&gt;, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable PeerName extends System.Object implements class System.IEquatable`1&lt;class System.Net.PeerToPeer.PeerName&gt;, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.PeerToPeer.PeerName" />
  <TypeSignature Language="VB.NET" Value="Public Class PeerName&#xA;Implements IEquatable(Of PeerName), ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class PeerName : IEquatable&lt;System::Net::PeerToPeer::PeerName ^&gt;, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Net.PeerToPeer.PeerName&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Gibt die Werte an, die ein Peer-to-Peer-<see cref="T:System.Net.PeerToPeer.PeerName" />-Objekt definieren. Ein Peername ist i. d. R. eine Zeichenfolge, mit der eine Peerressource identifiziert wird.</summary>
    <remarks>To be added.</remarks>
    <altmember cref="N:System.Net.PeerToPeer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.PeerToPeer.PeerName" />-Klasse.</summary>
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateFromPeerHostName(System.String)" />
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateRelativePeerName(System.Net.PeerToPeer.PeerName,System.String)" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PeerName (string remotePeerName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string remotePeerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (remotePeerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PeerName(System::String ^ remotePeerName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="remotePeerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="remotePeerName">Enthält den Peernamen, der als <see cref="T:System.Net.PeerToPeer.PeerName" />-Instanz codiert werden soll.</param>
        <summary>Initialisiert ein neues Objekt vom Typ <see cref="T:System.Net.PeerToPeer.PeerName" /> mit dem angegebenen <see cref="T:System.String" />-Wert des vollqualifizierten Peernamens.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Die angegebene <see cref="T:System.String" /> ist kein gültiger <see cref="T:System.Net.PeerToPeer.PeerName" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remotePeerName" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PeerName (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PeerName(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Verweis auf das Objekt, das die zum Deserialisieren dieser Instanz benötigten Daten enthält.</param>
        <param name="context">Kontext, der das Deserialisieren der Daten ermöglicht. Auch als Quelle der serialisierten Daten bezeichnet.</param>
        <summary>Füllt ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den Daten auf, die zum Serialisieren des <see cref="T:System.Net.PeerToPeer.PeerName" /> erforderlich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist für die Deserialisierung dieses Typs erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Parameter ist <see langword="null" />.</exception>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
        <altmember cref="N:System.Runtime.Serialization" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PeerName (string classifier, System.Net.PeerToPeer.PeerNameType peerNameType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string classifier, valuetype System.Net.PeerToPeer.PeerNameType peerNameType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.#ctor(System.String,System.Net.PeerToPeer.PeerNameType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PeerName(System::String ^ classifier, System::Net::PeerToPeer::PeerNameType peerNameType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="classifier" Type="System.String" />
        <Parameter Name="peerNameType" Type="System.Net.PeerToPeer.PeerNameType" />
      </Parameters>
      <Docs>
        <param name="classifier">
          <see cref="T:System.String" />, die den Peernamen enthält, der als <see cref="T:System.Net.PeerToPeer.PeerName" /> codiert werden soll.</param>
        <param name="peerNameType">
          <see cref="T:System.Net.PeerToPeer.PeerNameType" />-Enumerationswert, der den Typ des Peernamens angibt, der erstellt werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.PeerToPeer.PeerName" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor gibt ein Objekt vom Typ <xref:System.Net.PeerToPeer.PeerName> , enthält der vollqualifizierte Name des Peers. Außerdem wird angegeben, ob der Name des Peers gesichert oder nicht gesichert ist.  
  
 Diese Instanz verwendet die Standardidentität für den Peer für den aktuellen Benutzer sowie der angegebenen <xref:System.Net.PeerToPeer.PeerName.Classifier%2A>, zusätzlich zu den Typ des PeerName, mit der angegebenen Klassifizierung und dem Typ zu erstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <see cref="P:System.Net.PeerToPeer.PeerName.Classifier" /> enthält mindestens ein ungültiges Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.PeerToPeer.PeerToPeerException">-   Die als Grundlage für den <see cref="T:System.Net.PeerToPeer.PeerName" /> verwendete Standardidentität konnte nicht abgerufen werden.  
  
-   Der <see cref="T:System.Net.PeerToPeer.PeerName" /> konnte nicht erstellt werden.</exception>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Net.PeerToPeer.PeerName.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die die von diesem <see cref="P:System.Net.PeerToPeer.PeerName.Authority" />-Objekt verwendete <see cref="T:System.Net.PeerToPeer.PeerName" /> angibt.</summary>
        <value>Die Zeichenfolge, die den Authentifizierungsteil des angegebenen <see cref="T:System.Net.PeerToPeer.PeerName" /> enthält. Für gesicherte Peernamen enthält diese Eigenschaft den öffentlichen Schlüssel als aus 40 Zeichen bestehende Hexadezimalzeichenfolge. Für ungesicherte Peernamen wird diese Eigenschaft auf 0 (null) festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur der Besitzer oder Peerhost kann einen gesicherten Peernamen registrieren. Wird angenommen, ein Peername gesichert, wenn er durch ein selbst signiertes Zertifikat gesichert wird.  
  
 Peernamen Groß-/Kleinschreibung beachtet, und das Format eines Peer-Namens ist: *Zertifizierungsstelle.Klassifizierung*. Beispielsweise ist "0.MeinPeerName" einen Peernamen-wohlgeformt ist.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Mit einem sicheren Peernamen gewährleistet nicht die gesamtsicherheit der Netzwerk-Anwendung. Die Sicherheit der Anwendung ist implementierungsabhängig.</para>
        </block>
        <altmember cref="P:System.Net.PeerToPeer.PeerName.Classifier" />
        <altmember cref="T:System.Net.PeerToPeer.PeerNameType" />
      </Docs>
    </Member>
    <Member MemberName="Classifier">
      <MemberSignature Language="C#" Value="public string Classifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Classifier" />
      <MemberSignature Language="DocId" Value="P:System.Net.PeerToPeer.PeerName.Classifier" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Classifier As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Classifier { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die die Klassifizierung für einen Peer-to-Peer-<see cref="T:System.Net.PeerToPeer.PeerName" /> enthält.</summary>
        <value>Die Zeichenfolge, die den Klassifizierungsteil enthält, mit dem ein Peername für die <see cref="T:System.Net.PeerToPeer.PeerNameRegistration" /> oder die Auflösung in einer PNRP-<see cref="T:System.Net.PeerToPeer.Cloud" /> identifiziert wird.  
  
 Sofern nicht ausdrücklich angegeben, ist der Standardwert aller Eigenschaften für Referenztypen <see langword="null" /> und für Eigenschaften vom Typ <see langword="int" /> 0 (null).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Format eines Peer-Namens ist: *Zertifizierungsstelle.Klassifizierung*. Der Name des Peers *Klassifizierer* Komponente kann festgelegt werden, auf eine beliebige Zeichenfolge, enthält 149 Unicode-Zeichen, einschließlich, der `null` Abschlusszeichen ("\0"). Peer-Namenszeichenfolgen Groß-/Kleinschreibung beachtet.  
  
 Für gesicherte Peernamen sind die Klassifizierung und der Punkt (Punkt) nach der Zertifizierungsstelle optional. Für unsichere Peernamen ist der Klassifizierer nicht optional.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.PeerToPeer.PeerName.Authority" />
        <altmember cref="P:System.Net.PeerToPeer.PeerName.IsSecured" />
        <altmember cref="T:System.Net.PeerToPeer.PeerNameType" />
      </Docs>
    </Member>
    <Member MemberName="CreateFromPeerHostName">
      <MemberSignature Language="C#" Value="public static System.Net.PeerToPeer.PeerName CreateFromPeerHostName (string peerHostName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.PeerToPeer.PeerName CreateFromPeerHostName(string peerHostName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.CreateFromPeerHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromPeerHostName (peerHostName As String) As PeerName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::PeerToPeer::PeerName ^ CreateFromPeerHostName(System::String ^ peerHostName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.PeerToPeer.PeerName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peerHostName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="peerHostName">Eine Zeichenfolge mit dem DNS-qualifizierten Hostnamen.</param>
        <summary>Erstellt eine neue Instanz des angegebenen <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" />-Objekts mit dem angegebenen Peerhostnamen.</summary>
        <returns>Ein <see cref="T:System.Net.PeerToPeer.PeerName" />-Objekt, das den angegebenen Peerhostnamen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Peer-zu-Peer-Host ist "Seed-Knoten" verantwortlich für die Peer-zu-Peer networking-Sitzung zu initiieren, einladen von peers zur Teilnahme an Anwendungen für die diese Art der Netzwerkverbindung für Kommunikation, z. B. Chat-Gruppen oder Spiel am besten geeignet ist Sitzungen.  
  
 Diese Methode kann verwendet werden, zum Erstellen einer <xref:System.Net.PeerToPeer.PeerName> -Objekt auf Grundlage der <xref:System.Net.PeerToPeer.PeerName.PeerHostName%2A> Eigenschaft. Dieser Peername ist nicht die Identität des aufrufenden Knoten zugeordnet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der bereitgestellte <see cref="T:System.String" /> ist keine gültige Zeichenfolge für Peerhostnamen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.PeerToPeer.PeerToPeerException">Ein <see cref="T:System.Net.PeerToPeer.PeerName" /> konnte nicht aus dem angegebenen <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" /> erstellt werden</exception>
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateRelativePeerName(System.Net.PeerToPeer.PeerName,System.String)" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelativePeerName">
      <MemberSignature Language="C#" Value="public static System.Net.PeerToPeer.PeerName CreateRelativePeerName (System.Net.PeerToPeer.PeerName peerName, string classifier);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.PeerToPeer.PeerName CreateRelativePeerName(class System.Net.PeerToPeer.PeerName peerName, string classifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.CreateRelativePeerName(System.Net.PeerToPeer.PeerName,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::PeerToPeer::PeerName ^ CreateRelativePeerName(System::Net::PeerToPeer::PeerName ^ peerName, System::String ^ classifier);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.PeerToPeer.PeerName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peerName" Type="System.Net.PeerToPeer.PeerName" />
        <Parameter Name="classifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="peerName">Das <see cref="T:System.Net.PeerToPeer.PeerName" />-Objekt, für das der neue Klassifizierungszeichenfolgenwert festgelegt werden soll.</param>
        <param name="classifier">Der <see cref="P:System.Net.PeerToPeer.PeerName.Classifier" />, der für den zurückgegebenen <see cref="T:System.Net.PeerToPeer.PeerName" /> festgelegt werden soll.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Net.PeerToPeer.PeerName" />, indem das für das bereitgestellte <see cref="P:System.Net.PeerToPeer.PeerName.Classifier" />-Objekt definierte <see cref="T:System.Net.PeerToPeer.PeerName" />-Feld durch den angegebenen Klassifizierungszeichenfolgenwert ersetzt wird.</summary>
        <returns>Das neue <see cref="T:System.Net.PeerToPeer.PeerName" />-Objekt, das die aktualisierte Klassifizierung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.PeerToPeer.PeerName.Classifier%2A> wird an den vorhandenen angefügt <xref:System.Net.PeerToPeer.PeerName.Authority%2A> Teil der <xref:System.Net.PeerToPeer.PeerName>. Bei dieser Zeichenfolge wird nicht mehr als 149 Zeichen lang sein, einschließlich der `null` Abschlusszeichen. Geben Sie `null` der Peername der Identität zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der bereitgestellte <see cref="T:System.String" /> ist keine gültige Peernamensklassifizierung.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.PeerToPeer.PeerToPeerException">Ein <see cref="T:System.Net.PeerToPeer.PeerName" /> konnte nicht aus dem angegebenen <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" /> erstellt werden</exception>
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateFromPeerHostName(System.String)" />
        <altmember cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob der Inhalt dieses <see cref="T:System.Net.PeerToPeer.PeerName" />-Objekts dem Inhalt eines anderen Objekts entspricht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Implementierung von Equals wird definiert, indem IEquatable\<T >.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.PeerToPeer.PeerName.Authority" />
        <altmember cref="P:System.Net.PeerToPeer.PeerName.Classifier" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Net.PeerToPeer.PeerName other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Net.PeerToPeer.PeerName other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.Equals(System.Net.PeerToPeer.PeerName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As PeerName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Net::PeerToPeer::PeerName ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Net.PeerToPeer.PeerName" />
      </Parameters>
      <Docs>
        <param name="other">Der Peername, der mit diesem <see cref="T:System.Net.PeerToPeer.PeerName" /> verglichen werden soll.</param>
        <summary>Vergleicht unter Berücksichtigung von Groß- und Kleinschreibung den aktuellen <see cref="T:System.Net.PeerToPeer.PeerName" /> mit dem angegebenen Peernamen.</summary>
        <returns>Gibt <see langword="True" /> zurück, wenn der angegebene <see cref="T:System.Net.PeerToPeer.PeerName" /> dieselbe Ressource wie das aktuelle Peernamensobjekt identifiziert. Andernfalls gibt diese Methode <see langword="False" /> zurück.  
  
 Diese Methode gibt auch <see langword="False" /> zurück, wenn <paramref name="other" /> auf <see langword="null" /> festgelegt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Peernamen werden als gleich betrachtet, wenn sie dieselben Zeichen in enthalten ihre <xref:System.Net.PeerToPeer.PeerName.Authority%2A> und <xref:System.Net.PeerToPeer.PeerName.Classifier%2A> Komponenten.  
  
 Keine Normalizations werden die Zeichenfolgen vor dem Vergleich ausgeführt.  Alle Normalisierung sollte während oder vor dem Erstellen der Objekte auf derselben Ebene Namen abgeschlossen worden sein.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das <see cref="T:System.Object" />, das mit dem aktuellen <see cref="T:System.Net.PeerToPeer.PeerName" /> verglichen werden soll.</param>
        <summary>Bestimmt, ob der Inhalt dieses <see cref="T:System.Net.PeerToPeer.PeerName" /> mit dem Inhalt eines anderen Objekts übereinstimmt.</summary>
        <returns>
          <see langword="True" />, wenn der <see cref="T:System.Net.PeerToPeer.PeerName" /> und das Vergleichsobjekt die gleichen Informationen enthalten, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erbt, die standardmäßig Signatur und das Verhalten von <xref:System.Object>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="M:System.Object.GetHashCode" />-Methode außer Kraft.</summary>
        <returns>Ein Hashcode für das aktuelle <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Objekte als gleich betrachtet, wenn diese Methode den gleichen Hashcode für beide Identitäten zurückgibt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Enthält die serialisierten Daten, die dem <see cref="T:System.Net.PeerToPeer.PeerName" />-Objekt zugeordnet sind.</param>
        <param name="context">Enthält das Ziel für den serialisierten Datenstrom, der dem <see cref="T:System.Net.PeerToPeer.PeerName" />-Objekt zugeordnet ist.</param>
        <summary>Füllt ein Serialisierungsinformationsobjekt mit den Daten auf, die zum Serialisieren des <see cref="T:System.Net.PeerToPeer.PeerName" /> erforderlich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein abgeleiteter Typ muss die <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A>-Basistypmethode aufrufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="IsSecured">
      <MemberSignature Language="C#" Value="public bool IsSecured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecured" />
      <MemberSignature Language="DocId" Value="P:System.Net.PeerToPeer.PeerName.IsSecured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecured { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob es sich um einen gesicherten Peernamen handelt.</summary>
        <value>Wenn <see langword="true" />, ist dieser Peername mit einem Schlüsselpaar aus einem öffentlichen und einem privaten Schlüssel gesichert. Der Name enthält den SHA (Secure Hash Algorithm)-Hash des öffentlichen Schlüssels für das Benutzerzertifikat des Peercomputers. Andernfalls, wenn <see langword="false" />, ist dem Peernamen keine Identität zugeordnet.  
  
 Sofern nicht ausdrücklich angegeben, ist der Standardwert aller Eigenschaften für Referenztypen <see langword="null" /> und für Eigenschaften vom Typ <see langword="int" /> 0 (null).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird angenommen, ein Peername gesichert, wenn er durch ein selbst signiertes Zertifikat gesichert wird.  
  
 Nur der Besitzer kann einen gesicherten Peernamen mit PNRP registrieren.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Mit einem sicheren Peernamen gewährleistet nicht die gesamtsicherheit der Netzwerk-Anwendung. Die Sicherheit der Anwendung ist implementierungsabhängig.</para>
        </block>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
        <altmember cref="N:System.Security.Permissions" />
      </Docs>
    </Member>
    <Member MemberName="PeerHostName">
      <MemberSignature Language="C#" Value="public string PeerHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PeerHostName" />
      <MemberSignature Language="DocId" Value="P:System.Net.PeerToPeer.PeerName.PeerHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeerHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PeerHostName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Peer-to-Peer-Hosts ab. Dies ist eine DNS-codierte Version des <see cref="T:System.Net.PeerToPeer.PeerName" />, der einem <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" /> insofern entspricht, als beide Bezeichner sind.  Die beiden Bezeichner unterscheiden sich in der visuellen Darstellung.</summary>
        <value>Ein <see cref="T:System.String" />-Wert, bei dem es sich um den Namen des Peer-to-Peer-Hosts handelt. Sofern nicht ausdrücklich angegeben, ist für Referenztypen der Standardwert aller Eigenschaften <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Peer-zu-Peer-Host ist "Seed-Knoten" verantwortlich für die Peer-zu-Peer networking-Sitzung zu initiieren, einladen von peers zur Teilnahme an Anwendungen für die diese Art der Netzwerkverbindung für Kommunikation, z. B. Chat-Gruppen oder Spiel am besten geeignet ist Sitzungen.  
  
 Die <xref:System.Net.PeerToPeer.PeerName.PeerHostName%2A> Eigenschaft gibt den Namen des Peers, die die Peer-zu-Peer networking-Sitzung erstellt, und die den Host der Sitzung gilt.  Der Host einer Peer-zu-Peer networking-Sitzung erfasst möglicherweise Peers in mehr als eine <xref:System.Net.PeerToPeer.Cloud>. Darüber hinaus kann kein Peer gleichzeitig mehr als ein Peer-Host gehostet werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateRelativePeerName(System.Net.PeerToPeer.PeerName,System.String)" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Enthält die serialisierten Daten, die dem <see cref="T:System.Net.PeerToPeer.PeerName" />-Objekt zugeordnet sind.</param>
        <param name="context">Enthält das Ziel für den serialisierten Datenstrom, der dem <see cref="T:System.Net.PeerToPeer.PeerName" />-Objekt zugeordnet ist.</param>
        <summary>Implementiert die <see cref="T:System.Runtime.Serialization.ISerializable" />-Schnittstelle und gibt die zum Serialisieren der <see cref="T:System.Net.PeerToPeer.PeerName" />-Instanz erforderlichen Daten zurück.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolgendarstellung des aktuellen <see cref="T:System.Net.PeerToPeer.PeerName" />-Objekts zurück.</summary>
        <returns>Eine Zeichenfolge, die den aktuellen <see cref="T:System.Net.PeerToPeer.PeerName" /> darstellt und im folgenden Format angegeben wird: *Authority.Classifier*. Beispiel: "0.MeinInternetPeer".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erbt, die standardmäßig Signatur und das Verhalten von <xref:System.Object>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
  </Members>
</Type>