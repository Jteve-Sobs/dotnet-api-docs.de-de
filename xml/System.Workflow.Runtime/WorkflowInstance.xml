<Type Name="WorkflowInstance" FullName="System.Workflow.Runtime.WorkflowInstance">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="07d8382ec4e884cb18693125a3c051d1729b8b45" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37734425" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class WorkflowInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowInstance extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.WorkflowInstance" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowInstance" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowInstance sealed" />
  <TypeSignature Language="F#" Value="type WorkflowInstance = class" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a workflow instance.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 Die <xref:System.Workflow.Runtime.WorkflowInstance>-Klasse macht Methoden und Eigenschaften verfügbar, die verwendet werden können, um die Ausführung einer Workflowinstanz zu steuern. Es handelt sich dabei im Wesentlichen um einen Proxy der eigentlichen Workflowinstanz, die von der Workflowruntime-Engine verwendet wird. Ein Host oder ein Dienst kann die Workflowruntime-Engine anweisen, Aktionen für eine Workflowinstanz durchzuführen, indem er die entsprechenden Methoden aufruft, die in der <xref:System.Workflow.Runtime.WorkflowInstance>-Klasse enthalten sind.  Wenn die angeforderte Aktion nicht gültig ist, z.B. wenn der Host <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> für eine Workflowinstanz aufruft, die bereits abgeschlossen wurde, löst die Workflowruntime-Engine eine entsprechende Ausnahme aus.  
  
> [!NOTE]
>  Wenn eine Workflowinstanz nicht mehr reagiert, weil für einen Aufruf der Hostanwendung keine Rückgabe erfolgt, kann die Instanz nur durch das Neustarten der Laufzeit wiederhergestellt werden. Wenn die Instanz jedoch zwangsweise entladen, abgebrochen oder unterbrochen wurde, können Sie sie fortsetzen, indem Sie die <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie eine <xref:System.Workflow.Runtime.WorkflowInstance> in einem Workflowhost erstellen und starten können. Der Code erstellt eine <xref:System.Workflow.Runtime.WorkflowRuntime>-Instanz, fügt der Laufzeit Dienste hinzu und zeigt dann die empfohlene Vorgehensweise zum Erstellen eines <xref:System.Workflow.Runtime.WorkflowInstance>-Objekts. Im Code wird die <xref:System.Workflow.Runtime.WorkflowInstance> initialisiert, indem er die <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A>-Methode aufruft und den vorher erstellten Typ an sie übergibt. Die <xref:System.Workflow.Runtime.WorkflowInstance> wird mit dem <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A>-Methodenaufruf gestartet.  
  
 Dieses Codebeispiel ist Teil des Canceling a Workflow SDK-Beispiels in der Datei Program.cs. Weitere Informationen finden Sie unter [Abbrechen eines Workflows](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="workflowInstance.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aborts the workflow instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Workflowinstanz wird auf synchrone Weise abgebrochen. Die Rückgabe der Methode erfolgt also, nachdem die Workflowinstanz abgebrochen wurde. Die Workflowruntime-Engine macht die Workflowinstanz im Arbeitsspeicher ungültig und löscht den <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>. Wenn die Workflowinstanz einen Persistenzdienst verwendet hat, werden die Arbeitsschritte verworfen, die seit dem letzten Persistenzpunkt ausgeführt wurden. Nachdem es die Workflowinstanz abgebrochen hat, löst die Workflowruntime-Engine das <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted>-Ereignis aus. Sie können <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A> aufrufen, um die Workflowinstanz neu zu laden und am letzten Persistenzpunkt zu beginnen.  
  
 `Abort` unterscheidet sich von <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> wie folgt: `Abort` löscht einfach die Workflowinstanz im Arbeitsspeicher, und Sie können am letzten Persistenzpunkt neu beginnen, während 'Terminate' die Workflowinstanz im Arbeitsspeicher löscht und den Persistenzdienst informiert, dass die Instanz aus dem Arbeitsspeicher gelöscht wurde. Für den <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> bedeutet dies, dass alle Zustandsinformationen für diese Workflowinstanz bei der Beendigung aus der Datenbank gelöscht werden. Sie können die Workflowinstanz dann nicht mehr von einem vorher gespeicherten Persistenzpunkt neu laden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Aufruf zum Abbrechen einer Workflowinstanz vom Typ 'Workflow1'.  
  
 [!code-csharp[WF_Samples#13](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#13)]
 [!code-vb[WF_Samples#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The workflow runtime engine is not running.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyWorkflowChanges">
      <MemberSignature Language="C#" Value="public void ApplyWorkflowChanges (System.Workflow.ComponentModel.WorkflowChanges workflowChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyWorkflowChanges(class System.Workflow.ComponentModel.WorkflowChanges workflowChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ApplyWorkflowChanges(System.Workflow.ComponentModel.WorkflowChanges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyWorkflowChanges(System::Workflow::ComponentModel::WorkflowChanges ^ workflowChanges);" />
      <MemberSignature Language="F#" Value="member this.ApplyWorkflowChanges : System.Workflow.ComponentModel.WorkflowChanges -&gt; unit" Usage="workflowInstance.ApplyWorkflowChanges workflowChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowChanges" Type="System.Workflow.ComponentModel.WorkflowChanges" />
      </Parameters>
      <Docs>
        <param name="workflowChanges">A <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" /> specifying dynamic updates for the workflow instance.</param>
        <summary>Applies changes to the workflow instance specified by the <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Workflowinstanz nicht bereits unterbrochen wurde, unterbricht die Workflowruntime-Engine die Instanz vorübergehend, bevor die Änderungen angewendet werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Aufruf von ApplyWorkflowChanges für ein <xref:System.Workflow.Runtime.WorkflowInstance>-Objekt.  Dieses Beispiel stammt aus dem Ordering State Machine SDK-Beispiel in der Datei Mainform.cs.  Weitere Informationen finden Sie unter den [Beispielstatusmechanismus Sortierung](http://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c).  
  
 [!code-csharp[WF_Samples#89](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#89)]
 [!code-vb[WF_Samples#89](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The workflow runtime engine is not running.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItem">
      <MemberSignature Language="C#" Value="public void EnqueueItem (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItem(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItem(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItem (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItem(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItem : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItem (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">The name of the <see cref="T:System.Workflow.Runtime.WorkflowQueue" />.</param>
        <param name="item">The object to enqueue.</param>
        <param name="pendingWork">An <see cref="T:System.Workflow.Runtime.IPendingWork" /> that allows the sender to be notified when <c>item</c> is delivered.</param>
        <param name="workItem">An object to be passed to the <see cref="T:System.Workflow.Runtime.IPendingWork" /> methods.</param>
        <summary>Posts a message to the specified workflow queue synchronously.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sendet das `item` an die angegebene <xref:System.Workflow.Runtime.WorkflowQueue>. Wenn Sie benachrichtigt werden möchten, sobald die Meldung zugestellt wird, können Sie <xref:System.Workflow.Runtime.IPendingWork> in Ihrem Dienst implementieren und ein `workItem` und ein <xref:System.Workflow.Runtime.IPendingWork>-Objekt an <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> übergeben. Wenn Sie diese Benachrichtigung nicht verwenden möchten, können Sie einen NULL-Verweis (`Nothing` in Visual Basic) für `pendingWork` und `workItem` übergeben.  
  
 Wenn diese Methode mit einem Statuscomputer-Workflow zu verwenden, erhalten Sie möglicherweise eine Ausnahme mit der Meldung "Warteschlange"{0}' ist nicht aktiviert. " Dies ist der Fall, wenn der aktuelle Zustand des Statuscomputers nicht über die zur Behandlung eines bestimmten Ereignisses erforderlichen Informationen verfügt. Enthält z. B. wenn ein Zustand, als der aktuelle Status der <xref:System.Workflow.Activities.EventDrivenActivity> , enthält die <xref:System.Workflow.Activities.HandleExternalEventActivity> dargestellt wird von der Warteschlange '{0}".  
  
> [!NOTE]
>  Für Meldungen wird nicht garantiert, dass sie von der Workflowinstanz in der Reihenfolge empfangen werden, in der sie gesendet wurden. Wenn der Empfang einer Meldung in einer vorhandenen Warteschlange (Warteschlange A) z.&#160;B. dazu führt, dass eine weitere Warteschlange (Warteschlange B) erstellt wird, die nach der ersten Meldung auf eine weitere Meldung wartet, trifft die zweite Meldung ggf. zuerst ein und wird nicht empfangen, weil die dazugehörige Warteschlange noch nicht erstellt wurde. Um dies zu verhindern, sollte die zweite Meldung nicht gesendet werden, bevor das Vorhandensein der zweiten Warteschlange sichergestellt ist (mithilfe von <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>.)  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Verwendung von <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Wenn das <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled>-Ereignis eintritt, wird die in diesem Beispiel definierte `OnWorkflowIdled`-Methode aufgerufen. Sie bestimmt, welcher Workflow mithilfe der <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A>-Eigenschaft in den Leerlauf versetzt wird, und ruft anschließend eine Auflistung mit in der Warteschlange befindlichen Elementen für den Workflow ab, indem die <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>-Methode aufgerufen wird. Der Code durchläuft die Auflistung, um zu ermitteln, welche Aktivität auf das Ereignis wartet, das den Workflow in den Leerlauf versetzt hat. Anschließend sendet er eine Ausnahme an die Workflowwarteschlange, indem er die <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>-Methode zusammen mit dem Namen des Ereigniswarteschlangenelements verwendet.  
  
 Dieses Codebeispiel ist Teil des Canceling a Workflow SDK-Beispiels in der Datei Program.cs. Weitere Informationen finden Sie unter [Abbrechen eines Workflows](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queueName" /> is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">The workflow runtime engine is not running.  -or-  The <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> specified by <paramref name="queueName" /> does not exist.  -or-  The <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> specified by <paramref name="queueName" /> is not enabled.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItemOnIdle">
      <MemberSignature Language="C#" Value="public void EnqueueItemOnIdle (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItemOnIdle(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItemOnIdle (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItemOnIdle(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItemOnIdle : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItemOnIdle (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">The name of the <see cref="T:System.Workflow.Runtime.WorkflowQueue" />.</param>
        <param name="item">The object to enqueue.</param>
        <param name="pendingWork">An <see cref="T:System.Workflow.Runtime.IPendingWork" /> that allows the sender to be notified when <c>item</c> is delivered.</param>
        <param name="workItem">An object to be passed to the <see cref="T:System.Workflow.Runtime.IPendingWork" /> methods.</param>
        <summary>Posts a message to the specified workflow queue when the workflow is idle. <see cref="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" /> waits until the workflow reaches an idle point and enqueues after verifying that the workflow scheduler is idle (that is, no active operation is being executed).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartet, bis sich die Workflowinstanz im Leerlauf befindet, und sendet `item` dann an die angegebene <xref:System.Workflow.Runtime.WorkflowQueue>. Wenn Sie <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle%2A> aufrufen, während die Workflowinstanz unterbrochen wird, löst die Workflowruntime-Engine eine <xref:System.InvalidOperationException> aus. Wenn Sie benachrichtigt werden möchten, sobald die Meldung zugestellt wird, können Sie <xref:System.Workflow.Runtime.IPendingWork> in Ihrem Dienst implementieren und ein `workItem` und ein <xref:System.Workflow.Runtime.IPendingWork>-Objekt an <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> übergeben. Wenn Sie diese Benachrichtigung nicht verwenden möchten, können Sie einen NULL-Verweis (`Nothing` in Visual Basic) für `pendingWork` und `workItem` übergeben.  
  
 Wenn Sie diese Methode mit einem Statuscomputer-Workflow verwenden, erhalten Sie möglicherweise eine Ausnahme, die die Nachricht enthält "Warteschlange"{0}' ist nicht aktiviert. " Dies ist der Fall, wenn der aktuelle Zustand des Statuscomputers nicht über die zur Behandlung eines bestimmten Ereignisses erforderlichen Informationen verfügt. Enthält z. B. wenn ein Zustand, als der aktuelle Status der <xref:System.Workflow.Activities.EventDrivenActivity> , enthält die <xref:System.Workflow.Activities.HandleExternalEventActivity> dargestellt wird von der Warteschlange '{0}".  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie Informationen an eine Workflowinstanz senden, indem Sie die `EnqueueItemOnIdle`-Methode verwenden. Zuerst wird ein WorkflowInstance-Objekt erstellt und gestartet. Als Nächstes wird ein Objekt erstellt, das die <xref:System.Workflow.Runtime.IPendingWork>-Schnittstelle implementiert. `EnqueueItemOnIdle` wird anschließend aufgerufen. Dabei werden Zeichenfolgenwerte für den Warteschlangenamen, das eingereihte Element und die Arbeitsaufgabe übergeben, die an die Methoden des pendingWork-Objekts übergeben werden sollen.  
  
 [!code-csharp[WF_Samples#12](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#12)]
 [!code-vb[WF_Samples#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queueName" /> is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">The workflow runtime engine is not running.  -or-  The workflow instance is suspended.  -or-  The <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> specified by <paramref name="queueName" /> does not exist.  -or-  The <see cref="T:System.Workflow.Runtime.WorkflowQueue" /> specified by <paramref name="queueName" /> is not enabled.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="workflowInstance.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object to compare.</param>
        <summary>Returns a value that indicates whether the specified object is equal to the <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</summary>
        <returns>
          <see langword="true" /> if the specified object is equal to this <see cref="T:System.Workflow.Runtime.WorkflowInstance" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei dem Objekt muss es sich um eine Instanz der <xref:System.Workflow.Runtime.WorkflowInstance>-Klasse handeln, die dieselbe <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> wie diese <xref:System.Workflow.Runtime.WorkflowInstance> hat.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="workflowInstance.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for this workflow instance.</summary>
        <returns>The hash code for this <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetHashCode%2A> gibt auf Grundlage des Werts von <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> einen Hashcode zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowDefinition">
      <MemberSignature Language="C#" Value="public System.Workflow.ComponentModel.Activity GetWorkflowDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.ComponentModel.Activity GetWorkflowDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowDefinition () As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::ComponentModel::Activity ^ GetWorkflowDefinition();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowDefinition : unit -&gt; System.Workflow.ComponentModel.Activity" Usage="workflowInstance.GetWorkflowDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves the root activity for this workflow instance.</summary>
        <returns>An <see cref="T:System.Workflow.ComponentModel.Activity" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die Stammaktivität verwenden, um in der Aktivitätshierarchie des Workflows zu navigieren.  
  
 Diese Methode ist nicht threadsicher. Aus diesem Grund muss der Host seine Aufrufe dieser Methode synchronisieren.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Abrufen der Workflowdefinition aus einer Workflowinstanz.  Dieses Beispiel stammt aus dem Ordering State Machine SDK-Beispiel in der Datei Mainform.cs.  Weitere Informationen finden Sie unter den [Beispielstatusmechanismus Sortierung](http://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c).  
  
 [!code-csharp[WF_Samples#86](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#86)]
 [!code-vb[WF_Samples#86](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#86)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowNextTimerExpiration">
      <MemberSignature Language="C#" Value="public DateTime GetWorkflowNextTimerExpiration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime GetWorkflowNextTimerExpiration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowNextTimerExpiration () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime GetWorkflowNextTimerExpiration();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowNextTimerExpiration : unit -&gt; DateTime" Usage="workflowInstance.GetWorkflowNextTimerExpiration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the next point in time that this <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> is scheduled to be delivered a timer message.</summary>
        <returns>A DateTime value that represents the next <see cref="P:System.Workflow.Runtime.TimerEventSubscription.ExpiresAt" /> time this <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> will be delivered a timer message.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration%2A>-Methode verwenden, um zu bestimmen, ob weitere Workflowzeitgebermeldungen eingereiht werden sollen. Dieses Beispiel stammt aus dem WorkflowThreading SDK-Beispiel in der Datei Program.cs. Weitere Informationen finden Sie unter [Workflow-Threading-Beispiel](http://msdn.microsoft.com/library/5b650be7-09fa-47db-a2f6-523dc8ea5ee9).  
  
 [!code-csharp[WF_Samples#284](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#284)]
 [!code-vb[WF_Samples#284](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#284)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Workflow.Runtime.TimerEventSubscription" />
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowQueueData">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowQueueData () As ReadOnlyCollection(Of WorkflowQueueInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Workflow::Runtime::WorkflowQueueInfo ^&gt; ^ GetWorkflowQueueData();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowQueueData : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;" Usage="workflowInstance.GetWorkflowQueueData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a collection of <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" /> objects that contains the pending items and subscribed activities for the workflow queues associated with this workflow instance.</summary>
        <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> of <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" /> objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> gibt eine Auflistung von <xref:System.Workflow.Runtime.WorkflowQueueInfo>-Objekten zurück, die Informationen über den Status der Workflowwarteschlangen enthält, die dieser Workflowinstanz zugeordnet sind. <xref:System.Workflow.Runtime.WorkflowQueueInfo.Items%2A?displayProperty=nameWithType> enthält die anstehenden Elemente für <xref:System.Workflow.Runtime.WorkflowQueue> und <xref:System.Workflow.Runtime.WorkflowQueueInfo.SubscribedActivityNames%2A?displayProperty=nameWithType>  enthält eine Liste der Aktivitäten, die für die Elementzustellung in einer <xref:System.Workflow.Runtime.WorkflowQueue> abonniert wurden.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie mithilfe der <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>-Methode Informationen zum Zustand aller Workflowwarteschlangen erhalten können, die einem <xref:System.Workflow.Runtime.WorkflowInstance>-Objekt zugeordnet sind. Wenn das <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled>-Ereignis eintritt, wird die in diesem Beispiel definierte `OnWorkflowIdled`-Methode aufgerufen. Sie bestimmt, welcher Workflow mithilfe der <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A>-Eigenschaft in den Leerlauf versetzt wird, und ruft anschließend eine Auflistung mit in der Warteschlange befindlichen Elementen für den Workflow ab, indem die <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>-Methode aufgerufen wird. Der Code durchläuft die Auflistung, um zu ermitteln, welche Aktivität auf das Ereignis wartet, das den Workflow in den Leerlauf versetzt hat. Anschließend sendet er eine Ausnahme an die Workflowwarteschlange, indem er die <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>-Methode zusammen mit dem Namen des Ereigniswarteschlangenelements verwendet.  
  
 Dieses Codebeispiel ist Teil des Canceling a Workflow SDK-Beispiels in der Datei Program.cs. Weitere Informationen finden Sie unter [Abbrechen eines Workflows](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The workflow runtime engine is not running.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstanceId">
      <MemberSignature Language="C#" Value="public Guid InstanceId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid InstanceId" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid InstanceId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.InstanceId : Guid" Usage="System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the unique identifier for the workflow instance.</summary>
        <value>
          <see cref="T:System.Guid" /> der Workflowinstanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> verwenden, um auf die Workflowinstanz zu verweisen.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A>-Eigenschaft verwenden können, um Informationen zu einem <xref:System.Workflow.Runtime.WorkflowInstance>-Objekt zu erhalten. Der erste Codeausschnitt erstellt eine <xref:System.Workflow.Runtime.WorkflowInstance>-Variable mit dem Namen `instanceId`.  
  
 [!code-csharp[WF_Samples#210](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#210)]
 [!code-vb[WF_Samples#210](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#210)]  
  
 Der zweite Codeausschnitt verwendet die <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A>-Eigenschaft als erstes Objekt in einem `OrderEventArgs`-Konstruktoraufruf, wenn die `CallBackForApproval`-Methode aufgerufen wird.  
  
 Dieses Codebeispiel ist Teil des Listen SDK-Beispiels in der Datei OrderServiceImple.cs. Weitere Informationen finden Sie unter [Lauschen Beispiel](http://msdn.microsoft.com/library/1cec0e82-7544-429f-b717-0fc25eb42b7f).  
  
 [!code-csharp[WF_Samples#211](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#211)]
 [!code-vb[WF_Samples#211](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#211)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Load" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load();" />
      <MemberSignature Language="F#" Value="member this.Load : unit -&gt; unit" Usage="workflowInstance.Load " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Loads a previously unloaded workflow instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
  <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> ist synchron. Wenn die Workflowinstanz geladen werden kann, wird <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> zurückgegeben, nachdem die Workflowinstanz in den Arbeitsspeicher geladen und von der Workflowruntime-Engine geplant wurde. Die Laufzeit löst das <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded>-Ereignis aus, nachdem der Persistenzdienst die Workflowinstanz im Arbeitsspeicher wiederhergestellt hat, aber bevor die Workflowruntime-Engine die Instanz plant.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie ein vorher entladenes <xref:System.Workflow.Runtime.WorkflowInstance>-Objekt geladen wird.  
  
 [!code-csharp[WF_Samples#10](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#10)]
 [!code-vb[WF_Samples#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The workflow runtime engine is not running.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReloadTrackingProfiles">
      <MemberSignature Language="C#" Value="public void ReloadTrackingProfiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReloadTrackingProfiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ReloadTrackingProfiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReloadTrackingProfiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReloadTrackingProfiles();" />
      <MemberSignature Language="F#" Value="member this.ReloadTrackingProfiles : unit -&gt; unit" Usage="workflowInstance.ReloadTrackingProfiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reload the tracking profiles for this workflow instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Laufzeitverfolgungsinfrastruktur lädt jedes <xref:System.Workflow.Runtime.Tracking.TrackingProfile> für diese Workflowinstanz neu, das ihren Verfolgungskanälen zugeordnet ist. Wenn er sich nicht bereits im unterbrochenen Zustand befindet, wird der Workflow von der Laufzeitverfolgungsinfrastruktur vorübergehend unterbrochen, während die Verfolgungsprofile neu geladen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The workflow runtime engine is not running.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="workflowInstance.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resumes execution of a previously suspended workflow instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Host kann <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A> aufrufen, um die Ausführung einer Workflowinstanz fortzusetzen, die vorher unterbrochen wurde. Wenn die Workflowinstanz sich nicht im unterbrochenen Zustand befindet, wird keine Aktion ausgeführt. Die Laufzeit löst nur das <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed>-Ereignis aus, bevor die Ausführung der Workflowinstanz fortgesetzt wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Aufruf zum Fortsetzen einer vorher unterbrochenen Workflowinstanz.  Dieses Beispiel stammt aus dem Suspend and Terminate SDK-Beispiel.  Weitere Informationen finden Sie unter [Suspend- und Terminate-Beispiels](http://msdn.microsoft.com/library/f4dffa58-d01e-44fb-b5a1-3b283d2c4517).  
  
 [!code-csharp[WF_Samples#172](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#172)]
 [!code-vb[WF_Samples#172](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#172)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The workflow runtime engine is not running.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="workflowInstance.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts the execution of the workflow instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> ruft <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ExecuteActivity%2A> für die Stammaktivität dieser Workflowinstanz auf. Wenn <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> eine Ausnahme erkennt, wird die Workflowinstanz beendet, indem <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> aufgerufen wird. Dabei wird die <xref:System.Exception.Message%2A>-Eigenschaft der Ausnahme als Grund für die Beendigung übergeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A>-Methode verwenden können, um eine <xref:System.Workflow.Runtime.WorkflowInstance> für einen Workflowhost zu starten. Der Code erstellt eine <xref:System.Workflow.Runtime.WorkflowRuntime>-Instanz, fügt der Laufzeit Dienste hinzu und zeigt dann die empfohlene Vorgehensweise zum Erstellen eines <xref:System.Workflow.Runtime.WorkflowInstance>-Objekts. Er erstellt ein <xref:System.Type>-Objekt und wandelt es in eines der Workflowobjekte um, die dem Host zugeordnet sind. Im Code im nächsten Schritt wird die <xref:System.Workflow.Runtime.WorkflowInstance> initialisiert, indem der Code die <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A>-Methode aufruft und den vorher erstellten Typ an sie übergibt. Die <xref:System.Workflow.Runtime.WorkflowInstance> wird mit dem <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A>-Methodenaufruf gestartet.  
  
 Dieses Codebeispiel ist Teil des Canceling a Workflow SDK-Beispiels in der Datei Program.cs. Weitere Informationen finden Sie unter [Abbrechen eines Workflows](http://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The workflow runtime engine is not running.  -or-  The workflow instance has already been started.</exception>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Suspend(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Suspend : string -&gt; unit" Usage="workflowInstance.Suspend error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">A description of the reason for suspending the workflow instance.</param>
        <summary>Suspends the workflow instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Workflowinstanz wird auf synchrone Weise unterbrochen. Wenn die Workflowinstanz bereits unterbrochen wurde, wird keine Aktion ausgeführt. Andernfalls unterbricht die Workflowruntime-Engine die Workflowinstanz, löst das <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended>-Ereignis aus und übergibt `reason` in einem <xref:System.Workflow.Runtime.WorkflowSuspendedEventArgs>-Element.  
  
> [!NOTE]
>  <xref:System.Workflow.Runtime.WorkflowInstance.Suspend%2A> entlädt die Workflowinstanz nicht.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Aufruf zum Unterbrechen eines <xref:System.Workflow.Runtime.WorkflowInstance>-Objekts.  
  
 [!code-csharp[WF_Samples#9](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#9)]
 [!code-vb[WF_Samples#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The workflow runtime engine is not running.</exception>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Terminate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string -&gt; unit" Usage="workflowInstance.Terminate error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">A description of the reason for terminating the workflow instance.</param>
        <summary>Terminates the workflow instance in a synchronous manner.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Workflowinstanz wird auf synchrone Weise beendet. Der Host ruft <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> auf, um die Workflowinstanz zu beenden. Die Workflowruntime-Engine löscht die Workflowinstanz im Arbeitsspeicher und informiert den Persistenzdienst darüber, dass die Instanz aus dem Arbeitsspeicher gelöscht wurde. Für den <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> bedeutet dies, dass alle Zustandsinformationen für diese Workflowinstanz bei der Beendigung aus der Datenbank gelöscht werden. Sie können die Workflowinstanz dann nicht mehr von einem vorher gespeicherten Persistenzpunkt neu laden.  
  
 Nachdem die Workflowinstanz im Arbeitsspeicher gelöscht und der Persistenzdienst über die Beendigung informiert wurde, löst die `Terminate`-Methode das <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated>-Ereignis aus und übergibt `reason` in der <xref:System.Exception.Message%2A>-Eigenschaft einer <xref:System.Workflow.ComponentModel.WorkflowTerminatedException>, die in <xref:System.Workflow.Runtime.WorkflowTerminatedEventArgs> enthalten ist.  
  
 `Terminate` unterscheidet sich von <xref:System.Workflow.Runtime.WorkflowInstance.Abort%2A> wie folgt: 'Terminate' löscht die Workflowinstanz im Arbeitsspeicher und informiert den Persistenzdienst über die Beendigung, während `Abort` einfach die Workflowinstanz im Arbeitsspeicher löscht, die Sie dann am letzten Persistenzpunkt neu starten können.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Aufruf zum Beenden eines <xref:System.Workflow.Runtime.WorkflowInstance>-Objekts.  
  
 [!code-csharp[WF_Samples#8](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#8)]
 [!code-vb[WF_Samples#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The workflow runtime engine is not running.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryUnload">
      <MemberSignature Language="C#" Value="public bool TryUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.TryUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function TryUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryUnload();" />
      <MemberSignature Language="F#" Value="member this.TryUnload : unit -&gt; bool" Usage="workflowInstance.TryUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unloads the workflow instance from memory to the persistence store when the instance is suspended or idle.</summary>
        <returns>
          <see langword="true" /> if the workflow instance was unloaded; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Workflowinstanz sich im Leerlauf befindet oder unterbrochen wurde, verwendet <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> den Persistenzdienst, um die Workflowinstanz aus dem Arbeitsspeicher zu entfernen und in einem Datenspeicher beizubehalten. Wenn für <xref:System.Workflow.Runtime.WorkflowRuntime> kein Persistenzdienst registriert ist, löst <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> eine <xref:System.InvalidOperationException> aus. Wenn die Workflowinstanz erfolgreich beibehalten wird, löst die Laufzeit die <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> , und gibt `true`. <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> Gibt `false` , wenn die Workflowinstanz bereits entladen worden ist, wurde beendet, abgebrochen wurde oder bereits abgeschlossen wurde.  
  
 Der Host kann <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> verwenden, um Systemressourcen eines im Leerlauf befindlichen Workflows freizugeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die TryUnload-Methode verwenden, um einen Workflow zu entladen, wenn das <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled>-Ereignis ausgelöst wird. Dieses Beispiel stammt aus dem Using Persistence Services SDK-Beispiel in der Datei Program.cs. Weitere Informationen finden Sie unter [Using Persistence Services Sample](http://msdn.microsoft.com/library/3176b7e7-ae49-4d5c-802b-85032d6ebde6).  
  
 [!code-csharp[WF_Samples#280](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#280)]
 [!code-vb[WF_Samples#280](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#280)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There is no persistence service registered with the workflow runtime engine.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="workflowInstance.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unloads the workflow instance from memory to the persistence store. This call blocks until after the currently scheduled work is finished, or the end of a transaction scope.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A>Das Entladen verläuft synchron. Das heißt, die Rückgabe erfolgt, nachdem alle auszuführenden Aktionen abgeschlossen sind. Wenn sich die Workflowinstanz nicht im Leerlauf befindet, wartet die Laufzeit, bis die Instanz unterbrochen werden kann. Eine Instanz kann nur unterbrochen werden, nachdem die Bearbeitung des geplanten Arbeitsschritts abgeschlossen ist. In der Regel ist dies der Fall, wenn die momentan ausgeführte Aktivität von der <xref:System.Workflow.ComponentModel.Activity.Execute%2A>-Methode zurückgegeben wird. Wenn die Instanz jedoch eine <xref:System.Workflow.ComponentModel.TransactionScopeActivity> ausführt, muss der Transaktionsumfang die Ausführung abschließen, bevor die Instanz unterbrochen werden kann. Der Entladevorgang verwendet dann den Persistenzdienst, um die Workflowinstanz aus dem Arbeitsspeicher zu entfernen, und behält sie in einem Datenspeicher bei. Wenn für <xref:System.Workflow.Runtime.WorkflowRuntime> kein Persistenzdienst registriert ist, löst <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> eine <xref:System.InvalidOperationException> aus. Wenn die Workflowinstanz erfolgreich beibehalten wird, löst die Laufzeit das <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded>-Ereignis aus.  
  
 Der Host kann <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> verwenden, um Systemressourcen eines im Leerlauf befindlichen Workflows freizugeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> für ein <xref:System.Workflow.Runtime.WorkflowInstance>-Objekt aufrufen.  
  
 [!code-csharp[WF_Samples#11](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#11)]
 [!code-vb[WF_Samples#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There is no persistence service registered with the workflow runtime engine.</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkflowRuntime">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkflowRuntime As WorkflowRuntime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Workflow::Runtime::WorkflowRuntime ^ WorkflowRuntime { System::Workflow::Runtime::WorkflowRuntime ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkflowRuntime : System.Workflow.Runtime.WorkflowRuntime" Usage="System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowRuntime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> for this workflow instance.</summary>
        <value>
          <see cref="T:System.Workflow.Runtime.WorkflowRuntime" />, die die Ausführungsumgebung darstellt, in der diese Workflowinstanz ausgeführt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie auf die Ausführung der <xref:System.Workflow.Runtime.WorkflowRuntime> eines <xref:System.Workflow.Runtime.WorkflowInstance>-Objekts zugreifen.  
  
 [!code-csharp[WF_Samples#7](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#7)]
 [!code-vb[WF_Samples#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>