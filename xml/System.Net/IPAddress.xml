<Type Name="IPAddress" FullName="System.Net.IPAddress">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a8d4566fdf7241b77758298a7113078d3c7fb358" /><Meta Name="ms.sourcegitcommit" Value="a6c4dae9c1ba2cfbc4452907ef5697ad1f870c0d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/30/2019" /><Meta Name="ms.locfileid" Value="73083508" /></Metadata><TypeSignature Language="C#" Value="public class IPAddress" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit IPAddress extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.IPAddress" />
  <TypeSignature Language="VB.NET" Value="Public Class IPAddress" />
  <TypeSignature Language="C++ CLI" Value="public ref class IPAddress" />
  <TypeSignature Language="F#" Value="type IPAddress = class" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Primitives</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="67396-101">Stellt eine Internetprotokolladresse (IP) bereit.</span><span class="sxs-lookup"><span data-stu-id="67396-101">Provides an Internet Protocol (IP) address.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-102">Die <xref:System.Net.IPAddress>-Klasse enthält die Adresse eines Computers in einem IP-Netzwerk.</span><span class="sxs-lookup"><span data-stu-id="67396-102">The <xref:System.Net.IPAddress> class contains the address of a computer on an IP network.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="67396-103">Im folgenden Codebeispiel wird gezeigt, wie ein Server abgefragt wird, um die Familien Adressen und die von ihm unterstützten IP-Adressen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="67396-103">The following code example shows how to query a server to obtain the family addresses and the IP addresses it supports.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#1)]
 [!code-csharp[System.Net.IPAddress#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#1)]
 [!code-vb[System.Net.IPAddress#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="67396-104">Initialisiert eine neue Instanz der <see cref="T:System.Net.IPAddress" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="67396-104">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : byte[] -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="67396-105">Der Bytearraywert der IP-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-105">The byte array value of the IP address.</span></span></param>
        <summary><span data-ttu-id="67396-106">Initialisiert eine neue Instanz der <see cref="T:System.Net.IPAddress" />-Klasse mit der Adresse, die als <see cref="T:System.Byte" />-Array angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="67396-106">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-107">Die <xref:System.Net.IPAddress> wird erstellt, wobei die Eigenschaft <xref:System.Net.IPAddress.Address%2A> auf `address`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="67396-107">The <xref:System.Net.IPAddress> is created with the <xref:System.Net.IPAddress.Address%2A> property set to `address`.</span></span>  
  
 <span data-ttu-id="67396-108">Wenn die Länge `address` 4 ist, erstellt <xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29> eine IPv4-Adresse. Andernfalls wird eine IPv6-Adresse mit einem Bereich von 0 erstellt.</span><span class="sxs-lookup"><span data-stu-id="67396-108">If the length of `address` is 4, <xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29> constructs an IPv4 address; otherwise, an IPv6 address with a scope of 0 is constructed.</span></span>  
  
 <span data-ttu-id="67396-109">Es wird angenommen, dass das <xref:System.Byte> Array in der Netzwerk-Byte-Reihenfolge mit dem signifikantesten Byte First an der Indexposition 0 ist.</span><span class="sxs-lookup"><span data-stu-id="67396-109">The <xref:System.Byte> array is assumed to be in network byte order with the most significant byte first in index position 0.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="67396-110"><paramref name="address" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="67396-110"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="67396-111"><paramref name="address" /> enthält eine ungültige IP-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-111"><paramref name="address" /> contains a bad IP address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (long newAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 newAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (newAddress As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(long newAddress);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress newAddress" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="newAddress" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="newAddress"><span data-ttu-id="67396-112">Der Long-Wert der IP-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-112">The long value of the IP address.</span></span> <span data-ttu-id="67396-113">Der Wert 0x2414188f weist z. B. im Big-Endian-Format die IP-Adresse "143.24.20.36" auf.</span><span class="sxs-lookup"><span data-stu-id="67396-113">For example, the value 0x2414188f in big-endian format would be the IP address "143.24.20.36".</span></span></param>
        <summary><span data-ttu-id="67396-114">Initialisiert eine neue Instanz der <see cref="T:System.Net.IPAddress" />-Klasse mit der Adresse, die als <see cref="T:System.Int64" /> angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="67396-114">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as an <see cref="T:System.Int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-115">Die <xref:System.Net.IPAddress> Instanz wird erstellt, wobei die Eigenschaft <xref:System.Net.IPAddress.Address%2A> auf `newAddress`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="67396-115">The <xref:System.Net.IPAddress> instance is created with the <xref:System.Net.IPAddress.Address%2A> property set to `newAddress`.</span></span>  
  
 <span data-ttu-id="67396-116">Angenommen, der <xref:System.Int64> Wert ist in der Netzwerk-Byte Reihenfolge angegeben.</span><span class="sxs-lookup"><span data-stu-id="67396-116">The <xref:System.Int64> value is assumed to be in network byte order.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="67396-117"><paramref name="newAddress" /> &lt; 0 oder</span><span class="sxs-lookup"><span data-stu-id="67396-117"><paramref name="newAddress" /> &lt; 0 or</span></span> 
 <span data-ttu-id="67396-118"><paramref name="newAddress" /> &gt; 0x00000000FFFFFFFF</span><span class="sxs-lookup"><span data-stu-id="67396-118"><paramref name="newAddress" /> &gt; 0x00000000FFFFFFFF</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : ReadOnlySpan&lt;byte&gt; -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[],System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte(), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address, long scopeid);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : byte[] * int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress (address, scopeid)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
        <Parameter Name="scopeid" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="67396-119">Der Bytearraywert der IP-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-119">The byte array value of the IP address.</span></span></param>
        <param name="scopeid"><span data-ttu-id="67396-120">Der Long-Wert des Bezeichners für den Gültigkeitsbereich.</span><span class="sxs-lookup"><span data-stu-id="67396-120">The long value of the scope identifier.</span></span></param>
        <summary><span data-ttu-id="67396-121">Initialisiert eine neue Instanz der <see cref="T:System.Net.IPAddress" />-Klasse mit der Adresse, die als <see cref="T:System.Byte" />-Array angegeben ist, und dem angegebenen Bezeichner für den Gültigkeitsbereich.</span><span class="sxs-lookup"><span data-stu-id="67396-121">Initializes a new instance of the <see cref="T:System.Net.IPAddress" /> class with the address specified as a <see cref="T:System.Byte" /> array and the specified scope identifier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-122">Dieser Konstruktor instanziiert eine IPv6-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-122">This constructor instantiates an IPv6 address.</span></span> <span data-ttu-id="67396-123">Der `scopeid` identifiziert eine Netzwerkschnittstelle im Fall einer Link-Local-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-123">The `scopeid` identifies a network interface in the case of a link-local address.</span></span> <span data-ttu-id="67396-124">Der Gültigkeitsbereich ist nur für Link-Local-und Site-Local-Adressen gültig.</span><span class="sxs-lookup"><span data-stu-id="67396-124">The scope is valid only for link-local and site-local addresses.</span></span>  
  
 <span data-ttu-id="67396-125">Es wird angenommen, dass das <xref:System.Byte> Array in der Netzwerk-Byte-Reihenfolge mit dem signifikantesten Byte First an der Indexposition 0 ist.</span><span class="sxs-lookup"><span data-stu-id="67396-125">The <xref:System.Byte> array is assumed to be in network byte order with the most significant byte first in index position 0.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="67396-126"><paramref name="address" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="67396-126"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="67396-127"><paramref name="address" /> enthält eine ungültige IP-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-127"><paramref name="address" /> contains a bad IP address.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="67396-128"><paramref name="scopeid" /> &lt; 0 oder</span><span class="sxs-lookup"><span data-stu-id="67396-128"><paramref name="scopeid" /> &lt; 0 or</span></span> 
 <span data-ttu-id="67396-129"><paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</span><span class="sxs-lookup"><span data-stu-id="67396-129"><paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address, long scopeid);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : ReadOnlySpan&lt;byte&gt; * int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress (address, scopeid)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="scopeid" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <param name="scopeid">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public long Address { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.Address" />
      <MemberSignature Language="VB.NET" Value="Public Property Address As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Address { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Address : int64 with get, set" Usage="System.Net.IPAddress.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("IPAddress.Address is address family dependant, use Equals method for comparison.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-130">Eine Internetprotokolladresse (IP-Adresse).</span><span class="sxs-lookup"><span data-stu-id="67396-130">An Internet Protocol (IP) address.</span></span></summary>
        <value><span data-ttu-id="67396-131">Der Long-Wert der IP-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-131">The long value of the IP address.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-132">Diese Eigenschaft ist veraltet.</span><span class="sxs-lookup"><span data-stu-id="67396-132">This property is obsolete.</span></span> <span data-ttu-id="67396-133">Verwenden Sie <xref:System.Net.IPAddress.GetAddressBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="67396-133">Use <xref:System.Net.IPAddress.GetAddressBytes%2A>.</span></span>  
  
 <span data-ttu-id="67396-134">Verwenden Sie die <xref:System.Net.IPAddress.ToString%2A>-Methode, um <xref:System.Net.IPAddress.Address%2A> in eine punktierte Quad-Notation zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="67396-134">To convert <xref:System.Net.IPAddress.Address%2A> to dotted-quad notation, use the <xref:System.Net.IPAddress.ToString%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="67396-135">Die Adressfamilie ist <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="67396-135">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.IPAddress.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-136">Ruft die Adressfamilie der IP-Adresse ab.</span><span class="sxs-lookup"><span data-stu-id="67396-136">Gets the address family of the IP address.</span></span></summary>
        <value><span data-ttu-id="67396-137">Gibt <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> für IPv4 oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> für IPv6 zurück.</span><span class="sxs-lookup"><span data-stu-id="67396-137">Returns <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> for IPv4 or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> for IPv6.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="67396-138">Weitere Informationen finden Sie im Beispiel im Thema <xref:System.Net.IPAddress>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="67396-138">Refer to the example in the <xref:System.Net.IPAddress> class topic.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Any : System.Net.IPAddress" Usage="System.Net.IPAddress.Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-139">Stellt eine IP-Adresse bereit, die angibt, dass der Server die Clientaktivität an allen Netzwerkschnittstellen überwachen soll.</span><span class="sxs-lookup"><span data-stu-id="67396-139">Provides an IP address that indicates that the server must listen for client activity on all network interfaces.</span></span> <span data-ttu-id="67396-140">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="67396-140">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-141">Die <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType>-Methode verwendet das <xref:System.Net.IPAddress.Any> Feld, um anzugeben, dass eine <xref:System.Net.Sockets.Socket> Instanz auf allen Netzwerkschnittstellen auf Client Aktivitäten lauschen muss.</span><span class="sxs-lookup"><span data-stu-id="67396-141">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.Any> field to indicate that a <xref:System.Net.Sockets.Socket> instance must listen for client activity on all network interfaces.</span></span>  
  
 <span data-ttu-id="67396-142">Das <xref:System.Net.IPAddress.Any> Feld entspricht 0.0.0.0 in der punktierte-Quad-Notation.</span><span class="sxs-lookup"><span data-stu-id="67396-142">The <xref:System.Net.IPAddress.Any> field is equivalent to 0.0.0.0 in dotted-quad notation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Broadcast;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Broadcast" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Broadcast" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Broadcast As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Broadcast;" />
      <MemberSignature Language="F#" Value=" staticval mutable Broadcast : System.Net.IPAddress" Usage="System.Net.IPAddress.Broadcast" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-143">Stellt die IP-Übertragungsadresse bereit.</span><span class="sxs-lookup"><span data-stu-id="67396-143">Provides the IP broadcast address.</span></span> <span data-ttu-id="67396-144">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="67396-144">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-145">Das <xref:System.Net.IPAddress.Broadcast> Feld entspricht 255.255.255.255 in der punktierte-Quad-Notation.</span><span class="sxs-lookup"><span data-stu-id="67396-145">The <xref:System.Net.IPAddress.Broadcast> field is equivalent to 255.255.255.255 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="67396-146">Im folgenden Beispiel wird die <xref:System.Net.IPAddress.Broadcast> Adresse in der Konsole gedruckt.</span><span class="sxs-lookup"><span data-stu-id="67396-146">The following example prints the <xref:System.Net.IPAddress.Broadcast> address to the console.</span></span>  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#2)]
 [!code-csharp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#2)]
 [!code-vb[IPAddress_Broadcast_Loopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="iPAddress.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand"><span data-ttu-id="67396-147">Eine <see cref="T:System.Net.IPAddress" />-Instanz, die mit der aktuellen Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="67396-147">An <see cref="T:System.Net.IPAddress" /> instance to compare to the current instance.</span></span></param>
        <summary><span data-ttu-id="67396-148">Vergleicht zwei IP-Adressen.</span><span class="sxs-lookup"><span data-stu-id="67396-148">Compares two IP addresses.</span></span></summary>
        <returns><span data-ttu-id="67396-149"><see langword="true" />, wenn die zwei Adressen gleich sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="67396-149"><see langword="true" /> if the two addresses are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-150">Die <xref:System.Net.IPAddress.Equals%2A>-Methode vergleicht die aktuelle <xref:System.Net.IPAddress> Instanz mit dem `comparand`-Parameter und gibt `true` zurück, wenn die beiden Instanzen dieselbe IP-Adresse enthalten.</span><span class="sxs-lookup"><span data-stu-id="67396-150">The <xref:System.Net.IPAddress.Equals%2A> method compares the current <xref:System.Net.IPAddress> instance with the `comparand` parameter and returns `true` if the two instances contain the same IP address.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAddressBytes">
      <MemberSignature Language="C#" Value="public byte[] GetAddressBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetAddressBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetAddressBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAddressBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetAddressBytes();" />
      <MemberSignature Language="F#" Value="member this.GetAddressBytes : unit -&gt; byte[]" Usage="iPAddress.GetAddressBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="67396-151">Stellt eine Kopie der <see cref="T:System.Net.IPAddress" /> als Bytearray zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="67396-151">Provides a copy of the <see cref="T:System.Net.IPAddress" /> as an array of bytes.</span></span></summary>
        <returns><span data-ttu-id="67396-152">Ein <see cref="T:System.Byte" />-Array.</span><span class="sxs-lookup"><span data-stu-id="67396-152">A <see cref="T:System.Byte" /> array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="67396-153">Im folgenden Codebeispiel wird gezeigt, wie Sie eine Server-IP-Adresse im Byte-Format erhalten.</span><span class="sxs-lookup"><span data-stu-id="67396-153">The following code example shows how to get a server IP address in byte format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#2)]
 [!code-csharp[System.Net.IPAddress#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#2)]
 [!code-vb[System.Net.IPAddress#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="iPAddress.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="67396-154">Gibt einen Hashwert für eine IP-Adresse zurück.</span><span class="sxs-lookup"><span data-stu-id="67396-154">Returns a hash value for an IP address.</span></span></summary>
        <returns><span data-ttu-id="67396-155">Ein ganzzahliger Hashwert.</span><span class="sxs-lookup"><span data-stu-id="67396-155">An integer hash value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-156">Die <xref:System.Net.IPAddress.GetHashCode%2A>-Methode gibt einen Hashcode der IP-Adresse zurück.</span><span class="sxs-lookup"><span data-stu-id="67396-156">The <xref:System.Net.IPAddress.GetHashCode%2A> method returns a hash code of the IP address.</span></span> <span data-ttu-id="67396-157">Dieser Wert kann als Schlüssel in Hash Tabellen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="67396-157">This value can be used as a key in hash tables.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HostToNetworkOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="67396-158">Konvertiert einen Wert aus der Host-Bytereihenfolge in die Netzwerk-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-158">Converts a value from host byte order to network byte order.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static short HostToNetworkOrder (short host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 HostToNetworkOrder(int16 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short HostToNetworkOrder(short host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int16 -&gt; int16" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="67396-159">Die zu konvertierende Zahl in Host-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-159">The number to convert, expressed in host byte order.</span></span></param>
        <summary><span data-ttu-id="67396-160">Konvertiert einen kurzen Wert vom Typ Short aus der Host-Bytereihenfolge in die Netzwerk-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-160">Converts a short value from host byte order to network byte order.</span></span></summary>
        <returns><span data-ttu-id="67396-161">Ein Wert vom Typ Short, der in der Netzwerk-Bytereihenfolge ausgedrückt ist.</span><span class="sxs-lookup"><span data-stu-id="67396-161">A short value, expressed in network byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-162">Für verschiedene Computer werden unterschiedliche Konventionen für die Reihenfolge der Bytes in ganzzahligen multibytewerten verwendet</span><span class="sxs-lookup"><span data-stu-id="67396-162">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="67396-163">Einige Computer platzieren zuerst das signifikanteste Byte (als Big-Endian-Reihenfolge bezeichnet), und andere haben zuerst das am wenigsten signifikante Byte (als Little-Endian-Reihenfolge bezeichnet).</span><span class="sxs-lookup"><span data-stu-id="67396-163">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="67396-164">Wenn Sie mit Computern arbeiten möchten, die unterschiedliche Byte Reihen sortieren, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden, in der Netzwerk-Byte-Reihenfolge gesendet, die zuerst das wichtigste Byte aufweist</span><span class="sxs-lookup"><span data-stu-id="67396-164">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="67396-165">Die <xref:System.Net.IPAddress.HostToNetworkOrder%2A>-Methode konvertiert Multibytezeichen-ganzzahlige Werte, die auf dem Host System gespeichert sind, von der Byte Reihenfolge, die vom Host verwendet wird, in die vom Netzwerk verwendete Bytefolge.</span><span class="sxs-lookup"><span data-stu-id="67396-165">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static int HostToNetworkOrder (int host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 HostToNetworkOrder(int32 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int HostToNetworkOrder(int host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int -&gt; int" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="67396-166">Die zu konvertierende Zahl in Host-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-166">The number to convert, expressed in host byte order.</span></span></param>
        <summary><span data-ttu-id="67396-167">Konvertiert einen ganzzahligen Wert aus der Host-Bytereihenfolge in die Netzwerk-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-167">Converts an integer value from host byte order to network byte order.</span></span></summary>
        <returns><span data-ttu-id="67396-168">Ein ganzzahliger Wert, der in der Netzwerk-Bytereihenfolge ausgedrückt ist.</span><span class="sxs-lookup"><span data-stu-id="67396-168">An integer value, expressed in network byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-169">Für verschiedene Computer werden unterschiedliche Konventionen für die Reihenfolge der Bytes in ganzzahligen multibytewerten verwendet</span><span class="sxs-lookup"><span data-stu-id="67396-169">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="67396-170">Einige Computer platzieren zuerst das signifikanteste Byte (als Big-Endian-Reihenfolge bezeichnet), und andere haben zuerst das am wenigsten signifikante Byte (als Little-Endian-Reihenfolge bezeichnet).</span><span class="sxs-lookup"><span data-stu-id="67396-170">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="67396-171">Wenn Sie mit Computern arbeiten möchten, die unterschiedliche Byte Reihen sortieren, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden, in der Netzwerk-Byte-Reihenfolge gesendet, die zuerst das wichtigste Byte aufweist</span><span class="sxs-lookup"><span data-stu-id="67396-171">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="67396-172">Die <xref:System.Net.IPAddress.HostToNetworkOrder%2A>-Methode konvertiert Multibytezeichen-ganzzahlige Werte, die auf dem Host System gespeichert sind, von der Byte Reihenfolge, die vom Host verwendet wird, in die vom Netzwerk verwendete Bytefolge.</span><span class="sxs-lookup"><span data-stu-id="67396-172">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static long HostToNetworkOrder (long host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 HostToNetworkOrder(int64 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long HostToNetworkOrder(long host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int64 -&gt; int64" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="67396-173">Die zu konvertierende Zahl in Host-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-173">The number to convert, expressed in host byte order.</span></span></param>
        <summary><span data-ttu-id="67396-174">Konvertiert einen Wert vom Typ Long aus der Host-Bytereihenfolge in die Netzwerk-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-174">Converts a long value from host byte order to network byte order.</span></span></summary>
        <returns><span data-ttu-id="67396-175">Ein Wert vom Typ Long, der in Netzwerk-Bytereihenfolge ausgedrückt ist.</span><span class="sxs-lookup"><span data-stu-id="67396-175">A long value, expressed in network byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-176">Für verschiedene Computer werden unterschiedliche Konventionen für die Reihenfolge der Bytes in ganzzahligen multibytewerten verwendet</span><span class="sxs-lookup"><span data-stu-id="67396-176">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="67396-177">Einige Computer platzieren zuerst das signifikanteste Byte (als Big-Endian-Reihenfolge bezeichnet), und andere haben zuerst das am wenigsten signifikante Byte (als Little-Endian-Reihenfolge bezeichnet).</span><span class="sxs-lookup"><span data-stu-id="67396-177">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="67396-178">Wenn Sie mit Computern arbeiten möchten, die unterschiedliche Byte Reihen sortieren, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden, in der Netzwerk-Byte-Reihenfolge gesendet, die zuerst das wichtigste Byte aufweist</span><span class="sxs-lookup"><span data-stu-id="67396-178">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="67396-179">Die <xref:System.Net.IPAddress.HostToNetworkOrder%2A>-Methode konvertiert Multibytezeichen-ganzzahlige Werte, die auf dem Host System gespeichert sind, von der Byte Reihenfolge, die vom Host verwendet wird, in die vom Netzwerk verwendete Bytefolge.</span><span class="sxs-lookup"><span data-stu-id="67396-179">The <xref:System.Net.IPAddress.HostToNetworkOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the host to the byte order used by the network.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="IPv6Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6Any : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-180">Die <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />-Methode gibt über das <see cref="F:System.Net.IPAddress.IPv6Any" />-Feld an, dass ein <see cref="T:System.Net.Sockets.Socket" /> die Clientaktivität an allen Netzwerkschnittstellen überwachen muss.</span><span class="sxs-lookup"><span data-stu-id="67396-180">The <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method uses the <see cref="F:System.Net.IPAddress.IPv6Any" /> field to indicate that a <see cref="T:System.Net.Sockets.Socket" /> must listen for client activity on all network interfaces.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-181">Das <xref:System.Net.IPAddress.IPv6Any>-Feld entspricht 0:0:0:0:0:0:0:0 in der Doppelpunkt-hexadezimal Notation oder in der Compact-Notation::.</span><span class="sxs-lookup"><span data-stu-id="67396-181">The <xref:System.Net.IPAddress.IPv6Any> field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to :: in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="67396-182">Im folgenden Codebeispiel wird der Wert der Adresse des aktuellen Hosts im komprimierten Standardformat angezeigt.</span><span class="sxs-lookup"><span data-stu-id="67396-182">The following code example displays the value of the current host's Any address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#2)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#2)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Loopback;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6Loopback : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6Loopback" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-183">Stellt die IP-Loopback-Adresse bereit.</span><span class="sxs-lookup"><span data-stu-id="67396-183">Provides the IP loopback address.</span></span> <span data-ttu-id="67396-184">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="67396-184">This property is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-185">Das <xref:System.Net.IPAddress.IPv6Loopback> Feld entspricht 0:0:0:0:0:0:0:1 in der Doppelpunkt-hexadezimal Notation oder in:: 1 in der Compact-Notation.</span><span class="sxs-lookup"><span data-stu-id="67396-185">The <xref:System.Net.IPAddress.IPv6Loopback> field is equivalent to 0:0:0:0:0:0:0:1 in colon-hexadecimal notation, or to ::1 in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="67396-186">Im folgenden Codebeispiel wird der Wert der Loopback Adresse des aktuellen Hosts im komprimierten Standardformat angezeigt.</span><span class="sxs-lookup"><span data-stu-id="67396-186">The following code example displays the value of the current host's loopback address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6None;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6None : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-187">Stellt eine IP-Adresse bereit, die angibt, dass keine Netzwerkschnittstelle verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="67396-187">Provides an IP address that indicates that no network interface should be used.</span></span> <span data-ttu-id="67396-188">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="67396-188">This property is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-189">Die <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType>-Methode verwendet das <xref:System.Net.IPAddress.IPv6None> Feld, um anzugeben, dass eine <xref:System.Net.Sockets.Socket> nicht auf Client Aktivitäten lauschen darf.</span><span class="sxs-lookup"><span data-stu-id="67396-189">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.IPv6None> field to indicate that a <xref:System.Net.Sockets.Socket> must not listen for client activity.</span></span> <span data-ttu-id="67396-190">Das <xref:System.Net.IPAddress.IPv6None>-Feld entspricht 0:0:0:0:0:0:0:0 in einer Doppelpunkt-hexadezimal Notation oder zu:: 0 in der Compact-Notation.</span><span class="sxs-lookup"><span data-stu-id="67396-190">The <xref:System.Net.IPAddress.IPv6None> field is equivalent to 0:0:0:0:0:0:0:0 in colon-hexadecimal notation, or to ::0 in compact notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="67396-191">Im folgenden Codebeispiel wird der Wert der Adresse None des aktuellen Hosts im komprimierten Standardformat angezeigt.</span><span class="sxs-lookup"><span data-stu-id="67396-191">The following code example displays the value of the current host's None address in standard compressed format.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#3)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#3)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv4MappedToIPv6">
      <MemberSignature Language="C#" Value="public bool IsIPv4MappedToIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv4MappedToIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv4MappedToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv4MappedToIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv4MappedToIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv4MappedToIPv6 : bool" Usage="System.Net.IPAddress.IsIPv4MappedToIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-192">Ruft ab, ob die IP Adresse eine globale IPv4-zugeordnete IPv6 Adresse ist.</span><span class="sxs-lookup"><span data-stu-id="67396-192">Gets whether the IP address is an IPv4-mapped IPv6 address.</span></span></summary>
        <value><span data-ttu-id="67396-193">Gibt <see cref="T:System.Boolean" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="67396-193">Returns <see cref="T:System.Boolean" />.</span></span>  
  
 <span data-ttu-id="67396-194"><see langword="true" />, wenn die IP-Adresse eine IPv4-zugeordnete IPv6-Adresse ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="67396-194"><see langword="true" /> if the IP address is an IPv4-mapped IPv6 address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-195">Dual-Stack-Sockets erfordern immer IPv6-Adressen.</span><span class="sxs-lookup"><span data-stu-id="67396-195">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="67396-196">Die Möglichkeit der Interaktion mit einer IPv4-Adresse erfordert die Verwendung des IPv4-zugeordneten IPv6-Adress Formats.</span><span class="sxs-lookup"><span data-stu-id="67396-196">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="67396-197">Alle IPv4-Adressen müssen im IPv4-zugeordneten IPv6-Adressformat dargestellt werden, das einer reinen IPv6-Anwendung die Kommunikation mit einem IPv4-Knoten ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="67396-197">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="67396-198">Das IPv4-zugeordnete IPv6-Adressformat ermöglicht die Darstellung der IPv4-Adresse eines IPv4-Knotens als IPv6-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-198">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="67396-199">Die IPv4-Adresse wird in die 32 Bits der IPv6-Adresse mit niedriger Reihenfolge codiert, und die höherwertigen 96 Bits enthalten das feste Präfix 0:0: 0:0: 0: FFFF.</span><span class="sxs-lookup"><span data-stu-id="67396-199">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="67396-200">Das IPv4-zugeordnete IPv6-Adressformat wird in RFC 4291 angegeben.</span><span class="sxs-lookup"><span data-stu-id="67396-200">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="67396-201">Weitere Informationen finden Sie unter [www.ietf.org/RFC/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231).</span><span class="sxs-lookup"><span data-stu-id="67396-201">For more information, see [www.ietf.org/rfc/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6LinkLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6LinkLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6LinkLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6LinkLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6LinkLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6LinkLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6LinkLocal : bool" Usage="System.Net.IPAddress.IsIPv6LinkLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-202">Ruft ab, ob die Adresse eine IPv6-Link-Local-Adresse ist.</span><span class="sxs-lookup"><span data-stu-id="67396-202">Gets whether the address is an IPv6 link local address.</span></span></summary>
        <value><span data-ttu-id="67396-203"><see langword="true" />, wenn die IP-Adresse eine IPv6-Link-Local-Adresse ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="67396-203"><see langword="true" /> if the IP address is an IPv6 link local address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Multicast">
      <MemberSignature Language="C#" Value="public bool IsIPv6Multicast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Multicast" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Multicast" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Multicast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Multicast { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6Multicast : bool" Usage="System.Net.IPAddress.IsIPv6Multicast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-204">Ruft ab, ob die Adresse eine globale IPv6-Multicastadresse ist.</span><span class="sxs-lookup"><span data-stu-id="67396-204">Gets whether the address is an IPv6 multicast global address.</span></span></summary>
        <value><span data-ttu-id="67396-205"><see langword="true" />, wenn die IP-Adresse eine globale IPv6-Multicastadresse ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="67396-205"><see langword="true" /> if the IP address is an IPv6 multicast global address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6SiteLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6SiteLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6SiteLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6SiteLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6SiteLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6SiteLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6SiteLocal : bool" Usage="System.Net.IPAddress.IsIPv6SiteLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-206">Ruft ab, ob die Adresse eine IPv6-Site-Local-Adresse ist.</span><span class="sxs-lookup"><span data-stu-id="67396-206">Gets whether the address is an IPv6 site local address.</span></span></summary>
        <value><span data-ttu-id="67396-207"><see langword="true" />, wenn die IP-Adresse eine IPv6-Site-Local-Adresse ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="67396-207"><see langword="true" /> if the IP address is an IPv6 site local address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Teredo">
      <MemberSignature Language="C#" Value="public bool IsIPv6Teredo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Teredo" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Teredo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Teredo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Teredo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6Teredo : bool" Usage="System.Net.IPAddress.IsIPv6Teredo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-208">Ruft einen Wert ab, der angibt, ob die Adresse eine IPv6-Teredo-Adresse ist.</span><span class="sxs-lookup"><span data-stu-id="67396-208">Gets whether the address is an IPv6 Teredo address.</span></span></summary>
        <value><span data-ttu-id="67396-209"><see langword="true" />, wenn die IP-Adresse eine IPv6-Teredo-Adresse ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="67396-209"><see langword="true" /> if the IP address is an IPv6 Teredo address; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-210">Eine Teredo-Adresse ist eine IPv6-Adresse mit dem Präfix 2001::/32.</span><span class="sxs-lookup"><span data-stu-id="67396-210">A Teredo address is an IPv6 address with the prefix of 2001::/32.</span></span> <span data-ttu-id="67396-211">Teredo-Adressen können über die normale DNS-Namensauflösung zurückgegeben oder als eine IPv6-Adresse aufgezählt werden, die einer lokalen Schnittstelle zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="67396-211">Teredo addresses can be returned through normal DNS name resolution or enumerated as an IPv6 address assigned to a local interface.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.BeginGetUnicastAddresses(System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.EndGetUnicastAddresses(System.IAsyncResult)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.GetUnicastAddresses" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public static bool IsLoopback (System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLoopback(class System.Net.IPAddress address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.IsLoopback(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLoopback (address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLoopback(System::Net::IPAddress ^ address);" />
      <MemberSignature Language="F#" Value="static member IsLoopback : System.Net.IPAddress -&gt; bool" Usage="System.Net.IPAddress.IsLoopback address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="67396-212">Eine IP-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-212">An IP address.</span></span></param>
        <summary><span data-ttu-id="67396-213">Gibt an, ob es sich bei der angegebenen IP-Adresse um die Loopback-Adresse handelt.</span><span class="sxs-lookup"><span data-stu-id="67396-213">Indicates whether the specified IP address is the loopback address.</span></span></summary>
        <returns><span data-ttu-id="67396-214"><see langword="true" />, wenn <paramref name="address" /> die Loopback-Adresse ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="67396-214"><see langword="true" /> if <paramref name="address" /> is the loopback address; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-215">Die <xref:System.Net.IPAddress.IsLoopback%2A>-Methode vergleicht `address` mit <xref:System.Net.IPAddress.Loopback> und gibt `true` zurück, wenn die beiden IP-Adressen identisch sind.</span><span class="sxs-lookup"><span data-stu-id="67396-215">The <xref:System.Net.IPAddress.IsLoopback%2A> method compares `address` to <xref:System.Net.IPAddress.Loopback> and returns `true` if the two IP addresses are the same.</span></span>  
  
 <span data-ttu-id="67396-216">Im Fall von IPv4 gibt die <xref:System.Net.IPAddress.IsLoopback%2A> Methode `true` für jede IP-Adresse in der Form 127. X. Y. Z zurück (wobei X, Y und Z im Bereich 0-255 liegen), nicht nur <xref:System.Net.IPAddress.Loopback> (127.0.0.1).</span><span class="sxs-lookup"><span data-stu-id="67396-216">In the case of IPv4, that the <xref:System.Net.IPAddress.IsLoopback%2A> method returns `true` for any IP address of the form 127.X.Y.Z (where X, Y, and Z are in the range 0-255), not just <xref:System.Net.IPAddress.Loopback> (127.0.0.1).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="67396-217">Im folgenden Codebeispiel wird die <xref:System.Net.IPAddress.IsLoopback%2A>-Methode verwendet, um zu bestimmen, ob die angegebene Adresse eine Loopback Adresse ist.</span><span class="sxs-lookup"><span data-stu-id="67396-217">The following code example uses the <xref:System.Net.IPAddress.IsLoopback%2A> method to determine whether the specified address is a loopback address.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CPP/isloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CS/isloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/VB/isloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Loopback;" />
      <MemberSignature Language="F#" Value=" staticval mutable Loopback : System.Net.IPAddress" Usage="System.Net.IPAddress.Loopback" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-218">Stellt die IP-Loopback-Adresse bereit.</span><span class="sxs-lookup"><span data-stu-id="67396-218">Provides the IP loopback address.</span></span> <span data-ttu-id="67396-219">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="67396-219">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-220">Das <xref:System.Net.IPAddress.Loopback> Feld entspricht 127.0.0.1 in der punktierte-Quad-Notation.</span><span class="sxs-lookup"><span data-stu-id="67396-220">The <xref:System.Net.IPAddress.Loopback> field is equivalent to 127.0.0.1 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="67396-221">Im folgenden Beispiel wird die <xref:System.Net.IPAddress.Loopback> Adresse in der Konsole gedruckt.</span><span class="sxs-lookup"><span data-stu-id="67396-221">The following example prints the <xref:System.Net.IPAddress.Loopback> address to the console.</span></span>  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#1)]
 [!code-csharp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#1)]
 [!code-vb[IPAddress_Broadcast_Loopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv4">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv4 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv4() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv4 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv4();" />
      <MemberSignature Language="F#" Value="member this.MapToIPv4 : unit -&gt; System.Net.IPAddress" Usage="iPAddress.MapToIPv4 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="67396-222">Ordnet das <see cref="T:System.Net.IPAddress" />-Objekt einer IPv4-Adresse zu.</span><span class="sxs-lookup"><span data-stu-id="67396-222">Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv4 address.</span></span></summary>
        <returns><span data-ttu-id="67396-223">Gibt <see cref="T:System.Net.IPAddress" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="67396-223">Returns <see cref="T:System.Net.IPAddress" />.</span></span>  
  
<span data-ttu-id="67396-224">Eine IPv4-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-224">An IPv4 address.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-225">Dual-Stack-Sockets erfordern immer IPv6-Adressen.</span><span class="sxs-lookup"><span data-stu-id="67396-225">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="67396-226">Die Möglichkeit der Interaktion mit einer IPv4-Adresse erfordert die Verwendung des IPv4-zugeordneten IPv6-Adress Formats.</span><span class="sxs-lookup"><span data-stu-id="67396-226">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="67396-227">Alle IPv4-Adressen müssen im IPv4-zugeordneten IPv6-Adressformat dargestellt werden, das einer reinen IPv6-Anwendung die Kommunikation mit einem IPv4-Knoten ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="67396-227">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="67396-228">Das IPv4-zugeordnete IPv6-Adressformat ermöglicht die Darstellung der IPv4-Adresse eines IPv4-Knotens als IPv6-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-228">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="67396-229">Die IPv4-Adresse wird in die 32 Bits der IPv6-Adresse mit niedriger Reihenfolge codiert, und die höherwertigen 96 Bits enthalten das feste Präfix 0:0: 0:0: 0: FFFF.</span><span class="sxs-lookup"><span data-stu-id="67396-229">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="67396-230">Das IPv4-zugeordnete IPv6-Adressformat wird in RFC 4291 angegeben.</span><span class="sxs-lookup"><span data-stu-id="67396-230">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="67396-231">Weitere Informationen finden Sie unter [www.ietf.org/RFC/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231).</span><span class="sxs-lookup"><span data-stu-id="67396-231">For more information, see [www.ietf.org/rfc/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 <span data-ttu-id="67396-232">Wenn Sie <xref:System.Net.IPAddress.MapToIPv4%2A> verwenden möchten, um eine IPv4-Adresse aus dem IPv6-Format in das IPv4-Format zu konvertieren, müssen Sie zunächst sicherstellen, dass Sie über eine IPv4-Adresse verfügen.</span><span class="sxs-lookup"><span data-stu-id="67396-232">If you want to use <xref:System.Net.IPAddress.MapToIPv4%2A> to convert an IPv4 address from IPv6 format to IPv4 format, you must first ensure that you've got an IPv4 address.</span></span> <span data-ttu-id="67396-233">Ruft <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>auf, die `true` zurückgibt, wenn die IP-Adresse ursprünglich als IPv6 geschriebene IPv4-oder andernfalls `false`.</span><span class="sxs-lookup"><span data-stu-id="67396-233">Call <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>, which will return `true` if the IP address is originally IPv4 written as IPv6, or `false` otherwise.</span></span> <span data-ttu-id="67396-234">Wenn <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> `true`zurückgibt, verwenden Sie <xref:System.Net.IPAddress.MapToIPv4%2A>, um die Konvertierung durchführen.</span><span class="sxs-lookup"><span data-stu-id="67396-234">If <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> returns `true`, use <xref:System.Net.IPAddress.MapToIPv4%2A> to make the conversion.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv6">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv6 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv6() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv6 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv6();" />
      <MemberSignature Language="F#" Value="member this.MapToIPv6 : unit -&gt; System.Net.IPAddress" Usage="iPAddress.MapToIPv6 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="67396-235">Ordnet das <see cref="T:System.Net.IPAddress" />-Objekt einer IPv6-Adresse zu.</span><span class="sxs-lookup"><span data-stu-id="67396-235">Maps the <see cref="T:System.Net.IPAddress" /> object to an IPv6 address.</span></span></summary>
        <returns><span data-ttu-id="67396-236">Gibt <see cref="T:System.Net.IPAddress" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="67396-236">Returns <see cref="T:System.Net.IPAddress" />.</span></span>  
  
<span data-ttu-id="67396-237">Eine IPv6-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-237">An IPv6 address.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-238">Dual-Stack-Sockets erfordern immer IPv6-Adressen.</span><span class="sxs-lookup"><span data-stu-id="67396-238">Dual-stack sockets always require IPv6 addresses.</span></span> <span data-ttu-id="67396-239">Die Möglichkeit der Interaktion mit einer IPv4-Adresse erfordert die Verwendung des IPv4-zugeordneten IPv6-Adress Formats.</span><span class="sxs-lookup"><span data-stu-id="67396-239">The ability to interact with an IPv4 address requires the use of the IPv4-mapped IPv6 address format.</span></span> <span data-ttu-id="67396-240">Alle IPv4-Adressen müssen im IPv4-zugeordneten IPv6-Adressformat dargestellt werden, das einer reinen IPv6-Anwendung die Kommunikation mit einem IPv4-Knoten ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="67396-240">Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.</span></span> <span data-ttu-id="67396-241">Das IPv4-zugeordnete IPv6-Adressformat ermöglicht die Darstellung der IPv4-Adresse eines IPv4-Knotens als IPv6-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-241">The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.</span></span> <span data-ttu-id="67396-242">Die IPv4-Adresse wird in die 32 Bits der IPv6-Adresse mit niedriger Reihenfolge codiert, und die höherwertigen 96 Bits enthalten das feste Präfix 0:0: 0:0: 0: FFFF.</span><span class="sxs-lookup"><span data-stu-id="67396-242">The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.</span></span> <span data-ttu-id="67396-243">Das IPv4-zugeordnete IPv6-Adressformat wird in RFC 4291 angegeben.</span><span class="sxs-lookup"><span data-stu-id="67396-243">The IPv4-mapped IPv6 address format is specified in RFC 4291.</span></span> <span data-ttu-id="67396-244">Weitere Informationen finden Sie unter [www.ietf.org/RFC/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231).</span><span class="sxs-lookup"><span data-stu-id="67396-244">For more information, see [www.ietf.org/rfc/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="NetworkToHostOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="67396-245">Konvertiert eine Zahl aus der Netzwerk-Bytereihenfolge in die Host-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-245">Converts a number from network byte order to host byte order.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static short NetworkToHostOrder (short network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 NetworkToHostOrder(int16 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short NetworkToHostOrder(short network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int16 -&gt; int16" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="network"><span data-ttu-id="67396-246">Die zu konvertierende Zahl in der Netzwerk-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-246">The number to convert, expressed in network byte order.</span></span></param>
        <summary><span data-ttu-id="67396-247">Konvertiert einen Wert vom Typ Short aus der Netzwerk-Bytereihenfolge in die Host-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-247">Converts a short value from network byte order to host byte order.</span></span></summary>
        <returns><span data-ttu-id="67396-248">Ein Wert vom Typ Short, der in der Host-Bytereihenfolge ausgedrückt ist.</span><span class="sxs-lookup"><span data-stu-id="67396-248">A short value, expressed in host byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-249">Für verschiedene Computer werden unterschiedliche Konventionen für die Reihenfolge der Bytes in ganzzahligen multibytewerten verwendet</span><span class="sxs-lookup"><span data-stu-id="67396-249">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="67396-250">Einige Computer platzieren zuerst das signifikanteste Byte (als Big-Endian-Reihenfolge bezeichnet), und andere haben zuerst das am wenigsten signifikante Byte (als Little-Endian-Reihenfolge bezeichnet).</span><span class="sxs-lookup"><span data-stu-id="67396-250">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="67396-251">Wenn Sie mit Computern arbeiten möchten, die unterschiedliche Byte Reihen sortieren, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden, in der Netzwerk-Byte-Reihenfolge gesendet, die zuerst das wichtigste Byte aufweist</span><span class="sxs-lookup"><span data-stu-id="67396-251">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="67396-252">Die <xref:System.Net.IPAddress.NetworkToHostOrder%2A>-Methode konvertiert Multibytezeichen-ganzzahlige Werte, die auf dem Host System gespeichert sind, von der Byte Reihenfolge, die vom Netzwerk in der vom Host verwendeten Byte Reihenfolge verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="67396-252">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="67396-253">Im folgenden Beispiel wird die <xref:System.Net.IPAddress.NetworkToHostOrder%2A>-Methode zum Konvertieren eines kurzen Werts von der Netzwerk-Byte-Reihenfolge in die Host-Byte Reihenfolge</span><span class="sxs-lookup"><span data-stu-id="67396-253">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert a short value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#1)]
 [!code-csharp[IPAddress_NetworkToHost#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#1)]
 [!code-vb[IPAddress_NetworkToHost#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static int NetworkToHostOrder (int network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NetworkToHostOrder(int32 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NetworkToHostOrder(int network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int -&gt; int" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="network"><span data-ttu-id="67396-254">Die zu konvertierende Zahl in der Netzwerk-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-254">The number to convert, expressed in network byte order.</span></span></param>
        <summary><span data-ttu-id="67396-255">Konvertiert einen ganzzahligen Wert aus der Netzwerk-Bytereihenfolge in die Host-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-255">Converts an integer value from network byte order to host byte order.</span></span></summary>
        <returns><span data-ttu-id="67396-256">Ein ganzzahliger Wert, der in der Host-Bytereihenfolge ausgedrückt ist.</span><span class="sxs-lookup"><span data-stu-id="67396-256">An integer value, expressed in host byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-257">Für verschiedene Computer werden unterschiedliche Konventionen für die Reihenfolge der Bytes in ganzzahligen multibytewerten verwendet</span><span class="sxs-lookup"><span data-stu-id="67396-257">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="67396-258">Einige Computer platzieren zuerst das signifikanteste Byte (als Big-Endian-Reihenfolge bezeichnet), und andere haben zuerst das am wenigsten signifikante Byte (als Little-Endian-Reihenfolge bezeichnet).</span><span class="sxs-lookup"><span data-stu-id="67396-258">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="67396-259">Wenn Sie mit Computern arbeiten möchten, die unterschiedliche Byte Reihen sortieren, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden, in der Netzwerk-Byte-Reihenfolge gesendet, die zuerst das wichtigste Byte aufweist</span><span class="sxs-lookup"><span data-stu-id="67396-259">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="67396-260">Die <xref:System.Net.IPAddress.NetworkToHostOrder%2A>-Methode konvertiert Multibytezeichen-ganzzahlige Werte, die auf dem Host System gespeichert sind, von der Byte Reihenfolge, die vom Netzwerk in der vom Host verwendeten Byte Reihenfolge verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="67396-260">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="67396-261">Im folgenden Beispiel wird die <xref:System.Net.IPAddress.NetworkToHostOrder%2A>-Methode verwendet, um einen ganzzahligen Wert von der Netzwerk-Byte-Reihenfolge in die Host-Byte</span><span class="sxs-lookup"><span data-stu-id="67396-261">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert an integer value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#2)]
 [!code-csharp[IPAddress_NetworkToHost#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#2)]
 [!code-vb[IPAddress_NetworkToHost#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static long NetworkToHostOrder (long network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 NetworkToHostOrder(int64 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long NetworkToHostOrder(long network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int64 -&gt; int64" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="network"><span data-ttu-id="67396-262">Die zu konvertierende Zahl in der Netzwerk-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-262">The number to convert, expressed in network byte order.</span></span></param>
        <summary><span data-ttu-id="67396-263">Konvertiert einen Wert vom Typ Long aus der Netzwerk-Bytereihenfolge in die Host-Bytereihenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-263">Converts a long value from network byte order to host byte order.</span></span></summary>
        <returns><span data-ttu-id="67396-264">Ein Wert vom Typ Long, der in der Host-Bytereihenfolge ausgedrückt ist.</span><span class="sxs-lookup"><span data-stu-id="67396-264">A long value, expressed in host byte order.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-265">Für verschiedene Computer werden unterschiedliche Konventionen für die Reihenfolge der Bytes in ganzzahligen multibytewerten verwendet</span><span class="sxs-lookup"><span data-stu-id="67396-265">Different computers use different conventions for ordering the bytes within multibyte integer values.</span></span> <span data-ttu-id="67396-266">Einige Computer platzieren zuerst das signifikanteste Byte (als Big-Endian-Reihenfolge bezeichnet), und andere haben zuerst das am wenigsten signifikante Byte (als Little-Endian-Reihenfolge bezeichnet).</span><span class="sxs-lookup"><span data-stu-id="67396-266">Some computers put the most significant byte first (known as big-endian order) and others put the least-significant byte first (known as little-endian order).</span></span> <span data-ttu-id="67396-267">Wenn Sie mit Computern arbeiten möchten, die unterschiedliche Byte Reihen sortieren, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden, in der Netzwerk-Byte-Reihenfolge gesendet, die zuerst das wichtigste Byte aufweist</span><span class="sxs-lookup"><span data-stu-id="67396-267">To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.</span></span>  
  
 <span data-ttu-id="67396-268">Die <xref:System.Net.IPAddress.NetworkToHostOrder%2A>-Methode konvertiert Multibytezeichen-ganzzahlige Werte, die auf dem Host System gespeichert sind, von der Byte Reihenfolge, die vom Netzwerk in der vom Host verwendeten Byte Reihenfolge verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="67396-268">The <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method converts multibyte integer values that are stored on the host system from the byte order used by the network to the byte order used by the host.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="67396-269">Im folgenden Beispiel wird die-<xref:System.Net.IPAddress.NetworkToHostOrder%2A>-Methode verwendet, um einen Long-Wert von der Netzwerk-Byte-Reihenfolge in die Host-Byte</span><span class="sxs-lookup"><span data-stu-id="67396-269">The following example uses the <xref:System.Net.IPAddress.NetworkToHostOrder%2A> method to convert a long value from network byte order to host byte order.</span></span>  
  
 [!code-cpp[IPAddress_NetworkToHost#3](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#3)]
 [!code-csharp[IPAddress_NetworkToHost#3](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#3)]
 [!code-vb[IPAddress_NetworkToHost#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ None;" />
      <MemberSignature Language="F#" Value=" staticval mutable None : System.Net.IPAddress" Usage="System.Net.IPAddress.None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-270">Stellt eine IP-Adresse bereit, die angibt, dass keine Netzwerkschnittstelle verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="67396-270">Provides an IP address that indicates that no network interface should be used.</span></span> <span data-ttu-id="67396-271">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="67396-271">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-272">Die <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType>-Methode verwendet das <xref:System.Net.IPAddress.None> Feld, um anzugeben, dass eine <xref:System.Net.Sockets.Socket> nicht auf Client Aktivitäten lauschen darf.</span><span class="sxs-lookup"><span data-stu-id="67396-272">The <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType> method uses the <xref:System.Net.IPAddress.None> field to indicate that a <xref:System.Net.Sockets.Socket> must not listen for client activity.</span></span> <span data-ttu-id="67396-273">Das <xref:System.Net.IPAddress.None> Feld entspricht 255.255.255.255 in der punktierte-Quad-Notation.</span><span class="sxs-lookup"><span data-stu-id="67396-273">The <xref:System.Net.IPAddress.None> field is equivalent to 255.255.255.255 in dotted-quad notation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="67396-274">Im folgenden Beispiel wird die <xref:System.Net.IPAddress.None>-Eigenschaft verwendet, um anzugeben, dass keine Netzwerkschnittstelle verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="67396-274">The following example uses the <xref:System.Net.IPAddress.None> property to indicate that no network interface should be used.</span></span>  
  
 [!code-cpp[IPAddress_None#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_None/CPP/ipaddress_none.cpp#1)]
 [!code-csharp[IPAddress_None#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_None/CS/ipaddress_none.cs#1)]
 [!code-vb[IPAddress_None#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_None/VB/ipaddress_none.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As ReadOnlySpan(Of Char)) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; -&gt; System.Net.IPAddress" Usage="System.Net.IPAddress.Parse ipString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (string ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(string ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As String) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(System::String ^ ipString);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Net.IPAddress" Usage="System.Net.IPAddress.Parse ipString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ipString"><span data-ttu-id="67396-275">Eine Zeichenfolge, die eine IP-Adresse im Punktformat (Dotted Quad-Notation) für IPv4 und im durch Doppelpunkt getrennten Hexadezimalformat für IPv6 enthält.</span><span class="sxs-lookup"><span data-stu-id="67396-275">A string that contains an IP address in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</span></span></param>
        <summary><span data-ttu-id="67396-276">Konvertiert eine IP-Adresszeichenfolge in eine <see cref="T:System.Net.IPAddress" />-Instanz.</span><span class="sxs-lookup"><span data-stu-id="67396-276">Converts an IP address string to an <see cref="T:System.Net.IPAddress" /> instance.</span></span></summary>
        <returns><span data-ttu-id="67396-277">Eine <see cref="T:System.Net.IPAddress" />-Instanz.</span><span class="sxs-lookup"><span data-stu-id="67396-277">An <see cref="T:System.Net.IPAddress" /> instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-278">Die statische <xref:System.Net.IPAddress.Parse%2A>-Methode erstellt eine <xref:System.Net.IPAddress> Instanz aus einer IP-Adresse, die in der punktierte Quad-Notation für IPv4 und in der Doppelpunkt-hexadezimal Notation für IPv6 ausgedrückt wird.</span><span class="sxs-lookup"><span data-stu-id="67396-278">The static <xref:System.Net.IPAddress.Parse%2A> method creates an <xref:System.Net.IPAddress> instance from an IP address expressed in dotted-quad notation for IPv4 and in colon-hexadecimal notation for IPv6.</span></span>  
  
 <span data-ttu-id="67396-279">Die Anzahl der Teile (die jeweils durch einen bestimmten Teil getrennt sind) in `ipString` bestimmt, wie die IP-Adresse erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="67396-279">The number of parts (each part is separated by a period) in `ipString` determines how the IP address is constructed.</span></span> <span data-ttu-id="67396-280">Eine einteilige Adresse wird direkt in der Netzwerkadresse gespeichert.</span><span class="sxs-lookup"><span data-stu-id="67396-280">A one part address is stored directly in the network address.</span></span> <span data-ttu-id="67396-281">Eine zweiteilige Adresse, die für die Angabe einer Klasse eine Adresse geeignet ist, platziert den führenden Teil im ersten Byte und den nachfolgenden Teil in den rechten drei Bytes der Netzwerkadresse.</span><span class="sxs-lookup"><span data-stu-id="67396-281">A two part address, convenient for specifying a class A address, puts the leading part in the first byte and the trailing part in the right-most three bytes of the network address.</span></span> <span data-ttu-id="67396-282">Eine dreiteilige Adresse, die für die Angabe einer Class B-Adresse geeignet ist, legt den ersten Teil im ersten Byte, den zweiten Teil des zweiten Bytes und den letzten Teil in den rechten 2 Bytes der Netzwerkadresse ab.</span><span class="sxs-lookup"><span data-stu-id="67396-282">A three part address, convenient for specifying a class B address, puts the first part in the first byte, the second part in the second byte, and the final part in the right-most two bytes of the network address.</span></span> <span data-ttu-id="67396-283">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="67396-283">For example:</span></span>  
  
|<span data-ttu-id="67396-284">Anzahl von Teilen und Beispiel `ipString`</span><span class="sxs-lookup"><span data-stu-id="67396-284">Number of parts and example `ipString`</span></span>|<span data-ttu-id="67396-285">IPv4-Adresse für IPAddress</span><span class="sxs-lookup"><span data-stu-id="67396-285">IPv4 address for IPAddress</span></span>|  
|--------------------------------------------|--------------------------------|  
|<span data-ttu-id="67396-286">1--"65535"</span><span class="sxs-lookup"><span data-stu-id="67396-286">1 -- "65535"</span></span>|<span data-ttu-id="67396-287">0.0.255.255</span><span class="sxs-lookup"><span data-stu-id="67396-287">0.0.255.255</span></span>|  
|<span data-ttu-id="67396-288">2 -- "20.2"</span><span class="sxs-lookup"><span data-stu-id="67396-288">2 -- "20.2"</span></span>|<span data-ttu-id="67396-289">20.0.0.2</span><span class="sxs-lookup"><span data-stu-id="67396-289">20.0.0.2</span></span>|  
|<span data-ttu-id="67396-290">2 -- "20.65535"</span><span class="sxs-lookup"><span data-stu-id="67396-290">2 -- "20.65535"</span></span>|<span data-ttu-id="67396-291">20.0.255.255</span><span class="sxs-lookup"><span data-stu-id="67396-291">20.0.255.255</span></span>|  
|<span data-ttu-id="67396-292">3 -- "128.1.2"</span><span class="sxs-lookup"><span data-stu-id="67396-292">3 -- "128.1.2"</span></span>|<span data-ttu-id="67396-293">128.1.0.2</span><span class="sxs-lookup"><span data-stu-id="67396-293">128.1.0.2</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="67396-294">Der folgende Code konvertiert eine Zeichenfolge, die eine IP-Adresse enthält, in punktierte Quad-Notation für IPv4 oder in Doppelpunkt-hexadezimal Notation für IPv6 in eine Instanz der <xref:System.Net.IPAddress>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="67396-294">The following code converts a string that contains an IP address, in dotted-quad notation for IPv4 or in colon-hexadecimal notation for IPv6, into an instance of the <xref:System.Net.IPAddress> class.</span></span> <span data-ttu-id="67396-295">Anschließend wird die überladene <xref:System.Net.IPAddress.ToString%2A>-Methode verwendet, um die Adresse in der Standardnotation anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="67396-295">Then it uses the overloaded <xref:System.Net.IPAddress.ToString%2A> method to display the address in standard notation.</span></span>  
  
 [!code-cpp[System.Net.IPAddress.Parse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CPP/parse.cpp#1)]
 [!code-csharp[System.Net.IPAddress.Parse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CS/parse.cs#1)]
 [!code-vb[System.Net.IPAddress.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.Parse/VB/parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="67396-296"><paramref name="ipString" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="67396-296"><paramref name="ipString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="67396-297"><paramref name="ipString" /> ist keine gültige IP-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-297"><paramref name="ipString" /> is not a valid IP address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeId">
      <MemberSignature Language="C#" Value="public long ScopeId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ScopeId" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.ScopeId" />
      <MemberSignature Language="VB.NET" Value="Public Property ScopeId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ScopeId { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ScopeId : int64 with get, set" Usage="System.Net.IPAddress.ScopeId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="67396-298">Ruft den Bezeichner für den Gültigkeitsbereich der IPv6-Adresse ab oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="67396-298">Gets or sets the IPv6 address scope identifier.</span></span></summary>
        <value><span data-ttu-id="67396-299">Ein lange ganze Zahl, die den Gültigkeitsbereich der Adresse angibt.</span><span class="sxs-lookup"><span data-stu-id="67396-299">A long integer that specifies the scope of the address.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-300">Die Bedeutung <xref:System.Net.IPAddress.ScopeId%2A> ändert sich abhängig vom Kontext, in dem Sie verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="67396-300">The meaning of <xref:System.Net.IPAddress.ScopeId%2A> changes depending on the context in which it is used.</span></span>  
  
-   <span data-ttu-id="67396-301">Link-Local-Adresse.</span><span class="sxs-lookup"><span data-stu-id="67396-301">Link-local address.</span></span> <span data-ttu-id="67396-302">Auf einem Host mit mehreren Schnittstellen, die mit separaten Verknüpfungen verbunden sind, kann dieselbe Verbindungs lokale Adresse mehreren Schnittstellen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="67396-302">On a host with multiple interfaces connected to separate links, the same link-local address can be assigned to multiple interfaces.</span></span> <span data-ttu-id="67396-303">Um diese Mehrdeutigkeit auszuschließen, wird ein Bereichs Bezeichner verwendet, um die Schnittstelle anzugeben, über die Nachrichten ausgetauscht werden.</span><span class="sxs-lookup"><span data-stu-id="67396-303">To eliminate this ambiguity, a scope identifier is used to specify the interface over which messages are exchanged.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="67396-304">Link-Local-Adressen, die durch das Format Präfix (FP) FE80 identifiziert werden, werden von Knoten bei der Kommunikation mit benachbarten Knoten über denselben Link verwendet.</span><span class="sxs-lookup"><span data-stu-id="67396-304">Link-local addresses, identified by the Format Prefix (FP) FE80, are used by nodes when communicating with neighboring nodes on the same link.</span></span>  
  
-   <span data-ttu-id="67396-305">Site-Local-Adressen.</span><span class="sxs-lookup"><span data-stu-id="67396-305">Site-local addresses.</span></span> <span data-ttu-id="67396-306">Ein Host kann mit mehreren Standorten verbunden werden.</span><span class="sxs-lookup"><span data-stu-id="67396-306">A host can be connected to multiple sites.</span></span> <span data-ttu-id="67396-307">In diesem Fall wird ein Bereichs Bezeichner verwendet, um einen bestimmten Standort anzugeben, mit dem kommuniziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="67396-307">In this case, a scope identifier is used to indicate a specific site to communicate with.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="67396-308">Standort lokale Adressen, die durch das Format Präfix (FP) FEC0 identifiziert werden, werden von Knoten bei der Kommunikation über private Intranets verwendet.</span><span class="sxs-lookup"><span data-stu-id="67396-308">Site-local addresses, identified by the Format Prefix (FP) FEC0, are used by nodes when communicating on private intranets.</span></span>  
  
 <span data-ttu-id="67396-309">Die Notation, die verwendet wird, um den `ScopeId` mit einer Adresse anzugeben, ist `Address%ScopeId`.</span><span class="sxs-lookup"><span data-stu-id="67396-309">The notation that is used to specify the `ScopeId` with an address is `Address%ScopeId`.</span></span> <span data-ttu-id="67396-310">Beispiel: `FE80::5EFE:192.168.41.30%2.`</span><span class="sxs-lookup"><span data-stu-id="67396-310">For example, `FE80::5EFE:192.168.41.30%2.`</span></span>  
  
   
  
## Examples  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="67396-311"><see langword="AddressFamily" /> = <see langword="InterNetwork" />.</span><span class="sxs-lookup"><span data-stu-id="67396-311"><see langword="AddressFamily" /> = <see langword="InterNetwork" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="67396-312"><paramref name="scopeId" /> &lt; 0</span><span class="sxs-lookup"><span data-stu-id="67396-312"><paramref name="scopeId" /> &lt; 0</span></span> 
<span data-ttu-id="67396-313">- oder -</span><span class="sxs-lookup"><span data-stu-id="67396-313">-or-</span></span> <span data-ttu-id="67396-314">
-   <paramref name="scopeId" /> &gt; 0x00000000FFFFFFFF</span><span class="sxs-lookup"><span data-stu-id="67396-314">
-   <paramref name="scopeId" /> &gt; 0x00000000FFFFFFFF</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="iPAddress.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="67396-315">Konvertiert Internetadressen in die jeweilige Standardnotation.</span><span class="sxs-lookup"><span data-stu-id="67396-315">Converts an Internet address to its standard notation.</span></span></summary>
        <returns><span data-ttu-id="67396-316">Eine Zeichenfolge mit einer IP-Adresse im Punktformat für IPv4 oder im durch Doppelpunkt getrennten Hexadezimalformat für IPv6.</span><span class="sxs-lookup"><span data-stu-id="67396-316">A string that contains the IP address in either IPv4 dotted-quad or in IPv6 colon-hexadecimal notation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-317">Die <xref:System.Net.IPAddress.ToString%2A>-Methode konvertiert die in der <xref:System.Net.IPAddress.Address%2A>-Eigenschaft gespeicherte IP-Adresse entweder in eine IPv4-gepunktete Quad-oder IPv6-hexadezimal Notation.</span><span class="sxs-lookup"><span data-stu-id="67396-317">The <xref:System.Net.IPAddress.ToString%2A> method converts the IP address that is stored in the <xref:System.Net.IPAddress.Address%2A> property to either IPv4 dotted-quad or IPv6 colon-hexadecimal notation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="67396-318">Die Adressfamilie ist <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />, und die Adresse ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="67396-318">The address family is <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> and the address is bad.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryFormat(System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryFormat(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int -&gt; bool" Usage="iPAddress.TryFormat (destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.ReadOnlySpan{System.Char},System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As ReadOnlySpan(Of Char), ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IPAddress -&gt; bool" Usage="System.Net.IPAddress.TryParse (ipString, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="address" Type="System.Net.IPAddress" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.String,System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As String, ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * IPAddress -&gt; bool" Usage="System.Net.IPAddress.TryParse (ipString, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="address" Type="System.Net.IPAddress" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ipString"><span data-ttu-id="67396-319">Die zu überprüfende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-319">The string to validate.</span></span></param>
        <param name="address"><span data-ttu-id="67396-320">Die <see cref="T:System.Net.IPAddress" />-Version der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="67396-320">The <see cref="T:System.Net.IPAddress" /> version of the string.</span></span></param>
        <summary><span data-ttu-id="67396-321">Bestimmt, ob eine Zeichenfolge eine gültige IP-Adresse ist.</span><span class="sxs-lookup"><span data-stu-id="67396-321">Determines whether a string is a valid IP address.</span></span></summary>
        <returns><span data-ttu-id="67396-322"><see langword="true" />, wenn <paramref name="ipString" /> als IP-Adresse analysiert werden konnte, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="67396-322"><see langword="true" /> if <paramref name="ipString" /> was able to be parsed as an IP address; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="67396-323">Beachten Sie, dass diese Methode als gültiger ipString-Wert akzeptiert, der als <xref:System.Int64>analysiert werden kann. Anschließend wird diese Int64 als der lange Wert einer IP-Adresse in der Netzwerk-Byte Reihenfolge behandelt, ähnlich wie der <xref:System.Net.IPAddress.%23ctor%2A> Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="67396-323">Note that this method accepts as valid an ipString value that can be parsed as an <xref:System.Int64>, and then treats that Int64 as the long value of an IP address in network byte order, similar to the way that the <xref:System.Net.IPAddress.%23ctor%2A> constructor does.</span></span> <span data-ttu-id="67396-324">Dies bedeutet, dass diese Methode true zurückgibt, wenn das Int64-Element erfolgreich analysiert wird, selbst wenn es sich um eine Adresse handelt, die keine gültige IP-Adresse ist.</span><span class="sxs-lookup"><span data-stu-id="67396-324">This means that this method returns true if the Int64 is parsed successfully, even if it represents an address that's not a valid IP address.</span></span> <span data-ttu-id="67396-325">Wenn ipString z. b. "1" ist, gibt diese Methode "true" zurück, obwohl "1" (oder 0.0.0.1) keine gültige IP-Adresse ist und Sie möglicherweise davon ausgehen, dass diese Methode false zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="67396-325">For example, if ipString is "1", this method returns true even though "1" (or 0.0.0.1) is not a valid IP address and you might expect this method to return false.</span></span> <span data-ttu-id="67396-326">Wenn Sie diesen Fehler beheben, werden vorhandene apps nicht geändert, sodass das aktuelle Verhalten nicht geändert wird.</span><span class="sxs-lookup"><span data-stu-id="67396-326">Fixing this bug would break existing apps, so the current behavior will not be changed.</span></span> <span data-ttu-id="67396-327">Der Code kann dieses Verhalten vermeiden, indem er sicherstellt, dass er nur diese Methode verwendet, um IP-Adressen im gepunkteten Dezimal Format zu analysieren.</span><span class="sxs-lookup"><span data-stu-id="67396-327">Your code can avoid this behavior by ensuring that it only uses this method to parse IP addresses in dotted-decimal format.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="67396-328"><paramref name="ipString" /> ist NULL.</span><span class="sxs-lookup"><span data-stu-id="67396-328"><paramref name="ipString" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryWriteBytes(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteBytes(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; * int -&gt; bool" Usage="iPAddress.TryWriteBytes (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
