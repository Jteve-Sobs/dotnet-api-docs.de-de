<Type Name="IPAddress" FullName="System.Net.IPAddress">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a8d4566fdf7241b77758298a7113078d3c7fb358" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73338794" /></Metadata><TypeSignature Language="C#" Value="public class IPAddress" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit IPAddress extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.IPAddress" />
  <TypeSignature Language="VB.NET" Value="Public Class IPAddress" />
  <TypeSignature Language="C++ CLI" Value="public ref class IPAddress" />
  <TypeSignature Language="F#" Value="type IPAddress = class" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Primitives</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Internetprotokolladresse (IP) bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress>-Klasse enthält die Adresse eines Computers in einem IP-Netzwerk.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein Server abgefragt wird, um die Familien Adressen und die von ihm unterstützten IP-Adressen abzurufen.  
  
 [!code-cpp[System.Net.IPAddress#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#1)]
 [!code-csharp[System.Net.IPAddress#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#1)]
 [!code-vb[System.Net.IPAddress#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.IPAddress" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : byte[] -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="address">Der Bytearraywert der IP-Adresse.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.IPAddress" />-Klasse mit der Adresse, die als <see cref="T:System.Byte" />-Array angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress> wird erstellt, wobei die Eigenschaft <xref:System.Net.IPAddress.Address%2A> auf `address`festgelegt ist.  
  
 Wenn die Länge `address` 4 ist, erstellt <xref:System.Net.IPAddress.%23ctor%28System.Byte%5B%5D%29> eine IPv4-Adresse. Andernfalls wird eine IPv6-Adresse mit einem Bereich von 0 erstellt.  
  
 Es wird angenommen, dass das <xref:System.Byte> Array in der Netzwerk-Byte-Reihenfolge mit dem signifikantesten Byte First an der Indexposition 0 ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> enthält eine ungültige IP-Adresse.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (long newAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 newAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (newAddress As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(long newAddress);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress newAddress" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="newAddress" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="newAddress">Der Long-Wert der IP-Adresse. Der Wert 0x2414188f weist z. B. im Big-Endian-Format die IP-Adresse "143.24.20.36" auf.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.IPAddress" />-Klasse mit der Adresse, die als <see cref="T:System.Int64" /> angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress> Instanz wird erstellt, wobei die Eigenschaft <xref:System.Net.IPAddress.Address%2A> auf `newAddress`festgelegt ist.  
  
 Angenommen, der <xref:System.Int64> Wert ist in der Netzwerk-Byte Reihenfolge angegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newAddress" /> &lt; 0 oder 
 <paramref name="newAddress" /> &gt; 0x00000000FFFFFFFF</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : ReadOnlySpan&lt;byte&gt; -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (byte[] address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.Byte[],System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Byte(), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(cli::array &lt;System::Byte&gt; ^ address, long scopeid);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : byte[] * int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress (address, scopeid)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Byte[]" />
        <Parameter Name="scopeid" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">Der Bytearraywert der IP-Adresse.</param>
        <param name="scopeid">Der Long-Wert des Bezeichners für den Gültigkeitsbereich.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.IPAddress" />-Klasse mit der Adresse, die als <see cref="T:System.Byte" />-Array angegeben ist, und dem angegebenen Bezeichner für den Gültigkeitsbereich.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor instanziiert eine IPv6-Adresse. Der `scopeid` identifiziert eine Netzwerkschnittstelle im Fall einer Link-Local-Adresse. Der Gültigkeitsbereich ist nur für Link-Local-und Site-Local-Adressen gültig.  
  
 Es wird angenommen, dass das <xref:System.Byte> Array in der Netzwerk-Byte-Reihenfolge mit dem signifikantesten Byte First an der Indexposition 0 ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> enthält eine ungültige IP-Adresse.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="scopeid" /> &lt; 0 oder 
 <paramref name="scopeid" /> &gt; 0x00000000FFFFFFFF</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPAddress (ReadOnlySpan&lt;byte&gt; address, long scopeid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; address, int64 scopeid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.#ctor(System.ReadOnlySpan{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As ReadOnlySpan(Of Byte), scopeid As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPAddress(ReadOnlySpan&lt;System::Byte&gt; address, long scopeid);" />
      <MemberSignature Language="F#" Value="new System.Net.IPAddress : ReadOnlySpan&lt;byte&gt; * int64 -&gt; System.Net.IPAddress" Usage="new System.Net.IPAddress (address, scopeid)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="scopeid" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">To be added.</param>
        <param name="scopeid">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public long Address { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.Address" />
      <MemberSignature Language="VB.NET" Value="Public Property Address As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Address { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Address : int64 with get, set" Usage="System.Net.IPAddress.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("IPAddress.Address is address family dependant, use Equals method for comparison.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eine Internetprotokolladresse (IP-Adresse).</summary>
        <value>Der Long-Wert der IP-Adresse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist veraltet. Verwenden Sie <xref:System.Net.IPAddress.GetAddressBytes%2A>.  
  
 Verwenden Sie die <xref:System.Net.IPAddress.ToString%2A>-Methode, um <xref:System.Net.IPAddress.Address%2A> in eine punktierte Quad-Notation zu konvertieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Die Adressfamilie ist <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.IPAddress.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Adressfamilie der IP-Adresse ab.</summary>
        <value>Gibt <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> für IPv4 oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> für IPv6 zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Weitere Informationen finden Sie im Beispiel im Thema <xref:System.Net.IPAddress>-Klasse.  
  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Any : System.Net.IPAddress" Usage="System.Net.IPAddress.Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt eine IP-Adresse bereit, die angibt, dass der Server die Clientaktivität an allen Netzwerkschnittstellen überwachen soll. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType>-Methode verwendet das <xref:System.Net.IPAddress.Any> Feld, um anzugeben, dass eine <xref:System.Net.Sockets.Socket> Instanz auf allen Netzwerkschnittstellen auf Client Aktivitäten lauschen muss.  
  
 Das <xref:System.Net.IPAddress.Any> Feld entspricht 0.0.0.0 in der punktierte-Quad-Notation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Broadcast;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Broadcast" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Broadcast" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Broadcast As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Broadcast;" />
      <MemberSignature Language="F#" Value=" staticval mutable Broadcast : System.Net.IPAddress" Usage="System.Net.IPAddress.Broadcast" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt die IP-Übertragungsadresse bereit. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Net.IPAddress.Broadcast> Feld entspricht 255.255.255.255 in der punktierte-Quad-Notation.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Net.IPAddress.Broadcast> Adresse in der Konsole gedruckt.  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#2)]
 [!code-csharp[IPAddress_Broadcast_Loopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#2)]
 [!code-vb[IPAddress_Broadcast_Loopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="iPAddress.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">Eine <see cref="T:System.Net.IPAddress" />-Instanz, die mit der aktuellen Instanz verglichen werden soll.</param>
        <summary>Vergleicht zwei IP-Adressen.</summary>
        <returns><see langword="true" />, wenn die zwei Adressen gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress.Equals%2A>-Methode vergleicht die aktuelle <xref:System.Net.IPAddress> Instanz mit dem `comparand`-Parameter und gibt `true` zurück, wenn die beiden Instanzen dieselbe IP-Adresse enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAddressBytes">
      <MemberSignature Language="C#" Value="public byte[] GetAddressBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetAddressBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetAddressBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAddressBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetAddressBytes();" />
      <MemberSignature Language="F#" Value="member this.GetAddressBytes : unit -&gt; byte[]" Usage="iPAddress.GetAddressBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt eine Kopie der <see cref="T:System.Net.IPAddress" /> als Bytearray zur Verfügung.</summary>
        <returns>Ein <see cref="T:System.Byte" />-Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie eine Server-IP-Adresse im Byte-Format erhalten.  
  
 [!code-cpp[System.Net.IPAddress#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#2)]
 [!code-csharp[System.Net.IPAddress#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#2)]
 [!code-vb[System.Net.IPAddress#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="iPAddress.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashwert für eine IP-Adresse zurück.</summary>
        <returns>Ein ganzzahliger Hashwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress.GetHashCode%2A>-Methode gibt einen Hashcode der IP-Adresse zurück. Dieser Wert kann als Schlüssel in Hash Tabellen verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HostToNetworkOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert einen Wert aus der Host-Bytereihenfolge in die Netzwerk-Bytereihenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static short HostToNetworkOrder (short host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 HostToNetworkOrder(int16 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short HostToNetworkOrder(short host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int16 -&gt; int16" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="host">Die zu konvertierende Zahl in Host-Bytereihenfolge.</param>
        <summary>Konvertiert einen kurzen Wert vom Typ Short aus der Host-Bytereihenfolge in die Netzwerk-Bytereihenfolge.</summary>
        <returns>Ein Wert vom Typ Short, der in der Netzwerk-Bytereihenfolge ausgedrückt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für verschiedene Computer werden unterschiedliche Konventionen für die Reihenfolge der Bytes in ganzzahligen multibytewerten verwendet Einige Computer platzieren zuerst das signifikanteste Byte (als Big-Endian-Reihenfolge bezeichnet), und andere haben zuerst das am wenigsten signifikante Byte (als Little-Endian-Reihenfolge bezeichnet). Wenn Sie mit Computern arbeiten möchten, die unterschiedliche Byte Reihen sortieren, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden, in der Netzwerk-Byte-Reihenfolge gesendet, die zuerst das wichtigste Byte aufweist  
  
 Die <xref:System.Net.IPAddress.HostToNetworkOrder%2A>-Methode konvertiert Multibytezeichen-ganzzahlige Werte, die auf dem Host System gespeichert sind, von der Byte Reihenfolge, die vom Host verwendet wird, in die vom Netzwerk verwendete Bytefolge.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static int HostToNetworkOrder (int host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 HostToNetworkOrder(int32 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int HostToNetworkOrder(int host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int -&gt; int" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">Die zu konvertierende Zahl in Host-Bytereihenfolge.</param>
        <summary>Konvertiert einen ganzzahligen Wert aus der Host-Bytereihenfolge in die Netzwerk-Bytereihenfolge.</summary>
        <returns>Ein ganzzahliger Wert, der in der Netzwerk-Bytereihenfolge ausgedrückt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für verschiedene Computer werden unterschiedliche Konventionen für die Reihenfolge der Bytes in ganzzahligen multibytewerten verwendet Einige Computer platzieren zuerst das signifikanteste Byte (als Big-Endian-Reihenfolge bezeichnet), und andere haben zuerst das am wenigsten signifikante Byte (als Little-Endian-Reihenfolge bezeichnet). Wenn Sie mit Computern arbeiten möchten, die unterschiedliche Byte Reihen sortieren, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden, in der Netzwerk-Byte-Reihenfolge gesendet, die zuerst das wichtigste Byte aufweist  
  
 Die <xref:System.Net.IPAddress.HostToNetworkOrder%2A>-Methode konvertiert Multibytezeichen-ganzzahlige Werte, die auf dem Host System gespeichert sind, von der Byte Reihenfolge, die vom Host verwendet wird, in die vom Netzwerk verwendete Bytefolge.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="HostToNetworkOrder">
      <MemberSignature Language="C#" Value="public static long HostToNetworkOrder (long host);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 HostToNetworkOrder(int64 host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HostToNetworkOrder (host As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long HostToNetworkOrder(long host);" />
      <MemberSignature Language="F#" Value="static member HostToNetworkOrder : int64 -&gt; int64" Usage="System.Net.IPAddress.HostToNetworkOrder host" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="host">Die zu konvertierende Zahl in Host-Bytereihenfolge.</param>
        <summary>Konvertiert einen Wert vom Typ Long aus der Host-Bytereihenfolge in die Netzwerk-Bytereihenfolge.</summary>
        <returns>Ein Wert vom Typ Long, der in Netzwerk-Bytereihenfolge ausgedrückt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für verschiedene Computer werden unterschiedliche Konventionen für die Reihenfolge der Bytes in ganzzahligen multibytewerten verwendet Einige Computer platzieren zuerst das signifikanteste Byte (als Big-Endian-Reihenfolge bezeichnet), und andere haben zuerst das am wenigsten signifikante Byte (als Little-Endian-Reihenfolge bezeichnet). Wenn Sie mit Computern arbeiten möchten, die unterschiedliche Byte Reihen sortieren, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden, in der Netzwerk-Byte-Reihenfolge gesendet, die zuerst das wichtigste Byte aufweist  
  
 Die <xref:System.Net.IPAddress.HostToNetworkOrder%2A>-Methode konvertiert Multibytezeichen-ganzzahlige Werte, die auf dem Host System gespeichert sind, von der Byte Reihenfolge, die vom Host verwendet wird, in die vom Netzwerk verwendete Bytefolge.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="IPv6Any">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Any" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Any As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6Any : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Die <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />-Methode gibt über das <see cref="F:System.Net.IPAddress.IPv6Any" />-Feld an, dass ein <see cref="T:System.Net.Sockets.Socket" /> die Clientaktivität an allen Netzwerkschnittstellen überwachen muss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Net.IPAddress.IPv6Any>-Feld entspricht 0:0:0:0:0:0:0:0 in der Doppelpunkt-hexadezimal Notation oder in der Compact-Notation::.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der Adresse des aktuellen Hosts im komprimierten Standardformat angezeigt.  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#2)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#2)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6Loopback;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6Loopback : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6Loopback" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt die IP-Loopback-Adresse bereit. Diese Eigenschaft ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Net.IPAddress.IPv6Loopback> Feld entspricht 0:0:0:0:0:0:0:1 in der Doppelpunkt-hexadezimal Notation oder in:: 1 in der Compact-Notation.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der Loopback Adresse des aktuellen Hosts im komprimierten Standardformat angezeigt.  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IPv6None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress IPv6None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress IPv6None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.IPv6None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IPv6None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ IPv6None;" />
      <MemberSignature Language="F#" Value=" staticval mutable IPv6None : System.Net.IPAddress" Usage="System.Net.IPAddress.IPv6None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt eine IP-Adresse bereit, die angibt, dass keine Netzwerkschnittstelle verwendet werden soll. Diese Eigenschaft ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType>-Methode verwendet das <xref:System.Net.IPAddress.IPv6None> Feld, um anzugeben, dass eine <xref:System.Net.Sockets.Socket> nicht auf Client Aktivitäten lauschen darf. Das <xref:System.Net.IPAddress.IPv6None>-Feld entspricht 0:0:0:0:0:0:0:0 in einer Doppelpunkt-hexadezimal Notation oder zu:: 0 in der Compact-Notation.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der Adresse None des aktuellen Hosts im komprimierten Standardformat angezeigt.  
  
 [!code-cpp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CPP/noneanyloopback.cpp#3)]
 [!code-csharp[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/CS/noneanyloopback.cs#3)]
 [!code-vb[System.Net.IPAddress.IPv6NoneAnyLoopback#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IPv6NoneAnyLoopback/VB/noneanyloopback.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv4MappedToIPv6">
      <MemberSignature Language="C#" Value="public bool IsIPv4MappedToIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv4MappedToIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv4MappedToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv4MappedToIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv4MappedToIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv4MappedToIPv6 : bool" Usage="System.Net.IPAddress.IsIPv4MappedToIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob die IP Adresse eine globale IPv4-zugeordnete IPv6 Adresse ist.</summary>
        <value>Gibt <see cref="T:System.Boolean" /> zurück.  
  
 <see langword="true" />, wenn die IP-Adresse eine IPv4-zugeordnete IPv6-Adresse ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dual-Stack-Sockets erfordern immer IPv6-Adressen. Die Möglichkeit der Interaktion mit einer IPv4-Adresse erfordert die Verwendung des IPv4-zugeordneten IPv6-Adress Formats. Alle IPv4-Adressen müssen im IPv4-zugeordneten IPv6-Adressformat dargestellt werden, das einer reinen IPv6-Anwendung die Kommunikation mit einem IPv4-Knoten ermöglicht. Das IPv4-zugeordnete IPv6-Adressformat ermöglicht die Darstellung der IPv4-Adresse eines IPv4-Knotens als IPv6-Adresse. Die IPv4-Adresse wird in die 32 Bits der IPv6-Adresse mit niedriger Reihenfolge codiert, und die höherwertigen 96 Bits enthalten das feste Präfix 0:0: 0:0: 0: FFFF. Das IPv4-zugeordnete IPv6-Adressformat wird in RFC 4291 angegeben. Weitere Informationen finden Sie unter [www.ietf.org/RFC/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6LinkLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6LinkLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6LinkLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6LinkLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6LinkLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6LinkLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6LinkLocal : bool" Usage="System.Net.IPAddress.IsIPv6LinkLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob die Adresse eine IPv6-Link-Local-Adresse ist.</summary>
        <value><see langword="true" />, wenn die IP-Adresse eine IPv6-Link-Local-Adresse ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Multicast">
      <MemberSignature Language="C#" Value="public bool IsIPv6Multicast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Multicast" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Multicast" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Multicast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Multicast { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6Multicast : bool" Usage="System.Net.IPAddress.IsIPv6Multicast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob die Adresse eine globale IPv6-Multicastadresse ist.</summary>
        <value><see langword="true" />, wenn die IP-Adresse eine globale IPv6-Multicastadresse ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6SiteLocal">
      <MemberSignature Language="C#" Value="public bool IsIPv6SiteLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6SiteLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6SiteLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6SiteLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6SiteLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6SiteLocal : bool" Usage="System.Net.IPAddress.IsIPv6SiteLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob die Adresse eine IPv6-Site-Local-Adresse ist.</summary>
        <value><see langword="true" />, wenn die IP-Adresse eine IPv6-Site-Local-Adresse ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIPv6Teredo">
      <MemberSignature Language="C#" Value="public bool IsIPv6Teredo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIPv6Teredo" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.IsIPv6Teredo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsIPv6Teredo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsIPv6Teredo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsIPv6Teredo : bool" Usage="System.Net.IPAddress.IsIPv6Teredo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Adresse eine IPv6-Teredo-Adresse ist.</summary>
        <value><see langword="true" />, wenn die IP-Adresse eine IPv6-Teredo-Adresse ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Teredo-Adresse ist eine IPv6-Adresse mit dem Präfix 2001::/32. Teredo-Adressen können über die normale DNS-Namensauflösung zurückgegeben oder als eine IPv6-Adresse aufgezählt werden, die einer lokalen Schnittstelle zugewiesen ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.BeginGetUnicastAddresses(System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.EndGetUnicastAddresses(System.IAsyncResult)" />
        <altmember cref="M:System.Net.NetworkInformation.IPGlobalProperties.GetUnicastAddresses" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public static bool IsLoopback (System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLoopback(class System.Net.IPAddress address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.IsLoopback(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLoopback (address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLoopback(System::Net::IPAddress ^ address);" />
      <MemberSignature Language="F#" Value="static member IsLoopback : System.Net.IPAddress -&gt; bool" Usage="System.Net.IPAddress.IsLoopback address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="address">Eine IP-Adresse.</param>
        <summary>Gibt an, ob es sich bei der angegebenen IP-Adresse um die Loopback-Adresse handelt.</summary>
        <returns><see langword="true" />, wenn <paramref name="address" /> die Loopback-Adresse ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress.IsLoopback%2A>-Methode vergleicht `address` mit <xref:System.Net.IPAddress.Loopback> und gibt `true` zurück, wenn die beiden IP-Adressen identisch sind.  
  
 Im Fall von IPv4 gibt die <xref:System.Net.IPAddress.IsLoopback%2A> Methode `true` für jede IP-Adresse in der Form 127. X. Y. Z zurück (wobei X, Y und Z im Bereich 0-255 liegen), nicht nur <xref:System.Net.IPAddress.Loopback> (127.0.0.1).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.IPAddress.IsLoopback%2A>-Methode verwendet, um zu bestimmen, ob die angegebene Adresse eine Loopback Adresse ist.  
  
 [!code-cpp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CPP/isloopback.cpp#1)]
 [!code-csharp[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/CS/isloopback.cs#1)]
 [!code-vb[System.Net.IPAddress.IsLoopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.IsLoopback/VB/isloopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loopback">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress Loopback;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress Loopback" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.Loopback" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Loopback As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ Loopback;" />
      <MemberSignature Language="F#" Value=" staticval mutable Loopback : System.Net.IPAddress" Usage="System.Net.IPAddress.Loopback" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt die IP-Loopback-Adresse bereit. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Net.IPAddress.Loopback> Feld entspricht 127.0.0.1 in der punktierte-Quad-Notation.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Net.IPAddress.Loopback> Adresse in der Konsole gedruckt.  
  
 [!code-cpp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CPP/ipaddress_broadcast_loopback.cpp#1)]
 [!code-csharp[IPAddress_Broadcast_Loopback#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/CS/ipaddress_broadcast_loopback.cs#1)]
 [!code-vb[IPAddress_Broadcast_Loopback#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_Broadcast_Loopback/VB/ipaddress_broadcast_loopback.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv4">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv4 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv4() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv4 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv4();" />
      <MemberSignature Language="F#" Value="member this.MapToIPv4 : unit -&gt; System.Net.IPAddress" Usage="iPAddress.MapToIPv4 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ordnet das <see cref="T:System.Net.IPAddress" />-Objekt einer IPv4-Adresse zu.</summary>
        <returns>Gibt <see cref="T:System.Net.IPAddress" /> zurück.  
  
Eine IPv4-Adresse.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dual-Stack-Sockets erfordern immer IPv6-Adressen. Die Möglichkeit der Interaktion mit einer IPv4-Adresse erfordert die Verwendung des IPv4-zugeordneten IPv6-Adress Formats. Alle IPv4-Adressen müssen im IPv4-zugeordneten IPv6-Adressformat dargestellt werden, das einer reinen IPv6-Anwendung die Kommunikation mit einem IPv4-Knoten ermöglicht. Das IPv4-zugeordnete IPv6-Adressformat ermöglicht die Darstellung der IPv4-Adresse eines IPv4-Knotens als IPv6-Adresse. Die IPv4-Adresse wird in die 32 Bits der IPv6-Adresse mit niedriger Reihenfolge codiert, und die höherwertigen 96 Bits enthalten das feste Präfix 0:0: 0:0: 0: FFFF. Das IPv4-zugeordnete IPv6-Adressformat wird in RFC 4291 angegeben. Weitere Informationen finden Sie unter [www.ietf.org/RFC/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231).  
  
 Wenn Sie <xref:System.Net.IPAddress.MapToIPv4%2A> verwenden möchten, um eine IPv4-Adresse aus dem IPv6-Format in das IPv4-Format zu konvertieren, müssen Sie zunächst sicherstellen, dass Sie über eine IPv4-Adresse verfügen. Ruft <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A>auf, die `true` zurückgibt, wenn die IP-Adresse ursprünglich als IPv6 geschriebene IPv4-oder andernfalls `false`. Wenn <xref:System.Net.IPAddress.IsIPv4MappedToIPv6%2A> `true`zurückgibt, verwenden Sie <xref:System.Net.IPAddress.MapToIPv4%2A>, um die Konvertierung durchführen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapToIPv6">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress MapToIPv6 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.IPAddress MapToIPv6() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.MapToIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Function MapToIPv6 () As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::IPAddress ^ MapToIPv6();" />
      <MemberSignature Language="F#" Value="member this.MapToIPv6 : unit -&gt; System.Net.IPAddress" Usage="iPAddress.MapToIPv6 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ordnet das <see cref="T:System.Net.IPAddress" />-Objekt einer IPv6-Adresse zu.</summary>
        <returns>Gibt <see cref="T:System.Net.IPAddress" /> zurück.  
  
Eine IPv6-Adresse.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dual-Stack-Sockets erfordern immer IPv6-Adressen. Die Möglichkeit der Interaktion mit einer IPv4-Adresse erfordert die Verwendung des IPv4-zugeordneten IPv6-Adress Formats. Alle IPv4-Adressen müssen im IPv4-zugeordneten IPv6-Adressformat dargestellt werden, das einer reinen IPv6-Anwendung die Kommunikation mit einem IPv4-Knoten ermöglicht. Das IPv4-zugeordnete IPv6-Adressformat ermöglicht die Darstellung der IPv4-Adresse eines IPv4-Knotens als IPv6-Adresse. Die IPv4-Adresse wird in die 32 Bits der IPv6-Adresse mit niedriger Reihenfolge codiert, und die höherwertigen 96 Bits enthalten das feste Präfix 0:0: 0:0: 0: FFFF. Das IPv4-zugeordnete IPv6-Adressformat wird in RFC 4291 angegeben. Weitere Informationen finden Sie unter [www.ietf.org/RFC/rfc4291.txt](https://go.microsoft.com/fwlink/?LinkID=92231).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="NetworkToHostOrder">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert eine Zahl aus der Netzwerk-Bytereihenfolge in die Host-Bytereihenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static short NetworkToHostOrder (short network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 NetworkToHostOrder(int16 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short NetworkToHostOrder(short network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int16 -&gt; int16" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="network">Die zu konvertierende Zahl in der Netzwerk-Bytereihenfolge.</param>
        <summary>Konvertiert einen Wert vom Typ Short aus der Netzwerk-Bytereihenfolge in die Host-Bytereihenfolge.</summary>
        <returns>Ein Wert vom Typ Short, der in der Host-Bytereihenfolge ausgedrückt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für verschiedene Computer werden unterschiedliche Konventionen für die Reihenfolge der Bytes in ganzzahligen multibytewerten verwendet Einige Computer platzieren zuerst das signifikanteste Byte (als Big-Endian-Reihenfolge bezeichnet), und andere haben zuerst das am wenigsten signifikante Byte (als Little-Endian-Reihenfolge bezeichnet). Wenn Sie mit Computern arbeiten möchten, die unterschiedliche Byte Reihen sortieren, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden, in der Netzwerk-Byte-Reihenfolge gesendet, die zuerst das wichtigste Byte aufweist  
  
 Die <xref:System.Net.IPAddress.NetworkToHostOrder%2A>-Methode konvertiert Multibytezeichen-ganzzahlige Werte, die auf dem Host System gespeichert sind, von der Byte Reihenfolge, die vom Netzwerk in der vom Host verwendeten Byte Reihenfolge verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Net.IPAddress.NetworkToHostOrder%2A>-Methode zum Konvertieren eines kurzen Werts von der Netzwerk-Byte-Reihenfolge in die Host-Byte Reihenfolge  
  
 [!code-cpp[IPAddress_NetworkToHost#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#1)]
 [!code-csharp[IPAddress_NetworkToHost#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#1)]
 [!code-vb[IPAddress_NetworkToHost#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static int NetworkToHostOrder (int network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NetworkToHostOrder(int32 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NetworkToHostOrder(int network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int -&gt; int" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="network">Die zu konvertierende Zahl in der Netzwerk-Bytereihenfolge.</param>
        <summary>Konvertiert einen ganzzahligen Wert aus der Netzwerk-Bytereihenfolge in die Host-Bytereihenfolge.</summary>
        <returns>Ein ganzzahliger Wert, der in der Host-Bytereihenfolge ausgedrückt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für verschiedene Computer werden unterschiedliche Konventionen für die Reihenfolge der Bytes in ganzzahligen multibytewerten verwendet Einige Computer platzieren zuerst das signifikanteste Byte (als Big-Endian-Reihenfolge bezeichnet), und andere haben zuerst das am wenigsten signifikante Byte (als Little-Endian-Reihenfolge bezeichnet). Wenn Sie mit Computern arbeiten möchten, die unterschiedliche Byte Reihen sortieren, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden, in der Netzwerk-Byte-Reihenfolge gesendet, die zuerst das wichtigste Byte aufweist  
  
 Die <xref:System.Net.IPAddress.NetworkToHostOrder%2A>-Methode konvertiert Multibytezeichen-ganzzahlige Werte, die auf dem Host System gespeichert sind, von der Byte Reihenfolge, die vom Netzwerk in der vom Host verwendeten Byte Reihenfolge verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Net.IPAddress.NetworkToHostOrder%2A>-Methode verwendet, um einen ganzzahligen Wert von der Netzwerk-Byte-Reihenfolge in die Host-Byte  
  
 [!code-cpp[IPAddress_NetworkToHost#2](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#2)]
 [!code-csharp[IPAddress_NetworkToHost#2](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#2)]
 [!code-vb[IPAddress_NetworkToHost#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="NetworkToHostOrder">
      <MemberSignature Language="C#" Value="public static long NetworkToHostOrder (long network);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 NetworkToHostOrder(int64 network) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.NetworkToHostOrder(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NetworkToHostOrder (network As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long NetworkToHostOrder(long network);" />
      <MemberSignature Language="F#" Value="static member NetworkToHostOrder : int64 -&gt; int64" Usage="System.Net.IPAddress.NetworkToHostOrder network" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="network" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="network">Die zu konvertierende Zahl in der Netzwerk-Bytereihenfolge.</param>
        <summary>Konvertiert einen Wert vom Typ Long aus der Netzwerk-Bytereihenfolge in die Host-Bytereihenfolge.</summary>
        <returns>Ein Wert vom Typ Long, der in der Host-Bytereihenfolge ausgedrückt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für verschiedene Computer werden unterschiedliche Konventionen für die Reihenfolge der Bytes in ganzzahligen multibytewerten verwendet Einige Computer platzieren zuerst das signifikanteste Byte (als Big-Endian-Reihenfolge bezeichnet), und andere haben zuerst das am wenigsten signifikante Byte (als Little-Endian-Reihenfolge bezeichnet). Wenn Sie mit Computern arbeiten möchten, die unterschiedliche Byte Reihen sortieren, werden alle ganzzahligen Werte, die über das Netzwerk gesendet werden, in der Netzwerk-Byte-Reihenfolge gesendet, die zuerst das wichtigste Byte aufweist  
  
 Die <xref:System.Net.IPAddress.NetworkToHostOrder%2A>-Methode konvertiert Multibytezeichen-ganzzahlige Werte, die auf dem Host System gespeichert sind, von der Byte Reihenfolge, die vom Netzwerk in der vom Host verwendeten Byte Reihenfolge verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die-<xref:System.Net.IPAddress.NetworkToHostOrder%2A>-Methode verwendet, um einen Long-Wert von der Netzwerk-Byte-Reihenfolge in die Host-Byte  
  
 [!code-cpp[IPAddress_NetworkToHost#3](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CPP/ipaddress_networktohost.cpp#3)]
 [!code-csharp[IPAddress_NetworkToHost#3](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_NetworkToHost/CS/ipaddress_networktohost.cs#3)]
 [!code-vb[IPAddress_NetworkToHost#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_NetworkToHost/VB/ipaddress_networktohost.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.IPAddress.HostToNetworkOrder(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static readonly System.Net.IPAddress None;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Net.IPAddress None" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPAddress.None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly None As IPAddress " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Net::IPAddress ^ None;" />
      <MemberSignature Language="F#" Value=" staticval mutable None : System.Net.IPAddress" Usage="System.Net.IPAddress.None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt eine IP-Adresse bereit, die angibt, dass keine Netzwerkschnittstelle verwendet werden soll. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Bind%2A?displayProperty=nameWithType>-Methode verwendet das <xref:System.Net.IPAddress.None> Feld, um anzugeben, dass eine <xref:System.Net.Sockets.Socket> nicht auf Client Aktivitäten lauschen darf. Das <xref:System.Net.IPAddress.None> Feld entspricht 255.255.255.255 in der punktierte-Quad-Notation.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Net.IPAddress.None>-Eigenschaft verwendet, um anzugeben, dass keine Netzwerkschnittstelle verwendet werden soll.  
  
 [!code-cpp[IPAddress_None#1](~/samples/snippets/cpp/VS_Snippets_Remoting/IPAddress_None/CPP/ipaddress_none.cpp#1)]
 [!code-csharp[IPAddress_None#1](~/samples/snippets/csharp/VS_Snippets_Remoting/IPAddress_None/CS/ipaddress_none.cs#1)]
 [!code-vb[IPAddress_None#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPAddress_None/VB/ipaddress_none.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As ReadOnlySpan(Of Char)) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(ReadOnlySpan&lt;char&gt; ipString);" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; -&gt; System.Net.IPAddress" Usage="System.Net.IPAddress.Parse ipString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPAddress Parse (string ipString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPAddress Parse(string ipString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (ipString As String) As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPAddress ^ Parse(System::String ^ ipString);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Net.IPAddress" Usage="System.Net.IPAddress.Parse ipString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ipString">Eine Zeichenfolge, die eine IP-Adresse im Punktformat (Dotted Quad-Notation) für IPv4 und im durch Doppelpunkt getrennten Hexadezimalformat für IPv6 enthält.</param>
        <summary>Konvertiert eine IP-Adresszeichenfolge in eine <see cref="T:System.Net.IPAddress" />-Instanz.</summary>
        <returns>Eine <see cref="T:System.Net.IPAddress" />-Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statische <xref:System.Net.IPAddress.Parse%2A>-Methode erstellt eine <xref:System.Net.IPAddress> Instanz aus einer IP-Adresse, die in der punktierte Quad-Notation für IPv4 und in der Doppelpunkt-hexadezimal Notation für IPv6 ausgedrückt wird.  
  
 Die Anzahl der Teile (die jeweils durch einen bestimmten Teil getrennt sind) in `ipString` bestimmt, wie die IP-Adresse erstellt wird. Eine einteilige Adresse wird direkt in der Netzwerkadresse gespeichert. Eine zweiteilige Adresse, die für die Angabe einer Klasse eine Adresse geeignet ist, platziert den führenden Teil im ersten Byte und den nachfolgenden Teil in den rechten drei Bytes der Netzwerkadresse. Eine dreiteilige Adresse, die für die Angabe einer Class B-Adresse geeignet ist, legt den ersten Teil im ersten Byte, den zweiten Teil des zweiten Bytes und den letzten Teil in den rechten 2 Bytes der Netzwerkadresse ab. Beispiel:  
  
|Anzahl von Teilen und Beispiel `ipString`|IPv4-Adresse für IPAddress|  
|--------------------------------------------|--------------------------------|  
|1--"65535"|0.0.255.255|  
|2 -- "20.2"|20.0.0.2|  
|2 -- "20.65535"|20.0.255.255|  
|3 -- "128.1.2"|128.1.0.2|  
  
   
  
## Examples  
 Der folgende Code konvertiert eine Zeichenfolge, die eine IP-Adresse enthält, in punktierte Quad-Notation für IPv4 oder in Doppelpunkt-hexadezimal Notation für IPv6 in eine Instanz der <xref:System.Net.IPAddress>-Klasse. Anschließend wird die überladene <xref:System.Net.IPAddress.ToString%2A>-Methode verwendet, um die Adresse in der Standardnotation anzuzeigen.  
  
 [!code-cpp[System.Net.IPAddress.Parse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CPP/parse.cpp#1)]
 [!code-csharp[System.Net.IPAddress.Parse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress.Parse/CS/parse.cs#1)]
 [!code-vb[System.Net.IPAddress.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress.Parse/VB/parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="ipString" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="ipString" /> ist keine gültige IP-Adresse.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeId">
      <MemberSignature Language="C#" Value="public long ScopeId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ScopeId" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPAddress.ScopeId" />
      <MemberSignature Language="VB.NET" Value="Public Property ScopeId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ScopeId { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ScopeId : int64 with get, set" Usage="System.Net.IPAddress.ScopeId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Bezeichner für den Gültigkeitsbereich der IPv6-Adresse ab oder legt diesen fest.</summary>
        <value>Ein lange ganze Zahl, die den Gültigkeitsbereich der Adresse angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Bedeutung <xref:System.Net.IPAddress.ScopeId%2A> ändert sich abhängig vom Kontext, in dem Sie verwendet wird.  
  
-   Link-Local-Adresse. Auf einem Host mit mehreren Schnittstellen, die mit separaten Verknüpfungen verbunden sind, kann dieselbe Verbindungs lokale Adresse mehreren Schnittstellen zugewiesen werden. Um diese Mehrdeutigkeit auszuschließen, wird ein Bereichs Bezeichner verwendet, um die Schnittstelle anzugeben, über die Nachrichten ausgetauscht werden.  
  
> [!NOTE]
>  Link-Local-Adressen, die durch das Format Präfix (FP) FE80 identifiziert werden, werden von Knoten bei der Kommunikation mit benachbarten Knoten über denselben Link verwendet.  
  
-   Site-Local-Adressen. Ein Host kann mit mehreren Standorten verbunden werden. In diesem Fall wird ein Bereichs Bezeichner verwendet, um einen bestimmten Standort anzugeben, mit dem kommuniziert werden soll.  
  
> [!NOTE]
>  Standort lokale Adressen, die durch das Format Präfix (FP) FEC0 identifiziert werden, werden von Knoten bei der Kommunikation über private Intranets verwendet.  
  
 Die Notation, die verwendet wird, um den `ScopeId` mit einer Adresse anzugeben, ist `Address%ScopeId`. Beispiel: `FE80::5EFE:192.168.41.30%2.`  
  
   
  
## Examples  
 [!code-cpp[System.Net.IPAddress#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPAddress/CPP/ipaddress.cpp#3)]
 [!code-csharp[System.Net.IPAddress#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPAddress/CS/ipaddress.cs#3)]
 [!code-vb[System.Net.IPAddress#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPAddress/VB/ipaddress.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><see langword="AddressFamily" /> = <see langword="InterNetwork" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="scopeId" /> &lt; 0 
- oder - 
-   <paramref name="scopeId" /> &gt; 0x00000000FFFFFFFF</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="iPAddress.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert Internetadressen in die jeweilige Standardnotation.</summary>
        <returns>Eine Zeichenfolge mit einer IP-Adresse im Punktformat für IPv4 oder im durch Doppelpunkt getrennten Hexadezimalformat für IPv6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.IPAddress.ToString%2A>-Methode konvertiert die in der <xref:System.Net.IPAddress.Address%2A>-Eigenschaft gespeicherte IP-Adresse entweder in eine IPv4-gepunktete Quad-oder IPv6-hexadezimal Notation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Die Adressfamilie ist <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />, und die Adresse ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryFormat(System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryFormat(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int -&gt; bool" Usage="iPAddress.TryFormat (destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.ReadOnlySpan{System.Char},System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As ReadOnlySpan(Of Char), ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IPAddress -&gt; bool" Usage="System.Net.IPAddress.TryParse (ipString, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="address" Type="System.Net.IPAddress" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ipString">To be added.</param>
        <param name="address">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string ipString, out System.Net.IPAddress address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string ipString, [out] class System.Net.IPAddress&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryParse(System.String,System.Net.IPAddress@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (ipString As String, ByRef address As IPAddress) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ ipString, [Runtime::InteropServices::Out] System::Net::IPAddress ^ % address);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * IPAddress -&gt; bool" Usage="System.Net.IPAddress.TryParse (ipString, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipString" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="address" Type="System.Net.IPAddress" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ipString">Die zu überprüfende Zeichenfolge.</param>
        <param name="address">Die <see cref="T:System.Net.IPAddress" />-Version der Zeichenfolge.</param>
        <summary>Bestimmt, ob eine Zeichenfolge eine gültige IP-Adresse ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="ipString" /> als IP-Adresse analysiert werden konnte, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass diese Methode als gültiger ipString-Wert akzeptiert, der als <xref:System.Int64>analysiert werden kann. Anschließend wird diese Int64 als der lange Wert einer IP-Adresse in der Netzwerk-Byte Reihenfolge behandelt, ähnlich wie der <xref:System.Net.IPAddress.%23ctor%2A> Konstruktor. Dies bedeutet, dass diese Methode true zurückgibt, wenn das Int64-Element erfolgreich analysiert wird, selbst wenn es sich um eine Adresse handelt, die keine gültige IP-Adresse ist. Wenn ipString z. b. "1" ist, gibt diese Methode "true" zurück, obwohl "1" (oder 0.0.0.1) keine gültige IP-Adresse ist und Sie möglicherweise davon ausgehen, dass diese Methode false zurückgibt. Wenn Sie diesen Fehler beheben, werden vorhandene apps nicht geändert, sodass das aktuelle Verhalten nicht geändert wird. Der Code kann dieses Verhalten vermeiden, indem er sicherstellt, dass er nur diese Methode verwendet, um IP-Adressen im gepunkteten Dezimal Format zu analysieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="ipString" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPAddress.TryWriteBytes(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteBytes(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; * int -&gt; bool" Usage="iPAddress.TryWriteBytes (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
