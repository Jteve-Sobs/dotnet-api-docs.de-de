<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1b999ae370e27e86e6eb181f06a3653d09bab94e" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75109337" /></Metadata><TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.FriendAccessAllowed</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine HTTP-spezifische Implementierung der <see cref="T:System.Net.WebRequest" />-Klasse bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
>  Es wird nicht empfohlen, `HttpWebRequest` für die neue Entwicklung zu verwenden. Verwenden Sie stattdessen die <xref:System.Net.Http.HttpClient?displayProperty=nameWithType>-Klasse.

 Die <xref:System.Net.HttpWebRequest>-Klasse bietet Unterstützung für die Eigenschaften und Methoden, die in <xref:System.Net.WebRequest> definiert sind, sowie für zusätzliche Eigenschaften und Methoden, die dem Benutzer die direkte Interaktion mit Servern mithilfe von http ermöglichen.  
  
 Verwenden Sie nicht die <xref:System.Net.HttpWebRequest.%23ctor%2A> Konstruktor. Verwenden Sie die <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>-Methode, um neue <xref:System.Net.HttpWebRequest> Objekte zu initialisieren. Wenn das Schema für den Uniform Resource Identifier (URI) `http://` oder `https://`ist, gibt <xref:System.Net.WebRequest.Create%2A> ein <xref:System.Net.HttpWebRequest> Objekt zurück.  
  
 Die <xref:System.Net.HttpWebRequest.GetResponse%2A>-Methode sendet eine synchrone Anforderung an die Ressource, die in der <xref:System.Net.HttpWebRequest.RequestUri%2A>-Eigenschaft angegeben ist, und gibt eine <xref:System.Net.HttpWebResponse> zurück, die das Antwortobjekt enthält. Die Antwortdaten können mithilfe des von <xref:System.Net.HttpWebResponse.GetResponseStream%2A>zurückgegebenen Streams empfangen werden. Wenn das Antwortobjekt oder der Antwortstream geschlossen ist, werden die restlichen Daten verfällt. Die restlichen Daten werden entladen, und der Socket wird für nachfolgende Anforderungen wieder verwendet, wenn das Antwortobjekt oder der Stream geschlossen wird, wenn die folgenden Bedingungen erfüllt sind: Es handelt sich um eine Keep-Alive-oder Pipeline-Anforderung, nur eine kleine Menge an Daten, die empfangen werden muss, oder die die verbleibenden Daten werden in einem kurzen Zeitintervall empfangen. Wenn keine der genannten Bedingungen den Wert hat oder die Ausgleichs Zeit überschritten wird, wird der Socket geschlossen. Für Keep-Alive-oder pipeld-Verbindungen wird dringend empfohlen, dass die Anwendung die Datenströme bis EOF liest. Dadurch wird sichergestellt, dass der Socket für nachfolgende Anforderungen wieder verwendet wird, was zu einer besseren Leistung und weniger Ressourcen verwendet wird.  
  
 Wenn Sie Daten an die Ressource senden möchten, gibt die <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-Methode ein <xref:System.IO.Stream>-Objekt zurück, das zum Senden von Daten verwendet werden soll. Die Methoden <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> und <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> bieten asynchronen Zugriff auf den Datenstream senden.  
  
 Bei der Client Authentifizierung mit <xref:System.Net.HttpWebRequest>muss das Client Zertifikat im My-Zertifikat Speicher des aktuellen Benutzers installiert werden.  
  
 Die <xref:System.Net.HttpWebRequest>-Klasse löst eine <xref:System.Net.WebException> aus, wenn beim Zugriff auf eine Ressource Fehler auftreten. Die <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType>-Eigenschaft enthält einen <xref:System.Net.WebExceptionStatus> Wert, der die Fehlerquelle angibt. Wenn <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>ist, enthält die Eigenschaft <xref:System.Net.WebException.Response%2A> die von der Ressource empfangenen <xref:System.Net.HttpWebResponse>.  
  
 <xref:System.Net.HttpWebRequest> macht allgemeine HTTP-Header Werte verfügbar, die als Eigenschaften an die Internet Ressource gesendet, durch Methoden festgelegt oder vom System festgelegt werden. die folgende Tabelle enthält eine komplette Liste. Sie können andere Header in der <xref:System.Net.HttpWebRequest.Headers%2A>-Eigenschaft als Name-Wert-Paare festlegen. Beachten Sie, dass sich Server und Caches während der Anforderung möglicherweise ändern oder hinzufügen.  
  
 In der folgenden Tabelle werden die HTTP-Header aufgelistet, die entweder durch Eigenschaften oder Methoden oder das System festgelegt werden.  
  
|Header|Festgelegt von|  
|------------|------------|  
|Accept|Wird von der <xref:System.Net.HttpWebRequest.Accept%2A>-Eigenschaft festgelegt.|  
|Verbindung|Wird von der <xref:System.Net.HttpWebRequest.Connection%2A>-Eigenschaft <xref:System.Net.HttpWebRequest.KeepAlive%2A>-Eigenschaft festgelegt.|  
|Inhalts Länge|Wird von der <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft festgelegt.|  
|Inhaltstyp|Wird von der <xref:System.Net.HttpWebRequest.ContentType%2A>-Eigenschaft festgelegt.|  
|Expect|Wird von der <xref:System.Net.HttpWebRequest.Expect%2A>-Eigenschaft festgelegt.|  
|Datum|Wird vom System auf das aktuelle Datum festgelegt.|  
|Host|Wird vom System auf aktuelle Hostinformationen festgelegt.|  
|If-Modified-Since|Wird von der <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>-Eigenschaft festgelegt.|  
|Bereich|Wird durch die <xref:System.Net.HttpWebRequest.AddRange%2A>-Methode festgelegt.|  
|Referer|Wird von der <xref:System.Net.HttpWebRequest.Referer%2A>-Eigenschaft festgelegt.|  
|Übertragungs Codierung|Wird von der <xref:System.Net.HttpWebRequest.TransferEncoding%2A>-Eigenschaft festgelegt (die <xref:System.Net.HttpWebRequest.SendChunked%2A>-Eigenschaft muss `true`sein).|  
|User-Agent|Wird von der <xref:System.Net.HttpWebRequest.UserAgent%2A>-Eigenschaft festgelegt.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> wird automatisch registriert. Sie müssen die <xref:System.Net.WebRequest.RegisterPrefix%2A>-Methode nicht aufzurufen, um <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> zu registrieren, bevor Sie URIs verwenden, die mit `http://` oder `https://`beginnen.  
  
 Der lokale Computer oder die Anwendungs Konfigurationsdatei kann angeben, dass ein Standard Proxy verwendet werden soll. Wenn die <xref:System.Net.HttpWebRequest.Proxy%2A>-Eigenschaft angegeben ist, überschreiben die Proxy Einstellungen der <xref:System.Net.HttpWebRequest.Proxy%2A>-Eigenschaft den lokalen Computer bzw. die Anwendungs Konfigurationsdatei, und die <xref:System.Net.HttpWebRequest> Instanz verwendet die angegebenen Proxy Einstellungen. Wenn kein Proxy in einer Konfigurationsdatei angegeben ist und die <xref:System.Net.HttpWebRequest.Proxy%2A>-Eigenschaft nicht angegeben ist, verwendet die <xref:System.Net.HttpWebRequest>-Klasse die Proxy Einstellungen, die von Internet Explorer auf dem lokalen Computer geerbt wurden. Wenn in Internet Explorer keine Proxy Einstellungen vorhanden sind, wird die Anforderung direkt an den Server gesendet.  
  
 Die <xref:System.Net.HttpWebRequest>-Klasse analysiert eine Proxy Umgehungs Liste mit Platzhalter Zeichen, die von Internet Explorer anders geerbt werden, als die Umgehungs Liste direkt von Internet Explorer analysiert wird. Die <xref:System.Net.HttpWebRequest>-Klasse analysiert beispielsweise eine Umgehungs Liste von "NT *" aus Internet Explorer als regulären Ausdruck von "NT. $". Dies unterscheidet sich vom systemeigenen Verhalten von Internet Explorer. Eine URL vom Typ "`http://intxxxxx`" würde also den Proxy mit der <xref:System.Net.HttpWebRequest>-Klasse umgehen, den Proxy jedoch nicht mithilfe von Internet Explorer umgehen.  
  
> [!NOTE]
>  Das Framework speichert SSL-Sitzungen bei der Erstellung zwischen und versucht nach Möglichkeit, eine zwischengespeicherte Sitzung für eine neue Anforderung wiederzuverwenden. Beim Versuch, eine SSL-Sitzung wiederzuverwenden, verwendet das Framework das erste Element von <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (sofern vorhanden) oder versucht, anonyme Sitzungen wiederzuverwenden, wenn <xref:System.Net.HttpWebRequest.ClientCertificates%2A> leer ist.  
  
> [!NOTE]
>  Aus Sicherheitsgründen sind Cookies standardmäßig deaktiviert. Wenn Sie Cookies verwenden möchten, verwenden Sie die <xref:System.Net.HttpWebRequest.CookieContainer%2A>-Eigenschaft, um Cookies zu aktivieren.  
  
 Der .NET Framework 4,6 umfasst ein neues Sicherheits Feature, das unsichere Verschlüsselungs-und Hash Algorithmen für Verbindungen blockiert. Anwendungen, die TLS/SSL über APIs wie z. b. HttpClient, HttpWebRequest, FtpClient, SmtpClient, SslStream usw. und das Ziel .NET Framework 4,6 verwenden, erhalten standardmäßig das sicherere Verhalten.  
  
 Entwickler möchten dieses Verhalten möglicherweise ablehnen, um die Interoperabilität mit Ihren vorhandenen SSL3 Services-oder TLS-/RC4-Diensten aufrechtzuerhalten. In [diesem Artikel](https://support.microsoft.com/kb/3069494) wird erläutert, wie Sie den Code so ändern, dass das neue Verhalten deaktiviert ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Net.HttpWebRequest> für die URI-`http://www.contoso.com/`erstellt.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">für den Zugriff auf den angeforderten URI oder einen URI, an den die Anforderung umgeleitet wird. Zugehörige Enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
    <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Änderungen an der NTLM-Authentifizierung für "HttpWebRequest" in Version 3,5 SP1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.HttpWebRequest" />-Klasse. Diese Konstruktoren sind veraltet. Details finden Sie im Abschnitt „Hinweise“.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Beide <xref:System.Net.HttpWebRequest> Konstruktoren sind veraltet und sollten nicht verwendet werden. Ruft die <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType>-Methode auf, um neue <xref:System.Net.HttpWebRequest> Objekte zu initialisieren.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.HttpWebRequest" />-Klasse. Dieser Konstruktor ist veraltet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren des neuen <see cref="T:System.Net.HttpWebRequest" />-Objekts erforderlichen Informationen.</param>
        <param name="streamingContext">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt mit der Quelle und dem Ziel des serialisierten Streams, der dem neuen <see cref="T:System.Net.HttpWebRequest" />-Objekt zugeordnet ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.HttpWebRequest" />-Klasse aus den angegebenen Instanzen der <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Klasse und der <see cref="T:System.Runtime.Serialization.StreamingContext" />-Klasse. Dieser Konstruktor ist veraltet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung muss bei der Serialisierung im Modus mit voller Vertrauenswürdigkeit ausgeführt werden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">für den uneingeschränkten Zugriff auf Netzwerkressourcen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML- und SOAP-Serialisierung</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht eine Anforderung an eine Internetressource ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Net.HttpWebRequest.Abort%2A>-Methode wird eine Anforderung an eine Ressource abgebrochen. Nachdem eine Anforderung abgebrochen wurde, bewirkt das Aufrufen der Methoden <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>oder <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>, dass eine <xref:System.Net.WebException> mit der <xref:System.Net.WebException.Status%2A>-Eigenschaft auf <xref:System.Net.WebExceptionStatus.RequestCanceled>festgelegt ist.  
  
 Die <xref:System.Net.HttpWebRequest.Abort%2A>-Methode führt synchron den Rückruf aus, der für die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>-Methode oder die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>-Methode angegeben wird, wenn die <xref:System.Net.HttpWebRequest.Abort%2A>-Methode aufgerufen wird, während einer der beiden Vorgänge aussteht. Dies kann zu möglichen Deadlockproblemen führen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung](https://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Im Fall von asynchronen Anforderungen ist es die Aufgabe der Client Anwendung, ihren eigenen Timeout Mechanismus zu implementieren. Das folgende Codebeispiel zeigt, wie Sie dies tun.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="Accept" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Wert des <see langword="Accept" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die Eigenschaft <xref:System.Net.HttpWebRequest.Accept%2A> auf `null`fest, um den `Accept`-HTTP-Header zu löschen.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Eigenschaft auf <xref:System.Net.HttpWebRequest.Accept%2A> festgelegt.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt der Anforderung einen Bereichsheader hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Byte Sequenzen dargestellt werden, ist das Konzept eines Byte Bereichs für jede HTTP-Entität sinnvoll. Allerdings müssen nicht alle Clients und Server Byte Bereichs Vorgänge unterstützen.  
  
 Der Range-Header einer Anforderung ermöglicht einem Client, anzufordern, dass er nur einen Teil des angegebenen Byte Bereichs in einer HTTP-Entität empfangen möchte. Server müssen keine Bereichs Header Anforderungen unterstützen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="range">Der Start- oder Endpunkt des Bereichs.</param>
        <summary>Fügt einer Anforderung einen Bytebereichsheader für einen bestimmten Bereich am Anfang oder Ende der angeforderten Daten hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>-Methode fügt der Anforderung einen Byte Bereichs Header hinzu.  
  
 Wenn `range` positiv ist, gibt der `range` Parameter den Anfangspunkt des Bereichs an. Der Server sollte mit dem Senden von Daten aus dem `range`-Parameter beginnen, der an das Ende der Daten in der HTTP-Entität angegeben ist.  
  
 Wenn `range` negativ ist, gibt der `range` Parameter den Endpunkt des Bereichs an. Der Server sollte mit dem Senden von Daten vom Beginn der Daten in der HTTP-Entität an den angegebenen `range` Parameter beginnen.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Byte Sequenzen dargestellt werden, ist das Konzept eines Byte Bereichs für jede HTTP-Entität sinnvoll. Allerdings müssen nicht alle Clients und Server Byte Bereichs Vorgänge unterstützen.  
  
 Der Range-Header einer Anforderung ermöglicht einem Client, anzufordern, dass er nur einen Teil des angegebenen Byte Bereichs in einer HTTP-Entität empfangen möchte. Server müssen keine Bereichs Header Anforderungen unterstützen.  
  
 Ein Beispiel für einen Bereichs Header in einer HTTP-Protokoll Anforderung, der den Server anfordert, die ersten 100 Bytes (von der Start-an-Byte-Position 99) zu senden, lautet wie folgt:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel wäre der `range`-Parameter-99.  
  
 Ein HTTP-Server gibt die Unterstützung für Bereichs Header mit dem Accept-Ranges-Header an. Ein Beispiel für den Accept-Ranges-Header eines Servers, der Byte Bereiche unterstützt, wäre wie folgt:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, unterstützt der Server keine Bereichs Kopfzeilen. Ein Beispiel für den Accept-Ranges-Header von einem Server, der keine Bereiche unterstützt, aber den Accept-Ranges-Header erkennt, wäre wie folgt:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Bereichs Anforderung werden nur die der gesamten Anforderung zugeordneten HTTP-Header analysiert und über die Eigenschaften der <xref:System.Net.HttpWebResponse> Klasse verfügbar gemacht. Header, die mit jedem Bereich verknüpft sind, werden in der Antwort zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Anforderung ein Bereichs Header hinzugefügt.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="range">Der Start- oder Endpunkt des Bereichs.</param>
        <summary>Fügt einer Anforderung einen Bytebereichsheader für einen bestimmten Bereich am Anfang oder Ende der angeforderten Daten hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>-Methode fügt der Anforderung einen Byte Bereichs Header hinzu.  
  
 Wenn `range` positiv ist, gibt der `range` Parameter den Anfangspunkt des Bereichs an. Der Server sollte mit dem Senden von Daten aus dem `range`-Parameter beginnen, der an das Ende der Daten in der HTTP-Entität angegeben ist.  
  
 Wenn `range` negativ ist, gibt der `range` Parameter den Endpunkt des Bereichs an. Der Server sollte mit dem Senden von Daten vom Beginn der Daten in der HTTP-Entität an den angegebenen `range` Parameter beginnen.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Byte Sequenzen dargestellt werden, ist das Konzept eines Byte Bereichs für jede HTTP-Entität sinnvoll. Allerdings müssen nicht alle Clients und Server Byte Bereichs Vorgänge unterstützen.  
  
 Der Range-Header einer Anforderung ermöglicht einem Client, anzufordern, dass er nur einen Teil des angegebenen Byte Bereichs in einer HTTP-Entität empfangen möchte. Server müssen keine Bereichs Header Anforderungen unterstützen.  
  
 Ein Beispiel für einen Bereichs Header in einer HTTP-Protokoll Anforderung, der den Server anfordert, die ersten 100 Bytes (von der Start-an-Byte-Position 99) zu senden, lautet wie folgt:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel wäre der `range`-Parameter-99.  
  
 Ein HTTP-Server gibt die Unterstützung für Bereichs Header mit dem Accept-Ranges-Header an. Ein Beispiel für den Accept-Ranges-Header eines Servers, der Byte Bereiche unterstützt, wäre wie folgt:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, unterstützt der Server keine Bereichs Kopfzeilen. Ein Beispiel für den Accept-Ranges-Header von einem Server, der keine Bereiche unterstützt, aber den Accept-Ranges-Header erkennt, wäre wie folgt:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Bereichs Anforderung werden nur die der gesamten Anforderung zugeordneten HTTP-Header analysiert und über die Eigenschaften der <xref:System.Net.HttpWebResponse> Klasse verfügbar gemacht. Header, die mit jedem Bereich verknüpft sind, werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="to" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="from">Die Position, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="to">Die Position, an der das Senden von Daten beendet werden soll.</param>
        <summary>Fügt der Anforderung einen Bytebereichsheader für einen angegebenen Bereich hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>-Methode fügt der Anforderung einen Byte Bereichs Header hinzu.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Byte Sequenzen dargestellt werden, ist das Konzept eines Byte Bereichs für jede HTTP-Entität sinnvoll. Allerdings müssen nicht alle Clients und Server Byte Bereichs Vorgänge unterstützen.  
  
 Der Range-Header einer Anforderung ermöglicht einem Client, anzufordern, dass er nur einen Teil des angegebenen Byte Bereichs in einer HTTP-Entität empfangen möchte. Server müssen keine Bereichs Header Anforderungen unterstützen.  
  
 Ein Beispiel für einen Bereichs Header in einer HTTP-Protokoll Anforderung, der die ersten 100 Bytes anfordert, wäre Folgendes:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel würde der `from`-Parameter als 0 und der `to` Parameter als 99 angegeben werden. Der Bereichsspezifizierer wird von dieser Methode automatisch als "Bytes" festgelegt.  
  
 Ein HTTP-Server gibt die Unterstützung für Bereichs Header mit dem Accept-Ranges-Header an. Ein Beispiel für den Accept-Ranges-Header eines Servers, der Byte Bereiche unterstützt, wäre wie folgt:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, unterstützt der Server keine Bereichs Kopfzeilen. Ein Beispiel für den Accept-Ranges-Header von einem Server, der keine Bereiche unterstützt, aber den Accept-Ranges-Header erkennt, wäre wie folgt:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Bereichs Anforderung werden nur die der gesamten Anforderung zugeordneten HTTP-Header analysiert und über die Eigenschaften der <xref:System.Net.HttpWebResponse> Klasse verfügbar gemacht. Header, die mit jedem Bereich verknüpft sind, werden in der Antwort zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Anforderung ein Bereichs Header hinzugefügt.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> ist größer als <paramref name="to" />  
  
- oder - 
 <paramref name="from" /> oder <paramref name="to" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="to" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="from">Die Position, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="to">Die Position, an der das Senden von Daten beendet werden soll.</param>
        <summary>Fügt der Anforderung einen Bytebereichsheader für einen angegebenen Bereich hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>-Methode fügt der Anforderung einen Byte Bereichs Header hinzu.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Byte Sequenzen dargestellt werden, ist das Konzept eines Byte Bereichs für jede HTTP-Entität sinnvoll. Allerdings müssen nicht alle Clients und Server Byte Bereichs Vorgänge unterstützen.  
  
 Der Range-Header einer Anforderung ermöglicht einem Client, anzufordern, dass er nur einen Teil des angegebenen Byte Bereichs in einer HTTP-Entität empfangen möchte. Server müssen keine Bereichs Header Anforderungen unterstützen.  
  
 Ein Beispiel für einen Bereichs Header in einer HTTP-Protokoll Anforderung, der die ersten 100 Bytes anfordert, wäre Folgendes:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel würde der `from`-Parameter als 0 und der `to` Parameter als 99 angegeben werden. Der Bereichsspezifizierer wird von dieser Methode automatisch als "Bytes" festgelegt.  
  
 Ein HTTP-Server gibt die Unterstützung für Bereichs Header mit dem Accept-Ranges-Header an. Ein Beispiel für den Accept-Ranges-Header eines Servers, der Byte Bereiche unterstützt, wäre wie folgt:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, unterstützt der Server keine Bereichs Kopfzeilen. Ein Beispiel für den Accept-Ranges-Header von einem Server, der keine Bereiche unterstützt, aber den Accept-Ranges-Header erkennt, wäre wie folgt:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Bereichs Anforderung werden nur die der gesamten Anforderung zugeordneten HTTP-Header analysiert und über die Eigenschaften der <xref:System.Net.HttpWebResponse> Klasse verfügbar gemacht. Header, die mit jedem Bereich verknüpft sind, werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> ist größer als <paramref name="to" />  
  
- oder - 
 <paramref name="from" /> oder <paramref name="to" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="range" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Die Beschreibung des Bereichs.</param>
        <param name="range">Der Start- oder Endpunkt des Bereichs.</param>
        <summary>Fügt einer Anforderung einen Bereichsheader für einen bestimmten Bereich am Anfang oder Ende der angeforderten Daten hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bereichsheader hinzugefügt.  
  
 Wenn `range` positiv ist, gibt der `range` Parameter den Anfangspunkt des Bereichs an. Der Server sollte mit dem Senden von Daten aus dem `range`-Parameter beginnen, der an das Ende der Daten in der HTTP-Entität angegeben ist.  
  
 Wenn `range` negativ ist, gibt der `range` Parameter den Endpunkt des Bereichs an. Der Server sollte mit dem Senden von Daten vom Beginn der Daten in der HTTP-Entität an den angegebenen `range` Parameter beginnen.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Byte Sequenzen dargestellt werden, ist das Konzept eines Byte Bereichs für jede HTTP-Entität sinnvoll. Allerdings müssen nicht alle Clients und Server Byte Bereichs Vorgänge unterstützen.  
  
 Der Range-Header einer Anforderung ermöglicht einem Client, anzufordern, dass er nur einen Teil des angegebenen Byte Bereichs in einer HTTP-Entität empfangen möchte. Server müssen keine Bereichs Header Anforderungen unterstützen.  
  
 Der `rangeSpecifier`-Parameter würde normalerweise als "Bytes" angegeben werden, da dies der einzige von den meisten HTTP-Servern erkannte Bereichsspezifizierer ist. Wenn der `rangeSpecifier`-Parameter auf eine andere Zeichenfolge festgelegt wird, ist die Unterstützung für benutzerdefinierte Bereichsspezifizierer außer bytes (der in RFC 2616 durch IETF definierte Byte Bereichs Bezeichner) möglich.  
  
 Ein Beispiel für einen Bereichs Header in einer HTTP-Protokoll Anforderung, der die ersten 100 Bytes anfordert, wäre Folgendes:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 In diesem Beispiel würde der `rangeSpecifier`-Parameter als "Bytes" angegeben werden, und der `range` Parameter wäre "-99".  
  
 Ein HTTP-Server gibt die Unterstützung für Bereichs Header mit dem Accept-Ranges-Header in der Antwort an. Ein Beispiel für den Accept-Ranges-Header eines Servers, der Byte Bereiche unterstützt, wäre wie folgt:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, unterstützt der Server keine Bereichs Kopfzeilen. Ein Beispiel für den Accept-Ranges-Header von einem Server, der keine Bereiche unterstützt, aber den Accept-Ranges-Header erkennt, wäre wie folgt:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Bereichs Anforderung werden nur die der gesamten Anforderung zugeordneten HTTP-Header analysiert und über die Eigenschaften der <xref:System.Net.HttpWebResponse> Klasse verfügbar gemacht. Header, die mit jedem Bereich verknüpft sind, werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="range" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Die Beschreibung des Bereichs.</param>
        <param name="range">Der Start- oder Endpunkt des Bereichs.</param>
        <summary>Fügt einer Anforderung einen Bereichsheader für einen bestimmten Bereich am Anfang oder Ende der angeforderten Daten hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bereichsheader hinzugefügt.  
  
 Wenn `range` positiv ist, gibt der `range` Parameter den Anfangspunkt des Bereichs an. Der Server sollte mit dem Senden von Daten aus dem `range`-Parameter beginnen, der an das Ende der Daten in der HTTP-Entität angegeben ist.  
  
 Wenn `range` negativ ist, gibt der `range` Parameter den Endpunkt des Bereichs an. Der Server sollte mit dem Senden von Daten vom Beginn der Daten in der HTTP-Entität an den angegebenen `range` Parameter beginnen.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Byte Sequenzen dargestellt werden, ist das Konzept eines Byte Bereichs für jede HTTP-Entität sinnvoll. Allerdings müssen nicht alle Clients und Server Byte Bereichs Vorgänge unterstützen.  
  
 Der Range-Header einer Anforderung ermöglicht einem Client, anzufordern, dass er nur einen Teil des angegebenen Byte Bereichs in einer HTTP-Entität empfangen möchte. Server müssen keine Bereichs Header Anforderungen unterstützen.  
  
 Der `rangeSpecifier`-Parameter würde normalerweise als "Bytes" angegeben werden, da dies der einzige von den meisten HTTP-Servern erkannte Bereichsspezifizierer ist. Wenn der `rangeSpecifier`-Parameter auf eine andere Zeichenfolge festgelegt wird, ist die Unterstützung für benutzerdefinierte Bereichsspezifizierer außer bytes (der in RFC 2616 durch IETF definierte Byte Bereichs Bezeichner) möglich.  
  
 Ein Beispiel für einen Bereichs Header in einer HTTP-Protokoll Anforderung, der die ersten 100 Bytes anfordert, wäre Folgendes:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 In diesem Beispiel würde der `rangeSpecifier`-Parameter als "Bytes" angegeben werden, und der `range` Parameter wäre "-99".  
  
 Ein HTTP-Server gibt die Unterstützung für Bereichs Header mit dem Accept-Ranges-Header in der Antwort an. Ein Beispiel für den Accept-Ranges-Header eines Servers, der Byte Bereiche unterstützt, wäre wie folgt:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, unterstützt der Server keine Bereichs Kopfzeilen. Ein Beispiel für den Accept-Ranges-Header von einem Server, der keine Bereiche unterstützt, aber den Accept-Ranges-Header erkennt, wäre wie folgt:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Bereichs Anforderung werden nur die der gesamten Anforderung zugeordneten HTTP-Header analysiert und über die Eigenschaften der <xref:System.Net.HttpWebResponse> Klasse verfügbar gemacht. Header, die mit jedem Bereich verknüpft sind, werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="from" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="to" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Die Beschreibung des Bereichs.</param>
        <param name="from">Die Position, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="to">Die Position, an der das Senden von Daten beendet werden soll.</param>
        <summary>Fügt einer Anforderung einen Bereichsheader für einen angegebenen Bereich hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bereichsheader hinzugefügt.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Byte Sequenzen dargestellt werden, ist das Konzept eines Byte Bereichs für jede HTTP-Entität sinnvoll. Allerdings müssen nicht alle Clients und Server Byte Bereichs Vorgänge unterstützen.  
  
 Der Range-Header einer Anforderung ermöglicht einem Client, anzufordern, dass er nur einen Teil des angegebenen Byte Bereichs in einer HTTP-Entität empfangen möchte. Server müssen keine Bereichs Header Anforderungen unterstützen.  
  
 Der `rangeSpecifier`-Parameter würde normalerweise als "Bytes" angegeben werden, da dies der einzige von den meisten HTTP-Servern erkannte Bereichsspezifizierer ist. Wenn der `rangeSpecifier`-Parameter auf eine andere Zeichenfolge festgelegt wird, ist die Unterstützung für benutzerdefinierte Bereichsspezifizierer außer bytes (der in RFC 2616 durch IETF definierte Byte Bereichs Bezeichner) möglich.  
  
 Ein Beispiel für einen Bereichs Header in einer HTTP-Protokoll Anforderung, der die ersten 100 Bytes anfordert, wäre Folgendes:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel würde der `rangeSpecifier`-Parameter als "Bytes" angegeben werden, der `from`-Parameter ist 0, und der `to`-Parameter wäre 99.  
  
 Ein HTTP-Server gibt die Unterstützung für Bereichs Header mit dem Accept-Ranges-Header in der Antwort an. Ein Beispiel für den Accept-Ranges-Header eines Servers, der Byte Bereiche unterstützt, wäre wie folgt:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Die im Accept-Ranges-Header angegebene Zeichenfolge ist der Bereichsspezifizierer, der im `rangeSpecifier`-Parameter für diese Methode angegeben wird.  
  
 Wenn ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, unterstützt der Server keine Bereichs Kopfzeilen. Ein Beispiel für den Accept-Ranges-Header von einem Server, der keine Bereiche unterstützt, aber den Accept-Ranges-Header erkennt, wäre wie folgt:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Bereichs Anforderung werden nur die der gesamten Anforderung zugeordneten HTTP-Header analysiert und über die Eigenschaften der <xref:System.Net.HttpWebResponse> Klasse verfügbar gemacht. Header, die mit jedem Bereich verknüpft sind, werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> ist größer als <paramref name="to" />  
  
- oder - 
 <paramref name="from" /> oder <paramref name="to" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="from" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="to" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Die Beschreibung des Bereichs.</param>
        <param name="from">Die Position, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="to">Die Position, an der das Senden von Daten beendet werden soll.</param>
        <summary>Fügt einer Anforderung einen Bereichsheader für einen angegebenen Bereich hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bereichsheader hinzugefügt.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Byte Sequenzen dargestellt werden, ist das Konzept eines Byte Bereichs für jede HTTP-Entität sinnvoll. Allerdings müssen nicht alle Clients und Server Byte Bereichs Vorgänge unterstützen.  
  
 Der Range-Header einer Anforderung ermöglicht einem Client, anzufordern, dass er nur einen Teil des angegebenen Byte Bereichs in einer HTTP-Entität empfangen möchte. Server müssen keine Bereichs Header Anforderungen unterstützen.  
  
 Der `rangeSpecifier`-Parameter würde normalerweise als "Bytes" angegeben werden, da dies der einzige von den meisten HTTP-Servern erkannte Bereichsspezifizierer ist. Wenn der `rangeSpecifier`-Parameter auf eine andere Zeichenfolge festgelegt wird, ist die Unterstützung für benutzerdefinierte Bereichsspezifizierer außer bytes (der in RFC 2616 durch IETF definierte Byte Bereichs Bezeichner) möglich.  
  
 Ein Beispiel für einen Bereichs Header in einer HTTP-Protokoll Anforderung, der die ersten 100 Bytes anfordert, wäre Folgendes:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel würde der `rangeSpecifier`-Parameter als "Bytes" angegeben werden, der `from`-Parameter ist 0, und der `to`-Parameter wäre 99.  
  
 Ein HTTP-Server gibt die Unterstützung für Bereichs Header mit dem Accept-Ranges-Header in der Antwort an. Ein Beispiel für den Accept-Ranges-Header eines Servers, der Byte Bereiche unterstützt, wäre wie folgt:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Die im Accept-Ranges-Header angegebene Zeichenfolge ist der Bereichsspezifizierer, der im `rangeSpecifier`-Parameter für diese Methode angegeben wird.  
  
 Wenn ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, unterstützt der Server keine Bereichs Kopfzeilen. Ein Beispiel für den Accept-Ranges-Header von einem Server, der keine Bereiche unterstützt, aber den Accept-Ranges-Header erkennt, wäre wie folgt:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Bereichs Anforderung werden nur die der gesamten Anforderung zugeordneten HTTP-Header analysiert und über die Eigenschaften der <xref:System.Net.HttpWebResponse> Klasse verfügbar gemacht. Header, die mit jedem Bereich verknüpft sind, werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> ist größer als <paramref name="to" />  
  
- oder - 
 <paramref name="from" /> oder <paramref name="to" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den URI (Uniform Resource Identifier) der Internetressource ab, die auf die Anforderung reagiert.</summary>
        <value>Ein <see cref="T:System.Uri" />, der die Internetressource bezeichnet, die auf die Anforderung reagiert. Standardmäßig ist dies der URI, der von der <see cref="M:System.Net.WebRequest.Create(System.String)" />-Methode zum Initialisieren der Anforderung verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Address%2A>-Eigenschaft wird auf den URI festgelegt, nachdem alle Umleitungen, die während der Anforderung auftreten, fertiggestellt sind.  
  
 Der URI der ursprünglichen Anforderung wird in der <xref:System.Net.HttpWebRequest.RequestUri%2A>-Eigenschaft beibehalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob das <xref:System.Net.HttpWebRequest> Objekt `req` an einen anderen Speicherort umgeleitet wurde, um die Anforderung zu erfüllen, und legt den Wert der `hasChanged` Variablen auf `true` fest, wenn die Anforderung umgeleitet wurde. Andernfalls wird `hasChanged` auf `false`festgelegt.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="C#" Value="public bool AllowAutoRedirect { get; set; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAutoRedirect As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAutoRedirect { bool get(); void set(bool value); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anforderung Umleitungsantworten folgen soll, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn die Anforderung Umleitungsantworten von der Internetressource automatisch folgen soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> auf `true` fest, wenn die Anforderung http-Umleitungs Headern automatisch an den neuen Speicherort der Ressource weiterleiten soll. Die maximale Anzahl der nachfolgenden Umleitungen wird durch die <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A>-Eigenschaft festgelegt.  
  
 Wenn <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> auf `false`festgelegt ist, werden alle Antworten mit einem HTTP-Statuscode zwischen 300 und 399 an die Anwendung zurückgegeben.  
  
 Der Autorisierungs Header wird bei automatischen Umleitungen gelöscht, und <xref:System.Net.HttpWebRequest> versucht automatisch, sich am umgeleiteten Speicherort erneut zu authentifizieren. In der Praxis bedeutet dies, dass eine Anwendung keine benutzerdefinierten Authentifizierungsinformationen im Autorisierungs Header ablegen kann, wenn eine Umleitung möglich ist. Stattdessen muss die Anwendung ein benutzerdefiniertes Authentifizierungs Modul implementieren und registrieren. Mit dem <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> und der zugehörigen Klasse wird ein benutzerdefiniertes Authentifizierungs Modul implementiert. Mit der <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType>-Methode wird ein benutzerdefiniertes Authentifizierungs Modul registriert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>-Eigenschaft verwendet, damit die Anforderung Umleitungs Antworten befolgt.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die von der Internetressource empfangenen Daten gepuffert werden sollen, oder legt diesen Wert fest.</summary>
        <value><see langword="true" /> aktiviert die Zwischenspeicherung der aus der Internetressource empfangenen Daten, <see langword="false" /> deaktiviert die Zwischenspeicherung. Der Standardwert ist <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="C#" Value="public bool AllowWriteStreamBuffering { get; set; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowWriteStreamBuffering As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die an die Internetressource gesendeten Daten gepuffert werden sollen, oder legt diesen fest.</summary>
        <value><see langword="true" /> aktiviert das Puffern der an die Internetressource gesendeten Daten, <see langword="false" /> deaktiviert das Puffern. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> `true`ist, werden die Daten im Arbeitsspeicher gepuffert, damit Sie im Fall von Umleitungen oder Authentifizierungsanforderungen erneut gesendet werden können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A>-Eigenschaft verwendet, um die Daten Pufferung zu deaktivieren.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Das Festlegen von <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> auf <see langword="true" /> kann beim Hochladen großer Datasets zu Leistungsproblemen führen, da der Datenpuffer den gesamten verfügbaren Arbeitsspeicher verwenden könnte.</para></block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ der verwendeten Dekomprimierung ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Net.DecompressionMethods" />-Objekt, das den Typ der verwendeten Dekomprimierung angibt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Zustand des Objekts gestattet es nicht, dass diese Eigenschaft festgelegt wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Das Zustandsobjekt für diese Anforderung.</param>
        <summary>Startet eine asynchrone Anforderung eines <see cref="T:System.IO.Stream" />-Objekts, das zum Schreiben von Daten verwendet werden soll.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Anforderung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>-Methode startet eine asynchrone Anforderung eines Datenstroms, der zum Senden von Daten für die <xref:System.Net.HttpWebRequest>verwendet wird. Die asynchrone Rückruf Methode verwendet die <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>-Methode, um den eigentlichen Stream zurückzugeben.  
  
 Die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>-Methode erfordert, dass einige synchrone Setup Tasks (z. b. DNS-Auflösung, Proxy Erkennung und TCP-Socketverbindung) beendet werden, bevor diese Methode asynchron wird. Folglich sollte diese Methode niemals für einen Benutzeroberflächen Thread (UI) aufgerufen werden, da es viel Zeit in Anspruch nehmen kann (je nach Netzwerkeinstellungen), um die anfänglichen synchronen Setup Aufgaben abzuschließen, bevor eine Ausnahme ausgelöst wird oder die Methode ist erfolgreich.  
  
 Weitere Informationen zum Thread Pool finden Sie [unter der verwaltete Thread Pool](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  In Ihrer Anwendung können keine synchronen und asynchronen Methoden für eine bestimmte Anforderung gemischt werden. Wenn Sie die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>-Methode aufrufen, müssen Sie die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>-Methode verwenden, um die Antwort abzurufen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>-Methode verwendet, um eine asynchrone Anforderung für eine Streaminstanz vorzunehmen.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">Die <see cref="P:System.Net.HttpWebRequest.Method" />-Eigenschaft ist GET oder HEAD.  
  
- oder - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> ist <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> ist <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" /> und <see cref="P:System.Net.HttpWebRequest.Method" /> ist POST oder PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream wird von einem vorherigen Aufruf von <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> verwendet.  
  
- oder - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ist auf einen Wert festgelegt, und <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" />.  
  
- oder - 
Der Threadpool enthält nicht mehr genügend Threads.</exception>
        <exception cref="T:System.NotSupportedException">Die Anforderungcacheprüfung hat angezeigt, dass die Antwort auf diese Anforderung aus dem Cache erfolgen werden kann. Allerdings dürfen Anforderungen, die Daten schreiben, nicht den Cache verwenden. Diese Ausnahme kann auftreten, wenn Sie eine benutzerdefinierte Cacheprüfung verwenden, die nicht ordnungsgemäß implementiert ist.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.</exception>
        <exception cref="T:System.ObjectDisposedException">In einer .NET Compact Framework-Anwendung wurde ein Anforderungsstream mit leerem Inhalt nicht ordnungsgemäß abgerufen und geschlossen. Weitere Informationen über das Verarbeiten von Anforderungen mit einem Inhalt der Länge 0 (null) finden Sie unter [Network Programming in the .NET Compact Framework (Netzwerkprogrammierung in .NET Compact Framework.)](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Das Zustandsobjekt für diese Anforderung.</param>
        <summary>Startet eine asynchrone Anforderung an eine Internetressource.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Anforderung einer Antwort verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>-Methode startet eine asynchrone Anforderung einer Antwort von der Internet Ressource. Die asynchrone Rückruf Methode verwendet die <xref:System.Net.HttpWebRequest.EndGetResponse%2A>-Methode, um die tatsächliche <xref:System.Net.WebResponse>zurückzugeben.  
  
 In einigen Fällen wird eine <xref:System.Net.ProtocolViolationException> ausgelöst, wenn die in der <xref:System.Net.HttpWebRequest>-Klasse festgelegten Eigenschaften in Konflikt stehen. Diese Ausnahme tritt auf, wenn eine Anwendung die <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft und die-Eigenschaft <xref:System.Net.HttpWebRequest.SendChunked%2A> auf `true`festlegt und dann eine HTTP GET-Anforderung sendet. Diese Ausnahme tritt auf, wenn eine Anwendung versucht, Segmente an einen Server zu senden, der nur das HTTP 1,0-Protokoll unterstützt. Dies wird nicht unterstützt. Diese Ausnahme tritt auf, wenn eine Anwendung versucht, Daten zu senden, ohne die <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft festzulegen, oder wenn die <xref:System.Net.HttpWebRequest.SendChunked%2A> `false` ist, wenn die Pufferung deaktiviert ist, und bei einer KeepAlive-Verbindung (die <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft `true`ist)`.`  
  
 Wenn eine <xref:System.Net.WebException> ausgelöst wird, verwenden Sie die Eigenschaften <xref:System.Net.WebException.Response%2A> und <xref:System.Net.WebException.Status%2A> der Ausnahme, um die Antwort vom Server zu ermitteln.  
  
 Die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>-Methode erfordert, dass einige synchrone Setup Tasks (z. b. DNS-Auflösung, Proxy Erkennung und TCP-Socketverbindung) beendet werden, bevor diese Methode asynchron wird. Folglich sollte diese Methode niemals für einen Benutzeroberflächen Thread (UI) aufgerufen werden, da es viel Zeit in Anspruch nehmen kann (je nach Netzwerkeinstellungen), um die anfänglichen synchronen Setup Aufgaben abzuschließen, bevor eine Ausnahme ausgelöst wird oder die Methode ist erfolgreich.  
  
 Weitere Informationen zum Thread Pool finden Sie [unter der verwaltete Thread Pool](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  In Ihrer Anwendung können keine synchronen und asynchronen Methoden für eine bestimmte Anforderung gemischt werden. Wenn Sie die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>-Methode aufrufen, müssen Sie die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>-Methode verwenden, um die Antwort abzurufen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>-Methode verwendet, um eine asynchrone Anforderung einer Internet Ressource zu erstellen.  
  
> [!NOTE]
>  Im Fall von asynchronen Anforderungen ist es die Aufgabe der Client Anwendung, ihren eigenen Timeout Mechanismus zu implementieren. Das folgende Codebeispiel zeigt, wie Sie dies tun.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Stream wird bereits von einem vorherigen Aufruf von <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> verwendet.  
  
- oder - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ist auf einen Wert festgelegt, und <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" />.  
  
- oder - 
Der Threadpool enthält nicht mehr genügend Threads.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> ist GET oder HEAD, und <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist größer als 0 (null), oder <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="true" />.  
  
- oder - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> ist gleich <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> ist gleich <see langword="false" />, und <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist gleich -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist gleich <see langword="false" /> und <see cref="P:System.Net.HttpWebRequest.Method" /> ist gleich POST oder PUT.  
  
- oder - 
<see cref="T:System.Net.HttpWebRequest" /> verfügt über einen Entitätskörper, die <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />-Methode wird jedoch aufgerufen, ohne dass die <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />-Methode aufgerufen wird.  
  
- oder - 
<see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist größer als 0 (null), von der Anwendung werden jedoch nicht alle zugesagten Daten geschrieben.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificates As X509CertificateCollection" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection" Usage="System.Net.HttpWebRequest.ClientCertificates" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dieser Anforderung zugeordnete Auflistung von Sicherheitszertifikaten ab oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den dieser Anforderung zugeordneten Sicherheitszertifikaten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung kann einer Sammlung ein Zertifikat hinzufügen, verfügt jedoch möglicherweise nicht über die entsprechenden Zugriffsrechte. Um ein in der Auflistung enthaltenes Zertifikat verwenden zu können, muss die Anwendung über die gleichen Zugriffsrechte wie die Entität verfügen, die das Zertifikat ausgestellt hat.  
  
> [!NOTE]
>  Das Framework speichert SSL-Sitzungen bei der Erstellung zwischen und versucht nach Möglichkeit, eine zwischengespeicherte Sitzung für eine neue Anforderung wiederzuverwenden. Beim Versuch, eine SSL-Sitzung wiederzuverwenden, verwendet das Framework das erste Element von <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (sofern vorhanden) oder versucht, anonyme Sitzungen wiederzuverwenden, wenn <xref:System.Net.HttpWebRequest.ClientCertificates%2A> leer ist.  
  
> [!NOTE]
>  Aus Leistungsgründen sollten Sie ein Client Zertifikat nicht zu einem <xref:System.Net.HttpWebRequest> hinzufügen, es sei denn, Sie wissen, dass der Server Sie dazu auffordern wird.  
>   
>  Ein Codebeispiel, das veranschaulicht, wie die Zertifikate im Zertifikat Speicher des Clients aufgelistet werden, finden Sie in der <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection>-Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der für einen SET-Vorgang festgelegte Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="Connection" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Wert des <see langword="Connection" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anforderung sendet die <xref:System.Net.HttpWebRequest.Connection%2A>-Eigenschaft als `Connection`-HTTP-Header an die Internet Ressource. Wenn der Wert der <xref:System.Net.HttpWebRequest.KeepAlive%2A>-Eigenschaft `true`ist, wird der Wert "Keep-Alive" an das Ende des `Connection` Headers angehängt.  
  
 Legen Sie die Eigenschaft <xref:System.Net.HttpWebRequest.Connection%2A> auf `null`fest, um den `Connection`-HTTP-Header zu löschen.  
  
 Wenn Sie die <xref:System.Net.HttpWebRequest.Connection%2A>-Eigenschaft ändern, nachdem die Anforderung durch Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>-, <xref:System.Net.HttpWebRequest.GetResponse%2A>-oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>-Methode gestartet wurde, wird ein <xref:System.InvalidOperationException>ausgelöst.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.Connection%2A>-Eigenschaft verwendet, um den Wert des HTTP-Verbindungs Headers festzulegen.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert von <see cref="P:System.Net.HttpWebRequest.Connection" /> wird auf „Keep-Alive“ oder „Close“ festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der Verbindungsgruppe für die Anforderung ab oder legt diesen fest.</summary>
        <value>Der Name der Verbindungsgruppe für diese Anforderung. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A>-Eigenschaft ermöglicht es Ihnen, eine Anforderung einer Verbindungsgruppe zuzuordnen. Dies ist nützlich, wenn Ihre Anwendung Anforderungen an einen Server für verschiedene Benutzer sendet, z. b. eine Website, von der Kundeninformationen von einem Datenbankserver abgerufen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Benutzerinformationen verwendet werden, um eine Verbindungsgruppe zu bilden. dabei wird davon ausgegangen, dass die Variablen `username`, `password`und `domain` von der Anwendung festgelegt werden, bevor dieser Code aufgerufen wird.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jede Verbindungsgruppe erstellt zusätzliche Verbindungen für einen Server. Dies kann dazu führen, dass die Anzahl der von der <see cref="P:System.Net.ServicePoint.ConnectionLimit" />-Eigenschaft für diesen Server festgelegten Verbindungen überschritten wird.</para></block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
        <related type="Article" href="~/docs/framework/network-programming/connection-grouping.md">Verbindungsgruppierung</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see langword="Content-length" />-HTTP-Header ab oder legt diesen fest.</summary>
        <value>Die Anzahl der Bytes der an die Internetressource zu sendenden Daten. Der Standardwert ist -1. Dieser Wert gibt an, dass die Eigenschaft nicht festgelegt wurde und keine zu sendenden Anforderungsdaten vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft enthält den Wert, der als `Content-length`-HTTP-Header mit der Anforderung gesendet werden soll.  
  
 Jeder andere Wert als-1 in der <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft gibt an, dass die Anforderung Daten hochlädt und dass nur Methoden, die Daten hochladen, in der <xref:System.Net.HttpWebRequest.Method%2A>-Eigenschaft festgelegt werden dürfen.  
  
 Nachdem die <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft auf einen Wert festgelegt wurde, muss die Anzahl von Bytes in den Anforderungs Datenstrom geschrieben werden, der durch Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-Methode oder der <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>-und <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methoden zurückgegeben wird.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft auf die Länge der Zeichenfolge festgelegt, die gesendet wird.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Anforderung wurde durch Aufrufen der Methode <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> oder <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> gestartet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der neue <see cref="P:System.Net.HttpWebRequest.ContentLength" />-Wert ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="Content-type" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Wert des <see langword="Content-type" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ContentType%2A>-Eigenschaft enthält den Medientyp der Anforderung. Werte, die der <xref:System.Net.HttpWebRequest.ContentType%2A>-Eigenschaft zugewiesen sind, ersetzen vorhandene Inhalte, wenn die Anforderung den `Content-type`-HTTP-Header sendet.  
  
 Legen Sie die Eigenschaft <xref:System.Net.HttpWebRequest.ContentType%2A> auf `null`fest, um den `Content-type`-HTTP-Header zu löschen.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in <xref:System.Net.WebHeaderCollection> gespeichert. Wenn <xref:System.Net.WebHeaderCollection> festgelegt ist, geht der Eigenschafts Wert verloren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Eigenschaft auf <xref:System.Net.HttpWebRequest.ContentType%2A> festgelegt.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Delegatenmethode ab, die aufgerufen wird, wenn eine HTTP-100-Continue-Antwort von der Internetressource empfangen wird, oder legt diese fest.</summary>
        <value>Ein Delegat, der die Rückrufmethode implementiert, die ausgeführt wird, wenn die Internetressource eine HTTP-Continue-Antwort zurückgibt. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ContinueDelegate%2A>-Eigenschaft gibt die Rückruf Methode an, die aufgerufen werden soll, wenn der Client eine 100-Continue-Antwort empfängt.  
  
 Wenn die <xref:System.Net.HttpWebRequest.ContinueDelegate%2A>-Eigenschaft festgelegt ist, ruft der Client den-Delegaten immer dann auf, wenn Protokoll Antworten vom Typ <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) empfangen werden. Dies ist hilfreich, wenn Sie möchten, dass der Client den Status der Daten anzeigt, die von der Internet Ressource empfangen werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Timeout-Zeit (in Millisekunden) ab oder legt diese fest, bis zu der auf den Serverstatus gewartet wird, nachdem "100-Continue" vom Server empfangen wurde.</summary>
        <value>Das Timeout in Millisekunden, bis zu dem auf den Empfang von "100-Continue" gewartet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die 100-Continue-Antwort empfangen wird, bevor das Timeout abläuft, kann der Entitäts Text gesendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="C#" Value="public System.Net.CookieContainer CookieContainer { get; set; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Property CookieContainer As CookieContainer" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die der Anforderung zugeordneten Cookies ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Net.CookieContainer" /> mit den dieser Anforderung zugeordneten Cookies.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.CookieContainer%2A>-Eigenschaft stellt eine Instanz der <xref:System.Net.CookieContainer>-Klasse bereit, die die dieser Anforderung zugeordneten Cookies enthält.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> ist `null` standardmäßig. Sie müssen der-Eigenschaft ein <xref:System.Net.CookieContainer> Objekt zuweisen, damit Cookies in der <xref:System.Net.HttpWebResponse.Cookies%2A>-Eigenschaft der <xref:System.Net.HttpWebResponse> zurückgegeben werden, die von der <xref:System.Net.HttpWebRequest.GetResponse%2A>-Methode zurückgegeben wird.  
  
> [!NOTE]
>  Aus Sicherheitsgründen sind Cookies standardmäßig deaktiviert. Wenn Sie Cookies verwenden möchten, verwenden Sie die <xref:System.Net.HttpWebRequest.CookieContainer%2A>-Eigenschaft, um Cookies zu aktivieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Anforderung an eine URL gesendet, und die in der Antwort zurückgegebenen Cookies werden angezeigt.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Authentifizierungsinformationen für die Anforderung ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Net.ICredentials" />-Element mit den der Anforderung zugeordneten Anmeldeinformationen für die Authentifizierung. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Credentials%2A>-Eigenschaft enthält Authentifizierungsinformationen, um den Ersteller der Anforderung zu identifizieren. Bei der <xref:System.Net.HttpWebRequest.Credentials%2A>-Eigenschaft kann es sich um einen <xref:System.Net.NetworkCredential>handeln. in diesem Fall werden die Benutzer-, Kennwort-und Domänen Informationen, die im <xref:System.Net.NetworkCredential>-Objekt enthalten sind, zum Authentifizieren der Anforderung verwendet, oder es kann sich um eine <xref:System.Net.CredentialCache>handeln. in diesem Fall wird der Uniform Resource Identifier (URI) der Anforderung verwendet, um den Benutzer, das Kennwort und die Domänen Informationen für die  
  
 In den meisten Client Szenarien sollten Sie die <xref:System.Net.CredentialCache.DefaultCredentials%2A>-Eigenschaft verwenden, die die Anmelde Informationen des aktuell angemeldeten Benutzers enthält. Legen Sie zu diesem Zweck die <xref:System.Net.WebClient.UseDefaultCredentials%2A>-Eigenschaft auf `true` fest, anstatt diese Eigenschaft festzulegen.  
  
 Wenn die <xref:System.Net.HttpWebRequest>-Klasse in einer Anwendung der mittleren Ebene verwendet wird, z. b. eine ASP.NET-Anwendung, gehören die Anmelde Informationen in der <xref:System.Net.CredentialCache.DefaultCredentials%2A>-Eigenschaft zu dem Konto, auf dem die ASP-Seite ausgeführt wird (die serverseitigen Anmelde Informationen). In der Regel legen Sie diese Eigenschaft auf die Anmelde Informationen des Clients fest, in dessen Auftrag die Anforderung erfolgt.  
  
> [!NOTE]
>  Das NTLM-Authentifizierungsschema kann nicht verwendet werden, um die Identität eines anderen Benutzers anzunehmen. Kerberos muss speziell für die Unterstützung des Identitäts Wechsels konfiguriert werden.  
  
 Verwenden Sie die <xref:System.Net.CredentialCache>-Klasse, und binden Sie Ihre Anmelde Informationen an ein oder mehrere Authentifizierungs Schemas, um HttpWebRequest auf eine oder mehrere Authentifizierungsmethoden zu beschränken.  
  
 Zu den unterstützten Authentifizierungs Schemas gehören Digest, Aushandlung, Kerberos, NTLM und Basic.  
  
 Speichern Sie aus Sicherheitsgründen die Anmelde Informationen, die Sie in die Umleitung einschließen möchten, in einer <xref:System.Net.CredentialCache>, und weisen Sie diese dieser Eigenschaft zu. Diese Eigenschaft wird bei der Umleitung automatisch auf `null` festgelegt, wenn Sie etwas außer einem <xref:System.Net.CredentialCache>enthält. Wenn dieser Eigenschafts Wert automatisch auf `null` festgelegt wird, wird verhindert, dass Anmelde Informationen an ein unbeabsichtigtes Ziel gesendet werden.
  
## Examples  
 Im folgenden Codebeispiel werden die Anmelde Informationen für eine Anforderung festgelegt.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see langword="Date" />-HTTP-Headerwert für eine HTTP-Anforderung ab oder legt ihn fest.</summary>
        <value>Der Datumsheaderwert in der HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Date-Header `null`ist, wird der Rückgabewert auf <xref:System.DateTime.MinValue?displayProperty=nameWithType>festgelegt.  
  
 Die <xref:System.Net.HttpWebRequest.Date%2A>-Eigenschaft ist ein Standard <xref:System.DateTime?displayProperty=nameWithType> Objekt und kann ein <xref:System.DateTimeKind?displayProperty=nameWithType> Feld mit <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>oder <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>enthalten. Jede Art von Zeit kann festgelegt werden, wenn die <xref:System.Net.HttpWebRequest.Date%2A>-Eigenschaft verwendet wird. Wenn <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> festgelegt oder abgerufen wird, wird davon ausgegangen, dass die Eigenschaft <xref:System.Net.HttpWebRequest.Date%2A> <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (Ortszeit) ist.  
  
 Die Klassen im <xref:System.Net>-Namespace schreiben <xref:System.Net.HttpWebRequest.Date%2A> Sie immer bei der Übertragung während der Übertragung in Standardform im GMT (UTC)-Format.  
  
 Wenn die <xref:System.Net.HttpWebRequest.Date%2A>-Eigenschaft auf <xref:System.DateTime.MinValue?displayProperty=nameWithType>festgelegt ist, wird der `Date`-HTTP-Header aus der <xref:System.Net.HttpWebRequest.Headers%2A>-Eigenschaft und der <xref:System.Net.WebHeaderCollection>entfernt.  
  
 Wenn die <xref:System.Net.HttpWebRequest.Date%2A>-Eigenschaft <xref:System.DateTime.MinValue?displayProperty=nameWithType>ist, bedeutet dies, dass der `Date`-HTTP-Header nicht in der <xref:System.Net.HttpWebRequest.Headers%2A>-Eigenschaft und <xref:System.Net.WebHeaderCollection>enthalten ist.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
 Wenn die <xref:System.Net.HttpWebRequest.Date%2A> festgelegt ist und versucht wird, eine <xref:System.Net.HttpWebRequest> ohne Text zu senden, wird eine <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> von den Methoden <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>und <xref:System.Net.HttpWebRequest.EndGetResponse%2A> ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardcacherichtlinie für diese Anforderung ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Net.Cache.HttpRequestCachePolicy" />, die die für diese Anforderung gültige Cacherichtlinie angibt, wenn keine andere Richtlinie anwendbar ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Festlegen dieser Eigenschaft wird die angegebene Richtlinie für die HTTP-und HTTPS-Schemas registriert. Diese Richtlinie wird für diese Anforderung verwendet, wenn:  
  
 Für diese Anforderung ist keine <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> Eigenschaft angegeben.  
  
- oder -
  
 Die Computer-und Anwendungs Konfigurationsdateien geben keine Cache Richtlinie an, die auf die Uniform Resource Identifier (URI) anwendbar ist, die zum Erstellen dieser Anforderung verwendet wird.  
  
 Die Cache Richtlinie bestimmt, ob die angeforderte Ressource aus einem Cache entnommen werden kann, anstatt die Anforderung an den Ressourcen Host Computer zu senden.  
  
 Eine Kopie einer Ressource wird nur dem Cache hinzugefügt, wenn der Antwortstream für die Ressource abgerufen und am Ende des Streams gelesen wird. Daher kann eine andere Anforderung für dieselbe Ressource eine zwischengespeicherte Kopie verwenden, je nach der Cache Richtlinien Ebene für diese Anforderung.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">für den uneingeschränkten Zugriff auf Netzwerkressourcen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die standardmäßige maximale Länge einer HTTP-Fehlerantwort ab oder legt diese fest.</summary>
        <value>Die standardmäßige maximale Länge einer HTTP-Fehlerantwort.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert ist kleiner als 0 (null) und ungleich -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Standardwert für die <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />-Eigenschaft ab oder legt diesen fest.</summary>
        <value>Die Länge in KB (1024 Bytes) des Standardwerts für die maximale Größe empfangener Antwortheader. In der Standardkonfigurationsdatei ist dieser Wert auf 64 KB festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Länge des Antwort Headers hat die Antwortstatus Zeile und alle zusätzlichen Steuerungs Zeichen empfangen, die als Teil des HTTP-Protokolls empfangen werden. Der Wert-1 bedeutet, dass keine Beschränkung für die empfangenen Antwortheader erhoben wird. der Wert 0 bedeutet, dass alle Anforderungen fehlschlagen.  
  
 Dieser Wert kann auch in der Konfigurationsdatei geändert werden. Die Auswirkungen dieser Eigenschaft können überschrieben werden, indem die <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>-Eigenschaft für eine Instanz der <xref:System.Net.HttpWebRequest>-Klasse festgelegt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert ist ungleich -1 und kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet eine asynchrone Anforderung eines <see cref="T:System.IO.Stream" />-Objekts, das zum Schreiben von Daten verwendet werden soll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Die ausstehende Anforderung für einen Datenstrom.</param>
        <summary>Beendet eine asynchrone Anforderung eines <see cref="T:System.IO.Stream" />-Objekts, das zum Schreiben von Daten verwendet werden soll.</summary>
        <returns>Ein <see cref="T:System.IO.Stream" />, der zum Schreiben von Anforderungsdaten verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>-Methode schließt eine asynchrone Anforderung für einen Stream ab, der von der <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>-Methode gestartet wurde. Nachdem das <xref:System.IO.Stream> Objekt zurückgegeben wurde, können Sie mithilfe der <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>-Methode Daten mit dem <xref:System.Net.HttpWebRequest> senden.  
  
> [!NOTE]
>  Sie müssen den Wert der <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft festlegen, bevor Sie Daten in den Stream schreiben.  
  
> [!CAUTION]
>  Sie müssen die <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>-Methode aufzurufen, um den Stream zu schließen und die Verbindung für die Wiederverwendung freizugeben. Wenn Sie den Stream nicht schließen, wird für die Anwendung keine Verbindung mehr hergestellt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>-Methode verwendet, um eine asynchrone Anforderung für eine Streaminstanz zu beenden.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung wurde nicht abgeschlossen, und es ist kein Stream verfügbar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde von der aktuellen Instanz bei einem Aufruf von <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> nicht zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Methode wurde zuvor mit <paramref name="asyncResult" /> aufgerufen.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.  
  
- oder - 
Fehler beim Verarbeiten der Anforderung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult * TransportContext -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, context)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult * TransportContext -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Die ausstehende Anforderung für einen Datenstrom.</param>
        <param name="context">Der <see cref="T:System.Net.TransportContext" /> für den <see cref="T:System.IO.Stream" />.</param>
        <param name="transportContext">Der <see cref="T:System.Net.TransportContext" /> für den <see cref="T:System.IO.Stream" />.</param>
        <summary>Beendet eine asynchrone Anforderung eines <see cref="T:System.IO.Stream" />-Objekts, das zum Schreiben von Daten verwendet wird und das dem Datenstrom zugeordnete <see cref="T:System.Net.TransportContext" /> ausgibt.</summary>
        <returns>Ein <see cref="T:System.IO.Stream" />, der zum Schreiben von Anforderungsdaten verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>-Methode schließt eine asynchrone Anforderung für einen Stream ab, der von der <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>-Methode gestartet wurde, und gibt die <xref:System.Net.TransportContext> aus, die dem Stream zugeordnet ist. Nachdem das <xref:System.IO.Stream> Objekt zurückgegeben wurde, können Sie mithilfe der <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>-Methode Daten mit dem <xref:System.Net.HttpWebRequest> senden.  
  
 Einige Anwendungen, die die integrierte Windows-Authentifizierung mit erweitertem Schutz verwenden, müssen möglicherweise die von <xref:System.Net.HttpWebRequest> verwendete Transportschicht Abfragen, um das channelbindungstoken (CBT) aus dem zugrunde liegenden TLS-Kanal abzurufen. Die <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-Methode ermöglicht den Zugriff auf diese Informationen für HTTP-Methoden, die über einen Anforderungs Text verfügen (`POST` und `PUT` Anforderungen). Dies ist nur erforderlich, wenn die Anwendung ihre eigene Authentifizierung implementiert und Zugriff auf das CBT benötigt.  
  
> [!NOTE]
>  Wenn eine Anwendung den Wert der <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft festlegen muss, muss dies erfolgen, bevor der Stream abgerufen und Daten in den Stream geschrieben werden.  
  
> [!CAUTION]
>  Sie müssen die <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>-Methode aufzurufen, um den Stream zu schließen und die Verbindung für die Wiederverwendung freizugeben. Wenn Sie den Stream nicht schließen, wird für die Anwendung keine Verbindung mehr hergestellt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde von der aktuellen Instanz bei einem Aufruf von <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> nicht zurückgegeben.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Methode wurde zuvor mit <paramref name="asyncResult" /> aufgerufen.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung wurde nicht abgeschlossen, und es ist kein Stream verfügbar.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.  
  
- oder - 
Fehler beim Verarbeiten der Anforderung.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Die ausstehende Anforderung einer Antwort.</param>
        <summary>Beendet eine asynchrone Anforderung an eine Internetressource.</summary>
        <returns>Eine <see cref="T:System.Net.WebResponse" /> mit der Antwort von der Internetressource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.EndGetResponse%2A>-Methode schließt eine asynchrone Anforderung einer Internet Ressource ab, die durch Aufrufen der <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>-Methode gestartet wurde.  
  
> [!CAUTION]
>  Sie müssen die <xref:System.Net.HttpWebResponse.Close%2A>-Methode aufzurufen, um den Stream zu schließen und die Verbindung freizugeben. Wenn dies nicht der Fall ist, kann Ihre Anwendung nicht mehr über Verbindungen verfügen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.EndGetResponse%2A>-Methode verwendet, um eine asynchrone Anforderung einer Internet Ressource zu beenden.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Methode wurde zuvor mit <paramref name="asyncResult." /> aufgerufen.  
  
- oder - 
Die <see cref="P:System.Net.HttpWebRequest.ContentLength" />-Eigenschaft ist größer als 0 (null), aber die Daten wurden nicht in den Anforderungsdatenstrom geschrieben.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.  
  
- oder - 
Fehler beim Verarbeiten der Anforderung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde von der aktuellen Instanz bei einem Aufruf von <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> nicht zurückgegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="Expect" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Inhalt des <see langword="Expect" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 Der Wert für diese Eigenschaft wird in der <see cref="T:System.Net.WebHeaderCollection" /> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
</para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><see langword="Expect" /> ist auf eine Zeichenfolge festgelegt, die "100-continue" als Teilzeichenfolge enthält.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="httpWebRequest.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashwert für eine <see cref="T:System.Net.WebRequest" />-Instanz zurück.</summary>
        <returns>Ein ganzzahliger Hashwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Die GetHashCode-Methode gibt einen Hashcode für die Webanforderung zurück. Dieser Wert kann als Schlüssel in Hash Tabellen verwendet werden.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Die mit Daten zu füllende <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="streamingContext">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />, der das Ziel für diese Serialisierung angibt.</param>
        <summary>Füllt eine <see cref="T:System.Runtime.Serialization.SerializationInfo" /> mit den Daten auf, die zum Serialisieren des Zielobjekts erforderlich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Objekte, die in der <xref:System.Runtime.Serialization.SerializationInfo> enthalten sind, werden vom Formatierer automatisch nachverfolgt und serialisiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein <see cref="T:System.IO.Stream" />-Objekt ab, das zum Schreiben von Anforderungsdaten verwendet werden soll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.IO.Stream" />-Objekt ab, das zum Schreiben von Anforderungsdaten verwendet werden soll.</summary>
        <returns>Ein <see cref="T:System.IO.Stream" />, der zum Schreiben von Anforderungsdaten verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-Methode gibt einen Datenstrom zurück, der zum Senden von Daten für die <xref:System.Net.HttpWebRequest>verwendet werden soll. Nachdem das <xref:System.IO.Stream> Objekt zurückgegeben wurde, können Sie mithilfe der <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>-Methode Daten mit dem <xref:System.Net.HttpWebRequest> senden.  
  
 Wenn eine Anwendung den Wert der <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft festlegen muss, muss dies vor dem Abrufen des Streams erfolgen.  
  
 Sie müssen die <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>-Methode aufzurufen, um den Stream zu schließen und die Verbindung für die Wiederverwendung freizugeben. Wenn Sie den Stream nicht schließen, wird für die Anwendung keine Verbindung mehr hergestellt.  
  
> [!NOTE]
>  In Ihrer Anwendung können keine synchronen und asynchronen Methoden für eine bestimmte Anforderung gemischt werden. Wenn Sie die <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-Methode aufrufen, müssen Sie die <xref:System.Net.HttpWebRequest.GetResponse%2A>-Methode verwenden, um die Antwort abzurufen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-Methode verwendet, um eine Datenstrom Instanz zurückzugeben.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">Die <see cref="P:System.Net.HttpWebRequest.Method" />-Eigenschaft ist GET oder HEAD.  
  
- oder - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> ist <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> ist <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" /> und <see cref="P:System.Net.HttpWebRequest.Method" /> ist POST oder PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />-Methode wurde mehrmals aufgerufen.  
  
- oder - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ist auf einen Wert festgelegt, und <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Anforderungcacheprüfung hat angezeigt, dass die Antwort auf diese Anforderung aus dem Cache erfolgen werden kann. Allerdings dürfen Anforderungen, die Daten schreiben, nicht den Cache verwenden. Diese Ausnahme kann auftreten, wenn Sie eine benutzerdefinierte Cacheprüfung verwenden, die nicht ordnungsgemäß implementiert ist.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.  
  
- oder - 
Das Zeitlimit für die Anforderung ist abgelaufen.  
  
- oder - 
Fehler beim Verarbeiten der Anforderung.</exception>
        <exception cref="T:System.ObjectDisposedException">In einer .NET Compact Framework-Anwendung wurde ein Anforderungsstream mit leerem Inhalt nicht ordnungsgemäß abgerufen und geschlossen. Weitere Informationen über das Verarbeiten von Anforderungen mit einem Inhalt der Länge 0 (null) finden Sie unter [Network Programming in the .NET Compact Framework (Netzwerkprogrammierung in .NET Compact Framework.)](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : TransportContext -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="context">Der <see cref="T:System.Net.TransportContext" /> für den <see cref="T:System.IO.Stream" />.</param>
        <summary>Ruft ein <see cref="T:System.IO.Stream" />-Objekt ab, das zum Schreiben von Anforderungsdaten verwendet wird und das dem Datenstrom zugeordnete <see cref="T:System.Net.TransportContext" /> ausgibt.</summary>
        <returns>Ein <see cref="T:System.IO.Stream" />, der zum Schreiben von Anforderungsdaten verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-Methode gibt einen Datenstrom zurück, mit dem Daten für die <xref:System.Net.HttpWebRequest> gesendet und die dem Stream zugeordneten <xref:System.Net.TransportContext> ausgegeben werden. Nachdem das <xref:System.IO.Stream> Objekt zurückgegeben wurde, können Sie mithilfe der <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>-Methode Daten mit dem <xref:System.Net.HttpWebRequest> senden.  
  
 Einige Anwendungen, die die integrierte Windows-Authentifizierung mit erweitertem Schutz verwenden, müssen möglicherweise die von <xref:System.Net.HttpWebRequest> verwendete Transportschicht Abfragen, um das channelbindungstoken (CBT) aus dem zugrunde liegenden TLS-Kanal abzurufen. Die <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-Methode ermöglicht den Zugriff auf diese Informationen für HTTP-Methoden, die über einen Anforderungs Text verfügen (`POST` und `PUT` Anforderungen). Dies ist nur erforderlich, wenn die Anwendung ihre eigene Authentifizierung implementiert und Zugriff auf das CBT benötigt.  
  
 Wenn eine Anwendung den Wert der <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft festlegen muss, muss dies vor dem Abrufen des Streams erfolgen.  
  
 Sie müssen die <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>-Methode aufzurufen, um den Stream zu schließen und die Verbindung für die Wiederverwendung freizugeben. Wenn Sie den Stream nicht schließen, wird für die Anwendung keine Verbindung mehr hergestellt.  
  
> [!NOTE]
>  In Ihrer Anwendung können keine synchronen und asynchronen Methoden für eine bestimmte Anforderung gemischt werden. Wenn Sie die <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-Methode aufrufen, müssen Sie die <xref:System.Net.HttpWebRequest.GetResponse%2A>-Methode verwenden, um die Antwort abzurufen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Die <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />-Methode konnte den <see cref="T:System.IO.Stream" /> nicht abrufen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />-Methode wurde mehrmals aufgerufen.  
  
- oder - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ist auf einen Wert festgelegt, und <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Anforderungcacheprüfung hat angezeigt, dass die Antwort auf diese Anforderung aus dem Cache erfolgen werden kann. Allerdings dürfen Anforderungen, die Daten schreiben, nicht den Cache verwenden. Diese Ausnahme kann auftreten, wenn Sie eine benutzerdefinierte Cacheprüfung verwenden, die nicht ordnungsgemäß implementiert ist.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">Die <see cref="P:System.Net.HttpWebRequest.Method" />-Eigenschaft ist GET oder HEAD.  
  
- oder - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> ist <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> ist <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" /> und <see cref="P:System.Net.HttpWebRequest.Method" /> ist POST oder PUT.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.  
  
- oder - 
Das Zeitlimit für die Anforderung ist abgelaufen.  
  
- oder - 
Fehler beim Verarbeiten der Anforderung.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Antwort von einer Internetressource zurück.</summary>
        <returns>Eine <see cref="T:System.Net.WebResponse" /> mit der Antwort von der Internetressource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.GetResponse%2A>-Methode gibt ein <xref:System.Net.WebResponse> Objekt zurück, das die Antwort von der Internet Ressource enthält. Die tatsächliche Instanz, die zurückgegeben wird, ist eine <xref:System.Net.HttpWebResponse>, die für den Zugriff auf HTTP-spezifische Eigenschaften in diese Klasse umgewandelt werden kann.  
  
 In einigen Fällen wird eine <xref:System.Net.ProtocolViolationException> ausgelöst, wenn die in der <xref:System.Net.HttpWebRequest>-Klasse festgelegten Eigenschaften in Konflikt stehen. Diese Ausnahme tritt auf, wenn eine Anwendung die <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft und die-Eigenschaft <xref:System.Net.HttpWebRequest.SendChunked%2A> auf `true`festlegt und dann eine HTTP GET-Anforderung sendet. Diese Ausnahme tritt auf, wenn eine Anwendung versucht, Segmente an einen Server zu senden, der nur das HTTP 1,0-Protokoll unterstützt. Dies wird nicht unterstützt. Diese Ausnahme tritt auf, wenn eine Anwendung versucht, Daten zu senden, ohne die <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft festzulegen, oder wenn die <xref:System.Net.HttpWebRequest.SendChunked%2A> `false` ist, wenn die Pufferung deaktiviert ist, und bei einer KeepAlive-Verbindung (die <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft `true`ist)`.`  
  
> [!CAUTION]
>  Sie müssen die <xref:System.Net.HttpWebResponse.Close%2A>-Methode aufzurufen, um den Stream zu schließen und die Verbindung freizugeben. Wenn dies nicht der Fall ist, kann Ihre Anwendung nicht mehr über Verbindungen verfügen.  
  
 Wenn Sie die Post-Methode verwenden, müssen Sie den Anforderungs Datenstrom erhalten, die zu sendenden Daten schreiben und den Stream schließen. Diese Methode blockiert das warten auf den Post-Inhalt. Wenn kein Timeout festgelegt ist und Sie keinen Inhalt bereitstellen, wird der Aufruf Thread unbegrenzt blockiert.  
  
> [!NOTE]
>  Mehrere Aufrufe von <xref:System.Net.HttpWebRequest.GetResponse%2A> das gleiche Antwortobjekt zurückgeben. die Anforderung wird nicht neu ausgestellt.  
  
> [!NOTE]
>  In Ihrer Anwendung können keine synchronen und asynchronen Methoden für eine bestimmte Anforderung gemischt werden. Wenn Sie die <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-Methode aufrufen, müssen Sie die <xref:System.Net.HttpWebRequest.GetResponse%2A>-Methode verwenden, um die Antwort abzurufen.  
  
> [!NOTE]
>  Wenn eine <xref:System.Net.WebException> ausgelöst wird, verwenden Sie die Eigenschaften <xref:System.Net.WebException.Response%2A> und <xref:System.Net.WebException.Status%2A> der Ausnahme, um die Antwort vom Server zu ermitteln.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Aus Sicherheitsgründen sind Cookies standardmäßig deaktiviert. Wenn Sie Cookies verwenden möchten, verwenden Sie die <xref:System.Net.HttpWebRequest.CookieContainer%2A>-Eigenschaft, um Cookies zu aktivieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Antwort für eine Anforderung abgerufen.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Stream wird bereits von einem vorherigen Aufruf von <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> verwendet.  
  
- oder - 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ist auf einen Wert festgelegt, und <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> ist GET oder HEAD, und <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist entweder größer oder gleich 0 (null), oder <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="true" />.  
  
- oder - 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> ist <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> ist <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" /> und <see cref="P:System.Net.HttpWebRequest.Method" /> ist POST oder PUT.  
  
- oder - 
<see cref="T:System.Net.HttpWebRequest" /> verfügt über einen Entitätskörper, die <see cref="M:System.Net.HttpWebRequest.GetResponse" />-Methode wird jedoch aufgerufen, ohne dass die <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />-Methode aufgerufen wird.  
  
- oder - 
<see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist größer als 0 (null), von der Anwendung werden jedoch nicht alle zugesagten Daten geschrieben.</exception>
        <exception cref="T:System.NotSupportedException">Die Anforderungcacheprüfung hat ergeben, dass die Antwort auf diese Anforderung aus dem Cache bereitgestellt werden kann. Allerdings umfasst diese Anforderung Daten, die an den Server gesendet werden müssen. Anforderungen, durch die Daten gesendet werden, dürfen keinen Cache verwenden. Diese Ausnahme kann auftreten, wenn Sie eine benutzerdefinierte Cacheprüfung verwenden, die nicht ordnungsgemäß implementiert ist.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.  
  
- oder - 
Das Zeitlimit für die Anforderung ist abgelaufen.  
  
- oder - 
Fehler beim Verarbeiten der Anforderung.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="C#" Value="public bool HaveResponse { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HaveResponse As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HaveResponse { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Antwort von einer Internetressource empfangen wurde.</summary>
        <value><see langword="true" />, wenn eine Antwort empfangen wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.HaveResponse%2A>-Eigenschaft überprüft, um zu bestimmen, ob eine Antwort von einer Internet Ressource empfangen wurde.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine Auflistung der Name-Wert-Paare an, aus denen sich die HTTP-Header zusammensetzen.</summary>
        <value>Eine <see cref="T:System.Net.WebHeaderCollection" /> mit den Name-Wert-Paaren, aus denen sich die Header für die HTTP-Anforderung zusammensetzen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Headers%2A>-Auflistung enthält die Protokoll Header, die der Anforderung zugeordnet sind. In der folgenden Tabelle werden die HTTP-Header aufgelistet, die nicht in der <xref:System.Net.HttpWebRequest.Headers%2A>-Auflistung gespeichert sind, jedoch entweder vom System festgelegt oder durch Eigenschaften oder Methoden festgelegt werden.  
  
|Header|Festgelegt von|  
|------------|------------|  
|Accept|Wird von der <xref:System.Net.HttpWebRequest.Accept%2A>-Eigenschaft festgelegt.|  
|Verbindung|Wird von der <xref:System.Net.HttpWebRequest.Connection%2A>-Eigenschaft und <xref:System.Net.HttpWebRequest.KeepAlive%2A>-Eigenschaft festgelegt.|  
|Inhalts Länge|Wird von der <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft festgelegt.|  
|Inhaltstyp|Wird von der <xref:System.Net.HttpWebRequest.ContentType%2A>-Eigenschaft festgelegt.|  
|Expect|Wird von der <xref:System.Net.HttpWebRequest.Expect%2A>-Eigenschaft festgelegt.|  
|Datum|Wird von der <xref:System.Net.HttpWebRequest.Date%2A>-Eigenschaft festgelegt.|  
|Host|Wird von der <xref:System.Net.HttpWebRequest.Host%2A>-Eigenschaft festgelegt.|  
|If-Modified-Since|Wird von der <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>-Eigenschaft festgelegt.|  
|Bereich|Wird durch die <xref:System.Net.HttpWebRequest.AddRange%2A>-Methode festgelegt.|  
|Referer|Wird von der <xref:System.Net.HttpWebRequest.Referer%2A>-Eigenschaft festgelegt.|  
|Übertragungs Codierung|Wird von der <xref:System.Net.HttpWebRequest.TransferEncoding%2A>-Eigenschaft festgelegt (die <xref:System.Net.HttpWebRequest.SendChunked%2A>-Eigenschaft muss "true" lauten).|  
|User-Agent|Wird von der <xref:System.Net.HttpWebRequest.UserAgent%2A>-Eigenschaft festgelegt.|  
  
 Durch die <xref:System.Net.WebHeaderCollection.Add%2A>-Methode wird eine <xref:System.ArgumentException> ausgelöst, wenn Sie versuchen, einen dieser geschützten Header festzulegen.  
  
 Wenn Sie die <xref:System.Net.HttpWebRequest.Headers%2A>-Eigenschaft ändern, nachdem die Anforderung durch Aufrufen von <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode gestartet wurde, wird ein <xref:System.InvalidOperationException>ausgelöst.  
  
 Sie sollten nicht davon ausgehen, dass die Header Werte unverändert bleiben, da Webserver und Caches eine Webanforderung ändern oder Header hinzufügen können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.Headers%2A>-Eigenschaft verwendet, um die Name-Wert-Paare der http-Kopfzeile in der Konsole auszugeben.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Anforderung wurde durch Aufrufen der Methode <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> oder <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> gestartet.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Hostheaderwert ab, der in einer HTTP-Anforderung unabhängig vom Anforderungs-URI verwendet werden soll, oder legt ihn fest.</summary>
        <value>Der Hostheaderwert in der HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Host%2A> Eigenschaft kann verwendet werden, um den Host-Headerwert für die Verwendung in einer HTTP-Anforderung unabhängig vom Anforderungs-URI festgelegt. Die <xref:System.Net.HttpWebRequest.Host%2A>-Eigenschaft kann aus einem Hostnamen und einer optionalen Portnummer bestehen. Ein Host Header ohne Port Informationen impliziert den Standardport für den angeforderten Dienst (z. b. Port 80 für eine HTTP-URL).  
  
 Das Format zum Angeben eines Hosts und Ports muss den Regeln im Abschnitt 14,23 von rfc2616 entsprechen, die vom IETF veröffentlicht werden. Ein Beispiel für die Erfüllung dieser Anforderungen, die den Port 8080 angibt, wäre der folgende Wert für die <xref:System.Net.HttpWebRequest.Host%2A>-Eigenschaft:  
  
 `www.contoso.com:8080`  
  
 Wenn Sie die <xref:System.Net.HttpWebRequest.Host%2A>-Eigenschaft verwenden, um einen benutzerdefinierten Host Header Wert explizit anzugeben, wirkt sich dies auch auf Zwischenspeicherung, Cookies und Authentifizierung aus Wenn eine Anwendung Anmelde Informationen für ein bestimmtes URI-Präfix bereitstellt, müssen die Anwendungen sicherstellen, dass der URI, der den Wert des Host Headers enthält, nicht der Zielserver im URI verwendet wird. Der Schlüssel, der beim Zwischenspeichern von Ressourcen verwendet wird, verwendet den Host Header Wert anstelle des Anforderungs-URI. Cookies werden in einem <xref:System.Net.CookieContainer> gespeichert und logisch nach dem Server Domänen Namen gruppiert. Wenn die Anwendung einen Host Header angibt, wird dieser Wert als Domäne verwendet.  
  
 Wenn die <xref:System.Net.HttpWebRequest.Host%2A>-Eigenschaft nicht festgelegt ist, basiert der Host Header Wert, der in einer HTTP-Anforderung verwendet werden soll, auf dem Anforderungs-URI.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Hostheader kann nicht auf <see langword="null" /> festgelegt werden.</exception>
        <exception cref="T:System.ArgumentException">Der Hostheader kann nicht auf einen ungültigen Wert festgelegt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Hostheader kann nicht festgelegt werden, nachdem das Senden von <see cref="T:System.Net.HttpWebRequest" /> bereits gestartet wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="If-Modified-Since" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Eine <see cref="T:System.DateTime" /> mit dem Inhalt des <see langword="If-Modified-Since" />-HTTP-Headers. Der Standardwert ist das aktuelle Datum und die aktuelle Uhrzeit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>-Eigenschaft ist ein Standard <xref:System.DateTime?displayProperty=nameWithType> Objekt und kann ein <xref:System.DateTimeKind?displayProperty=nameWithType> Feld mit <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>oder <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>enthalten. Jede Art von Zeit kann festgelegt werden, wenn die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>-Eigenschaft verwendet wird. Wenn <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> festgelegt oder abgerufen wird, wird davon ausgegangen, dass die Eigenschaft <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (Ortszeit) ist.  
  
 Die Klassen im <xref:System.Net>-Namespace schreiben <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Sie immer bei der Übertragung während der Übertragung in Standardform im GMT (UTC)-Format.  
  
 Wenn die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>-Eigenschaft auf <xref:System.DateTime.MinValue?displayProperty=nameWithType>festgelegt ist, wird der `If-Modified-Since`-HTTP-Header aus der <xref:System.Net.HttpWebRequest.Headers%2A>-Eigenschaft und der <xref:System.Net.WebHeaderCollection>entfernt.  
  
 Wenn die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>-Eigenschaft <xref:System.DateTime.MinValue?displayProperty=nameWithType>ist, bedeutet dies, dass der `If-Modified-Since`-HTTP-Header nicht in der <xref:System.Net.HttpWebRequest.Headers%2A>-Eigenschaft und <xref:System.Net.WebHeaderCollection>enthalten ist.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>-Eigenschaft überprüft.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine permanente Verbindung mit der Internetressource hergestellt werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Anforderung an die Internetressource einen <see langword="Connection" />-HTTP-Header mit dem KeepAlive-Wert enthalten soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf `true` fest, um einen `Connection`-HTTP-Header mit dem Wert Keep-Alive zu senden. Eine Anwendung verwendet <xref:System.Net.HttpWebRequest.KeepAlive%2A>, um eine Einstellung für persistente Verbindungen anzugeben. Wenn die <xref:System.Net.HttpWebRequest.KeepAlive%2A>-Eigenschaft `true`ist, führt die Anwendung permanente Verbindungen zu den Servern aus, die Sie unterstützen.  
  
> [!NOTE]
>  Bei Verwendung von HTTP/1.1 ist Keep-Alive standardmäßig aktiviert. Wenn Sie <xref:System.Net.HttpWebRequest.KeepAlive%2A> auf `false` festlegen, kann dies dazu führen, dass ein `Connection: Close` Header an den Server gesendet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.KeepAlive%2A>-Eigenschaft auf `false` festgelegt, um zu vermeiden, dass eine permanente Verbindung mit der Internet Ressource hergestellt wird.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Anzahl von Umleitungen ab, denen die Anforderung folgt, oder legt diese fest.</summary>
        <value>Die maximale Anzahl von Umleitungsantworten, denen die Anforderung folgt. Der Standardwert ist 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A>-Eigenschaft legt die maximale Anzahl von Umleitungen fest, nach denen die Anforderung befolgt werden soll, wenn die <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>-Eigenschaft `true`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert dieser Eigenschaft festgelegt.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert wird auf 0 oder weniger festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximal zulässige Länge der Antwortheader ab oder legt diese fest.</summary>
        <value>Die Länge der Antwortheader in KB (1024 Bytes).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Länge des Antwort Headers umfasst die Antwortstatus Zeile und alle zusätzlichen Steuerungs Zeichen, die als Teil des HTTP-Protokolls empfangen werden. Der Wert-1 bedeutet, dass für die Antwortheader keine Beschränkung festgelegt wird. der Wert 0 bedeutet, dass alle Anforderungen fehlschlagen.  
  
 Wenn die <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>-Eigenschaft nicht explizit festgelegt ist, wird standardmäßig der Wert der <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A>-Eigenschaft verwendet.  
  
 Wenn die Länge des empfangenen Antwort Headers den Wert der <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>-Eigenschaft überschreitet, lösen die Methoden <xref:System.Net.HttpWebRequest.EndGetResponse%2A> oder <xref:System.Net.HttpWebRequest.GetResponse%2A> eine <xref:System.Net.WebException> aus, bei der die <xref:System.Net.WebException.Status%2A>-Eigenschaft auf <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert dieser Eigenschaft festgelegt.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Eigenschaft wird festgelegt, nachdem die Anforderung bereits gesendet wurde.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert ist kleiner als 0 (null) und ungleich -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Medientyp der Anforderung ab oder legt diesen fest.</summary>
        <value>Der Medientyp der Anforderung. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert der <xref:System.Net.HttpWebRequest.MediaType%2A>-Eigenschaft wirkt sich auf die <xref:System.Net.HttpWebResponse.CharacterSet%2A>-Eigenschaft aus. Wenn Sie die <xref:System.Net.HttpWebRequest.MediaType%2A> in der Anforderung festlegen, wird der entsprechende Medientyp aus der Liste der Zeichensätze ausgewählt, die im Antwort `Content-type`-HTTP-Header zurückgegeben werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Methode für die Anforderung ab oder legt diese fest.</summary>
        <value>Die Anforderungsmethode zum Herstellen der Verbindung mit der Internetressource. Der Standardwert ist GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Method%2A>-Eigenschaft kann auf einen der HTTP 1,1-Protokoll Verben festgelegt werden: Get, Head, Post, Put, DELETE, Trace oder Options.  
  
 Wenn die <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft auf einen anderen Wert als-1 festgelegt ist, muss die <xref:System.Net.HttpWebRequest.Method%2A>-Eigenschaft auf eine Protokoll Eigenschaft festgelegt werden, mit der Daten hochgeladen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.Method%2A>-Eigenschaft auf Post festgelegt.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wurde keine Methode bereitgestellt.  
  
 - oder -  
  
 Die Methodenzeichenfolge enthält ungültige Zeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anforderung über Pipelineverbindungen zur Internetressource gesendet werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Anforderung über Pipelineverbindungen gesendet werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung verwendet die <xref:System.Net.HttpWebRequest.Pipelined%2A>-Eigenschaft, um eine Einstellung für Pipeline Verbindungen anzugeben. Wenn <xref:System.Net.HttpWebRequest.Pipelined%2A> `true`ist, werden von einer Anwendung Pipeline Verbindungen zu den Servern hergestellt, von denen Sie unterstützt werden.  
  
 Pipeline Verbindungen werden nur hergestellt, wenn die <xref:System.Net.HttpWebRequest.KeepAlive%2A>-Eigenschaft ebenfalls `true`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der <xref:System.Net.HttpWebRequest.Pipelined%2A>-Eigenschaft auf der Konsole ausgegeben.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob mit der Anforderung ein Autorisierungsheader gesendet wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, um nach der Authentifizierung einen Authorization-HTTP-Header mit Anforderungen zu senden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Client Anforderung an eine bestimmte <xref:System.Uri> erfolgreich authentifiziert wurde, wenn <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> `true` und Anmelde Informationen bereitgestellt werden, wird der Autorisierungs Header mit jeder Anforderung an jede <xref:System.Uri> gesendet, die mit der spezifischen <xref:System.Uri> bis zum letzten Schrägstrich übereinstimmt. Wenn sich die Client Anforderung für eine bestimmte <xref:System.Uri> authentifiziert hat, die Folgendes enthält:  
  
 `http://www.contoso.com/firstpath/`  
  
 Anschließend wird der Autorisierungs Header für die Vorauthentifizierung mit jeder Anforderung an eine der folgenden <xref:System.Uri> Instanzen gesendet:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Der Autorisierungs Header wird jedoch nicht mit Anforderungen an eine der folgenden <xref:System.Uri> Instanzen gesendet:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Wenn die Client Anforderung an einen bestimmten <xref:System.Uri> nicht erfolgreich authentifiziert wird, verwendet die Anforderung Standard Authentifizierungs Prozeduren.  
  
 Mit Ausnahme der ersten Anforderung gibt die <xref:System.Net.WebRequest.PreAuthenticate%2A>-Eigenschaft an, ob Authentifizierungsinformationen mit nachfolgenden Anforderungen an einen <xref:System.Uri> gesendet werden sollen, der mit dem spezifischen <xref:System.Uri> bis zum letzten Schrägstrich übereinstimmt, ohne dass darauf gewartet wird, dass der Server auf die Warteschlange gestellt wird.  
  
 Das folgende Dialogfeld zwischen Client und Server veranschaulicht die Auswirkung dieser Eigenschaft. Im Dialogfeld wird davon ausgegangen, dass die Standard Authentifizierung verwendet wird.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> ist `false`:  
  
 Client: Get someurl  
  
 Server: 401 WWW-Authenticate Basic  
  
 Client: erhalten Sie Autorisierungs Header.  
  
 Server: 200 OK  
  
 Client: Get someurl  
  
 Server: 401 WWW-Authenticate Basic  
  
 Client: erhalten Sie Autorisierungs Header.  
  
 Server: 200 OK  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> ist `true`:  
  
 Client: Get someurl  
  
 Server: 401 WWW-Authenticate Basic  
  
 Client: erhalten Sie Autorisierungs Header.  
  
 Server: 200 OK  
  
 Client: someurl mit Autorisierungs Headern erhalten  
  
 Wenn das Authentifizierungsschema die Vorauthentifizierung nicht unterstützt, wird der Wert dieser Eigenschaft ignoriert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für die Anforderung zu verwendende HTTP-Version ab oder legt diese fest.</summary>
        <value>Die für die Anforderung zu verwendende HTTP-Version. Der Standardwert ist <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest>-Klasse unterstützt nur die Versionen 1,0 und 1,1 von http. Wenn <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> auf eine andere Version festgelegt wird, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Um die HTTP-Version der aktuellen Anforderung festzulegen, verwenden Sie die Felder <xref:System.Net.HttpVersion.Version10> und <xref:System.Net.HttpVersion.Version11> der <xref:System.Net.HttpVersion>-Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.ProtocolVersion%2A>-Eigenschaft festgelegt.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die HTTP-Version wird auf einen anderen Wert als 1.0 oder 1.1 festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Proxyinformationen für die Anforderung ab oder legt diese fest.</summary>
        <value>Das <see cref="T:System.Net.IWebProxy" />-Objekt, das als Proxy für die Anforderung verwendet werden soll. Der Standardwert wird durch Aufrufen der <see cref="P:System.Net.GlobalProxySelection.Select" />-Eigenschaft festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Proxy%2A>-Eigenschaft identifiziert das <xref:System.Net.WebProxy> Objekt, das zum Verarbeiten von Anforderungen an Internet Ressourcen verwendet werden soll. Um anzugeben, dass kein Proxy verwendet werden soll, legen Sie die <xref:System.Net.HttpWebRequest.Proxy%2A>-Eigenschaft auf die Proxy Instanz fest, die von der <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType>-Methode zurückgegeben wird.  
  
 Der lokale Computer oder die Anwendungs Konfigurationsdatei kann angeben, dass ein Standard Proxy verwendet werden soll. Wenn die <xref:System.Net.HttpWebRequest.Proxy%2A>-Eigenschaft angegeben ist, überschreiben die Proxy Einstellungen der <xref:System.Net.HttpWebRequest.Proxy%2A>-Eigenschaft den lokalen Computer bzw. die Anwendungs Konfigurationsdatei, und die <xref:System.Net.HttpWebRequest> Instanz verwendet die angegebenen Proxy Einstellungen. Wenn kein Proxy in einer Konfigurationsdatei angegeben ist und die <xref:System.Net.HttpWebRequest.Proxy%2A>-Eigenschaft nicht angegeben ist, verwendet die <xref:System.Net.HttpWebRequest>-Klasse die Proxy Einstellungen, die von Internet Explorer auf dem lokalen Computer geerbt wurden. Wenn in Internet Explorer keine Proxy Einstellungen vorhanden sind, wird die Anforderung direkt an den Server gesendet.  
  
 Die <xref:System.Net.HttpWebRequest>-Klasse analysiert eine Proxy Umgehungs Liste mit Platzhalter Zeichen, die von Internet Explorer geerbt wurden, genauso, wie die Umgehungs Liste direkt von Internet Explorer analysiert wird. Beispielsweise wird die <xref:System.Net.HttpWebRequest>-Klasse eine Umgehungs Liste von "NT *" aus Internet Explorer als regulärer Ausdruck "NT.\*" analysieren. Eine URL vom Typ "`http://nt.com`" würde also den Proxy umgehen, indem er die <xref:System.Net.HttpWebRequest>-Klasse und Internet Explorer verwendet.  
  
 Die <xref:System.Net.HttpWebRequest>-Klasse unterstützt die lokale Proxy Umgehung. Wenn eine der folgenden Bedingungen erfüllt ist, wird ein Ziel von der-Klasse als Local betrachtet:  
  
-   Das Ziel enthält einen flachen Namen (keine Punkte in der URL).  
  
-   Das Ziel enthält eine Loopback Adresse (<xref:System.Net.IPAddress.Loopback> oder <xref:System.Net.IPAddress.IPv6Loopback>), oder das Ziel enthält eine <xref:System.Net.IPAddress>, die dem lokalen Computer zugewiesen ist.  
  
-   Das Domänen Suffix des Ziels stimmt mit dem Domänen Suffix (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>) des lokalen Computers überein.  
  
 Wenn Sie die <xref:System.Net.HttpWebRequest.Proxy%2A>-Eigenschaft ändern, nachdem die Anforderung durch Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>-, <xref:System.Net.HttpWebRequest.GetResponse%2A>-oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>-Methode gestartet wurde, wird ein <xref:System.InvalidOperationException>ausgelöst. Weitere Informationen zum Proxy Element finden Sie unter [\&lt; defaultProxy\&gt; -Element (Netzwerkeinstellungen)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.Proxy%2A>-Methode verwendet, um die Proxy Informationen für die Anforderung zu erhalten.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Für <see cref="P:System.Net.HttpWebRequest.Proxy" /> ist <see langword="null" /> festgelegt.</exception>
        <exception cref="T:System.InvalidOperationException">Die Anforderung wurde durch Aufrufen von <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> oder <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> gestartet.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <permission cref="T:System.Net.WebPermission">, Um die <see cref="P:System.Net.HttpWebRequest.Proxy" />-Eigenschaft zu erhalten oder festzulegen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/bb707c72-eed2-4a82-8800-c9e68df2fd4f">Konfigurieren von Internetanwendungen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/353c0a8b-4cee-44f6-8e65-60e286743df9">Proxykonfiguration</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fcd9c3bd-93de-4c92-8ff3-837327ad18de">Automatische Proxyerkennung</related>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Timeout in Millisekunden für das Schreiben in einen Stream oder das Lesen aus einem Stream ab oder legt dieses fest.</summary>
        <value>Die Anzahl der Millisekunden vor dem Timeout für das Schreiben oder lesen. Der Standardwert ist 300.000 Millisekunden (5 Minuten).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>-Eigenschaft wird beim Schreiben in den Stream verwendet, der von der <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-Methode zurückgegeben wird, oder aus dem von der <xref:System.Net.HttpWebResponse.GetResponseStream%2A>-Methode zurückgegebenen Stream.  
  
 Die <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>-Eigenschaft steuert insbesondere das Timeout für die <xref:System.IO.Stream.Read%2A>-Methode, die zum Lesen des Streams verwendet wird, der von der <xref:System.Net.HttpWebResponse.GetResponseStream%2A>-Methode zurückgegeben wird, und für die <xref:System.IO.Stream.Write%2A>-Methode, die zum Schreiben in den von der <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-Methode zurückgegebenen Stream verwendet wird.  
  
 Verwenden Sie die <xref:System.Net.HttpWebRequest.Timeout%2A>-Eigenschaft, um die Zeitspanne anzugeben, die auf den Abschluss der Anforderung gewartet werden soll.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>-Eigenschaft festgelegt wird.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Anforderung wurde bereits gesendet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen SET-Vorgang angegebene Wert ist kleiner oder gleich 0 (null) und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="Referer" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Wert des <see langword="Referer" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>-Eigenschaft `true`ist, wird die Eigenschaft <xref:System.Net.HttpWebRequest.Referer%2A> automatisch festgelegt, wenn die Anforderung an einen anderen Standort umgeleitet wird.  
  
 Legen Sie die Eigenschaft <xref:System.Net.HttpWebRequest.Referer%2A> auf `null`fest, um den `Referer`-HTTP-Header zu löschen.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Eigenschaft auf <xref:System.Net.HttpWebRequest.Referer%2A> festgelegt.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den ursprünglichen URI (Uniform Resource Identifier) der Anforderung ab.</summary>
        <value>Ein <see cref="T:System.Uri" /> mit dem URI der Internetressource, der an die <see cref="M:System.Net.WebRequest.Create(System.String)" />-Methode übergeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Uri> Objekt, das durch den-Befehl <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>an <xref:System.Net.HttpWebRequest> übertragen wird.  
  
 Wenn ein Umleitungs Header folgt, wird die <xref:System.Net.HttpWebRequest.RequestUri%2A>-Eigenschaft nicht geändert. Um den tatsächlichen URI zu erhalten, der auf die Anforderung geantwortet hat, überprüfen Sie die <xref:System.Net.HttpWebRequest.Address%2A>-Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob das <xref:System.Net.HttpWebRequest> Objekt `req` an einen anderen Speicherort umgeleitet wurde, um die Anforderung zu erfüllen, und legt den Wert der `hasChanged` Variablen auf `true` fest, wenn die Anforderung umgeleitet wurde. Andernfalls wird `hasChanged` auf `false`festgelegt.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Daten in Segmenten an die Internetressource gesendet werden sollen, oder legt diesen fest.</summary>
        <value><see langword="true" />, um die Daten in Segmenten an die Internetressource zu senden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.HttpWebRequest.SendChunked%2A> `true`ist, sendet die Anforderung Daten in Segmenten an die Internet Ressource. Die Internet Ressource muss das Empfangen von segmentierten Daten unterstützen.  
  
 Wenn Sie die <xref:System.Net.HttpWebRequest.SendChunked%2A>-Eigenschaft ändern, nachdem die Anforderung durch Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>-, <xref:System.Net.HttpWebRequest.GetResponse%2A>-oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>-Methode gestartet wurde, wird ein <xref:System.InvalidOperationException>ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.SendChunked%2A>-Eigenschaft auf `true` festgelegt, damit Daten in Segmenten an die Internet Ressource gesendet werden können.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Anforderung wurde durch Aufrufen der Methode <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> oder <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> gestartet.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Rückruffunktion zur Überprüfung des Serverzertifikats ab oder legt diese fest.</summary>
        <value>Eine Rückruffunktion zur Überprüfung des Serverzertifikats.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert ist, dass keine Rückruffunktion festgelegt ist und die <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A>-Eigenschaft `null`ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den für die Anforderung zu verwendenden Dienstpunkt ab.</summary>
        <value>Ein <see cref="T:System.Net.ServicePoint" />, der die Netzwerkverbindung mit der Internetressource darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType>-Eigenschaft kann sich von <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> unterscheiden, wenn die Anforderung umgeleitet wird.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anforderung Unterstützung für einen <see cref="T:System.Net.CookieContainer" /> bereitstellt.</summary>
        <value><see langword="true" />, wenn die Anforderung Unterstützung für eine <see cref="T:System.Net.CookieContainer" />bereitstellt. Andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Die mit Daten zu füllende <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="streamingContext">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />, der das Ziel für diese Serialisierung angibt.</param>
        <summary>Füllt eine <see cref="T:System.Runtime.Serialization.SerializationInfo" /> mit den Daten auf, die zum Serialisieren des Zielobjekts erforderlich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Objekte, die in der <xref:System.Runtime.Serialization.SerializationInfo> enthalten sind, werden vom Formatierer automatisch nachverfolgt und serialisiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Timeoutwert in Millisekunden für die <see cref="M:System.Net.HttpWebRequest.GetResponse" />-Methode und die <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />-Methode ab oder legt diesen fest.</summary>
        <value>Die Anzahl der Millisekunden, die gewartet werden soll, bevor für die Anforderung ein Timeout eintritt. Der Standardwert ist 100.000 Millisekunden (100 Sekunden).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> ist die Anzahl von Millisekunden, die eine nachfolgende synchrone Anforderung, die mit der <xref:System.Net.HttpWebRequest.GetResponse%2A>-Methode erfolgt, auf eine Antwort wartet, und die <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-Methode wartet auf einen Stream. Der <xref:System.Net.HttpWebRequest.Timeout%2A> gilt für die gesamte Anforderung und Antwort, nicht einzeln für die <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-und <xref:System.Net.HttpWebRequest.GetResponse%2A> Methodenaufrufe. Wenn die Ressource nicht innerhalb des Timeout Zeitraums zurückgegeben wird, löst die Anforderung eine <xref:System.Net.WebException> aus, bei der die <xref:System.Net.WebException.Status%2A>-Eigenschaft auf <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>festgelegt ist.  
  
 Die <xref:System.Net.HttpWebRequest.Timeout%2A>-Eigenschaft muss festgelegt werden, bevor die <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-oder <xref:System.Net.HttpWebRequest.GetResponse%2A>-Methode aufgerufen wird. Das Ändern der <xref:System.Net.HttpWebRequest.Timeout%2A>-Eigenschaft nach dem Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A>-oder <xref:System.Net.HttpWebRequest.GetResponse%2A>-Methode hat keine Auswirkungen.  
  
 Die <xref:System.Net.HttpWebRequest.Timeout%2A>-Eigenschaft wirkt sich nicht auf asynchrone Anforderungen aus, die mit der <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>-oder <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>-Methode vorgenommen wurden.  
  
> [!CAUTION]
>  Im Fall von asynchronen Anforderungen implementiert die Client Anwendung ihren eigenen Timeout Mechanismus. Weitere Informationen finden Sie im Beispiel in der <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>-Methode.  
  
 Verwenden Sie die <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>-Eigenschaft, um die Zeitspanne anzugeben, die vor dem Timeout eines Lese-oder Schreibvorgangs gewartet werden soll.  
  
 Eine Domain Name System (DNS)-Abfrage kann bis zu 15 Sekunden dauern, bis eine Rückgabe oder ein Timeout auftritt. Wenn Ihre Anforderung einen Hostnamen enthält, der aufgelöst werden muss, und Sie <xref:System.Net.FileWebRequest.Timeout%2A> auf einen Wert weniger als 15 Sekunden festlegen, kann es 15 Sekunden oder länger dauern, bis ein <xref:System.Net.WebException> ausgelöst wird, um ein Timeout für die Anforderung anzugeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.Timeout%2A>-Eigenschaft des <xref:System.Net.HttpWebRequest>-Objekts festgelegt.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der angegebene Wert ist kleiner als null (0) und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="Transfer-encoding" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Wert des <see langword="Transfer-encoding" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bevor Sie die <xref:System.Net.HttpWebRequest.TransferEncoding%2A>-Eigenschaft festlegen können, müssen Sie zunächst die Eigenschaft <xref:System.Net.HttpWebRequest.SendChunked%2A> auf `true`festlegen. Das Löschen <xref:System.Net.HttpWebRequest.TransferEncoding%2A> durch Festlegen auf `null` hat keine Auswirkung auf den Wert von <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Werte, die der <xref:System.Net.HttpWebRequest.TransferEncoding%2A>-Eigenschaft zugewiesen sind, ersetzen jeglichen vorhandenen Inhalt.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> wird festgelegt, wenn <see cref="P:System.Net.HttpWebRequest.SendChunked" /> den Wert <see langword="false" /> aufweist.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> wird auf den Wert "Chunked" festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Freigabe NTLM-authentifizierter Hochgeschwindigkeitsverbindungen zulässig ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, um die authentifizierte Verbindung geöffnet zu halten, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für diese Eigenschaft ist `false`, was bewirkt, dass die aktuelle Verbindung geschlossen wird, nachdem eine Anforderung abgeschlossen wurde. Die Anwendung muss die Authentifizierungs Sequenz jedes Mal durchlaufen, wenn eine neue Anforderung ausgegeben wird.  
  
 Wenn diese Eigenschaft auf `true`festgelegt ist, bleibt die zum Abrufen der Antwort verwendete Verbindung geöffnet, nachdem die Authentifizierung durchgeführt wurde. In diesem Fall können andere Anforderungen, bei denen diese Eigenschaft auf `true` festgelegt ist, die Verbindung ohne erneute Authentifizierung verwenden. Anders ausgedrückt: Wenn eine Verbindung für Benutzer a authentifiziert wurde, kann Benutzer B eine Verbindung wieder verwenden. die Anforderung von Benutzer B wird basierend auf den Anmelde Informationen von Benutzer a erfüllt.  
  
> [!CAUTION]
>  Da es für eine Anwendung möglich ist, die Verbindung ohne Authentifizierung zu verwenden, müssen Sie sicherstellen, dass in Ihrem System keine Verwaltungs Anfälligkeit vorhanden ist, wenn Sie diese Eigenschaft auf `true`festlegen. Wenn Ihre Anwendung Anforderungen für mehrere Benutzer sendet (die Identität mehrerer Benutzerkonten annimmt) und die Authentifizierung zum Schützen von Ressourcen verwendet, sollten Sie diese Eigenschaft nicht auf `true` festlegen, es sei denn, Sie verwenden Verbindungs Gruppen wie unten beschrieben.  
  
 Möglicherweise möchten Sie diesen Mechanismus aktivieren, wenn Ihre Anwendung Leistungsprobleme aufweist und die Anwendung auf einem Webserver mit integrierter Windows-Authentifizierung ausgeführt wird.  
  
 Wenn Sie diese Einstellung aktivieren, werden Sicherheitsrisiken für das System geöffnet. Wenn Sie die <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A>-Eigenschaft auf festlegen `true` müssen Sie die folgenden Vorkehrungen treffen:  
  
-   Verwenden Sie die <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A>-Eigenschaft, um Verbindungen für verschiedene Benutzer zu verwalten. Dadurch wird die potenzielle Verwendung der Verbindung durch nicht authentifizierte Anwendungen vermieden. Beispielsweise sollte Benutzer a einen eindeutigen Namen der Verbindungsgruppe aufweisen, der sich von Benutzer B unterscheidet. Dadurch wird für jedes Benutzerkonto eine Isolationsschicht bereitstellt.  
  
-   Führen Sie Ihre Anwendung in einer geschützten Umgebung aus, um mögliche Verbindungs Exploits zu vermeiden.  
  
 Wenn Sie den Back-End-Server steuern, können Sie als Alternative die Authentifizierungs Persistenz deaktivieren. Dies erhöht die Leistung in geringerem Maße, ist aber sicherer. Weitere Informationen finden Sie in der MSDN Library unter [https://msdn.microsoft.com/library](https://msdn.microsoft.com/library)in der MSDN Library.  
  
> [!NOTE]
>  Wenn sowohl <xref:System.Net.WebRequest.PreAuthenticate%2A> als auch <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> auf `true`festgelegt sind, wird jede Anforderung mit einer Verbindung aus dem unsicheren Pool gesendet, jedoch mit einem Autorisierungs Header.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Zum Festlegen dieser Eigenschaft ist eine uneingeschränkte Web-Berechtigung erforderlich.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der steuert, ob mit den Anforderungen Standardanmeldeinformationen gesendet werden, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Standardanmeldeinformationen verwendet werden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf `true` fest, wenn von diesem <xref:System.Net.HttpWebRequest> Objekt vorgenommene Anforderungen durch den Server mithilfe der Anmelde Informationen des aktuell angemeldeten Benutzers authentifiziert werden sollen. Bei Client Anwendungen ist dies das gewünschte Verhalten in den meisten Szenarien. Für Anwendungen der mittleren Ebene, z. b. ASP.NET-Anwendungen, legen Sie die <xref:System.Net.HttpWebRequest.Credentials%2A>-Eigenschaft in der Regel auf die Anmelde Informationen des Clients fest, für den die Anforderung erfolgt ist, anstatt diese Eigenschaft zu verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Sie haben versucht, diese Eigenschaft nach dem Senden der Anforderung festzulegen.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="User-agent" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Wert des <see langword="User-agent" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 Der Wert für diese Eigenschaft wird in der <see cref="T:System.Net.WebHeaderCollection" /> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Eigenschaft auf <xref:System.Net.HttpWebRequest.UserAgent%2A> festgelegt.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
