<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7e369a0b3e7163d5656a4e4438a7c8ef86b94cb1" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53391955" /></Metadata><TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.FriendAccessAllowed</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine HTTP-spezifische Implementierung der <see cref="T:System.Net.WebRequest" />-Klasse bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
>  Es wird nicht empfohlen, die Verwendung von `HttpWebRequest` für neue Entwicklungen. Verwenden Sie stattdessen die <xref:System.Net.Http.HttpClient?displayProperty=nameWithType> Klasse.

 Die <xref:System.Net.HttpWebRequest> -Klasse bietet Unterstützung für die Eigenschaften und Methoden definiert, <xref:System.Net.WebRequest> und zusätzliche Eigenschaften und Methoden, die den Benutzer, die direkte Interaktion mit den Servern, die über HTTP zu ermöglichen.  
  
 Verwenden Sie nicht die <xref:System.Net.HttpWebRequest.%23ctor%2A> Konstruktor. Verwenden der <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> Methode zum Initialisieren neuer <xref:System.Net.HttpWebRequest> Objekte. Wenn das Schema für den Uniform Resource Identifier (URI) ist `http://` oder `https://`, <xref:System.Net.WebRequest.Create%2A> gibt ein <xref:System.Net.HttpWebRequest> Objekt.  
  
 Die <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode führt eine synchrone Anforderung an die Ressource im angegebenen die <xref:System.Net.HttpWebRequest.RequestUri%2A> Eigenschaft und gibt eine <xref:System.Net.HttpWebResponse> , enthält das Response-Objekt. Die Antwortdaten können empfangen werden, mithilfe des von zurückgegebenen Streams <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Wenn das Response-Objekt oder der Antwortstream geschlossen ist, werden Verbleibende Daten verfallen. Die übrigen Daten werden ausgeglichen werden, und der Socket werden für nachfolgende Anforderungen wiederverwendet, wenn die Response-Objekt oder den Stream zu schließen, wenn die folgenden Bedingungen enthalten: eine Keep-alive oder Pipeline-Anforderung ist, muss nur eine kleine Menge Daten empfangen werden, oder Verbleibende Daten wird in einem kurzen Zeitraum empfangen. Wenn keine der genannten Bedingungen enthalten, oder die Ausgleichsmodus Zeit überschritten wird, wird der Socket geschlossen werden. Es wird dringend empfohlen, dass die Anwendung die Datenströme bis EOF liest, für Keep-alive oder Pipeline-Verbindungen. Dadurch wird sichergestellt, dass der Socket wiederverwendet für nachfolgende Anforderungen, wodurch eine bessere Leistung und weniger Ressourcen, die verwendet werden.  
  
 Wenn Sie zum Senden von Daten an die Ressource möchten, die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Methode gibt eine <xref:System.IO.Stream> Objekt, das zum Senden von Daten verwendet. Die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> und <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methoden ermöglichen den asynchronen Zugriff auf den Datenstrom senden.  
  
 Für die Clientauthentifizierung mit <xref:System.Net.HttpWebRequest>, muss das Clientzertifikat installiert werden, den persönlichen Zertifikatsspeicher des aktuellen Benutzers.  
  
 Die <xref:System.Net.HttpWebRequest> -Klasse löst eine <xref:System.Net.WebException> Wenn beim Zugriff auf eine Ressource Fehler auftreten. Die <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> Eigenschaft enthält eine <xref:System.Net.WebExceptionStatus> Wert, der die Quelle des Fehlers angibt. Wenn <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> ist <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, <xref:System.Net.WebException.Response%2A> Eigenschaft enthält die <xref:System.Net.HttpWebResponse> von der Ressource empfangen.  
  
 <xref:System.Net.HttpWebRequest> macht allgemeine HTTP-Headerwerte in die Internetressource als Eigenschaften Methoden oder gesendet, vom System festgelegt verfügbar. Die folgende Tabelle enthält eine vollständige Liste. Sie können weitere Header festlegen, in der <xref:System.Net.HttpWebRequest.Headers%2A> Eigenschaft als Name/Wert-Paaren. Beachten Sie, dass Server Caches zu ändern oder Header, während der Anforderung hinzufügen.  
  
 Die folgende Tabelle enthält die HTTP-Header, die entweder durch die Eigenschaften, Methoden oder das System festgelegt werden.  
  
|Header|Festlegen, indem|  
|------------|------------|  
|Akzeptieren|Festlegen, indem die <xref:System.Net.HttpWebRequest.Accept%2A> Eigenschaft.|  
|Verbindung|Festlegen, indem die <xref:System.Net.HttpWebRequest.Connection%2A> Eigenschaft <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft.|  
|Content-Length|Festlegen, indem die <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft.|  
|Inhaltstyp|Festlegen, indem die <xref:System.Net.HttpWebRequest.ContentType%2A> Eigenschaft.|  
|Erwartet|Festlegen, indem die <xref:System.Net.HttpWebRequest.Expect%2A> Eigenschaft.|  
|Datum|Durch das System an das aktuelle Datum festgelegt.|  
|Host|Legen Sie durch das System an die aktuellen Hostinformationen.|  
|If-Modified-Since|Festlegen, indem die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft.|  
|Bereich|Festlegen, indem die <xref:System.Net.HttpWebRequest.AddRange%2A> Methode.|  
|Referer|Festlegen, indem die <xref:System.Net.HttpWebRequest.Referer%2A> Eigenschaft.|  
|Transfer-Encoding|Festlegen, indem die <xref:System.Net.HttpWebRequest.TransferEncoding%2A> Eigenschaft (die <xref:System.Net.HttpWebRequest.SendChunked%2A> -Eigenschaft muss sein `true`).|  
|Benutzer-Agent|Festlegen, indem die <xref:System.Net.HttpWebRequest.UserAgent%2A> Eigenschaft.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> wird automatisch registriert. Sie müssen nicht aufrufen, die <xref:System.Net.WebRequest.RegisterPrefix%2A> -Methode registrieren <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> vor der Verwendung von URIs ab `http://` oder `https://`.  
  
 Dem lokalen Computer oder eine Anwendungskonfigurationsdatei können Sie angeben, dass ein standardmäßige Proxy verwendet werden. Wenn die <xref:System.Net.HttpWebRequest.Proxy%2A> -Eigenschaft angegeben ist, klicken Sie dann auf die Proxy-Einstellungen aus der <xref:System.Net.HttpWebRequest.Proxy%2A> Eigenschaft zu überschreiben, dem lokalen Computer oder eine Anwendungskonfigurationsdatei und die <xref:System.Net.HttpWebRequest> -Instanz verwendet die angegebenen Proxyeinstellungen. Wenn kein Proxy in einer Konfigurationsdatei angegeben ist und die <xref:System.Net.HttpWebRequest.Proxy%2A> Eigenschaft ist nicht vorgegeben, die <xref:System.Net.HttpWebRequest> Klasse verwendet die Proxyeinstellungen von Internet Explorer geerbt werden, auf dem lokalen Computer. Wenn es keine Proxyeinstellungen in Internet Explorer sind, wird die Anforderung direkt an den Server gesendet.  
  
 Die <xref:System.Net.HttpWebRequest> -Klasse parst eine Proxyumgehungsliste mit Platzhalterzeichen, geerbt von Internet Explorer anders als der Umgehungsliste aufgeführt, die direkt von Internet Explorer analysiert wird. Z. B. die <xref:System.Net.HttpWebRequest> -Klasse analysiert eine Umgehungsliste der "nt *" von Internet Explorer als regulärer Ausdruck des "nt. $". Dies unterscheidet sich von dessen natives Verhalten von Internet Explorer. Daher eine URL in der "`http://intxxxxx`" den Proxy mithilfe der <xref:System.Net.HttpWebRequest> Klasse, sondern würde nicht umgehen des Proxys mit Internet Explorer.  
  
> [!NOTE]
>  Das Framework SSL-Sitzungen werden zwischengespeichert, wie sie erstellt werden und versucht, eine zwischengespeicherte-Sitzung für eine neue Anforderung, nach Möglichkeit wiederzuverwenden. Beim Versuch, eine SSL-Sitzung erneut verwenden, wird das Framework verwendet das erste Element der <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (sofern vorhanden), oder versucht, eine anonyme Sitzung erneut zu verwenden, wenn <xref:System.Net.HttpWebRequest.ClientCertificates%2A> ist leer.  
  
> [!NOTE]
>  Aus Sicherheitsgründen sind Cookies standardmäßig deaktiviert. Wenn Sie Cookies verwenden möchten, verwenden Sie die <xref:System.Net.HttpWebRequest.CookieContainer%2A> Eigenschaft, um Cookies zu aktivieren.  
  
 .NET Framework 4.6 umfasst eine neue Sicherheitsfunktion, die unsichere Verschlüsselung und Hashalgorithmen für Verbindungen blockiert. Mithilfe von TLS/SSL über APIs wie z. B. "HttpClient", "HttpWebRequest", FTPClient, SmtpClient, SslStream usw. und als Ziel .NET Framework 4.6-Anwendungen das sicherere Verhalten wird standardmäßig abgerufen.  
  
 Entwickler sollten dieses Verhalten abwählen, um die Interoperabilität mit ihren vorhandenen SSL3-Diensten oder TLS mit RC4-Dienste zu gewährleisten. [In diesem Artikel](https://support.microsoft.com/kb/3069494) wird erläutert, wie Sie Ihren Code ändern, sodass das neue Verhalten deaktiviert ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein <xref:System.Net.HttpWebRequest> für den URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">auf dem angeforderten URI oder einen beliebigen URI, der die Anforderung umgeleitet wurde. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
    <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Änderungen an der NTLM-Authentifizierung für "HttpWebRequest" in Version 3.5 SP1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.HttpWebRequest" />-Klasse. Diese Konstruktoren sind veraltet. Details finden Sie im Abschnitt „Hinweise“.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Beide <xref:System.Net.HttpWebRequest> Konstruktoren sind veraltet und sollte nicht verwendet werden. Rufen Sie die <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> Methode zum Initialisieren neuer <xref:System.Net.HttpWebRequest> Objekte.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.HttpWebRequest" />-Klasse. Dieser Konstruktor ist veraltet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren des neuen <see cref="T:System.Net.HttpWebRequest" />-Objekts erforderlichen Informationen.</param>
        <param name="streamingContext">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt mit der Quelle und dem Ziel des serialisierten Streams, der dem neuen <see cref="T:System.Net.HttpWebRequest" />-Objekt zugeordnet ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.HttpWebRequest" />-Klasse aus den angegebenen Instanzen der <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Klasse und der <see cref="T:System.Runtime.Serialization.StreamingContext" />-Klasse. Dieser Konstruktor ist veraltet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung muss im Modus mit vollständiger Vertrauenswürdigkeit ausgeführt, bei der Serialisierung.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">für einen uneingeschränkten Zugriff auf Netzwerkressourcen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML- und SOAP-Serialisierung</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht eine Anforderung an eine Internetressource ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Abort%2A> Methode bricht eine Anforderung auf eine Ressource ab. Aufrufen, nachdem eine Anforderung abgebrochen wird, die <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, oder <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methode bewirkt, dass eine <xref:System.Net.WebException> mit der <xref:System.Net.WebException.Status%2A> -Eigenschaftensatz auf <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 Die <xref:System.Net.HttpWebRequest.Abort%2A> Methode wird synchron ausgeführt, den Rückruf angegeben, um die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methoden Wenn die <xref:System.Net.HttpWebRequest.Abort%2A> Methode wird aufgerufen, während einer dieser Vorgänge ausstehen. Dies kann zu Probleme Deadlock führen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung](https://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Im Fall von asynchronen Anforderungen ist es die Verantwortung für die Clientanwendung einen eigenen Timeoutmechanismus implementiert. Im folgenden Codebeispiel wird veranschaulicht, wie Sie zu diesem Zweck wird.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="Accept" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Wert des <see langword="Accept" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Löschen der `Accept` HTTP-Header festlegen, die <xref:System.Net.HttpWebRequest.Accept%2A> Eigenschaft `null`.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Eigenschaft auf <xref:System.Net.HttpWebRequest.Accept%2A> festgelegt.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt der Anforderung einen Bereichsheader hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da alle HTTP-Entitäten in der HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich sinnvoll für jede HTTP-Entität. Allerdings möchte, dass nicht alle Clients und Servern Byte-Range-Vorgänge zu unterstützen.  
  
 Der Range-Header für eine Anforderung kann ein Client anfordern, dass sie nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, um Header bereichsanforderungen zu unterstützen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">Der Start- oder Endpunkt des Bereichs.</param>
        <summary>Fügt einer Anforderung einen Bytebereichsheader für einen bestimmten Bereich am Anfang oder Ende der angeforderten Daten hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bytebereichsheader hinzugefügt.  
  
 Wenn `range` positiv ist, werden die `range` Parameter gibt den Ausgangspunkt des Bereichs. Der Server sollte starten, Senden von Daten aus der `range` -Parameter an das Ende der Daten in der HTTP-Entität.  
  
 Wenn `range` negativ ist, die `range` Parameter gibt den Endpunkt des Bereichs an. Die Server sollten beginnen des Sendevorgangs von Daten vom Anfang der Daten in die HTTP-Entität, die die `range` Parameter wurde angegeben.  
  
 Da alle HTTP-Entitäten in der HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich sinnvoll für jede HTTP-Entität. Allerdings möchte, dass nicht alle Clients und Servern Byte-Range-Vorgänge zu unterstützen.  
  
 Der Range-Header für eine Anforderung kann ein Client anfordern, dass sie nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, um Header bereichsanforderungen zu unterstützen.  
  
 Ein Beispiel einer Range-Header in einer HTTP-Protokoll-Anforderung, die anfordert, den Server senden die ersten 100 Bytes (von Anfang an Byteposition 99) würde folgendermaßen lauten:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel die `range` Parameter würde -99 sein.  
  
 Ein HTTP-Server gibt Unterstützung für Range-Header mit dem Accept-Ranges-Header an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn Sie ein Accept-Ranges-Header nicht in den Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Range-Anforderung nur die HTTP-Headern, die die gesamte Anforderung zugeordnete analysiert und über Eigenschaften zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Anforderung einen Bereichsheader hinzugefügt.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">Der Start- oder Endpunkt des Bereichs.</param>
        <summary>Fügt einer Anforderung einen Bytebereichsheader für einen bestimmten Bereich am Anfang oder Ende der angeforderten Daten hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bytebereichsheader hinzugefügt.  
  
 Wenn `range` positiv ist, werden die `range` Parameter gibt den Ausgangspunkt des Bereichs. Der Server sollte starten, Senden von Daten aus der `range` -Parameter an das Ende der Daten in der HTTP-Entität.  
  
 Wenn `range` negativ ist, die `range` Parameter gibt den Endpunkt des Bereichs an. Die Server sollten beginnen des Sendevorgangs von Daten vom Anfang der Daten in die HTTP-Entität, die die `range` Parameter wurde angegeben.  
  
 Da alle HTTP-Entitäten in der HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich sinnvoll für jede HTTP-Entität. Allerdings möchte, dass nicht alle Clients und Servern Byte-Range-Vorgänge zu unterstützen.  
  
 Der Range-Header für eine Anforderung kann ein Client anfordern, dass sie nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, um Header bereichsanforderungen zu unterstützen.  
  
 Ein Beispiel einer Range-Header in einer HTTP-Protokoll-Anforderung, die anfordert, den Server senden die ersten 100 Bytes (von Anfang an Byteposition 99) würde folgendermaßen lauten:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel die `range` Parameter würde -99 sein.  
  
 Ein HTTP-Server gibt Unterstützung für Range-Header mit dem Accept-Ranges-Header an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn Sie ein Accept-Ranges-Header nicht in den Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Range-Anforderung nur die HTTP-Headern, die die gesamte Anforderung zugeordnete analysiert und über Eigenschaften zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">Die Position, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="to">Die Position, an der das Senden von Daten beendet werden soll.</param>
        <summary>Fügt der Anforderung einen Bytebereichsheader für einen angegebenen Bereich hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bytebereichsheader hinzugefügt.  
  
 Da alle HTTP-Entitäten in der HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich sinnvoll für jede HTTP-Entität. Allerdings möchte, dass nicht alle Clients und Servern Byte-Range-Vorgänge zu unterstützen.  
  
 Der Range-Header für eine Anforderung kann ein Client anfordern, dass sie nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, um Header bereichsanforderungen zu unterstützen.  
  
 Ein Beispiel für eine Range-Header in einer HTTP-Protokoll-Anforderung, die Anforderungen die ersten 100 Bytes würde Folgendes sein:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel die `from` Parameter würde als 0 angegeben werden und die `to` Parameter würde als 99 angegeben werden. Der Range-Bezeichner wird von dieser Methode automatisch als "Byte" festgelegt.  
  
 Ein HTTP-Server gibt Unterstützung für Range-Header mit dem Accept-Ranges-Header an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn Sie ein Accept-Ranges-Header nicht in den Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Range-Anforderung nur die HTTP-Headern, die die gesamte Anforderung zugeordnete analysiert und über Eigenschaften zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Anforderung einen Bereichsheader hinzugefügt.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> ist größer als <paramref name="to" />  
  
- oder -  
 <paramref name="from" /> oder <paramref name="to" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">Die Position, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="to">Die Position, an der das Senden von Daten beendet werden soll.</param>
        <summary>Fügt der Anforderung einen Bytebereichsheader für einen angegebenen Bereich hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bytebereichsheader hinzugefügt.  
  
 Da alle HTTP-Entitäten in der HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich sinnvoll für jede HTTP-Entität. Allerdings möchte, dass nicht alle Clients und Servern Byte-Range-Vorgänge zu unterstützen.  
  
 Der Range-Header für eine Anforderung kann ein Client anfordern, dass sie nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, um Header bereichsanforderungen zu unterstützen.  
  
 Ein Beispiel für eine Range-Header in einer HTTP-Protokoll-Anforderung, die Anforderungen die ersten 100 Bytes würde Folgendes sein:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel die `from` Parameter würde als 0 angegeben werden und die `to` Parameter würde als 99 angegeben werden. Der Range-Bezeichner wird von dieser Methode automatisch als "Byte" festgelegt.  
  
 Ein HTTP-Server gibt Unterstützung für Range-Header mit dem Accept-Ranges-Header an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn Sie ein Accept-Ranges-Header nicht in den Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Range-Anforderung nur die HTTP-Headern, die die gesamte Anforderung zugeordnete analysiert und über Eigenschaften zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> ist größer als <paramref name="to" />  
  
- oder -  
 <paramref name="from" /> oder <paramref name="to" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Die Beschreibung des Bereichs.</param>
        <param name="range">Der Start- oder Endpunkt des Bereichs.</param>
        <summary>Fügt einer Anforderung einen Bereichsheader für einen bestimmten Bereich am Anfang oder Ende der angeforderten Daten hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bereichsheader hinzugefügt.  
  
 Wenn `range` positiv ist, werden die `range` Parameter gibt den Ausgangspunkt des Bereichs. Der Server sollte starten, Senden von Daten aus der `range` -Parameter an das Ende der Daten in der HTTP-Entität.  
  
 Wenn `range` negativ ist, die `range` Parameter gibt den Endpunkt des Bereichs an. Die Server sollten beginnen des Sendevorgangs von Daten vom Anfang der Daten in die HTTP-Entität, die die `range` Parameter wurde angegeben.  
  
 Da alle HTTP-Entitäten in der HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich sinnvoll für jede HTTP-Entität. Allerdings möchte, dass nicht alle Clients und Servern Byte-Range-Vorgänge zu unterstützen.  
  
 Der Range-Header für eine Anforderung kann ein Client anfordern, dass sie nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, um Header bereichsanforderungen zu unterstützen.  
  
 Die `rangeSpecifier` Parameter würde normalerweise als "Byte", angegeben werden, da dies der einzige Bereichsspezifizierer erkannt, die von den meisten HTTP-Servern ist. Festlegen der `rangeSpecifier` Parameter, um eine andere Zeichenfolge ermöglicht Unterstützung für benutzerdefinierte keine Bytes (der Byte-Range-Bezeichner, der in RFC 2616 definiert sind, von der IETF ist).  
  
 Ein Beispiel für eine Range-Header in einer HTTP-Protokoll-Anforderung, die Anforderungen die ersten 100 Bytes würde Folgendes sein:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 In diesem Beispiel die `rangeSpecifier` Parameter würde als "Byte" angegeben werden und die `range` Parameter würde -99 sein.  
  
 Ein HTTP-Server gibt Unterstützung für Range-Header mit dem Accept-Ranges-Header in der Antwort an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn Sie ein Accept-Ranges-Header nicht in den Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Range-Anforderung nur die HTTP-Headern, die die gesamte Anforderung zugeordnete analysiert und über Eigenschaften zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Die Beschreibung des Bereichs.</param>
        <param name="range">Der Start- oder Endpunkt des Bereichs.</param>
        <summary>Fügt einer Anforderung einen Bereichsheader für einen bestimmten Bereich am Anfang oder Ende der angeforderten Daten hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bereichsheader hinzugefügt.  
  
 Wenn `range` positiv ist, werden die `range` Parameter gibt den Ausgangspunkt des Bereichs. Der Server sollte starten, Senden von Daten aus der `range` -Parameter an das Ende der Daten in der HTTP-Entität.  
  
 Wenn `range` negativ ist, die `range` Parameter gibt den Endpunkt des Bereichs an. Die Server sollten beginnen des Sendevorgangs von Daten vom Anfang der Daten in die HTTP-Entität, die die `range` Parameter wurde angegeben.  
  
 Da alle HTTP-Entitäten in der HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich sinnvoll für jede HTTP-Entität. Allerdings möchte, dass nicht alle Clients und Servern Byte-Range-Vorgänge zu unterstützen.  
  
 Der Range-Header für eine Anforderung kann ein Client anfordern, dass sie nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, um Header bereichsanforderungen zu unterstützen.  
  
 Die `rangeSpecifier` Parameter würde normalerweise als "Byte", angegeben werden, da dies der einzige Bereichsspezifizierer erkannt, die von den meisten HTTP-Servern ist. Festlegen der `rangeSpecifier` Parameter, um eine andere Zeichenfolge ermöglicht Unterstützung für benutzerdefinierte keine Bytes (der Byte-Range-Bezeichner, der in RFC 2616 definiert sind, von der IETF ist).  
  
 Ein Beispiel für eine Range-Header in einer HTTP-Protokoll-Anforderung, die Anforderungen die ersten 100 Bytes würde Folgendes sein:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 In diesem Beispiel die `rangeSpecifier` Parameter würde als "Byte" angegeben werden und die `range` Parameter würde -99 sein.  
  
 Ein HTTP-Server gibt Unterstützung für Range-Header mit dem Accept-Ranges-Header in der Antwort an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn Sie ein Accept-Ranges-Header nicht in den Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Range-Anforderung nur die HTTP-Headern, die die gesamte Anforderung zugeordnete analysiert und über Eigenschaften zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Die Beschreibung des Bereichs.</param>
        <param name="from">Die Position, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="to">Die Position, an der das Senden von Daten beendet werden soll.</param>
        <summary>Fügt einer Anforderung einen Bereichsheader für einen angegebenen Bereich hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bereichsheader hinzugefügt.  
  
 Da alle HTTP-Entitäten in der HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich sinnvoll für jede HTTP-Entität. Allerdings möchte, dass nicht alle Clients und Servern Byte-Range-Vorgänge zu unterstützen.  
  
 Der Range-Header für eine Anforderung kann ein Client anfordern, dass sie nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, um Header bereichsanforderungen zu unterstützen.  
  
 Die `rangeSpecifier` Parameter würde normalerweise als "Byte", angegeben werden, da dies der einzige Bereichsspezifizierer erkannt, die von den meisten HTTP-Servern ist. Festlegen der `rangeSpecifier` Parameter, um eine andere Zeichenfolge ermöglicht Unterstützung für benutzerdefinierte keine Bytes (der Byte-Range-Bezeichner, der in RFC 2616 definiert sind, von der IETF ist).  
  
 Ein Beispiel für eine Range-Header in einer HTTP-Protokoll-Anforderung, die Anforderungen die ersten 100 Bytes würde Folgendes sein:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel die `rangeSpecifier` Parameter würde als "Byte", angegeben werden die `from` Parameter würden 0 (null) sein und die `to` Parameter würde 99 sein.  
  
 Ein HTTP-Server gibt Unterstützung für Range-Header mit dem Accept-Ranges-Header in der Antwort an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Die Zeichenfolge, die im Accept-Ranges-Header angegebene ist der Bereich-Bezeichner, die von in angegeben werden die `rangeSpecifier` Parameter für diese Methode.  
  
 Wenn Sie ein Accept-Ranges-Header nicht in den Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Range-Anforderung nur die HTTP-Headern, die die gesamte Anforderung zugeordnete analysiert und über Eigenschaften zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> ist größer als <paramref name="to" />  
  
- oder -  
 <paramref name="from" /> oder <paramref name="to" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Die Beschreibung des Bereichs.</param>
        <param name="from">Die Position, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="to">Die Position, an der das Senden von Daten beendet werden soll.</param>
        <summary>Fügt einer Anforderung einen Bereichsheader für einen angegebenen Bereich hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bereichsheader hinzugefügt.  
  
 Da alle HTTP-Entitäten in der HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich sinnvoll für jede HTTP-Entität. Allerdings möchte, dass nicht alle Clients und Servern Byte-Range-Vorgänge zu unterstützen.  
  
 Der Range-Header für eine Anforderung kann ein Client anfordern, dass sie nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, um Header bereichsanforderungen zu unterstützen.  
  
 Die `rangeSpecifier` Parameter würde normalerweise als "Byte", angegeben werden, da dies der einzige Bereichsspezifizierer erkannt, die von den meisten HTTP-Servern ist. Festlegen der `rangeSpecifier` Parameter, um eine andere Zeichenfolge ermöglicht Unterstützung für benutzerdefinierte keine Bytes (der Byte-Range-Bezeichner, der in RFC 2616 definiert sind, von der IETF ist).  
  
 Ein Beispiel für eine Range-Header in einer HTTP-Protokoll-Anforderung, die Anforderungen die ersten 100 Bytes würde Folgendes sein:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel die `rangeSpecifier` Parameter würde als "Byte", angegeben werden die `from` Parameter würden 0 (null) sein und die `to` Parameter würde 99 sein.  
  
 Ein HTTP-Server gibt Unterstützung für Range-Header mit dem Accept-Ranges-Header in der Antwort an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Die Zeichenfolge, die im Accept-Ranges-Header angegebene ist der Bereich-Bezeichner, die von in angegeben werden die `rangeSpecifier` Parameter für diese Methode.  
  
 Wenn Sie ein Accept-Ranges-Header nicht in den Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Range-Anforderung nur die HTTP-Headern, die die gesamte Anforderung zugeordnete analysiert und über Eigenschaften zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> ist größer als <paramref name="to" />  
  
- oder -  
 <paramref name="from" /> oder <paramref name="to" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Bereichsheader konnte nicht hinzugefügt werden.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den URI (Uniform Resource Identifier) der Internetressource ab, die auf die Anforderung reagiert.</summary>
        <value>Ein <see cref="T:System.Uri" />, der die Internetressource bezeichnet, die auf die Anforderung reagiert. Standardmäßig ist dies der URI, der von der <see cref="M:System.Net.WebRequest.Create(System.String)" />-Methode zum Initialisieren der Anforderung verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Address%2A> Eigenschaft an den URI festgelegt ist, nachdem alle umleitungen, die auftreten, während der Anforderung abgeschlossen sind.  
  
 Der URI der ursprünglichen Anforderung werden in der <xref:System.Net.HttpWebRequest.RequestUri%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob die <xref:System.Net.HttpWebRequest> Objekt `req` an einen anderen Speicherort zur Verarbeitung der Anforderung umgeleitet wurde, und legt den Wert für die `hasChanged` Variable `true` , wenn die Anforderung umgeleitet wurde; andernfalls `hasChanged`nastaven NA hodnotu `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anforderung Umleitungsantworten folgen soll, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn die Anforderung Umleitungsantworten von der Internetressource automatisch folgen soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> zu `true` ggf. die Anforderung an die HTTP-Umleitung-Header an den neuen Speicherort der Ressource automatisch zu folgen. Die maximale Anzahl von umleitungen befolgt wird festgelegt, durch die <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> Eigenschaft.  
  
 Wenn <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> nastaven NA hodnotu `false`, allen Antworten mit HTTP-Statuscode zwischen 300 und 399 an die Anwendung zurückgegeben wird.  
  
 Der Authorization-Header auf Auto-umleitungen deaktiviert ist und <xref:System.Net.HttpWebRequest> automatisch versucht, am Umleitungsspeicherort belassen erneut zu authentifizieren. In der Praxis bedeutet dies, dass eine Anwendung Informationen für die benutzerdefinierte Authentifizierung in der Authorization-Header versetzt werden kann, wenn es möglich ist, die Umleitung auftreten. Stattdessen muss die Anwendung zu implementieren und registrieren ein benutzerdefiniertes Authentifizierungsmodul. Die <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> und verwandte Klassen werden verwendet, um ein benutzerdefiniertes Authentifizierungsmodul zu implementieren. Die <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> Methode registriert ein benutzerdefiniertes Authentifizierungsmodul.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> Eigenschaft, um die Anforderung Umleitungsantworten folgen zu können.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die von der Internetressource empfangenen Daten gepuffert werden sollen, oder legt diesen Wert fest.</summary>
        <value><see langword="true" /> aktiviert die Zwischenspeicherung der aus der Internetressource empfangenen Daten, <see langword="false" /> deaktiviert die Zwischenspeicherung. Der Standardwert ist <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die an die Internetressource gesendeten Daten gepuffert werden sollen, oder legt diesen fest.</summary>
        <value><see langword="true" /> aktiviert das Puffern der an die Internetressource gesendeten Daten, <see langword="false" /> deaktiviert das Puffern. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> ist `true`, die Daten im Arbeitsspeicher gepuffert werden, damit er bei umleitungen oder Authentifizierung Anforderungen erneut gesendet werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> Eigenschaft deaktiviert das Puffern der Daten.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Festlegen von <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> zu <see langword="true" /> kann zu Leistungsproblemen führen, wenn große Datasets hochladen, da der Datenpuffer gesamten verfügbaren Arbeitsspeicher verwenden kann.</para></block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ der verwendeten Dekomprimierung ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Net.DecompressionMethods" /> Objekt, das den Typ der dekomprimierung angibt, der verwendet wird.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Zustand des Objekts gestattet es nicht, dass diese Eigenschaft festgelegt wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Das Zustandsobjekt für diese Anforderung.</param>
        <summary>Startet eine asynchrone Anforderung eines <see cref="T:System.IO.Stream" />-Objekts, das zum Schreiben von Daten verwendet werden soll.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Anforderung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Methode startet eine asynchrone Anforderung eines Streams verwendet zum Senden von Daten für die <xref:System.Net.HttpWebRequest>. Die asynchrone Rückrufmethode verwendet die <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methode, um den eigentlichen Stream zurückzugeben.  
  
 Die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Methode erfordert einige synchrone Setupaufgaben (DNS-Auflösung, Proxyerkennung und TCP-Socketverbindung, z. B.) abgeschlossen, bevor diese Methode asynchron wird. Daher diese Methode sollte nie aufgerufen werden für einen Benutzeroberflächenthread (UI) da es sehr viel Zeit (bis zu mehrere Minuten je nach den Einstellungen des Netzwerks) dauern kann, die synchrone Anfangssetup vor der Ausnahme Aufgaben für ein Fehler ausgelöst wird, oder die Methode erfolgreich ist.  
  
 Weitere Informationen zu den Threadpool, finden Sie unter [der verwaltete Threadpool](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Synchrone und asynchrone Methoden für eine bestimmte Anforderung kann nicht Ihrer Anwendung vermischt werden. Aufrufen der <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> -Methode müssen Sie verwenden die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode zum Abrufen der Antwort.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Methode, um eine asynchrone Anfrage für eine Stream-Instanz.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">Die <see cref="P:System.Net.HttpWebRequest.Method" />-Eigenschaft ist GET oder HEAD.  
  
- oder -  
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> ist <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> ist <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" /> und <see cref="P:System.Net.HttpWebRequest.Method" /> ist POST oder PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream wird von einem vorherigen Aufruf von <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> verwendet.  
  
- oder -  
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ist auf einen Wert festgelegt, und <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" />.  
  
- oder -  
Der Threadpool enthält nicht mehr genügend Threads.</exception>
        <exception cref="T:System.NotSupportedException">Die Anforderungcacheprüfung hat angezeigt, dass die Antwort auf diese Anforderung aus dem Cache erfolgen werden kann. Allerdings dürfen Anforderungen, die Daten schreiben, nicht den Cache verwenden. Diese Ausnahme kann auftreten, wenn Sie eine benutzerdefinierte Anforderungcacheprüfung verwenden, die nicht ordnungsgemäß implementiert ist.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.</exception>
        <exception cref="T:System.ObjectDisposedException">In einer .NET Compact Framework-Anwendung wurde ein Anforderungsstream mit leerem Inhalt nicht ordnungsgemäß abgerufen und geschlossen. Weitere Informationen über das Verarbeiten von Anforderungen mit einem Inhalt der Länge 0 (null) finden Sie unter [Network Programming in the .NET Compact Framework (Netzwerkprogrammierung in .NET Compact Framework.)](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Das Zustandsobjekt für diese Anforderung.</param>
        <summary>Startet eine asynchrone Anforderung an eine Internetressource.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Anforderung einer Antwort verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> -Methode startet eine asynchrone Anforderung einer Antwort von der Internetressource. Die asynchrone Rückrufmethode verwendet die <xref:System.Net.HttpWebRequest.EndGetResponse%2A> Methode zum Zurückgeben der tatsächlichen <xref:System.Net.WebResponse>.  
  
 Ein <xref:System.Net.ProtocolViolationException> in vielen Fällen ausgelöst, wenn die Eigenschaften für Festlegen der <xref:System.Net.HttpWebRequest> Klasse stehen in Konflikt. Diese Ausnahme tritt auf, wenn eine Anwendung wird die <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft und die <xref:System.Net.HttpWebRequest.SendChunked%2A> Eigenschaft `true`, und sendet dann eine HTTP GET-Anforderung. Diese Ausnahme tritt auf, wenn eine Anwendung, zum Senden von aufgeteilte auf einem Server, der nur HTTP 1.0-Protokoll unterstützt versucht, in denen dies wird nicht unterstützt. Diese Ausnahme tritt auf, wenn eine Anwendung, zum Senden von Daten festlegen, ohne versucht die <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft oder die <xref:System.Net.HttpWebRequest.SendChunked%2A> ist `false` bei der Pufferung deaktiviert ist, und klicken Sie auf eine Keepalive-Verbindung (die <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft `true`)`.`  
  
 Wenn eine <xref:System.Net.WebException> ist ausgelöst wird, verwenden die <xref:System.Net.WebException.Response%2A> und <xref:System.Net.WebException.Status%2A> Eigenschaften der Ausnahme, um die Antwort vom Server zu bestimmen.  
  
 Die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode erfordert einige synchrone Setupaufgaben (DNS-Auflösung, Proxyerkennung und TCP-Socketverbindung, z. B.) abgeschlossen, bevor diese Methode asynchron wird. Daher diese Methode sollte nie aufgerufen werden für einen Benutzeroberflächenthread (UI) da es sehr viel Zeit (bis zu mehrere Minuten je nach den Einstellungen des Netzwerks) dauern kann, die synchrone Anfangssetup vor der Ausnahme Aufgaben für ein Fehler ausgelöst wird, oder die Methode erfolgreich ist.  
  
 Weitere Informationen zu den Threadpool, finden Sie unter [der verwaltete Threadpool](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Synchrone und asynchrone Methoden für eine bestimmte Anforderung kann nicht Ihrer Anwendung vermischt werden. Aufrufen der <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> -Methode müssen Sie verwenden die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode zum Abrufen der Antwort.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [ &#91; \<Topic://conUsingNetworkTracing >&#93;](https://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode, um eine asynchrone Anforderung einer Internetressource.  
  
> [!NOTE]
>  Im Fall von asynchronen Anforderungen ist es die Verantwortung für die Clientanwendung einen eigenen Timeoutmechanismus implementiert. Im folgenden Codebeispiel wird veranschaulicht, wie es geht.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Stream wird bereits von einem vorherigen Aufruf von <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> verwendet.  
  
- oder -  
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ist auf einen Wert festgelegt, und <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" />.  
  
- oder -  
Der Threadpool enthält nicht mehr genügend Threads.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> ist GET oder HEAD, und <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist größer als 0 (null), oder <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="true" />.  
  
- oder -  
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> ist gleich <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> ist gleich <see langword="false" />, und <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist gleich -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist gleich <see langword="false" /> und <see cref="P:System.Net.HttpWebRequest.Method" /> ist gleich POST oder PUT.  
  
- oder -  
<see cref="T:System.Net.HttpWebRequest" /> verfügt über einen Entitätskörper, die <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />-Methode wird jedoch aufgerufen, ohne dass die <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />-Methode aufgerufen wird.  
  
- oder -  
<see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist größer als 0 (null), von der Anwendung werden jedoch nicht alle zugesagten Daten geschrieben.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dieser Anforderung zugeordnete Auflistung von Sicherheitszertifikaten ab oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den dieser Anforderung zugeordneten Sicherheitszertifikaten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung kann ein Zertifikat zu einer Auflistung hinzufügen, aber möglicherweise nicht über die Zugriffsrechte für diese. Um ein Zertifikat in der Auflistung enthaltenen verwenden zu können, muss die Anwendung die gleichen Zugriffsrechte wie die Entität verfügen, die das Zertifikat ausgestellt hat.  
  
> [!NOTE]
>  Das Framework SSL-Sitzungen werden zwischengespeichert, wie sie erstellt werden und versucht, eine zwischengespeicherte-Sitzung für eine neue Anforderung, nach Möglichkeit wiederzuverwenden. Beim Versuch, eine SSL-Sitzung erneut verwenden, wird das Framework verwendet das erste Element der <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (sofern vorhanden), oder versucht, eine anonyme Sitzung erneut zu verwenden, wenn <xref:System.Net.HttpWebRequest.ClientCertificates%2A> ist leer.  
  
> [!NOTE]
>  Aus Leistungsgründen sollten nicht Sie ein Clientzertifikat Hinzufügen einer <xref:System.Net.HttpWebRequest> , sofern Sie nicht der Server fordert dafür.  
>   
>  Ein Codebeispiel zur Veranschaulichung Auflisten der Zertifikate im Zertifikatspeicher Clients finden Sie unter den <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der für einen SET-Vorgang festgelegte Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="Connection" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Wert des <see langword="Connection" />-HTTP-Headers. Der Standardwert ist <see langword="null" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anforderung sendet die <xref:System.Net.HttpWebRequest.Connection%2A> Eigenschaft, um die Internetressource die `Connection` HTTP-Header. Wenn der Wert des der <xref:System.Net.HttpWebRequest.KeepAlive%2A> -Eigenschaft ist `true`, der "Keep-alive-Wert wird an das Ende angefügt der `Connection` Header.  
  
 Zum Löschen der `Connection` HTTP-Header festlegen, die <xref:System.Net.HttpWebRequest.Connection%2A> Eigenschaft `null`.  
  
 Ändern der <xref:System.Net.HttpWebRequest.Connection%2A> Eigenschaft nach dem Start der Anforderung durch Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> -Methode löst eine <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.Connection%2A> Eigenschaft zum Festlegen des Werts des Verbindungs-HTTP-Headers.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert von <see cref="P:System.Net.HttpWebRequest.Connection" /> wird auf „Keep-Alive“ oder „Close“ festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der Verbindungsgruppe für die Anforderung ab oder legt diesen fest.</summary>
        <value>Der Name der Verbindungsgruppe für diese Anforderung. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> -Eigenschaft ermöglicht es Ihnen, eine Verbindungsgruppe eine Anforderung zugeordnet werden soll. Dies ist nützlich, wenn Ihre Anwendung Anforderungen an einen Server für andere Benutzer, z. B. eine Website gesendet werden, die Informationen zu den Kunden von einem Datenbankserver abruft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird zeigen, wie Benutzerinformationen zu einer Verbindungsgruppe, vorausgesetzt, dass die Variablen `username`, `password`, und `domain` werden die von der Anwendung festgelegt werden, bevor dieser Code aufgerufen wird.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jede verbindungsgruppierung erstellt zusätzliche Verbindungen für einen Server. Kann dies überschreitet die Anzahl der Verbindungen, die festlegen, indem die <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> Eigenschaft für diesen Server.</para></block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
        <related type="Article" href="~/docs/framework/network-programming/connection-grouping.md">Verbindungsgruppierung</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see langword="Content-length" />-HTTP-Header ab oder legt diesen fest.</summary>
        <value>Die Anzahl der Bytes der an die Internetressource zu sendenden Daten. Der Standardwert ist -1. Dieser Wert gibt an, dass die Eigenschaft nicht festgelegt wurde und keine zu sendenden Anforderungsdaten vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft enthält den Wert als senden die `Content-length` HTTP-Header mit der Anforderung.  
  
 Einen anderen Wert als 1, in der <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft gibt an, dass die Anforderung Daten hochlädt und dürfen nur die Methoden, die Daten hochladen festgelegt werden, der <xref:System.Net.HttpWebRequest.Method%2A> Eigenschaft.  
  
 Nach der <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft auf einen Wert festgelegt ist, diese Anzahl an Bytes muss geschrieben werden in den Anforderungsdatenstrom, die durch den Aufruf zurückgegeben wird das <xref:System.Net.HttpWebRequest.GetRequestStream%2A> -Methode oder beide der <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> und <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methoden.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft, um die Länge der Zeichenfolge bereitgestellt wird.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Anforderung wurde durch Aufrufen der Methode <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> oder <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> gestartet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der neue <see cref="P:System.Net.HttpWebRequest.ContentLength" />-Wert ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="Content-type" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Wert des <see langword="Content-type" />-HTTP-Headers. Der Standardwert ist <see langword="null" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ContentType%2A> Eigenschaft enthält den Medientyp der Anforderung. Werte für die <xref:System.Net.HttpWebRequest.ContentType%2A> Eigenschaft ersetzen alle vorhandenen Inhalte auf, wenn die Anforderung sendet die `Content-type` HTTP-Header.  
  
 Zum Löschen der `Content-type` HTTP-Header festlegen, die <xref:System.Net.HttpWebRequest.ContentType%2A> Eigenschaft `null`.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft befindet sich in <xref:System.Net.WebHeaderCollection> . Wenn <xref:System.Net.WebHeaderCollection> festgelegt ist, wird der Eigenschaftswert ist unterbrochen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Eigenschaft auf <xref:System.Net.HttpWebRequest.ContentType%2A> festgelegt.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Delegatenmethode ab, die aufgerufen wird, wenn eine HTTP-100-Continue-Antwort von der Internetressource empfangen wird, oder legt diese fest.</summary>
        <value>Ein Delegat, der die Rückrufmethode implementiert, die ausgeführt wird, wenn die Internetressource eine HTTP-Continue-Antwort zurückgibt. Der Standardwert ist <see langword="null" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> Eigenschaft gibt an, die Callback-Methode aufrufen, wenn der Client, eine 100 empfängt-Continue-Antwort.  
  
 Wenn die <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> Eigenschaft festgelegt ist, wird der Client Ruft den Delegaten Protokoll jedes Mal, wenn die Antworten des Typs <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) empfangen werden. Dies ist hilfreich, wenn der Client den Status der von der Internetressource empfangenen Daten anzeigen soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Timeout-Zeit (in Millisekunden) ab oder legt diese fest, bis zu der auf den Serverstatus gewartet wird, nachdem "100-Continue" vom Server empfangen wurde.</summary>
        <value>Das Timeout in Millisekunden, bis zu dem auf den Empfang von "100-Continue" gewartet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der 100-Continue-Antwort empfangen wird, vor dem Ablauf des Timeouts der einheitstextkörper kann gesendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die der Anforderung zugeordneten Cookies ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Net.CookieContainer" /> mit den dieser Anforderung zugeordneten Cookies.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.CookieContainer%2A> Eigenschaft stellt eine Instanz der <xref:System.Net.CookieContainer> -Klasse, die dieser Anforderung zugeordneten Cookies enthält.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> ist `null` standardmäßig. Müssen Sie Zuweisen einer <xref:System.Net.CookieContainer> Objekt, das die Eigenschaft, wenn Cookies der <xref:System.Net.HttpWebResponse.Cookies%2A> Eigenschaft der <xref:System.Net.HttpWebResponse> zurückgegebenes der <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode.  
  
> [!NOTE]
>  Aus Sicherheitsgründen sind Cookies standardmäßig deaktiviert. Wenn Sie Cookies verwenden möchten, verwenden Sie die <xref:System.Net.HttpWebRequest.CookieContainer%2A> Eigenschaft, um Cookies zu aktivieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet eine Anforderung an eine URL, und zeigt die Cookies, die in der Antwort zurückgegeben.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Authentifizierungsinformationen für die Anforderung ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Net.ICredentials" />-Element mit den der Anforderung zugeordneten Anmeldeinformationen für die Authentifizierung. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Credentials%2A> Eigenschaft enthält die Authentifizierungsinformationen, die den Ersteller der Anforderung zu identifizieren. Die <xref:System.Net.HttpWebRequest.Credentials%2A> Eigenschaft kann es sich entweder eine <xref:System.Net.NetworkCredential>, welcher Fall muss der Benutzer, Kennwort und Domäneninformationen in der <xref:System.Net.NetworkCredential> Objekt wird zum Authentifizieren der Anforderung verwendet, oder es kann eine <xref:System.Net.CredentialCache>, in diesem Fall den Uniform Resource Bezeichner (URI) der Anforderung wird verwendet, um zu bestimmen, die Benutzer, Kennwort und Domäneninformationen, zum Authentifizieren der Anforderung verwendet wird.  
  
 Verwenden Sie in den meisten Clientszenarien, die <xref:System.Net.CredentialCache.DefaultCredentials%2A> -Eigenschaft, die die Anmeldeinformationen des aktuell angemeldeten Benutzers enthält. Zu diesem Zweck legen Sie die <xref:System.Net.WebClient.UseDefaultCredentials%2A> Eigenschaft `true` statt durch Festlegen dieser Eigenschaft.  
  
 Wenn die <xref:System.Net.HttpWebRequest> Klasse wird in einer Anwendung der mittleren Ebene, z. B. die Anmeldeinformationen in einer ASP.NET-Anwendung verwendet die <xref:System.Net.CredentialCache.DefaultCredentials%2A> Eigenschaft gehört, für das Konto, unter der ASP-Seite (die serverseitige-Anmeldeinformationen). In der Regel würden Sie diese Eigenschaft auf die Anmeldeinformationen des Clients festlegen, in die Namen angefordert wird.  
  
> [!NOTE]
>  Das NTLM-Authentifizierungsschema kann nicht verwendet werden, um die Identität eines anderen Benutzers annehmen. Kerberos muss speziell konfiguriert werden, um den Identitätswechsel unterstützt.  
  
 Um "HttpWebRequest" auf eine oder mehrere Authentifizierungsmethoden zu beschränken, verwenden Sie die <xref:System.Net.CredentialCache> Klasse, und binden Sie Ihre Anmeldeinformationen an einen oder mehrere Authentifizierungsschemas  
  
 Unterstützten Authentifizierungsschemen enthalten, Digest, Negotiate, Kerberos, NTLM und Basic.  
  
 Aus Sicherheitsgründen bei umleitungen automatisch folgen, speichern Sie die Anmeldeinformationen, die Sie die Umleitung in enthalten sein sollen eine <xref:System.Net.CredentialCache> und weisen sie diese Eigenschaft. Diese Eigenschaft wird automatisch festgelegt werden, um `null` bei der Umleitung, wenn sie nichts außer enthält eine <xref:System.Net.CredentialCache>. Dass der Wert dieser Eigenschaft auf automatisch festgelegt werden `null` unter diesen Bedingungen verhindert, dass Anmeldeinformationen in einem nicht beabsichtigten Ziel gesendet werden.
  
## Examples  
 Das folgende Codebeispiel legt die Anmeldeinformationen für eine Anforderung fest.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see langword="Date" />-HTTP-Headerwert für eine HTTP-Anforderung ab oder legt ihn fest.</summary>
        <value>Der Datumsheaderwert in der HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Date-Header ist `null`, und klicken Sie dann der zurückgegebenen Wert, um festgelegt wird <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 Die <xref:System.Net.HttpWebRequest.Date%2A> Eigenschaft ist ein Standard <xref:System.DateTime?displayProperty=nameWithType> Objekt enthalten kann, und wählen Sie eine <xref:System.DateTimeKind?displayProperty=nameWithType> Feld <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, oder <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jede Art von Zeit kann festgelegt werden, wenn die <xref:System.Net.HttpWebRequest.Date%2A> Eigenschaft. Wenn <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> festgelegt oder abgerufen, die <xref:System.Net.HttpWebRequest.Date%2A> Eigenschaft wird als <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (Ortszeit).  
  
 Die Klassen in der <xref:System.Net> Namespace immer schreiben die <xref:System.Net.HttpWebRequest.Date%2A> Eigenschaft über das Netzwerk während der Übertragung im Standardformat mit GMT (Utc).  
  
 Wenn der <xref:System.Net.HttpWebRequest.Date%2A> -Eigenschaftensatz auf <xref:System.DateTime.MinValue?displayProperty=nameWithType>, und klicken Sie dann die `Date` HTTP-Header wird aus entfernt der <xref:System.Net.HttpWebRequest.Headers%2A> Eigenschaft und die <xref:System.Net.WebHeaderCollection>.  
  
 Wenn die <xref:System.Net.HttpWebRequest.Date%2A> -Eigenschaft ist <xref:System.DateTime.MinValue?displayProperty=nameWithType>, dies bedeutet, dass die `Date` HTTP-Header ist nicht enthalten, der <xref:System.Net.HttpWebRequest.Headers%2A> Eigenschaft und die <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
 Wenn die <xref:System.Net.HttpWebRequest.Date%2A> festgelegt ist und es wird versucht, zum Senden von einer <xref:System.Net.HttpWebRequest> ohne Textteil, ein <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> wird ausgelöst werden, um die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, und <xref:System.Net.HttpWebRequest.EndGetResponse%2A> Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardcacherichtlinie für diese Anforderung ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Net.Cache.HttpRequestCachePolicy" />, die die für diese Anforderung gültige Cacherichtlinie angibt, wenn keine andere Richtlinie anwendbar ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Festlegen dieser Eigenschaft registriert die angegebene Richtlinie für die HTTP- und HTTPS-Schemas. Diese Richtlinie ist für diese Anforderung verwendet, wenn:  
  
 Es gibt keine <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> Eigenschaft, die für diese Anforderung angegeben.  
  
- oder - 
  
 Die Dateien geben Sie eine Cacherichtlinie, die auf den Uniform Resource Identifier (URI) gilt, mit der diese Anforderung erstellt keine Computer- und anwendungsspezifische-Konfiguration.  
  
 Die Cacherichtlinie bestimmt, ob die angeforderte Ressource aus einem Cache anstatt der Anforderung auf dem Hostcomputer für die Ressource ausgeführt werden kann.  
  
 Eine Kopie einer Ressource wird nur mit dem Cache hinzugefügt, wenn der Antwortstream für die Ressource abgerufen und bis zum Ende des Streams gelesen wird. Damit eine andere Anforderung für dieselbe Ressource eine zwischengespeicherte Kopie, abhängig von der Ebene des Caches-Richtlinie für diese Anforderung verwenden kann.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">für einen uneingeschränkten Zugriff auf Netzwerkressourcen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die standardmäßige maximale Länge einer HTTP-Fehlerantwort ab oder legt diese fest.</summary>
        <value>Die standardmäßige maximale Länge einer HTTP-Fehlerantwort.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert ist kleiner als 0 (null) und ungleich -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Standardwert für die <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />-Eigenschaft ab oder legt diesen fest.</summary>
        <value>Die Länge in KB (1024 Bytes) des Standardwerts für die maximale Größe empfangener Antwortheader. In der Standardkonfigurationsdatei ist dieser Wert auf 64 KB festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Länge des Antwortheaders empfangen der Antwort-Statuszeile und alle zusätzlichen Steuerzeichen, die als Teil des HTTP-Protokoll empfangen werden. Ein Wert von-1 bedeutet, dass, die keine Beschränkung auf die Header der Antwort empfangen wird. ein Wert von 0 bedeutet, bei denen alle Anforderungen.  
  
 Dieser Wert kann auch in der Konfigurationsdatei geändert werden. Die Auswirkungen dieser Eigenschaft kann überschrieben werden, indem die <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> Eigenschaft in einer Instanz von der <xref:System.Net.HttpWebRequest> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert ist ungleich -1 und kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet eine asynchrone Anforderung eines <see cref="T:System.IO.Stream" />-Objekts, das zum Schreiben von Daten verwendet werden soll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Die ausstehende Anforderung für einen Datenstrom.</param>
        <summary>Beendet eine asynchrone Anforderung eines <see cref="T:System.IO.Stream" />-Objekts, das zum Schreiben von Daten verwendet werden soll.</summary>
        <returns>Ein <see cref="T:System.IO.Stream" />, der zum Schreiben von Anforderungsdaten verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methode schließt eine asynchrone Anforderung für einen Stream, der von gestartet wurde. die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Methode. Nach der <xref:System.IO.Stream> Objekt zurückgegeben wurde, können Sie Daten mit Senden der <xref:System.Net.HttpWebRequest> mithilfe der <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> Methode.  
  
> [!NOTE]
>  Sie müssen den Wert der Festlegen der <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft vor dem Schreiben von Daten in den Stream.  
  
> [!CAUTION]
>  Rufen Sie die <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> Methode, um den Stream zu schließen und die Verbindung für die Wiederverwendung freizugeben. Fehler beim Schließen des Streams bewirkt, dass Ihre Anwendung nicht mehr genügend Verbindungen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methode, um eine asynchrone Anforderung für eine Stream-Instanz zu beenden.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung wurde nicht abgeschlossen, und es ist kein Stream verfügbar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde von der aktuellen Instanz bei einem Aufruf von <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> nicht zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Methode wurde zuvor mit <paramref name="asyncResult" /> aufgerufen.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.  
  
- oder -  
Beim Verarbeiten der Anforderung ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Die ausstehende Anforderung für einen Datenstrom.</param>
        <param name="context">Der <see cref="T:System.Net.TransportContext" /> für den <see cref="T:System.IO.Stream" />.</param>
        <param name="transportContext">Der <see cref="T:System.Net.TransportContext" /> für den <see cref="T:System.IO.Stream" />.</param>
        <summary>Beendet eine asynchrone Anforderung eines <see cref="T:System.IO.Stream" />-Objekts, das zum Schreiben von Daten verwendet wird und das dem Datenstrom zugeordnete <see cref="T:System.Net.TransportContext" /> ausgibt.</summary>
        <returns>Ein <see cref="T:System.IO.Stream" />, der zum Schreiben von Anforderungsdaten verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methode schließt eine asynchrone Anforderung für einen Stream, der von gestartet wurde. die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> -Methode und die Ausgaben der <xref:System.Net.TransportContext> dem Stream zugewiesen sind. Nach der <xref:System.IO.Stream> Objekt zurückgegeben wurde, können Sie Daten mit Senden der <xref:System.Net.HttpWebRequest> mithilfe der <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> Methode.  
  
 Einige Anwendungen, die integrierte Windows-Authentifizierung mit erweitertem Schutz verwendet die Transportschicht von verwendeten Abfragen können müssen möglicherweise <xref:System.Net.HttpWebRequest> um das Channelbindungstoken (CBT) aus den zugrunde liegenden TLS-Kanal abzurufen. Die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> -Methode bietet Zugriff auf diese Informationen für HTTP-Methoden, die einen Anforderungstext enthalten (`POST` und `PUT` Anforderungen). Dies ist nur erforderlich, wenn die Anwendung, eine eigene Authentifizierung implementiert wird und Zugriff auf das CBT benötigt.  
  
> [!NOTE]
>  Wenn eine Anwendung zum Festlegen des Werts, der muss die <xref:System.Net.HttpWebRequest.ContentLength%2A> -Eigenschaft, und dies muss vor dem Abrufen des Streams und Schreiben von Daten in der sie ausgeführt werden.  
  
> [!CAUTION]
>  Rufen Sie die <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> Methode, um den Stream zu schließen und die Verbindung für die Wiederverwendung freizugeben. Fehler beim Schließen des Streams bewirkt, dass Ihre Anwendung nicht mehr genügend Verbindungen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde von der aktuellen Instanz bei einem Aufruf von <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> nicht zurückgegeben.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Methode wurde zuvor mit <paramref name="asyncResult" /> aufgerufen.</exception>
        <exception cref="T:System.IO.IOException">Die Anforderung wurde nicht abgeschlossen, und es ist kein Stream verfügbar.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.  
  
- oder -  
Beim Verarbeiten der Anforderung ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Die ausstehende Anforderung einer Antwort.</param>
        <summary>Beendet eine asynchrone Anforderung an eine Internetressource.</summary>
        <returns>Eine <see cref="T:System.Net.WebResponse" /> mit der Antwort von der Internetressource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.EndGetResponse%2A> Methode schließt eine asynchrone Anforderung einer Internetressource, die durch den Aufruf gestartet wurde die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode.  
  
> [!CAUTION]
>  Rufen Sie die <xref:System.Net.HttpWebResponse.Close%2A> Methode, um den Stream zu schließen und die Verbindung freizugeben. Bei unterlassen kann dazu führen, dass Ihre Anwendung nicht mehr genügend Verbindungen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.EndGetResponse%2A> Methode, um eine asynchrone Anforderung einer Internetressource zu beenden.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Diese Methode wurde zuvor mit <paramref name="asyncResult." /> aufgerufen.  
  
- oder -  
Die <see cref="P:System.Net.HttpWebRequest.ContentLength" />-Eigenschaft ist größer als 0 (null), aber die Daten wurden nicht in den Anforderungsdatenstrom geschrieben.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.  
  
- oder -  
Beim Verarbeiten der Anforderung ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde von der aktuellen Instanz bei einem Aufruf von <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> nicht zurückgegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="Expect" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Inhalt des <see langword="Expect" />-HTTP-Headers. Der Standardwert ist <see langword="null" />sein.  
  
 <block subset="none" type="note"><para>  
 Der Wert für diese Eigenschaft wird in der <see cref="T:System.Net.WebHeaderCollection" /> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
</para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><see langword="Expect" /> ist auf eine Zeichenfolge festgelegt, die "100-continue" als Teilzeichenfolge enthält.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="httpWebRequest.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashwert für eine <see cref="T:System.Net.WebRequest" />-Instanz zurück.</summary>
        <returns>Ein ganzzahliger Hashwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Die GetHashCode-Methode gibt einen Hashcode der webanforderung zurück. Dieser Wert kann als Schlüssel für Hashtabellen verwendet werden.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Die mit Daten zu füllende <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="streamingContext">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />, der das Ziel für diese Serialisierung angibt.</param>
        <summary>Füllt eine <see cref="T:System.Runtime.Serialization.SerializationInfo" /> mit den Daten auf, die zum Serialisieren des Zielobjekts erforderlich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Objekttypen die <xref:System.Runtime.Serialization.SerializationInfo> werden automatisch nachverfolgt und vom Formatierungsprogramm serialisiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein <see cref="T:System.IO.Stream" />-Objekt ab, das zum Schreiben von Anforderungsdaten verwendet werden soll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.IO.Stream" />-Objekt ab, das zum Schreiben von Anforderungsdaten verwendet werden soll.</summary>
        <returns>Ein <see cref="T:System.IO.Stream" />, der zum Schreiben von Anforderungsdaten verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Methode gibt einen Stream zu verwenden, um das Senden von Daten für die <xref:System.Net.HttpWebRequest>. Nach der <xref:System.IO.Stream> Objekt zurückgegeben wurde, können Sie Daten mit Senden der <xref:System.Net.HttpWebRequest> mithilfe der <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> Methode.  
  
 Wenn eine Anwendung zum Festlegen des Werts, der muss die <xref:System.Net.HttpWebRequest.ContentLength%2A> -Eigenschaft, und dies muss vor dem Abrufen des Streams ausgeführt werden.  
  
 Rufen Sie die <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> Methode, um den Stream zu schließen und die Verbindung für die Wiederverwendung freizugeben. Fehler beim Schließen des Streams bewirkt, dass Ihre Anwendung nicht mehr genügend Verbindungen.  
  
> [!NOTE]
>  Synchrone und asynchrone Methoden für eine bestimmte Anforderung kann nicht Ihrer Anwendung vermischt werden. Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A> -Methode müssen Sie verwenden die <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode zum Abrufen der Antwort.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Methode, um eine Stream-Instanz zurückzugeben.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">Die <see cref="P:System.Net.HttpWebRequest.Method" />-Eigenschaft ist GET oder HEAD.  
  
- oder -  
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> ist <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> ist <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" /> und <see cref="P:System.Net.HttpWebRequest.Method" /> ist POST oder PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />-Methode wurde mehrmals aufgerufen.  
  
- oder -  
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ist auf einen Wert festgelegt, und <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Anforderungcacheprüfung hat angezeigt, dass die Antwort auf diese Anforderung aus dem Cache erfolgen werden kann. Allerdings dürfen Anforderungen, die Daten schreiben, nicht den Cache verwenden. Diese Ausnahme kann auftreten, wenn Sie eine benutzerdefinierte Anforderungcacheprüfung verwenden, die nicht ordnungsgemäß implementiert ist.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.  
  
- oder -  
Das Zeitlimit für die Anforderung ist abgelaufen.  
  
- oder -  
Fehler beim Verarbeiten der Anforderung.</exception>
        <exception cref="T:System.ObjectDisposedException">In einer .NET Compact Framework-Anwendung wurde ein Anforderungsstream mit leerem Inhalt nicht ordnungsgemäß abgerufen und geschlossen. Weitere Informationen über das Verarbeiten von Anforderungen mit einem Inhalt der Länge 0 (null) finden Sie unter [Network Programming in the .NET Compact Framework (Netzwerkprogrammierung in .NET Compact Framework.)](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">Der <see cref="T:System.Net.TransportContext" /> für den <see cref="T:System.IO.Stream" />.</param>
        <summary>Ruft ein <see cref="T:System.IO.Stream" />-Objekt ab, das zum Schreiben von Anforderungsdaten verwendet wird und das dem Datenstrom zugeordnete <see cref="T:System.Net.TransportContext" /> ausgibt.</summary>
        <returns>Ein <see cref="T:System.IO.Stream" />, der zum Schreiben von Anforderungsdaten verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Methode gibt einen Stream zu verwenden, um das Senden von Daten für die <xref:System.Net.HttpWebRequest> und gibt die <xref:System.Net.TransportContext> dem Stream zugewiesen sind. Nach der <xref:System.IO.Stream> Objekt zurückgegeben wurde, können Sie Daten mit Senden der <xref:System.Net.HttpWebRequest> mithilfe der <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> Methode.  
  
 Einige Anwendungen, die integrierte Windows-Authentifizierung mit erweitertem Schutz verwendet die Transportschicht von verwendeten Abfragen können müssen möglicherweise <xref:System.Net.HttpWebRequest> um das Channelbindungstoken (CBT) aus den zugrunde liegenden TLS-Kanal abzurufen. Die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> -Methode bietet Zugriff auf diese Informationen für HTTP-Methoden, die einen Anforderungstext enthalten (`POST` und `PUT` Anforderungen). Dies ist nur erforderlich, wenn die Anwendung, eine eigene Authentifizierung implementiert wird und Zugriff auf das CBT benötigt.  
  
 Wenn eine Anwendung zum Festlegen des Werts, der muss die <xref:System.Net.HttpWebRequest.ContentLength%2A> -Eigenschaft, und dies muss vor dem Abrufen des Streams ausgeführt werden.  
  
 Rufen Sie die <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> Methode, um den Stream zu schließen und die Verbindung für die Wiederverwendung freizugeben. Fehler beim Schließen des Streams bewirkt, dass Ihre Anwendung nicht mehr genügend Verbindungen.  
  
> [!NOTE]
>  Synchrone und asynchrone Methoden für eine bestimmte Anforderung kann nicht Ihrer Anwendung vermischt werden. Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A> -Methode müssen Sie verwenden die <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode zum Abrufen der Antwort.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Die <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />-Methode konnte den <see cref="T:System.IO.Stream" /> nicht abrufen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />-Methode wurde mehrmals aufgerufen.  
  
- oder -  
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ist auf einen Wert festgelegt, und <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Anforderungcacheprüfung hat angezeigt, dass die Antwort auf diese Anforderung aus dem Cache erfolgen werden kann. Allerdings dürfen Anforderungen, die Daten schreiben, nicht den Cache verwenden. Diese Ausnahme kann auftreten, wenn Sie eine benutzerdefinierte Anforderungcacheprüfung verwenden, die nicht ordnungsgemäß implementiert ist.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">Die <see cref="P:System.Net.HttpWebRequest.Method" />-Eigenschaft ist GET oder HEAD.  
  
- oder -  
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> ist <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> ist <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" /> und <see cref="P:System.Net.HttpWebRequest.Method" /> ist POST oder PUT.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.  
  
- oder -  
Das Zeitlimit für die Anforderung ist abgelaufen.  
  
- oder -  
Beim Verarbeiten der Anforderung ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Antwort von einer Internetressource zurück.</summary>
        <returns>Eine <see cref="T:System.Net.WebResponse" /> mit der Antwort von der Internetressource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode gibt eine <xref:System.Net.WebResponse> -Objekt, das die Antwort der Internetressource enthält. Die tatsächliche Instanz zurückgegeben wird ein <xref:System.Net.HttpWebResponse>, und auf diese Klasse zum Zugriff auf HTTP-spezifische Eigenschaften umgewandelt werden kann.  
  
 Ein <xref:System.Net.ProtocolViolationException> in vielen Fällen ausgelöst, wenn die Eigenschaften für Festlegen der <xref:System.Net.HttpWebRequest> Klasse stehen in Konflikt. Diese Ausnahme tritt auf, wenn eine Anwendung wird die <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft und die <xref:System.Net.HttpWebRequest.SendChunked%2A> Eigenschaft `true`, und sendet dann eine HTTP GET-Anforderung. Diese Ausnahme tritt auf, wenn eine Anwendung, zum Senden von aufgeteilte auf einem Server, der nur HTTP 1.0-Protokoll unterstützt versucht, in denen dies wird nicht unterstützt. Diese Ausnahme tritt auf, wenn eine Anwendung, zum Senden von Daten festlegen, ohne versucht die <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft oder die <xref:System.Net.HttpWebRequest.SendChunked%2A> ist `false` bei der Pufferung deaktiviert ist, und klicken Sie auf eine Keepalive-Verbindung (die <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft `true`)`.`  
  
> [!CAUTION]
>  Rufen Sie die <xref:System.Net.HttpWebResponse.Close%2A> Methode, um den Stream zu schließen und die Verbindung freizugeben. Bei unterlassen kann dazu führen, dass Ihre Anwendung nicht mehr genügend Verbindungen.  
  
 Wenn Sie die POST-Methode verwenden zu können, müssen Sie den Anforderungsstream abzurufen, Schreiben Sie die Daten bereitgestellt werden und schließt den Stream. Diese Methode blockiert, warten auf Inhalt zu veröffentlichen; Wenn kein Timeout festgelegt ist, und Sie keinen Inhalt, der aufrufende Thread blockiert auf unbestimmte Zeit bieten.  
  
> [!NOTE]
>  Mehrere Aufrufe <xref:System.Net.HttpWebRequest.GetResponse%2A> desselben Objekts Antwort zurückgegeben wird die Anforderung nicht erneut gesendet.  
  
> [!NOTE]
>  Synchrone und asynchrone Methoden für eine bestimmte Anforderung kann nicht Ihrer Anwendung vermischt werden. Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A> -Methode müssen Sie verwenden die <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode zum Abrufen der Antwort.  
  
> [!NOTE]
>  Wenn eine <xref:System.Net.WebException> ist ausgelöst wird, verwenden die <xref:System.Net.WebException.Response%2A> und <xref:System.Net.WebException.Status%2A> Eigenschaften der Ausnahme, um die Antwort vom Server zu bestimmen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Aus Sicherheitsgründen sind Cookies standardmäßig deaktiviert. Wenn Sie Cookies verwenden möchten, verwenden Sie die <xref:System.Net.HttpWebRequest.CookieContainer%2A> Eigenschaft, um Cookies zu aktivieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft die Antwort für eine Anforderung ab.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Stream wird bereits von einem vorherigen Aufruf von <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> verwendet.  
  
- oder -  
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> ist auf einen Wert festgelegt, und <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> ist GET oder HEAD, und <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist entweder größer oder gleich 0 (null), oder <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="true" />.  
  
- oder -  
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> ist <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> ist <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> ist <see langword="false" /> und <see cref="P:System.Net.HttpWebRequest.Method" /> ist POST oder PUT.  
  
- oder -  
<see cref="T:System.Net.HttpWebRequest" /> verfügt über einen Entitätskörper, die <see cref="M:System.Net.HttpWebRequest.GetResponse" />-Methode wird jedoch aufgerufen, ohne dass die <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />-Methode aufgerufen wird.  
  
- oder -  
<see cref="P:System.Net.HttpWebRequest.ContentLength" /> ist größer als 0 (null), von der Anwendung werden jedoch nicht alle zugesagten Daten geschrieben.</exception>
        <exception cref="T:System.NotSupportedException">Die Anforderungcacheprüfung hat ergeben, dass die Antwort auf diese Anforderung aus dem Cache bereitgestellt werden kann. Allerdings umfasst diese Anforderung Daten, die an den Server gesendet werden müssen. Anforderungen, durch die Daten gesendet werden, dürfen keinen Cache verwenden. Diese Ausnahme kann auftreten, wenn Sie eine benutzerdefinierte Cacheprüfung verwenden, die nicht ordnungsgemäß implementiert ist.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> wurde bereits aufgerufen.  
  
- oder -  
Das Zeitlimit für die Anforderung ist abgelaufen.  
  
- oder -  
Beim Verarbeiten der Anforderung ist ein Fehler aufgetreten.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Antwort von einer Internetressource empfangen wurde.</summary>
        <value><see langword="true" />, wenn eine Antwort empfangen wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird überprüft die <xref:System.Net.HttpWebRequest.HaveResponse%2A> Eigenschaft, um zu bestimmen, ob eine Antwort von einer Internetressource empfangen wurde.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine Auflistung der Name-Wert-Paare an, aus denen sich die HTTP-Header zusammensetzen.</summary>
        <value>Eine <see cref="T:System.Net.WebHeaderCollection" /> mit den Name-Wert-Paaren, aus denen sich die Header für die HTTP-Anforderung zusammensetzen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Headers%2A> Auflistung enthält, die mit der Anforderung zugewiesenen Protokollheader. Die folgende Tabelle enthält die HTTP-Header, die nicht in gespeichert werden die <xref:System.Net.HttpWebRequest.Headers%2A> Auflistung jedoch sind entweder vom System festgelegt oder Festlegen von Eigenschaften oder Methoden.  
  
|Header|Festlegen, indem|  
|------------|------------|  
|Akzeptieren|Festlegen, indem die <xref:System.Net.HttpWebRequest.Accept%2A> Eigenschaft.|  
|Verbindung|Festlegen, indem die <xref:System.Net.HttpWebRequest.Connection%2A> Eigenschaft und <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft.|  
|Content-Length|Festlegen, indem die <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft.|  
|Inhaltstyp|Festlegen, indem die <xref:System.Net.HttpWebRequest.ContentType%2A> Eigenschaft.|  
|Erwartet|Festlegen, indem die <xref:System.Net.HttpWebRequest.Expect%2A> Eigenschaft.|  
|Datum|Festlegen, indem die <xref:System.Net.HttpWebRequest.Date%2A> Eigenschaft.|  
|Host|Festlegen, indem die <xref:System.Net.HttpWebRequest.Host%2A> Eigenschaft.|  
|If-Modified-Since|Festlegen, indem die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft.|  
|Bereich|Festlegen, indem die <xref:System.Net.HttpWebRequest.AddRange%2A> Methode.|  
|Referer|Festlegen, indem die <xref:System.Net.HttpWebRequest.Referer%2A> Eigenschaft.|  
|Transfer-Encoding|Festlegen, indem die <xref:System.Net.HttpWebRequest.TransferEncoding%2A> Eigenschaft (die <xref:System.Net.HttpWebRequest.SendChunked%2A> Eigenschaft muss "true" sein).|  
|Benutzer-Agent|Festlegen, indem die <xref:System.Net.HttpWebRequest.UserAgent%2A> Eigenschaft.|  
  
 Die <xref:System.Net.WebHeaderCollection.Add%2A> -Methode löst eine <xref:System.ArgumentException> , wenn Sie versuchen, einen dieser geschützten Header festzulegen.  
  
 Ändern der <xref:System.Net.HttpWebRequest.Headers%2A> Eigenschaft nach dem Start der Anforderung durch den Aufruf <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> -Methode löst eine <xref:System.InvalidOperationException>.  
  
 Sie sollten nicht davon ausgehen, dass die Headerwerte unverändert bleiben werden, da Webservern und Caches geändert oder Header zu einer webanforderung hinzufügen können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.Headers%2A> -Eigenschaft der HTTP-Header-Wert-Paare in der Konsole ausgegeben.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Anforderung wurde durch Aufrufen der Methode <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> oder <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> gestartet.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Hostheaderwert ab, der in einer HTTP-Anforderung unabhängig vom Anforderungs-URI verwendet werden soll, oder legt ihn fest.</summary>
        <value>Der Hostheaderwert in der HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Host%2A> Eigenschaft kann verwendet werden, um den Host-Headerwert für die Verwendung in einer HTTP-Anforderung unabhängig vom Anforderungs-URI festgelegt. Die <xref:System.Net.HttpWebRequest.Host%2A> Eigenschaft kann einen Hostnamen und eine optionale Portnummer bestehen. Ein Hostheader, ohne die Portinformationen weist darauf hin, der Standardport für den angeforderten Dienst (Port 80 für HTTP-URL, z. B.).  
  
 Das Format zum Angeben eines Hosts und-Ports gelten die Regeln in Abschnitt 14.23 rfc2616, die von der IETF veröffentlicht. Ein Beispiel zur Einhaltung dieser Anforderungen, der angibt, einen Port 8080 wäre der folgende Wert für die <xref:System.Net.HttpWebRequest.Host%2A> Eigenschaft:  
  
 `www.contoso.com:8080`  
  
 Mithilfe der <xref:System.Net.HttpWebRequest.Host%2A> Eigenschaft explizit einen benutzerdefinierten Host-Headerwert angeben, wirkt sich auch auf Bereiche caching, Cookies und Authentifizierung. Wenn eine Anwendung Anmeldeinformationen für ein bestimmtes URI-Präfix enthält, muss die Anwendungen sicherstellen, dass den URI, der mit dem Wert des Host-Header, nicht auf dem Zielserver im URI verwenden. Der Schlüssel verwendet, wenn die Zwischenspeicherung von Ressourcen, wird der Hostheaderwert anstelle von Anforderungs-URI verwendet. Cookies werden gespeichert und einem <xref:System.Net.CookieContainer> und nach dem Domänennamen des Servers logisch gruppiert. Wenn die Anwendung einen Hostheader angegeben ist, wird dieser Wert als Domäne verwendet werden.  
  
 Wenn die <xref:System.Net.HttpWebRequest.Host%2A> Eigenschaft nicht festgelegt, wird der Hostheaderwert in eine HTTP-Anforderung mit basiert darauf, dass des Anforderungs-URI.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Hostheader kann nicht auf <see langword="null" /> festgelegt werden.</exception>
        <exception cref="T:System.ArgumentException">Der Hostheader kann nicht auf einen ungültigen Wert festgelegt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Hostheader kann nicht festgelegt werden, nachdem das Senden von <see cref="T:System.Net.HttpWebRequest" /> bereits gestartet wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="If-Modified-Since" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Eine <see cref="T:System.DateTime" /> mit dem Inhalt des <see langword="If-Modified-Since" />-HTTP-Headers. Der Standardwert ist das aktuelle Datum und die aktuelle Uhrzeit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft ist ein Standard <xref:System.DateTime?displayProperty=nameWithType> Objekt enthalten kann, und wählen Sie eine <xref:System.DateTimeKind?displayProperty=nameWithType> Feld <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, oder <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jede Art von Zeit kann festgelegt werden, wenn die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft. Wenn <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> festgelegt oder abgerufen, die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft wird als <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (Ortszeit).  
  
 Die Klassen in der <xref:System.Net> Namespace immer schreiben die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft über das Netzwerk während der Übertragung im Standardformat mit GMT (Utc).  
  
 Wenn der <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> -Eigenschaftensatz auf <xref:System.DateTime.MinValue?displayProperty=nameWithType>, und klicken Sie dann die `If-Modified-Since` HTTP-Header wird aus entfernt der <xref:System.Net.HttpWebRequest.Headers%2A> Eigenschaft und die <xref:System.Net.WebHeaderCollection>.  
  
 Wenn die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> -Eigenschaft ist <xref:System.DateTime.MinValue?displayProperty=nameWithType>, dies bedeutet, dass die `If-Modified-Since` HTTP-Header ist nicht enthalten, der <xref:System.Net.HttpWebRequest.Headers%2A> Eigenschaft und die <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine permanente Verbindung mit der Internetressource hergestellt werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Anforderung an die Internetressource einen <see langword="Connection" />-HTTP-Header mit dem KeepAlive-Wert enthalten soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf `true` zum Senden einer `Connection` HTTP-Header mit dem KeepAlive-Wert. Eine Anwendung verwendet <xref:System.Net.HttpWebRequest.KeepAlive%2A> um eine permanente Verbindungen bevorzugt anzugeben. Wenn die <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft `true`, die Anwendung sendet, permanente Verbindungen mit den Servern, die sie unterstützen.  
  
> [!NOTE]
>  Wenn Sie HTTP/1.1 verwenden zu können, ist Keep-Alive standardmäßig aktiviert. Festlegen von <xref:System.Net.HttpWebRequest.KeepAlive%2A> zu `false` strafbar senden eine `Connection: Close` -Header an den Server.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft `false` um zu vermeiden, eine permanente Verbindung mit der Internetressource hergestellt.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Anzahl von Umleitungen ab, denen die Anforderung folgt, oder legt diese fest.</summary>
        <value>Die maximale Anzahl von Umleitungsantworten, denen die Anforderung folgt. Der Standardwert ist 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> Eigenschaft legt die maximale Anzahl von umleitungen für die Anforderung, wenn führen die <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> Eigenschaft `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel legt den Wert dieser Eigenschaft fest.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert wird auf 0 oder weniger festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximal zulässige Länge der Antwortheader ab oder legt diese fest.</summary>
        <value>Die Länge der Antwortheader in KB (1024 Bytes).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Länge des Antwortheaders enthält die Antwort-Statuszeile und alle zusätzlichen Steuerzeichen, die als Teil des HTTP-Protokoll empfangen werden. Ein Wert-1 bedeutet, dass, die keine Obergrenze für die Header der Antwort festgelegt wird. ein Wert von 0 bedeutet, bei denen alle Anforderungen.  
  
 Wenn die <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> Eigenschaft nicht explizit festgelegt ist, wird standardmäßig des Werts des der <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> Eigenschaft.  
  
 Überschreitet die Länge des Antwortheaders empfangen den Wert des der <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> -Eigenschaft, die <xref:System.Net.HttpWebRequest.EndGetResponse%2A> oder <xref:System.Net.HttpWebRequest.GetResponse%2A> Methoden lösen eine <xref:System.Net.WebException> mit der <xref:System.Net.WebException.Status%2A> -Eigenschaftensatz auf <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 Das folgende Codebeispiel legt den Wert dieser Eigenschaft fest.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Eigenschaft wird festgelegt, nachdem die Anforderung bereits gesendet wurde.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert ist kleiner als 0 (null) und ungleich -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Medientyp der Anforderung ab oder legt diesen fest.</summary>
        <value>Der Medientyp der Anforderung. Der Standardwert ist <see langword="null" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des der <xref:System.Net.HttpWebRequest.MediaType%2A> Eigenschaft wirkt sich auf die <xref:System.Net.HttpWebResponse.CharacterSet%2A> Eigenschaft. Beim Festlegen der <xref:System.Net.HttpWebRequest.MediaType%2A> in der Anforderung, wird der entsprechende Medientyp ausgewählt, aus der Liste der Zeichensätze, die in der Antwort zurückgegebenen `Content-type` HTTP-Header.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Methode für die Anforderung ab oder legt diese fest.</summary>
        <value>Die Anforderungsmethode zum Herstellen der Verbindung mit der Internetressource. Der Standardwert ist GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Method%2A> Eigenschaft kann auf eines der HTTP 1.1-Protokollverben festgelegt werden: GET, HEAD, POST, PUT, löschen "," ABLAUFVERFOLGUNG "oder"-Optionen.  
  
 Wenn die <xref:System.Net.HttpWebRequest.ContentLength%2A> -Eigenschaftensatz auf einen anderen Wert als-1 ist, die <xref:System.Net.HttpWebRequest.Method%2A> Eigenschaft muss festgelegt werden, um eine Protokolleigenschaft, die Daten hochlädt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.Method%2A> Eigenschaft POST.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wurde keine Methode bereitgestellt.  
  
- oder -  
Die Methodenzeichenfolge enthält ungültige Zeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anforderung über Pipelineverbindungen zur Internetressource gesendet werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Anforderung über Pipelineverbindungen gesendet werden soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung verwendet die <xref:System.Net.HttpWebRequest.Pipelined%2A> Eigenschaft, die eine Vorliebe für pipelineverbindungen angibt. Wenn <xref:System.Net.HttpWebRequest.Pipelined%2A> ist `true`, eine Anwendung macht pipelineverbindungen mit den Servern, die sie unterstützen.  
  
 Pipelineverbindungen erfolgen nur, wenn die <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft ist auch `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel gibt den Wert des der <xref:System.Net.HttpWebRequest.Pipelined%2A> Eigenschaft an die Konsole.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob mit der Anforderung ein Autorisierungsheader gesendet wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, um nach der Authentifizierung einen Authorization-HTTP-Header mit Anforderungen zu senden, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach der eine Clientanforderung auf eine bestimmte <xref:System.Uri> erfolgreich authentifiziert wurde, wenn <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> ist `true` und Anmeldeinformationen angegeben werden, der Authorization-Header wird mit jeder Anforderung gesendet, in einen <xref:System.Uri> , entspricht die spezifischen <xref:System.Uri>bis zum letzten Schrägstrich. Wenn die Clientanforderung erfolgreich zu einem bestimmten authentifiziert <xref:System.Uri> , die Folgendes enthält:  
  
 `http://www.contoso.com/firstpath/`  
  
 Und klicken Sie dann der Authorization-Header für die Vorauthentifizierung bei jeder Anforderung, auf eine der folgenden gesendet wird <xref:System.Uri> Instanzen:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Der Authorization-Header wird jedoch nicht gesendet mit Anforderungen auf eine der folgenden <xref:System.Uri> Instanzen:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Wenn der Client für eine bestimmte Anforderung <xref:System.Uri> ist nicht erfolgreich authentifiziert, das die Anforderung Standardauthentifizierungsprozeduren verwendet.  
  
 Mit Ausnahme der ersten Anforderung der <xref:System.Net.WebRequest.PreAuthenticate%2A> Eigenschaft gibt an, ob Authentifizierungsinformationen mit nachfolgenden Anforderungen zum Senden einer <xref:System.Uri> , entspricht die spezifischen <xref:System.Uri> bis zum letzten Schrägstrich ohne darauf warten, werden Durchlaufen vom Server.  
  
 Das folgende Dialogfeld zwischen Client und Server veranschaulicht die Auswirkungen dieser Eigenschaft. Das Dialogfeld wird davon ausgegangen, dass die Standardauthentifizierung verwendet wird.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> ist `false`:  
  
 Client: SomeUrl abrufen  
  
 Server: 401 WWW-Authenticate Basic  
  
 Client: ERHALTEN Sie mit der Authorization-Header  
  
 Server: 200 OK  
  
 Client: SomeUrl abrufen  
  
 Server: 401 WWW-Authenticate Basic  
  
 Client: ERHALTEN Sie mit der Authorization-Header  
  
 Server: 200 OK  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> ist `true`:  
  
 Client: SomeUrl abrufen  
  
 Server: 401 WWW-Authenticate Basic  
  
 Client: ERHALTEN Sie mit der Authorization-Header  
  
 Server: 200 OK  
  
 Client: Abrufen von SomeUrl mit Authorization-Header  
  
 Wenn das Authentifizierungsschema Vorauthentifizierung nicht unterstützt, wird der Wert dieser Eigenschaft ignoriert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für die Anforderung zu verwendende HTTP-Version ab oder legt diese fest.</summary>
        <value>Die für die Anforderung zu verwendende HTTP-Version. Der Standardwert ist <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest> -Klasse unterstützt nur die Versionen 1.0 und 1.1 von HTTP. Festlegen von <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> auf eine andere Version löst eine Ausnahme aus.  
  
> [!NOTE]
>  Verwenden Sie zum Festlegen der HTTP-Version der aktuellen Anforderung die <xref:System.Net.HttpVersion.Version10> und <xref:System.Net.HttpVersion.Version11> Felder der <xref:System.Net.HttpVersion> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> Eigenschaft.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die HTTP-Version wird auf einen anderen Wert als 1.0 oder 1.1 festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Proxyinformationen für die Anforderung ab oder legt diese fest.</summary>
        <value>Das <see cref="T:System.Net.IWebProxy" />-Objekt, das als Proxy für die Anforderung verwendet werden soll. Der Standardwert wird durch Aufrufen der <see cref="P:System.Net.GlobalProxySelection.Select" />-Eigenschaft festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Proxy%2A> identifiziert die <xref:System.Net.WebProxy> Objekt, das zum Verarbeiten von Anforderungen und Ressourcen im Internet verwendet. Um anzugeben, dass kein Proxy verwendet werden soll, legen die <xref:System.Net.HttpWebRequest.Proxy%2A> -Eigenschaft auf die Proxyinstanz, die zurückgegeben werden, indem die <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> Methode.  
  
 Dem lokalen Computer oder eine Anwendungskonfigurationsdatei können Sie angeben, dass ein standardmäßige Proxy verwendet werden. Wenn die <xref:System.Net.HttpWebRequest.Proxy%2A> -Eigenschaft angegeben ist, klicken Sie dann auf die Proxy-Einstellungen aus der <xref:System.Net.HttpWebRequest.Proxy%2A> Eigenschaft zu überschreiben, dem lokalen Computer oder eine Anwendungskonfigurationsdatei und die <xref:System.Net.HttpWebRequest> -Instanz verwendet die angegebenen Proxyeinstellungen. Wenn kein Proxy in einer Konfigurationsdatei angegeben ist und die <xref:System.Net.HttpWebRequest.Proxy%2A> Eigenschaft ist nicht vorgegeben, die <xref:System.Net.HttpWebRequest> Klasse verwendet die Proxyeinstellungen von Internet Explorer geerbt werden, auf dem lokalen Computer. Wenn es keine Proxyeinstellungen in Internet Explorer sind, wird die Anforderung direkt an den Server gesendet.  
  
 Die <xref:System.Net.HttpWebRequest> Klasse analysiert eine Proxyumgehungsliste mit Platzhalterzeichen geerbt von Internet Explorer identisch wie der Umgehungsliste aufgeführt, die direkt von Internet Explorer analysiert wird. Z. B. die <xref:System.Net.HttpWebRequest> -Klasse analysiert eine Umgehungsliste der "nt *" von Internet Explorer als regulärer Ausdruck des "nt.\*". Daher eine URL in der "`http://nt.com`" den Proxy mithilfe der <xref:System.Net.HttpWebRequest> -Klasse und Internet Explorer verwenden.  
  
 Die <xref:System.Net.HttpWebRequest> -Klasse unterstützt die Umgehung von lokalen Proxys. Die Klasse betrachtet ein Ziel lokal, wenn eine der folgenden Bedingungen erfüllt sind:  
  
-   Das Ziel enthält einen flachen Name (keine Punkte in der URL).  
  
-   Das Ziel enthält eine Loopback-Adresse (<xref:System.Net.IPAddress.Loopback> oder <xref:System.Net.IPAddress.IPv6Loopback>) oder das Ziel enthält eine <xref:System.Net.IPAddress> zugewiesen, auf dem lokalen Computer.  
  
-   Das Domänensuffix des Ziels entspricht Domänensuffix des lokalen Computers (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Ändern der <xref:System.Net.HttpWebRequest.Proxy%2A> Eigenschaft nach dem Start der Anforderung durch Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> -Methode löst eine <xref:System.InvalidOperationException>. Die Proxy-Element. Informationen finden Sie unter [ \&Lt; DefaultProxy\&Gt; -Element (Netzwerkeinstellungen)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.Proxy%2A> Methode, um die Proxyinformationen für die Anforderung abzurufen.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Für <see cref="P:System.Net.HttpWebRequest.Proxy" /> ist <see langword="null" /> festgelegt.</exception>
        <exception cref="T:System.InvalidOperationException">Die Anforderung wurde durch Aufrufen von <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> oder <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> gestartet.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <permission cref="T:System.Net.WebPermission">Zum Abrufen oder Festlegen der <see cref="P:System.Net.HttpWebRequest.Proxy" /> Eigenschaft. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy-Element (Netzwerkeinstellungen)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/bb707c72-eed2-4a82-8800-c9e68df2fd4f">Konfigurieren von Internetanwendungen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/353c0a8b-4cee-44f6-8e65-60e286743df9">Proxykonfiguration</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fcd9c3bd-93de-4c92-8ff3-837327ad18de">Automatische Proxyerkennung</related>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Timeout in Millisekunden für das Schreiben in einen Stream oder das Lesen aus einem Stream ab oder legt dieses fest.</summary>
        <value>Die Anzahl von Millisekunden vor dem Timeout für das Schreiben oder Lesen. Der Standardwert ist 300.000 Millisekunden (5 Minuten).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> Eigenschaft wird verwendet, beim Schreiben in den von zurückgegebenen Datenstrom der <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Methode oder Lesen des Streams vom die <xref:System.Net.HttpWebResponse.GetResponseStream%2A> Methode.  
  
 Insbesondere die <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> -Eigenschaft steuert das Timeout für die <xref:System.IO.Stream.Read%2A> -Methode, die verwendet wird, zum Lesen des Streams vom die <xref:System.Net.HttpWebResponse.GetResponseStream%2A> -Methode, und für die <xref:System.IO.Stream.Write%2A> -Methode, die verwendet wird, um in den von der zurückgegebenenDatenstromzuschreiben<xref:System.Net.HttpWebRequest.GetRequestStream%2A>Methode.  
  
 Verwenden Sie zum Angeben der Zeitspanne bis zum Abschluss der Anforderung überschreitet die <xref:System.Net.HttpWebRequest.Timeout%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>-Eigenschaft festgelegt wird.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Anforderung wurde bereits gesendet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen SET-Vorgang angegebene Wert ist kleiner oder gleich 0 (null) und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="Referer" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Wert des <see langword="Referer" />-HTTP-Headers. Der Standardwert ist <see langword="null" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> Eigenschaft `true`, <xref:System.Net.HttpWebRequest.Referer%2A> Eigenschaft wird automatisch festgelegt, wenn die Anforderung an einen anderen Standort umgeleitet wird.  
  
 Zum Löschen der `Referer` HTTP-Header festlegen, die <xref:System.Net.HttpWebRequest.Referer%2A> Eigenschaft `null`.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Eigenschaft auf <xref:System.Net.HttpWebRequest.Referer%2A> festgelegt.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den ursprünglichen URI (Uniform Resource Identifier) der Anforderung ab.</summary>
        <value>Ein <see cref="T:System.Uri" /> mit dem URI der Internetressource, der an die <see cref="M:System.Net.WebRequest.Create(System.String)" />-Methode übergeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri> -Objekt übergeben, um <xref:System.Net.HttpWebRequest> durch den Aufruf von <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 Nach einer Umleitung Header ändert nicht die <xref:System.Net.HttpWebRequest.RequestUri%2A> Eigenschaft. Zum Abrufen des tatsächlichen URI, der die Anforderung beantwortet hat, untersuchen die <xref:System.Net.HttpWebRequest.Address%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob die <xref:System.Net.HttpWebRequest> Objekt `req` an einen anderen Speicherort zur Verarbeitung der Anforderung umgeleitet wurde, und legt den Wert für die `hasChanged` Variable `true` Wenn die Anforderung umgeleitet, andernfalls `hasChanged` nastaven NA hodnotu `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Daten in Segmenten an die Internetressource gesendet werden sollen, oder legt diesen fest.</summary>
        <value><see langword="true" />, um die Daten in Segmenten an die Internetressource zu senden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.HttpWebRequest.SendChunked%2A> ist `true`, die Anforderung sendet Daten an die Internetressource in Segmenten. Die Internetressource muss das Empfangen von Daten in Segmenten unterstützen.  
  
 Ändern der <xref:System.Net.HttpWebRequest.SendChunked%2A> Eigenschaft nach dem Start der Anforderung durch Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> -Methode löst eine <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.SendChunked%2A> Eigenschaft `true` , damit Daten in Segmenten an die Internetressource gesendet werden können.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Anforderung wurde durch Aufrufen der Methode <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> oder <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> gestartet.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Rückruffunktion zur Überprüfung des Serverzertifikats ab oder legt diese fest.</summary>
        <value>Eine Rückruffunktion zur Überprüfung des Serverzertifikats.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert ist, dass keine Rückruffunktion festgelegt ist und die <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> Eigenschaft `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den für die Anforderung zu verwendenden Dienstpunkt ab.</summary>
        <value>Ein <see cref="T:System.Net.ServicePoint" />, der die Netzwerkverbindung mit der Internetressource darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> Eigenschaft möglicherweise von <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> , wenn die Anforderung umgeleitet wird.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anforderung Unterstützung für einen <see cref="T:System.Net.CookieContainer" /> bereitstellt.</summary>
        <value><see langword="true" />, wenn der Vorgang Unterstützung für einen <see cref="T:System.Net.CookieContainer" /> bietet, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Die mit Daten zu füllende <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="streamingContext">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />, der das Ziel für diese Serialisierung angibt.</param>
        <summary>Füllt eine <see cref="T:System.Runtime.Serialization.SerializationInfo" /> mit den Daten auf, die zum Serialisieren des Zielobjekts erforderlich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Objekttypen die <xref:System.Runtime.Serialization.SerializationInfo> werden automatisch nachverfolgt und vom Formatierungsprogramm serialisiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Timeoutwert in Millisekunden für die <see cref="M:System.Net.HttpWebRequest.GetResponse" />-Methode und die <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />-Methode ab oder legt diesen fest.</summary>
        <value>Die Wartezeit in Millisekunden bis zum Timeout der Anforderung. Der Standardwert ist 100.000 Millisekunden (100 Sekunden).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> ist die Anzahl der Millisekunden, der bei eine nachfolgende synchrone Anforderung erstellt die <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode, die für eine Antwort wartet und die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Methode wartet für einen Stream. Die <xref:System.Net.HttpWebRequest.Timeout%2A> gilt auf die gesamte Anforderung und Antwort nicht einzeln für die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> und <xref:System.Net.HttpWebRequest.GetResponse%2A> Methodenaufrufe. Wenn die Ressource innerhalb des Timeoutzeitraums nicht zurückgegeben wird, löst die Anforderung einer <xref:System.Net.WebException> mit der <xref:System.Net.WebException.Status%2A> -Eigenschaftensatz auf <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 Die <xref:System.Net.HttpWebRequest.Timeout%2A> Eigenschaft muss festgelegt werden, bevor die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> oder <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode wird aufgerufen. Ändern der <xref:System.Net.HttpWebRequest.Timeout%2A> Eigenschaft nach dem Aufruf der <xref:System.Net.HttpWebRequest.GetRequestStream%2A> oder <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode hat keine Auswirkung  
  
 Die <xref:System.Net.HttpWebRequest.Timeout%2A> Eigenschaft hat keine Auswirkungen auf die asynchrone Anforderungen, die durch die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> oder <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Methode.  
  
> [!CAUTION]
>  Im Fall von asynchronen Anforderungen auf wird die Clientanwendung einen eigenen Timeoutmechanismus implementiert. Finden Sie im Beispiel in der <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode.  
  
 Verwenden Sie zum Angeben der Zeitspanne bis zum Lesen oder Schreiben Timeout des Vorgangs die <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> Eigenschaft.  
  
 Eine Domain Name System (DNS)-Abfrage dauert bis zu 15 Sekunden oder das Timeout an. Wenn Ihre Anforderung enthält einen Hostnamen an, die Lösung erforderlich sind, und legen Sie Sie <xref:System.Net.FileWebRequest.Timeout%2A> auf einen Wert kleiner als 15 Sekunden dauert möglicherweise 15 Sekunden oder mehr vor einer <xref:System.Net.WebException> wird ausgelöst, um ein Timeout bei der Anforderung angeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.Timeout%2A> Eigenschaft der <xref:System.Net.HttpWebRequest> Objekt.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der angegebene Wert ist kleiner als null (0) und ungleich <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="Transfer-encoding" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Wert des <see langword="Transfer-encoding" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bevor Sie festlegen können die <xref:System.Net.HttpWebRequest.TransferEncoding%2A> -Eigenschaft, müssen Sie zunächst Festlegen der <xref:System.Net.HttpWebRequest.SendChunked%2A> Eigenschaft `true`. Löschen von <xref:System.Net.HttpWebRequest.TransferEncoding%2A> durch Festlegung auf `null` hat keine Auswirkungen auf den Wert der <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Werte für die <xref:System.Net.HttpWebRequest.TransferEncoding%2A> Eigenschaft ersetzen alle vorhandenen Inhalte.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> wird festgelegt, wenn <see cref="P:System.Net.HttpWebRequest.SendChunked" /> den Wert <see langword="false" /> aufweist.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> wird auf den Wert "Chunked" festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Freigabe NTLM-authentifizierter Hochgeschwindigkeitsverbindungen zulässig ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, um die authentifizierte Verbindung geöffnet zu halten, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für diese Eigenschaft ist `false`, die bewirkt, dass der aktuellen Verbindungs geschlossen wird, nachdem eine Anforderung abgeschlossen wurde. Die Authentifizierungsfolge muss Ihre Anwendung durchlaufen, jedes Mal, wenn sie eine neue Anforderung ausgibt.  
  
 Wenn diese Eigenschaft, um festgelegt wird `true`, die zum Abrufen der Antwort verwendete Verbindung bleibt geöffnet, nachdem die Authentifizierung durchgeführt wurde. In diesem Fall andere Anforderungen, die diese Eigenschaft auf festgelegt haben `true` möglicherweise verwenden Sie die Verbindung, ohne Sie erneut zu authentifizieren. Das heißt, wenn eine Verbindung für Benutzer A authentifiziert wurde, Benutzer B kann wiederverwenden, A-Verbindung. Benutzer B die Anforderung erfüllt ist, basierend auf den Anmeldeinformationen von Benutzer A.  
  
> [!CAUTION]
>  Da es für eine Anwendung die Verbindung zu verwenden, ohne Authentifizierung möglich ist, müssen Sie darauf achten, keine administrativen Sicherheitslücken in Ihrem System vorhanden ist, beim Festlegen dieser Eigenschaft auf `true`. Wenn Ihre Anwendung die Anforderungen für mehrere Benutzer sendet (nimmt mehrere Benutzerkonten) und stützt sich auf die Authentifizierung beim Schützen von Ressourcen, legen Sie nicht diese Eigenschaft auf `true` , wenn Sie das Verbindungsgruppen verwenden, wie unten beschrieben.  
  
 Sie sollten erwägen die Aktivierung dieser Mechanismus aus, wenn Ihre Leistung Probleme und Ihre Anwendung auf einem Webserver mit integrierter Windows-Authentifizierung ausgeführt wird.  
  
 Diese Einstellung aktivieren, wird das System von Sicherheitsrisiken. Setzen Sie die <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> Eigenschaft `true` Achten Sie darauf, dass Sie die folgenden Vorsichtsmaßnahmen getroffen werden:  
  
-   Verwenden der <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> Eigenschaft zum Verwalten von Verbindungen für andere Benutzer. Dadurch wird die mögliche Verwendung der Verbindung von Anwendungen nicht authentifizierte vermieden. Benutzer A sollte z. B. einen eindeutiger Verbindungsname Gruppe verfügen, der wird der Benutzer B. Dadurch wird eine Ebene der Isolation für jedes Benutzerkonto.  
  
-   Führen Sie die Anwendung in einer geschützten Umgebung aus, um zu verhindern, dass Exploits der Verbindung.  
  
 Wenn Sie den Back-End-Server zu steuern, als Alternative sollten Sie authentifizierungspersistenz deaktivieren. Dies verbessert die Leistung in geringerem Maße, aber es ist sicherer. Weitere Informationen zu suchen, in der MSDN Library unter nach AuthPersistence [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Wenn beide <xref:System.Net.WebRequest.PreAuthenticate%2A> und <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> festgelegt `true`, jede Anforderung wird mit einer Verbindung aus dem Pool unsicher, jedoch mit einem Autorisierungsheader gesendet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Uneingeschränkte Web-Berechtigung ist erforderlich, diese Eigenschaft festzulegen.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der steuert, ob mit den Anforderungen Standardanmeldeinformationen gesendet werden, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Standardanmeldeinformationen verwendet werden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf `true` bei Anforderungen von dieser <xref:System.Net.HttpWebRequest> Objekt sollte, wenn vom Server angefordert authentifiziert werden mit den Anmeldeinformationen des aktuell angemeldeten Benutzers. Bei Clientanwendungen ist dies das gewünschte Verhalten in den meisten Szenarien. Für Anwendungen der mittleren Ebene, z. B. ASP.NET-Anwendungen anstelle dieser Eigenschaft legen Sie in der Regel die <xref:System.Net.HttpWebRequest.Credentials%2A> Eigenschaft, um die Anmeldeinformationen des Clients in deren Auftrag die Anforderung wird ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Sie haben versucht, diese Eigenschaft nach dem Senden der Anforderung festzulegen.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des <see langword="User-agent" />-HTTP-Headers ab oder legt ihn fest.</summary>
        <value>Der Wert des <see langword="User-agent" />-HTTP-Headers. Der Standardwert ist <see langword="null" />sein.  
  
 <block subset="none" type="note"><para>  
 Der Wert für diese Eigenschaft wird in der <see cref="T:System.Net.WebHeaderCollection" /> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Eigenschaft auf <xref:System.Net.HttpWebRequest.UserAgent%2A> festgelegt.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>