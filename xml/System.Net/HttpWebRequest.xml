<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e375cff6d3f3621aa35b61963b8d8aa09e4f97b6" />
    <Meta Name="ms.sourcegitcommit" Value="b3480b6208c3cad466469e76294a96f5ab1ef04c" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/16/2018" />
    <Meta Name="ms.locfileid" Value="35691819" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Provides an HTTP-specific implementation of the <see cref="T:System.Net.WebRequest" /> class.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest> Klasse bietet Unterstützung für die Eigenschaften und Methoden definiert, <xref:System.Net.WebRequest> und für zusätzliche Eigenschaften und Methoden, die dem Benutzer ermöglichen, direkt mit Servern, die über HTTP zu interagieren.  
  
 Verwenden Sie nicht die <xref:System.Net.HttpWebRequest.%23ctor%2A> Konstruktor. Verwenden der <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> Methode zum Initialisieren neuer <xref:System.Net.HttpWebRequest> Objekte. Wenn das Schema für den Uniform Resource Identifier (URI) ist `http://` oder `https://`, <xref:System.Net.WebRequest.Create%2A> gibt ein <xref:System.Net.HttpWebRequest> Objekt.  
  
 Die <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode ist eine synchrone Anforderung für die die angegebene Ressource der <xref:System.Net.HttpWebRequest.RequestUri%2A> Eigenschaft und gibt eine <xref:System.Net.HttpWebResponse> , enthält das Antwortobjekt. Die Antwortdaten empfangen werden können, mit dem Stream zurückgegebenes <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Wenn das Antwortobjekt oder den Antwortstream geschlossen ist, verbleiben die Daten verfallen. Die übrigen Daten werden entladen werden, und der Socket wird für nachfolgende Abfragen erneut verwendet werden, beim die Response-Objekt oder den Stream zu schließen, halten Sie die folgenden Bedingungen: eine Keep-alive "oder" Pipeline-Anforderung ist, muss nur eine kleine Menge Daten empfangen werden, oder die Verbleibende Daten wird in einem kurzen Zeitraum empfangen. Wenn keine der genannten Bedingungen enthalten, oder die Ausgleichsmodus Zeit überschritten wird, wird der Socket geschlossen. Keep-alive "oder" Pipeline Verbindungen wird dringend empfohlen, dass die Anwendung die Datenströme bis EOF liest. Dadurch wird sichergestellt, dass der Socket für nachfolgende Anforderungen, die resultierenden in eine bessere Leistung und weniger Ressourcen erneut verwendet werden.  
  
 Wenn Daten an die Ressource gesendet werden sollen die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Methode gibt ein <xref:System.IO.Stream> Objekt, das zum Senden von Daten verwendet. Die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> und <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methoden ermöglichen den asynchronen Zugriff auf den Datenstrom senden.  
  
 Für die Clientauthentifizierung mit <xref:System.Net.HttpWebRequest>, das Clientzertifikat muss installiert sein, den Zertifikatspeicher des aktuellen Benutzers.  
  
 Die <xref:System.Net.HttpWebRequest> -Klasse löst eine <xref:System.Net.WebException> Auftreten von Fehlern beim Zugriff auf eine Ressource. Die <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> Eigenschaft enthält eine <xref:System.Net.WebExceptionStatus> -Wert, der die Quelle des Fehlers angibt. Wenn <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> ist <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, <xref:System.Net.WebException.Response%2A> Eigenschaft enthält die <xref:System.Net.HttpWebResponse> empfangen, die von der Ressource.  
  
 <xref:System.Net.HttpWebRequest> macht allgemeine HTTP-Header-Werte an die Internetressource gesendet, als Eigenschaften, durch Methoden festgelegt oder vom System festgelegt; Die folgende Tabelle enthält eine vollständige Liste. Sie können auch andere Header festlegen, in der <xref:System.Net.HttpWebRequest.Headers%2A> Eigenschaft als Name/Wert-Paaren. Beachten Sie, dass Server und Caches möglicherweise Header ändern oder während der Anforderung hinzufügen.  
  
 Die folgende Tabelle enthält die HTTP-Header, die entweder von Eigenschaften oder Methoden oder das System festgelegt werden.  
  
|Header|Festgelegt durch|  
|------------|------------|  
|Akzeptieren|Durch Festlegen der <xref:System.Net.HttpWebRequest.Accept%2A> Eigenschaft.|  
|Verbindung|Durch Festlegen der <xref:System.Net.HttpWebRequest.Connection%2A> Eigenschaft <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft.|  
|Content-Length|Durch Festlegen der <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft.|  
|Inhaltstyp|Durch Festlegen der <xref:System.Net.HttpWebRequest.ContentType%2A> Eigenschaft.|  
|erwartet|Durch Festlegen der <xref:System.Net.HttpWebRequest.Expect%2A> Eigenschaft.|  
|Datum|Durch das System auf das aktuelle Datum festgelegt.|  
|Host|Durch das System auf die aktuellen Hostinformationen festgelegt.|  
|If-Modified-Since|Durch Festlegen der <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft.|  
|Bereich|Durch Festlegen der <xref:System.Net.HttpWebRequest.AddRange%2A> Methode.|  
|Referer|Durch Festlegen der <xref:System.Net.HttpWebRequest.Referer%2A> Eigenschaft.|  
|Transfer-Encoding|Durch Festlegen der <xref:System.Net.HttpWebRequest.TransferEncoding%2A> Eigenschaft (die <xref:System.Net.HttpWebRequest.SendChunked%2A> Eigenschaft muss `true`).|  
|Benutzer-Agent|Durch Festlegen der <xref:System.Net.HttpWebRequest.UserAgent%2A> Eigenschaft.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> wird automatisch registriert. Sie müssen nicht Aufrufen der <xref:System.Net.WebRequest.RegisterPrefix%2A> Methode, um registrieren <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> vor der Verwendung von URIs ab `http://` oder `https://`.  
  
 Dem lokalen Computer oder eine Anwendungskonfigurationsdatei kann angeben, dass ein standardmäßige Proxy verwendet werden. Wenn die <xref:System.Net.HttpWebRequest.Proxy%2A> Eigenschaft angegeben ist, klicken Sie dann auf die Proxy-Einstellungen aus der <xref:System.Net.HttpWebRequest.Proxy%2A> Eigenschaft zu überschreiben, dem lokalen Computer oder eine Anwendungskonfigurationsdatei und die <xref:System.Net.HttpWebRequest> Instanz verwendet die angegebenen Proxyeinstellungen. Wenn kein Proxy in eine Datei "App.config" angegeben ist und die <xref:System.Net.HttpWebRequest.Proxy%2A> Eigenschaft ist nicht vorgegeben, die <xref:System.Net.HttpWebRequest> Klasse verwendet die Proxyeinstellungen von Internet Explorer geerbt werden, auf dem lokalen Computer. Wenn es keine Proxyeinstellungen in Internet Explorer sind, wird die Anforderung direkt an den Server gesendet.  
  
 Die <xref:System.Net.HttpWebRequest> Klasse analysiert eine Proxyumgehungsliste mit Platzhalterzeichen vererbt von Internet Explorer anders als die Umgehungsliste direkt vom Internet Explorer analysiert wird. Z. B. die <xref:System.Net.HttpWebRequest> -Klasse analysiert eine Umgehungsliste des "nt *" von Internet Explorer als regulären Ausdruck "nt. $". Dies unterscheidet sich von der Verhalten von systemeigenem von Internet Explorer. Daher eine URL von "`http://intxxxxx`" den Proxy mithilfe der <xref:System.Net.HttpWebRequest> Klasse, aber würde umgeht den Proxy mithilfe von Internet Explorer.  
  
> [!NOTE]
>  Das Framework SSL-Sitzungen werden zwischengespeichert, wie sie erstellt werden und versucht, eine zwischengespeicherte-Sitzung für eine neue Anforderung nach Möglichkeit wiederverwendet. Beim Versuch, eine SSL-Sitzung wiederzuverwenden, verwendet das Framework das erste Element des <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (sofern vorhanden), oder versucht, eine anonyme Sitzung wiederzuverwenden, wenn <xref:System.Net.HttpWebRequest.ClientCertificates%2A> ist leer.  
  
> [!NOTE]
>  Cookies sind aus Gründen der Sicherheit standardmäßig deaktiviert. Wenn Sie Cookies verwenden möchten, verwenden Sie die <xref:System.Net.HttpWebRequest.CookieContainer%2A> Eigenschaft, um Cookies zu aktivieren.  
  
 .NET Framework 4.6 umfasst eine neue Sicherheitsfunktion, die unsichere Verschlüsselungssammlungen und Hashalgorithmen für Verbindungen blockiert. Anwendungen verwenden TLS/SSL über APIs wie z. B. "HttpClient", HttpWebRequest-Anforderung, FTPClient, SmtpClient, SslStream usw. und .NET Framework 4.6 abzielt erhalten die sicherere Verhalten in der Standardeinstellung.  
  
 Möglicherweise möchten Entwickler dieses Verhalten abzuwählen, um die Interoperabilität mit ihrer vorhandenen SSL3-Diensten oder TLS mit RC4-Dienste zu verwalten. [In diesem Artikel](https://support.microsoft.com/kb/3069494) wird erläutert, wie Sie Ihren Code ändern, damit das neue Verhalten deaktiviert ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Net.HttpWebRequest> für den URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">Zugriffsrechte für den angeforderten URI oder einen beliebigen URI, der die Anforderung umgeleitet wurde. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class. These constructors are obsolete; see the Remarks section for details.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Beide <xref:System.Net.HttpWebRequest> Konstruktoren sind veraltet und sollte nicht verwendet werden. Rufen Sie die <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> Methode zum Initialisieren neuer <xref:System.Net.HttpWebRequest> Objekte.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class. This constructor is obsolete.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the new <see cref="T:System.Net.HttpWebRequest" /> object.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains the source and destination of the serialized stream associated with the new <see cref="T:System.Net.HttpWebRequest" /> object.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class from the specified instances of the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> and <see cref="T:System.Runtime.Serialization.StreamingContext" /> classes. This constructor is obsolete.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung muss im Modus mit vollständiger Vertrauenswürdigkeit ausgeführt, bei Verwendung der Serialisierung.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">für den uneingeschränkten Zugriff auf Netzwerkressourcen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels a request to an Internet resource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Abort%2A> -Methode bricht eine Anforderung an eine Ressource ab. Nach dem Abbruch einer Anforderung Aufrufen der <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, oder <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> -Methode nimmt eine <xref:System.Net.WebException> mit der <xref:System.Net.WebException.Status%2A> -Eigenschaftensatz auf <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 Die <xref:System.Net.HttpWebRequest.Abort%2A> Methode wird synchron ausgeführt, den Rückruf angegeben, um die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methoden Wenn die <xref:System.Net.HttpWebRequest.Abort%2A> Methode wird aufgerufen, während einer dieser Vorgänge ausstehen. Dies kann zu potenziellen Deadlock-Probleme führen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Im Fall von asynchronen Anforderungen ist es die Aufgabe von der Clientanwendung, die einen eigenen Timeoutmechanismus implementieren. Im folgenden Codebeispiel wird veranschaulicht, wie dies.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Accept" /> HTTP header.</summary>
        <value>Der Wert des <see langword="Accept" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 So löschen Sie die `Accept` HTTP-Header festlegen, die <xref:System.Net.HttpWebRequest.Accept%2A> Eigenschaft, um `null`.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Eigenschaft auf <xref:System.Net.HttpWebRequest.Accept%2A> festgelegt.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds a range header to the request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich für alle HTTP-Entität von Bedeutung. Allerdings müssen nicht alle Clients und Servern Bytebereichs-Vorgänge unterstützen.  
  
 Die Range-Header in einer Anforderung kann ein Client anfordern, dass es nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, Unterstützung für Range-Header-Anforderungen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a byte range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bytebereichsheader hinzugefügt.  
  
 Wenn `range` positiv ist, wird die `range` Parameter gibt den Ausgangspunkt des Bereichs. Starten des Servers sollte Senden von Daten aus der `range` Parameter angegeben, um das Ende der Daten in der HTTP-Entität.  
  
 Wenn `range` ist ein negativer Wert, der `range` Parameter gibt den Endpunkt des Bereichs. Starten des Servers muss das Senden von Daten vom Beginn der Daten in die HTTP-Entität, die die `range` Parameter wurde angegeben.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich für alle HTTP-Entität von Bedeutung. Allerdings müssen nicht alle Clients und Servern Bytebereichs-Vorgänge unterstützen.  
  
 Die Range-Header in einer Anforderung kann ein Client anfordern, dass es nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, Unterstützung für Range-Header-Anforderungen.  
  
 Ein Beispiel einer Range-Header in einer HTTP-Protokoll-Anforderung, die anfordert, Server senden, die ersten 100 Bytes (vom Anfang bis zum Byteposition 99) die folgenden wäre:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel die `range` Parameter wäre-99.  
  
 Ein HTTP-Server gibt die Unterstützung für Range-Header mit dem Accept-Ranges-Header an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn Sie ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Anforderung zum Bereich nur die HTTP-Header, die der gesamte Anforderung zugeordneten analysiert und via-Eigenschaften auf zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Anforderung einen Bereichsheader hinzugefügt.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a byte range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bytebereichsheader hinzugefügt.  
  
 Wenn `range` positiv ist, wird die `range` Parameter gibt den Ausgangspunkt des Bereichs. Starten des Servers sollte Senden von Daten aus der `range` Parameter angegeben, um das Ende der Daten in der HTTP-Entität.  
  
 Wenn `range` ist ein negativer Wert, der `range` Parameter gibt den Endpunkt des Bereichs. Starten des Servers muss das Senden von Daten vom Beginn der Daten in die HTTP-Entität, die die `range` Parameter wurde angegeben.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich für alle HTTP-Entität von Bedeutung. Allerdings müssen nicht alle Clients und Servern Bytebereichs-Vorgänge unterstützen.  
  
 Die Range-Header in einer Anforderung kann ein Client anfordern, dass es nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, Unterstützung für Range-Header-Anforderungen.  
  
 Ein Beispiel einer Range-Header in einer HTTP-Protokoll-Anforderung, die anfordert, Server senden, die ersten 100 Bytes (vom Anfang bis zum Byteposition 99) die folgenden wäre:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel die `range` Parameter wäre-99.  
  
 Ein HTTP-Server gibt die Unterstützung für Range-Header mit dem Accept-Ranges-Header an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn Sie ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Anforderung zum Bereich nur die HTTP-Header, die der gesamte Anforderung zugeordneten analysiert und via-Eigenschaften auf zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a byte range header to the request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bytebereichsheader hinzugefügt.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich für alle HTTP-Entität von Bedeutung. Allerdings müssen nicht alle Clients und Servern Bytebereichs-Vorgänge unterstützen.  
  
 Die Range-Header in einer Anforderung kann ein Client anfordern, dass es nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, Unterstützung für Range-Header-Anforderungen.  
  
 Ein Beispiel für eine Range-Header in einer HTTP-Protokoll-Anforderung, die Anforderungen die ersten 100 Bytes wäre Folgendes:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel die `from` Parameter würde als 0 angegeben werden und die `to` Parameter würde als 99 angegeben werden. Der Bereichsbezeichner wird von dieser Methode automatisch als "Bytes" festgelegt.  
  
 Ein HTTP-Server gibt die Unterstützung für Range-Header mit dem Accept-Ranges-Header an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn Sie ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Anforderung zum Bereich nur die HTTP-Header, die der gesamte Anforderung zugeordneten analysiert und via-Eigenschaften auf zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Anforderung einen Bereichsheader hinzugefügt.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a byte range header to the request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bytebereichsheader hinzugefügt.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich für alle HTTP-Entität von Bedeutung. Allerdings müssen nicht alle Clients und Servern Bytebereichs-Vorgänge unterstützen.  
  
 Die Range-Header in einer Anforderung kann ein Client anfordern, dass es nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, Unterstützung für Range-Header-Anforderungen.  
  
 Ein Beispiel für eine Range-Header in einer HTTP-Protokoll-Anforderung, die Anforderungen die ersten 100 Bytes wäre Folgendes:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel die `from` Parameter würde als 0 angegeben werden und die `to` Parameter würde als 99 angegeben werden. Der Bereichsbezeichner wird von dieser Methode automatisch als "Bytes" festgelegt.  
  
 Ein HTTP-Server gibt die Unterstützung für Range-Header mit dem Accept-Ranges-Header an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn Sie ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Anforderung zum Bereich nur die HTTP-Header, die der gesamte Anforderung zugeordneten analysiert und via-Eigenschaften auf zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a Range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bereichsheader hinzugefügt.  
  
 Wenn `range` positiv ist, wird die `range` Parameter gibt den Ausgangspunkt des Bereichs. Starten des Servers sollte Senden von Daten aus der `range` Parameter angegeben, um das Ende der Daten in der HTTP-Entität.  
  
 Wenn `range` ist ein negativer Wert, der `range` Parameter gibt den Endpunkt des Bereichs. Starten des Servers muss das Senden von Daten vom Beginn der Daten in die HTTP-Entität, die die `range` Parameter wurde angegeben.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich für alle HTTP-Entität von Bedeutung. Allerdings müssen nicht alle Clients und Servern Bytebereichs-Vorgänge unterstützen.  
  
 Die Range-Header in einer Anforderung kann ein Client anfordern, dass es nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, Unterstützung für Range-Header-Anforderungen.  
  
 Die `rangeSpecifier` Parameter würde normalerweise als "Byte", angegeben werden, da dies nur Bereichsbezeichner, die von den meisten HTTP-Server erkannt wird. Festlegen der `rangeSpecifier` Parameter an eine andere Zeichenfolge erlaubt die Unterstützung für benutzerdefinierte als Bytes (der Bytebereichs-Bezeichner, die in RFC 2616 durch die IETF definiert).  
  
 Ein Beispiel für eine Range-Header in einer HTTP-Protokoll-Anforderung, die Anforderungen die ersten 100 Bytes wäre Folgendes:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 In diesem Beispiel die `rangeSpecifier` Parameter würde als "Bytes" angegeben werden und die `range` Parameter wäre-99.  
  
 Ein HTTP-Server gibt Unterstützung für Range-Header mit den Accept-Ranges-Header in der Antwort an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn Sie ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Anforderung zum Bereich nur die HTTP-Header, die der gesamte Anforderung zugeordneten analysiert und via-Eigenschaften auf zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a Range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bereichsheader hinzugefügt.  
  
 Wenn `range` positiv ist, wird die `range` Parameter gibt den Ausgangspunkt des Bereichs. Starten des Servers sollte Senden von Daten aus der `range` Parameter angegeben, um das Ende der Daten in der HTTP-Entität.  
  
 Wenn `range` ist ein negativer Wert, der `range` Parameter gibt den Endpunkt des Bereichs. Starten des Servers muss das Senden von Daten vom Beginn der Daten in die HTTP-Entität, die die `range` Parameter wurde angegeben.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich für alle HTTP-Entität von Bedeutung. Allerdings müssen nicht alle Clients und Servern Bytebereichs-Vorgänge unterstützen.  
  
 Die Range-Header in einer Anforderung kann ein Client anfordern, dass es nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, Unterstützung für Range-Header-Anforderungen.  
  
 Die `rangeSpecifier` Parameter würde normalerweise als "Byte", angegeben werden, da dies nur Bereichsbezeichner, die von den meisten HTTP-Server erkannt wird. Festlegen der `rangeSpecifier` Parameter an eine andere Zeichenfolge erlaubt die Unterstützung für benutzerdefinierte als Bytes (der Bytebereichs-Bezeichner, die in RFC 2616 durch die IETF definiert).  
  
 Ein Beispiel für eine Range-Header in einer HTTP-Protokoll-Anforderung, die Anforderungen die ersten 100 Bytes wäre Folgendes:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 In diesem Beispiel die `rangeSpecifier` Parameter würde als "Bytes" angegeben werden und die `range` Parameter wäre-99.  
  
 Ein HTTP-Server gibt Unterstützung für Range-Header mit den Accept-Ranges-Header in der Antwort an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Wenn Sie ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Anforderung zum Bereich nur die HTTP-Header, die der gesamte Anforderung zugeordneten analysiert und via-Eigenschaften auf zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a range header to a request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bereichsheader hinzugefügt.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich für alle HTTP-Entität von Bedeutung. Allerdings müssen nicht alle Clients und Servern Bytebereichs-Vorgänge unterstützen.  
  
 Die Range-Header in einer Anforderung kann ein Client anfordern, dass es nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, Unterstützung für Range-Header-Anforderungen.  
  
 Die `rangeSpecifier` Parameter würde normalerweise als "Byte", angegeben werden, da dies nur Bereichsbezeichner, die von den meisten HTTP-Server erkannt wird. Festlegen der `rangeSpecifier` Parameter an eine andere Zeichenfolge erlaubt die Unterstützung für benutzerdefinierte als Bytes (der Bytebereichs-Bezeichner, die in RFC 2616 durch die IETF definiert).  
  
 Ein Beispiel für eine Range-Header in einer HTTP-Protokoll-Anforderung, die Anforderungen die ersten 100 Bytes wäre Folgendes:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel die `rangeSpecifier` Parameter würde als "Byte", angegeben werden die `from` Parameter würde "0" sein und die `to` Parameter würde 99 sein.  
  
 Ein HTTP-Server gibt Unterstützung für Range-Header mit den Accept-Ranges-Header in der Antwort an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Die Zeichenfolge, die im Accept-Ranges-Header angegebene ist der Bereichsbezeichner, die von in angegeben werden, würde der `rangeSpecifier` -Parameter für diese Methode.  
  
 Wenn Sie ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Anforderung zum Bereich nur die HTTP-Header, die der gesamte Anforderung zugeordneten analysiert und via-Eigenschaften auf zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a range header to a request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Methode der Anforderung einen Bereichsheader hinzugefügt.  
  
 Da alle HTTP-Entitäten in HTTP-Nachrichten als Bytefolgen dargestellt werden, ist das Konzept der einen Bytebereich für alle HTTP-Entität von Bedeutung. Allerdings müssen nicht alle Clients und Servern Bytebereichs-Vorgänge unterstützen.  
  
 Die Range-Header in einer Anforderung kann ein Client anfordern, dass es nur einen Teil des angegebenen Bereichs von Bytes in einer HTTP-Entität empfangen möchte. Server sind nicht erforderlich, Unterstützung für Range-Header-Anforderungen.  
  
 Die `rangeSpecifier` Parameter würde normalerweise als "Byte", angegeben werden, da dies nur Bereichsbezeichner, die von den meisten HTTP-Server erkannt wird. Festlegen der `rangeSpecifier` Parameter an eine andere Zeichenfolge erlaubt die Unterstützung für benutzerdefinierte als Bytes (der Bytebereichs-Bezeichner, die in RFC 2616 durch die IETF definiert).  
  
 Ein Beispiel für eine Range-Header in einer HTTP-Protokoll-Anforderung, die Anforderungen die ersten 100 Bytes wäre Folgendes:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 In diesem Beispiel die `rangeSpecifier` Parameter würde als "Byte", angegeben werden die `from` Parameter würde "0" sein und die `to` Parameter würde 99 sein.  
  
 Ein HTTP-Server gibt Unterstützung für Range-Header mit den Accept-Ranges-Header in der Antwort an. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bytebereiche unterstützt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Die Zeichenfolge, die im Accept-Ranges-Header angegebene ist der Bereichsbezeichner, die von in angegeben werden, würde der `rangeSpecifier` -Parameter für diese Methode.  
  
 Wenn Sie ein Accept-Ranges-Header nicht im Header der Antwort vom Server empfangen wird, wird vom Server Range-Header nicht unterstützt. Ein Beispiel für den Accept-Ranges-Header von einem Server, der Bereiche nicht unterstützt, aber den Accept-Ranges-Header, erkennt würde folgendermaßen aussehen:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Beim Empfang der Antwort von einer Anforderung zum Bereich nur die HTTP-Header, die der gesamte Anforderung zugeordneten analysiert und via-Eigenschaften auf zur Verfügung gestellt werden die <xref:System.Net.HttpWebResponse> Klasse. Jeder Bereich zugeordneten Header werden in der Antwort zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Uniform Resource Identifier (URI) of the Internet resource that actually responds to the request.</summary>
        <value>Ein <see cref="T:System.Uri" />, der die Internetressource bezeichnet, die auf die Anforderung reagiert. Standardmäßig ist dies der URI, der von der <see cref="M:System.Net.WebRequest.Create(System.String)" />-Methode zum Initialisieren der Anforderung verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Address%2A> Eigenschaft an den URI festgelegt ist, nachdem alle umleitungen, die durchgeführt werden während der Anforderung abgeschlossen sind.  
  
 Der URI der ursprünglichen Anforderung bleiben der <xref:System.Net.HttpWebRequest.RequestUri%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob die <xref:System.Net.HttpWebRequest> Objekt `req` an einen anderen Speicherort für die Anforderung umgeleitet wurde, und legt den Wert des der `hasChanged` Variable `true` , wenn die Anforderung umgeleitet wurde; andernfalls `hasChanged`festgelegt ist, um `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the request should follow redirection responses.</summary>
        <value>
          <see langword="true" />, wenn die Anforderung Umleitungsantworten von der Internetressource automatisch folgen soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> zu `true` , wenn Sie die Anforderung Header der HTTP-Umleitung an den neuen Speicherort der Ressource automatisch folgen soll. Die maximale Anzahl von umleitungen folgen wird festgelegt, indem die <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> Eigenschaft.  
  
 Wenn <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> festgelegt ist, um `false`, alle Antworten mit HTTP-Statuscode zwischen 300 und 399 wird an die Anwendung zurückgegeben.  
  
 Der Authorization-Header auf automatische umleitungen deaktiviert ist und <xref:System.Net.HttpWebRequest> wird automatisch versucht, die an umgeleiteten Speicherort erneut zu authentifizieren. In der Praxis bedeutet dies, dass eine Anwendung kann nicht benutzerdefinierte Authentifizierungsinformationen in der Authorization-Header nehmen, wenn es möglich ist, die Umleitung auftreten. Stattdessen muss die Anwendung implementieren, und registrieren ein benutzerdefiniertes Authentifizierungsmodul. Die <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> und verwandte Klassen werden verwendet, um ein benutzerdefiniertes Authentifizierungsmodul zu implementieren. Die <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> Methode registriert ein benutzerdefiniertes Authentifizierungsmodul.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> Eigenschaft, um die Anforderung Umleitungsantworten folgen zu können.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to buffer the received from the Internet resource.</summary>
        <value>
          <see langword="true" /> aktiviert die Zwischenspeicherung der aus der Internetressource empfangenen Daten, <see langword="false" /> deaktiviert die Zwischenspeicherung. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to buffer the data sent to the Internet resource.</summary>
        <value>
          <see langword="true" /> aktiviert das Puffern der an die Internetressource gesendeten Daten, <see langword="false" /> deaktiviert das Puffern. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> ist `true`, die Daten im Arbeitsspeicher gepuffert werden, damit er im Fall von umleitungen oder Authentifizierung Anforderungen erneut gesendet werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> -Eigenschaft Datenpufferung deaktiviert.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Festlegen von <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> auf <see langword="true" /> möglicherweise Leistungsprobleme beim Hochladen großer Datasets erstellt werden, da Datenpuffer gesamten verfügbaren Arbeitsspeicher verwenden kann.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of decompression that is used.</summary>
        <value>Ein <see cref="T:System.Net.DecompressionMethods" /> Objekt, das den Typ der dekomprimierung angibt, der verwendet wird.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">The object's current state does not allow this property to be set.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">The state object for this request.</param>
        <summary>Begins an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Methode startet eine asynchrone Anforderung eines Streams verwendet, um das Senden von Daten für die <xref:System.Net.HttpWebRequest>. Die asynchrone Rückrufmethode verwendet die <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methode, um den tatsächlichen Stream zurück.  
  
 Die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Methode erfordert einige synchrone Setupaufgaben (DNS-Auflösung Proxyerkennung und TCP-Socketverbindung, z. B.) abgeschlossen, bevor diese Methode asynchron ist. Daher diese Methode sollte nie aufgerufen werden auf einen Thread für die Benutzeroberfläche (UI), da es sehr viel Zeit (bis zu mehrere Minuten je nach den Einstellungen) bei den synchronen Anfangssetup vor einer Ausnahme Tasks für ein Fehler ausgelöst wird, nehmen möglicherweise oder die Methode erfolgreich ist.  
  
 Weitere Informationen zu den Threadpool finden Sie unter [der verwaltete Threadpool](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Synchrone und asynchrone Methoden für eine bestimmte Anforderung kann nicht die Anwendung kombiniert werden. Beim Aufrufen der <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> -Methode, müssen Sie verwenden die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode, um die Antwort abzurufen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Methode, um eine asynchrone Anforderung für eine Instanz des Streams.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.InvalidOperationException">The stream is being used by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.  -or-  The thread pool is running out of threads.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.</exception>
        <exception cref="T:System.ObjectDisposedException">In a .NET Compact Framework application, a request stream with zero content length was not obtained and closed correctly. For more information about handling zero content length requests, see [Network Programming in the .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate</param>
        <param name="state">The state object for this request.</param>
        <summary>Begins an asynchronous request to an Internet resource.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous request for a response.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode startet eine asynchrone Anforderung einer Antwort von der Internetressource. Die asynchrone Rückrufmethode verwendet die <xref:System.Net.HttpWebRequest.EndGetResponse%2A> Methode zum Zurückgeben der tatsächlichen <xref:System.Net.WebResponse>.  
  
 Ein <xref:System.Net.ProtocolViolationException> wird in mehreren Fällen ausgelöst, wenn die Eigenschaften festlegen, auf die <xref:System.Net.HttpWebRequest> Klasse stehen in Konflikt. Diese Ausnahme tritt auf, wenn eine Anwendung festlegt der <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft und die <xref:System.Net.HttpWebRequest.SendChunked%2A> Eigenschaft, um `true`, und klicken Sie dann eine HTTP GET-Anforderung sendet. Diese Ausnahme tritt auf, wenn eine Anwendung, zum Senden von Segmenten mit einem Server, der nur HTTP 1.0-Protokoll unterstützt versucht, in denen dies wird nicht unterstützt. Diese Ausnahme tritt auf, wenn eine Anwendung, zum Senden von Daten festlegen, ohne versucht die <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft oder die <xref:System.Net.HttpWebRequest.SendChunked%2A> ist `false` Wenn Pufferung deaktiviert ist, und klicken Sie auf eine Keepalive-Verbindung (die <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft ist `true`)`.`  
  
 Wenn eine <xref:System.Net.WebException> ist ausgelöst wird, verwenden die <xref:System.Net.WebException.Response%2A> und <xref:System.Net.WebException.Status%2A> Eigenschaften der Ausnahme, um die Antwort vom Server zu bestimmen.  
  
 Die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode erfordert einige synchrone Setupaufgaben (DNS-Auflösung Proxyerkennung und TCP-Socketverbindung, z. B.) abgeschlossen, bevor diese Methode asynchron ist. Daher diese Methode sollte nie aufgerufen werden auf einen Thread für die Benutzeroberfläche (UI), da es sehr viel Zeit (bis zu mehrere Minuten je nach den Einstellungen) bei den synchronen Anfangssetup vor einer Ausnahme Tasks für ein Fehler ausgelöst wird, nehmen möglicherweise oder die Methode erfolgreich ist.  
  
 Weitere Informationen zu den Threadpool finden Sie unter [ &#91; \<Topic://cpconthreadpooling >&#93;](http://msdn.microsoft.com/library/2be05b06-a42e-4c9d-a739-96c21d673927).  
  
> [!NOTE]
>  Synchrone und asynchrone Methoden für eine bestimmte Anforderung kann nicht die Anwendung kombiniert werden. Beim Aufrufen der <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> -Methode, müssen Sie verwenden die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode, um die Antwort abzurufen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [ &#91; \<Topic://conUsingNetworkTracing >&#93;](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode, um eine asynchrone Anforderung einer Internetressource.  
  
> [!NOTE]
>  Im Fall von asynchronen Anforderungen ist es die Aufgabe von der Clientanwendung, die einen eigenen Timeoutmechanismus implementieren. Im folgenden Codebeispiel wird veranschaulicht, wie Sie dies durchführen.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The stream is already in use by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.  -or-  The thread pool is running out of threads.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> is GET or HEAD, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero or <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="true" />.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" /> and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.  -or-  The <see cref="T:System.Net.HttpWebRequest" /> has an entity body but the <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method is called without calling the <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> method.  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero, but the application does not write all of the promised data.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the collection of security certificates that are associated with this request.</summary>
        <value>Die <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> mit den dieser Anforderung zugeordneten Sicherheitszertifikaten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung kann ein Zertifikat zu einer Auflistung hinzufügen, aber möglicherweise keine Zugriffsberechtigungen. Um ein Zertifikat in der Auflistung enthaltenen verwenden zu können, muss die Anwendung die gleichen Zugriffsrechte wie die Entität verfügen, die das Zertifikat ausgestellt hat.  
  
> [!NOTE]
>  Das Framework SSL-Sitzungen werden zwischengespeichert, wie sie erstellt werden und versucht, eine zwischengespeicherte-Sitzung für eine neue Anforderung nach Möglichkeit wiederverwendet. Beim Versuch, eine SSL-Sitzung wiederzuverwenden, verwendet das Framework das erste Element des <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (sofern vorhanden), oder versucht, eine anonyme Sitzung wiederzuverwenden, wenn <xref:System.Net.HttpWebRequest.ClientCertificates%2A> ist leer.  
  
> [!NOTE]
>  Aus Gründen der Leistung, die Sie ein Clientzertifikat hinzufügen darf keine <xref:System.Net.HttpWebRequest> , außer Sie wissen, fragt der Server dafür.  
>   
>  Ein Codebeispiel zur Veranschaulichung wie die Zertifikate im Zertifikatspeicher Clients aufgelistet werden, finden Sie unter der <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value specified for a set operation is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Connection" /> HTTP header.</summary>
        <value>Der Wert des <see langword="Connection" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anforderung sendet die <xref:System.Net.HttpWebRequest.Connection%2A> an die Internetressource als Eigenschaft der `Connection` HTTP-Header. Wenn der Wert von der <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft ist `true`, wird der Wert "Keep-alive" an das Ende angefügt der `Connection` Header.  
  
 So löschen Sie die `Connection` HTTP-Header festlegen, die <xref:System.Net.HttpWebRequest.Connection%2A> Eigenschaft, um `null`.  
  
 Ändern der <xref:System.Net.HttpWebRequest.Connection%2A> Eigenschaft nach dem Start der Anforderung durch Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> -Methode löst eine <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Net.HttpWebRequest.Connection%2A> Eigenschaft zum Festlegen des Werts der Verbindungs-HTTP-Headers.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value of <see cref="P:System.Net.HttpWebRequest.Connection" /> is set to Keep-alive or Close.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the connection group for the request.</summary>
        <value>Der Name der Verbindungsgruppe für diese Anforderung. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> -Eigenschaft ermöglicht es Ihnen, eine Anforderung einer Verbindungsgruppe zugeordnet werden soll. Dies ist hilfreich, wenn Ihre Anwendung Anforderungen an einen Server für verschiedene Benutzer, z. B. eine Website gesendet werden, die Kundeninformationen aus einem Datenbankserver abruft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie mit Benutzerinformationen bilden eine Verbindungsgruppe, vorausgesetzt, dass die Variablen `username`, `password`, und `domain` von der Anwendung festgelegt werden, bevor dieser Code aufgerufen wird.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jede Gruppe "Verbindung" erstellt zusätzliche Verbindungen für einen Server. Kann dies überschreitet die Anzahl der Verbindungen festlegen, indem die <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> Eigenschaft für diesen Server.</para>
        </block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see langword="Content-length" /> HTTP header.</summary>
        <value>Die Anzahl der Bytes der an die Internetressource zu sendenden Daten. Der Standardwert ist -1. Dieser Wert gibt an, dass die Eigenschaft nicht festgelegt wurde und keine zu sendenden Anforderungsdaten vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ContentLength%2A> -Eigenschaft enthält den Wert zum Senden als die `Content-length` HTTP-Header mit der Anforderung.  
  
 Einen anderen Wert als-1 in der <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft gibt an, dass die Anforderung Daten hochlädt, dass nur die Methoden, die Daten hochladen zulässig sind, festgelegt werden, der <xref:System.Net.HttpWebRequest.Method%2A> Eigenschaft.  
  
 Nach der <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft auf einen Wert festgelegt ist, diese Anzahl an Bytes muss geschrieben werden in den Anforderungsstream, die durch den Aufruf zurückgegeben wird das <xref:System.Net.HttpWebRequest.GetRequestStream%2A> -Methode oder beide der <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> und <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methoden.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft, um die Länge der Zeichenfolge bereitgestellt wird.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The new <see cref="P:System.Net.HttpWebRequest.ContentLength" /> value is less than 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Content-type" /> HTTP header.</summary>
        <value>Der Wert des <see langword="Content-type" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ContentType%2A> Eigenschaft enthält den Medientyp der Anforderung. Werte für die <xref:System.Net.HttpWebRequest.ContentType%2A> Eigenschaft ersetzen alle vorhandenen Inhalte auf, wenn die Anforderung sendet die `Content-type` HTTP-Header.  
  
 So löschen Sie die `Content-type` HTTP-Header festlegen, die <xref:System.Net.HttpWebRequest.ContentType%2A> Eigenschaft, um `null`.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft befindet sich in <xref:System.Net.WebHeaderCollection> . Wenn <xref:System.Net.WebHeaderCollection> festgelegt ist, wird der Eigenschaftswert verloren gegangen ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Eigenschaft auf <xref:System.Net.HttpWebRequest.ContentType%2A> festgelegt.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the delegate method called when an HTTP 100-continue response is received from the Internet resource.</summary>
        <value>Ein Delegat, der die Rückrufmethode implementiert, die ausgeführt wird, wenn die Internetressource eine HTTP-Continue-Antwort zurückgibt. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> Eigenschaft gibt an, die Rückrufmethode, die aufgerufen wird, wenn der Client, eine 100 empfängt-Continue-Antwort.  
  
 Wenn die <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> Eigenschaft festgelegt ist, wird der Client Ruft den Delegaten bei jedem Protokoll Antworten des Typs <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) empfangen werden. Dies ist hilfreich, wenn der Client den Status der von der Internetressource empfangenen Daten anzeigen soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a timeout, in milliseconds, to wait until the 100-Continue is received from the server.</summary>
        <value>Das Timeout in Millisekunden, bis zu dem auf den Empfang von "100-Continue" gewartet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der 100-Continue-Antwort empfangen wird, vor Ablauf des Timeouts Entitätstext kann gesendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the cookies associated with the request.</summary>
        <value>Ein <see cref="T:System.Net.CookieContainer" /> mit den dieser Anforderung zugeordneten Cookies.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.CookieContainer%2A> Eigenschaft enthält eine Instanz von der <xref:System.Net.CookieContainer> -Klasse, die dieser Anforderung zugeordneten Cookies enthält.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> ist `null` standardmäßig. Sie zuweisen müssen eine <xref:System.Net.CookieContainer> Objekt, das die Eigenschaft so, dass im zurückgegebenen Cookies der <xref:System.Net.HttpWebResponse.Cookies%2A> Eigenschaft von der <xref:System.Net.HttpWebResponse> zurückgegebenes die <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode.  
  
> [!NOTE]
>  Cookies sind aus Gründen der Sicherheit standardmäßig deaktiviert. Wenn Sie Cookies verwenden möchten, verwenden Sie die <xref:System.Net.HttpWebRequest.CookieContainer%2A> Eigenschaft, um Cookies zu aktivieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet eine Anforderung an eine URL und zeigt die Cookies, die in der Antwort zurückgegeben.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets authentication information for the request.</summary>
        <value>Ein <see cref="T:System.Net.ICredentials" />-Element mit den der Anforderung zugeordneten Anmeldeinformationen für die Authentifizierung. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Credentials%2A> Eigenschaft enthält Informationen zur Benutzerauthentifizierung zum Identifizieren der Ersteller der Anforderung. Die <xref:System.Net.HttpWebRequest.Credentials%2A> Eigenschaft kann es sich um eine <xref:System.Net.NetworkCredential>in diesem Fall muss der Benutzer, Kennwort, und Domäneninformationen enthalten, die der <xref:System.Net.NetworkCredential> Objekt wird zum Authentifizieren der Anforderung verwendet, oder es kann eine <xref:System.Net.CredentialCache>, in diesem Fall den Uniform Resource Identifier (URI) der Anforderung wird verwendet, um zu bestimmen, die Benutzer, Kennwort und Domäneninformationen verwenden, um die Anforderung zu authentifizieren.  
  
 In den meisten Clientszenarien, sollten Sie verwenden die <xref:System.Net.CredentialCache.DefaultCredentials%2A> -Eigenschaft, die die Anmeldeinformationen des angemeldeten Benutzers enthält. Legen Sie hierzu die <xref:System.Net.WebClient.UseDefaultCredentials%2A> Eigenschaft `true` anstatt durch Festlegen dieser Eigenschaft.  
  
 Wenn die <xref:System.Net.HttpWebRequest> Klasse wird in einer Anwendung der mittleren Ebene, z. B. die Anmeldeinformationen in einer ASP.NET-Anwendung verwendet die <xref:System.Net.CredentialCache.DefaultCredentials%2A> Eigenschaft für das Konto, das Ausführen der ASP-Seite (die serverseitigen Anmeldeinformationen) gehören. In der Regel würden Sie diese Eigenschaft auf die Anmeldeinformationen des Clients festlegen, in die Auftrag angefordert wird.  
  
> [!NOTE]
>  Das NTLM-Authentifizierungsschema kann nicht verwendet werden, um die Identität eines anderen Benutzers annehmen. Kerberos muss speziell konfiguriert werden, um den Identitätswechsel unterstützt.  
  
 Um HttpWebRequest auf eine oder mehrere Authentifizierungsmethoden zu beschränken, verwenden die <xref:System.Net.CredentialCache> Klasse und Ihre Anmeldeinformationen an einen oder mehrere Authentifizierungsschemas binden  
  
 Unterstützten Authentifizierungsschemen enthalten, Digest, Negotiate, Kerberos, NTLM und Basic.  
  
 Aus Sicherheitsgründen beim leitet automatisch stehenden, speichern Sie die Anmeldeinformationen, die in der Umleitung in enthalten sein sollen eine <xref:System.Net.CredentialCache> und weisen sie dieser Eigenschaft. Diese Eigenschaft wird automatisch festgelegt werden, um `null` nach der Umleitung, wenn er alles außer enthält eine <xref:System.Net.CredentialCache>. Mit diesen Eigenschaftswert auf automatisch festgelegt werden `null` unter diesen Umständen verhindert, dass Anmeldeinformationen an jedes beliebige unbeabsichtigten Ziel gesendet werden.
  
## Examples  
 Das folgende Codebeispiel legt die Anmeldeinformationen für eine Anforderung fest.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the <see langword="Date" /> HTTP header value to use in an HTTP request.</summary>
        <value>Der Datumsheaderwert in der HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Date-Header ist `null`, und klicken Sie dann der Rückgabewert festgelegt wird <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 Die <xref:System.Net.HttpWebRequest.Date%2A> Eigenschaft ist ein Standard <xref:System.DateTime?displayProperty=nameWithType> Objekt enthalten kann, und wählen Sie eine <xref:System.DateTimeKind?displayProperty=nameWithType> Feld <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, oder <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jede Art von Zeit kann festgelegt werden, bei Verwendung der <xref:System.Net.HttpWebRequest.Date%2A> Eigenschaft. Wenn <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> festgelegt oder abgerufen wird, wird die <xref:System.Net.HttpWebRequest.Date%2A> wird davon ausgegangen, dass werden <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (lokale Zeit).  
  
 Die Klassen in der <xref:System.Net> Namespace immer schreibt sie die <xref:System.Net.HttpWebRequest.Date%2A> Eigenschaft bei der Übertragung während der Übertragung im Standardformat mit GMT (Utc).  
  
 Wenn die <xref:System.Net.HttpWebRequest.Date%2A> -Eigenschaftensatz auf <xref:System.DateTime.MinValue?displayProperty=nameWithType>, und klicken Sie dann die `Date` HTTP-Header aus entfernt wird der <xref:System.Net.HttpWebRequest.Headers%2A> Eigenschaft und die <xref:System.Net.WebHeaderCollection>.  
  
 Wenn die <xref:System.Net.HttpWebRequest.Date%2A> Eigenschaft ist <xref:System.DateTime.MinValue?displayProperty=nameWithType>, dies bedeutet, dass die `Date` HTTP-Header ist nicht enthalten, der <xref:System.Net.HttpWebRequest.Headers%2A> Eigenschaft und die <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
 Wenn die <xref:System.Net.HttpWebRequest.Date%2A> festgelegt ist und es wird versucht, zum Senden einer <xref:System.Net.HttpWebRequest> ohne Textteil, ein <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> wird ausgelöst, um die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, und <xref:System.Net.HttpWebRequest.EndGetResponse%2A> Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default cache policy for this request.</summary>
        <value>Eine <see cref="T:System.Net.Cache.HttpRequestCachePolicy" />, die die für diese Anforderung gültige Cacherichtlinie angibt, wenn keine andere Richtlinie anwendbar ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Festlegen dieser Eigenschaft registriert die angegebene Richtlinie für die HTTP- und HTTPS-Schemas. Diese Richtlinie ist für diese Anforderung verwendet, wenn:  
  
 Es ist keine <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> -Eigenschaft für diese Anforderung angegeben.  
  
 \- oder –  
  
 Die Dateien geben Sie eine Cacherichtlinie, die auf den Uniform Resource Identifier (URI) anwendbar ist, mit der diese Anforderung erstellt keine Computer- und anwendungsspezifische-Konfiguration.  
  
 Die Cacherichtlinie bestimmt, ob die angeforderte Ressource aus einem Cache für die Anforderung an den Hostcomputer für die Ressource gesendet werden, anstatt ausgeführt werden kann.  
  
 Eine Kopie einer Ressource wird nur in den Cache hinzugefügt, wenn der Antwortstream für die Ressource abgerufen und bis zum Ende des Streams gelesen wird. Damit eine andere Anforderung für die gleiche Ressource eine zwischengespeicherte Kopie abhängig von der Cacheebene für die Richtlinie für diese Anforderung verwenden kann.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">für den uneingeschränkten Zugriff auf Netzwerkressourcen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default maximum length of an HTTP error response.</summary>
        <value>Die standardmäßige maximale Länge einer HTTP-Fehlerantwort.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is less than 0 and is not equal to -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default for the <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> property.</summary>
        <value>Die Länge in KB (1024 Bytes) des Standardwerts für die maximale Größe empfangener Antwortheader. In der Standardkonfigurationsdatei ist dieser Wert auf 64 KB festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Länge der Antwortheader empfangen der Antwortstatuszeile und keine zusätzlichen Steuerzeichen, die als Teil des HTTP-Protokoll empfangen werden. Ein Wert von-1 bedeutet, dass, die keine auf die Antwortheader empfangen Beschränkung. der Wert 0 bedeutet, bei denen alle Anforderungen.  
  
 Dieser Wert kann auch in der Konfigurationsdatei geändert werden. Die Auswirkung dieser Eigenschaft kann überschrieben werden, indem die <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> Eigenschaft in einer Instanz von der <xref:System.Net.HttpWebRequest> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is not equal to -1 and is less than zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a stream.</param>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methode schließt eine asynchrone Anforderung eines Streams, der von gestartet wurde. die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Methode. Nach der <xref:System.IO.Stream> Objekt zurückgegeben wurde, können Sie Daten mit senden die <xref:System.Net.HttpWebRequest> mithilfe der <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> Methode.  
  
> [!NOTE]
>  Müssen Sie den Wert der Festlegen der <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft vor dem Schreiben von Daten in den Stream.  
  
> [!CAUTION]
>  Rufen Sie die <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> Methode, um den Stream schließen und die Verbindung für die Wiederverwendung freizugeben. Fehler beim Schließen des Streams wird Ihre Anwendung nicht mehr genügend Verbindungen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methode beendet eine asynchrone Anforderung für eine Instanz des Streams.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The request did not complete, and no stream is available.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a stream.</param>
        <param name="context">To be added.</param>
        <param name="transportContext">To be added.</param>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data and outputs the <see cref="T:System.Net.TransportContext" /> associated with the stream.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Methode schließt eine asynchrone Anforderung eines Streams, der von gestartet wurde. die <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> -Methode und die Ausgaben der <xref:System.Net.TransportContext> dem Datenstrom zugeordnete. Nach der <xref:System.IO.Stream> Objekt zurückgegeben wurde, können Sie Daten mit senden die <xref:System.Net.HttpWebRequest> mithilfe der <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> Methode.  
  
 Einige Anwendungen, die integrierte Windows-Authentifizierung mit erweitertem Schutz verwenden, damit Abfragen die Transportschicht von verwendet werden müssen möglicherweise <xref:System.Net.HttpWebRequest> um das Kanalbindungstoken (CBT) aus den zugrunde liegenden TLS-Kanal abzurufen. Die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> -Methode bietet Zugriff auf diese Informationen für HTTP-Methoden, die einen Anforderungstext enthalten (`POST` und `PUT` Anforderungen). Dies ist nur erforderlich, wenn die Anwendung ihre eigene Authentifizierung implementiert wird und Zugriff auf das CBT benötigt.  
  
> [!NOTE]
>  Wenn eine Anwendung zum Festlegen des Werts von der <xref:System.Net.HttpWebRequest.ContentLength%2A> -Eigenschaft, und dies muss vor dem Abrufen des Streams und Schreiben von Daten darauf ausgeführt werden.  
  
> [!CAUTION]
>  Rufen Sie die <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> Methode, um den Stream schließen und die Verbindung für die Wiederverwendung freizugeben. Fehler beim Schließen des Streams wird Ihre Anwendung nicht mehr genügend Verbindungen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">The request did not complete, and no stream is available.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a response.</param>
        <summary>Ends an asynchronous request to an Internet resource.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> that contains the response from the Internet resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.EndGetResponse%2A> Methode schließt eine asynchrone Anforderung einer Internetressource, die durch Aufrufen des Starts der <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode.  
  
> [!CAUTION]
>  Rufen Sie die <xref:System.Net.HttpWebResponse.Close%2A> Methode, um den Stream schließen und die Verbindung freizugeben. Bei unterlassen kann dazu führen, dass Ihre Anwendung nicht genügend Verbindungen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Net.HttpWebRequest.EndGetResponse%2A> Methode beendet eine asynchrone Anforderung einer Internetressource.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult." />  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> property is greater than 0 but the data has not been written to the request stream.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Expect" /> HTTP header.</summary>
        <value>Der Inhalt des <see langword="Expect" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.  
  
 <block subset="none" type="note"><para> Der Wert für diese Eigenschaft befindet sich in <see cref="T:System.Net.WebHeaderCollection" />. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  </para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> is set to a string that contains "100-continue" as a substring.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that specifies the destination for this serialization.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data required to serialize the target object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Objekte eingeschlossen wurden die <xref:System.Runtime.Serialization.SerializationInfo> automatisch nachverfolgt und vom Formatierungsprogramm serialisiert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Methodenrückgabe einen Datenstrom zu verwenden, um das Senden von Daten für die <xref:System.Net.HttpWebRequest>. Nach der <xref:System.IO.Stream> Objekt zurückgegeben wurde, können Sie Daten mit senden die <xref:System.Net.HttpWebRequest> mithilfe der <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> Methode.  
  
 Wenn eine Anwendung zum Festlegen des Werts, der die <xref:System.Net.HttpWebRequest.ContentLength%2A> -Eigenschaft, und dies muss erfolgen, vor dem Abrufen des Streams.  
  
 Rufen Sie die <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> Methode, um den Stream schließen und die Verbindung für die Wiederverwendung freizugeben. Fehler beim Schließen des Streams wird Ihre Anwendung nicht mehr genügend Verbindungen.  
  
> [!NOTE]
>  Synchrone und asynchrone Methoden für eine bestimmte Anforderung kann nicht die Anwendung kombiniert werden. Beim Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A> -Methode, müssen Sie verwenden die <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode, um die Antwort abzurufen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Methode, um eine Streaminstanz zurückzugeben.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method is called more than once.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.ObjectDisposedException">In a .NET Compact Framework application, a request stream with zero content length was not obtained and closed correctly. For more information about handling zero content length requests, see [Network Programming in the .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">The <see cref="T:System.Net.TransportContext" /> for the <see cref="T:System.IO.Stream" />.</param>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data and outputs the <see cref="T:System.Net.TransportContext" /> associated with the stream.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Methodenrückgabe einen Datenstrom zu verwenden, um das Senden von Daten für die <xref:System.Net.HttpWebRequest> und gibt die <xref:System.Net.TransportContext> dem Datenstrom zugeordnete. Nach der <xref:System.IO.Stream> Objekt zurückgegeben wurde, können Sie Daten mit senden die <xref:System.Net.HttpWebRequest> mithilfe der <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> Methode.  
  
 Einige Anwendungen, die integrierte Windows-Authentifizierung mit erweitertem Schutz verwenden, damit Abfragen die Transportschicht von verwendet werden müssen möglicherweise <xref:System.Net.HttpWebRequest> um das Kanalbindungstoken (CBT) aus den zugrunde liegenden TLS-Kanal abzurufen. Die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> -Methode bietet Zugriff auf diese Informationen für HTTP-Methoden, die einen Anforderungstext enthalten (`POST` und `PUT` Anforderungen). Dies ist nur erforderlich, wenn die Anwendung ihre eigene Authentifizierung implementiert wird und Zugriff auf das CBT benötigt.  
  
 Wenn eine Anwendung zum Festlegen des Werts, der die <xref:System.Net.HttpWebRequest.ContentLength%2A> -Eigenschaft, und dies muss erfolgen, vor dem Abrufen des Streams.  
  
 Rufen Sie die <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> Methode, um den Stream schließen und die Verbindung für die Wiederverwendung freizugeben. Fehler beim Schließen des Streams wird Ihre Anwendung nicht mehr genügend Verbindungen.  
  
> [!NOTE]
>  Synchrone und asynchrone Methoden für eine bestimmte Anforderung kann nicht die Anwendung kombiniert werden. Beim Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A> -Methode, müssen Sie verwenden die <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode, um die Antwort abzurufen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method was unable to obtain the <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method is called more than once.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a response from an Internet resource.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> that contains the response from the Internet resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode gibt ein <xref:System.Net.WebResponse> -Objekt, das die Antwort von der Internetressource enthält. Die tatsächliche Instanz zurückgegeben wird ein <xref:System.Net.HttpWebResponse>, und für diese Klasse zum Zugriff auf HTTP-spezifische Eigenschaften umgewandelt werden kann.  
  
 Ein <xref:System.Net.ProtocolViolationException> wird in mehreren Fällen ausgelöst, wenn die Eigenschaften festlegen, auf die <xref:System.Net.HttpWebRequest> Klasse stehen in Konflikt. Diese Ausnahme tritt auf, wenn eine Anwendung festlegt der <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft und die <xref:System.Net.HttpWebRequest.SendChunked%2A> Eigenschaft, um `true`, und klicken Sie dann eine HTTP GET-Anforderung sendet. Diese Ausnahme tritt auf, wenn eine Anwendung, zum Senden von Segmenten mit einem Server, der nur HTTP 1.0-Protokoll unterstützt versucht, in denen dies wird nicht unterstützt. Diese Ausnahme tritt auf, wenn eine Anwendung, zum Senden von Daten festlegen, ohne versucht die <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft oder die <xref:System.Net.HttpWebRequest.SendChunked%2A> ist `false` Wenn Pufferung deaktiviert ist, und klicken Sie auf eine Keepalive-Verbindung (die <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft ist `true`)`.`  
  
> [!CAUTION]
>  Rufen Sie die <xref:System.Net.HttpWebResponse.Close%2A> Methode, um den Stream schließen und die Verbindung freizugeben. Bei unterlassen kann dazu führen, dass Ihre Anwendung nicht genügend Verbindungen.  
  
 Wenn Sie die POST-Methode verwenden, müssen Sie den Anforderungsstream abzurufen, schreiben die Daten bereitgestellt werden und schließt den Stream. Diese Methode blockiert, wartet auf Inhalt an; Wenn kein Timeout festgelegt ist, und Sie keinen Inhalt, der aufrufende Thread blockiert unbegrenzt bereitstellen.  
  
> [!NOTE]
>  Mehrere Aufrufe <xref:System.Net.HttpWebRequest.GetResponse%2A> Zurückgeben der gleichen Response-Objekt; die Anforderung wird nicht erneut gesendet.  
  
> [!NOTE]
>  Synchrone und asynchrone Methoden für eine bestimmte Anforderung kann nicht die Anwendung kombiniert werden. Beim Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A> -Methode, müssen Sie verwenden die <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode, um die Antwort abzurufen.  
  
> [!NOTE]
>  Wenn eine <xref:System.Net.WebException> ist ausgelöst wird, verwenden die <xref:System.Net.WebException.Response%2A> und <xref:System.Net.WebException.Status%2A> Eigenschaften der Ausnahme, um die Antwort vom Server zu bestimmen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Cookies sind aus Gründen der Sicherheit standardmäßig deaktiviert. Wenn Sie Cookies verwenden möchten, verwenden Sie die <xref:System.Net.HttpWebRequest.CookieContainer%2A> Eigenschaft, um Cookies zu aktivieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft die Antwort für eine Anforderung ab.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The stream is already in use by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> is GET or HEAD, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater or equal to zero or <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="true" />.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.  -or-  The <see cref="T:System.Net.HttpWebRequest" /> has an entity body but the <see cref="M:System.Net.HttpWebRequest.GetResponse" /> method is called without calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method.  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero, but the application does not write all of the promised data.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, this request includes data to be sent to the server. Requests that send data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether a response has been received from an Internet resource.</summary>
        <value>
          <see langword="true" />, wenn eine Antwort empfangen wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird überprüft die <xref:System.Net.HttpWebRequest.HaveResponse%2A> Eigenschaft, um zu bestimmen, ob eine Antwort von einer Internetressource empfangen wurde.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies a collection of the name/value pairs that make up the HTTP headers.</summary>
        <value>Eine <see cref="T:System.Net.WebHeaderCollection" /> mit den Name-Wert-Paaren, aus denen sich die Header für die HTTP-Anforderung zusammensetzen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Headers%2A> Auflistung enthält die Protokollheader der Anforderung zugeordnet ist. Die folgende Tabelle enthält die HTTP-Header, die nicht im rowsetcache der <xref:System.Net.HttpWebRequest.Headers%2A> Auflistung jedoch sind entweder vom System oder festgelegte Eigenschaften oder Methoden.  
  
|Header|Festgelegt durch|  
|------------|------------|  
|Akzeptieren|Durch Festlegen der <xref:System.Net.HttpWebRequest.Accept%2A> Eigenschaft.|  
|Verbindung|Durch Festlegen der <xref:System.Net.HttpWebRequest.Connection%2A> Eigenschaft und <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft.|  
|Content-Length|Durch Festlegen der <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft.|  
|Inhaltstyp|Durch Festlegen der <xref:System.Net.HttpWebRequest.ContentType%2A> Eigenschaft.|  
|erwartet|Durch Festlegen der <xref:System.Net.HttpWebRequest.Expect%2A> Eigenschaft.|  
|Datum|Durch Festlegen der <xref:System.Net.HttpWebRequest.Date%2A> Eigenschaft.|  
|Host|Durch Festlegen der <xref:System.Net.HttpWebRequest.Host%2A> Eigenschaft.|  
|If-Modified-Since|Durch Festlegen der <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft.|  
|Bereich|Durch Festlegen der <xref:System.Net.HttpWebRequest.AddRange%2A> Methode.|  
|Referer|Durch Festlegen der <xref:System.Net.HttpWebRequest.Referer%2A> Eigenschaft.|  
|Transfer-Encoding|Durch Festlegen der <xref:System.Net.HttpWebRequest.TransferEncoding%2A> Eigenschaft (die <xref:System.Net.HttpWebRequest.SendChunked%2A> -Eigenschaft muss "true" sein).|  
|Benutzer-Agent|Durch Festlegen der <xref:System.Net.HttpWebRequest.UserAgent%2A> Eigenschaft.|  
  
 Die <xref:System.Net.WebHeaderCollection.Add%2A> -Methode löst eine <xref:System.ArgumentException> , wenn Sie versuchen, einen dieser geschützten Header festzulegen.  
  
 Ändern der <xref:System.Net.HttpWebRequest.Headers%2A> Eigenschaft nach dem Start der Anforderung durch den Aufruf <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> -Methode löst eine <xref:System.InvalidOperationException>.  
  
 Sie sollten nicht davon ausgehen, dass die Headerwerte unverändert bleiben werden, da Webservern und Caches ändern oder -Header zu einer webanforderung hinzufügen können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Net.HttpWebRequest.Headers%2A> -Eigenschaft der HTTP-Header-Wert-Paare in der Konsole ausgegeben.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the Host header value to use in an HTTP request independent from the request URI.</summary>
        <value>Der Hostheaderwert in der HTTP-Anforderung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Host%2A> Eigenschaft kann verwendet werden, um den Host-Headerwert für die Verwendung in einer HTTP-Anforderung unabhängig vom Anforderungs-URI festgelegt. Die <xref:System.Net.HttpWebRequest.Host%2A> Eigenschaft kann einen Hostnamen und einer optionalen Portnummer bestehen. Ein Hostheader ohne Portinformationen impliziert den Standardport für den angeforderten Dienst (Port 80 für HTTP-URL, z. B.).  
  
 Das Format für einen Host und Port angeben, muss den Regeln in Abschnitt 14.23 rfc2616 veröffentlicht, die durch die IETF entsprechen. Ein Beispiel mit diesen Anforderungen, einen Port 8080 angegeben, wäre die folgenden Werte für die <xref:System.Net.HttpWebRequest.Host%2A> Eigenschaft:  
  
 `www.contoso.com:8080`  
  
 Mithilfe der <xref:System.Net.HttpWebRequest.Host%2A> Eigenschaft explizit einen benutzerdefinierten Host-Headerwert angeben, wirkt sich auch auf Bereiche zwischenspeichern, Cookies und Authentifizierung. Wenn eine Anwendung Anmeldeinformationen für einen bestimmten URI-Präfix enthält, muss die Anwendungen sicherstellen, dass der URI, der mit dem Wert des Hostheaders, nicht auf dem Zielserver im URI verwenden. Der Schlüssel beim Zwischenspeichern von Ressourcen, verwendet der Hostheaderwert anstatt von der Anforderungs-URI. Cookies werden gespeichert und einem <xref:System.Net.CookieContainer> und nach dem Domänennamen des Servers logisch gruppiert. Wenn die Anwendung einen Hostheader angegeben ist, wird dieser Wert als Domäne verwendet werden.  
  
 Wenn die <xref:System.Net.HttpWebRequest.Host%2A> Eigenschaft nicht festgelegt ist, wird der Host-Headerwert für die Verwendung in einer HTTP-Anforderung basiert auf der Anforderungs-URI.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The Host header cannot be set to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The Host header cannot be set to an invalid value.</exception>
        <exception cref="T:System.InvalidOperationException">The Host header cannot be set after the <see cref="T:System.Net.HttpWebRequest" /> has already started to be sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="If-Modified-Since" /> HTTP header.</summary>
        <value>Eine <see cref="T:System.DateTime" /> mit dem Inhalt des <see langword="If-Modified-Since" />-HTTP-Headers. Der Standardwert ist das aktuelle Datum und die aktuelle Uhrzeit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft ist ein Standard <xref:System.DateTime?displayProperty=nameWithType> Objekt enthalten kann, und wählen Sie eine <xref:System.DateTimeKind?displayProperty=nameWithType> Feld <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, oder <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Jede Art von Zeit kann festgelegt werden, bei Verwendung der <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft. Wenn <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> festgelegt oder abgerufen wird, wird die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> wird davon ausgegangen, dass werden <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (lokale Zeit).  
  
 Die Klassen in der <xref:System.Net> Namespace immer schreibt sie die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft bei der Übertragung während der Übertragung im Standardformat mit GMT (Utc).  
  
 Wenn die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> -Eigenschaftensatz auf <xref:System.DateTime.MinValue?displayProperty=nameWithType>, und klicken Sie dann die `If-Modified-Since` HTTP-Header aus entfernt wird der <xref:System.Net.HttpWebRequest.Headers%2A> Eigenschaft und die <xref:System.Net.WebHeaderCollection>.  
  
 Wenn die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft ist <xref:System.DateTime.MinValue?displayProperty=nameWithType>, dies bedeutet, dass die `If-Modified-Since` HTTP-Header ist nicht enthalten, der <xref:System.Net.HttpWebRequest.Headers%2A> Eigenschaft und die <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft die <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Eigenschaft.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to make a persistent connection to the Internet resource.</summary>
        <value>
          <see langword="true" />, wenn die Anforderung an die Internetressource einen <see langword="Connection" />-HTTP-Header mit dem KeepAlive-Wert enthalten soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf `true` zum Senden einer `Connection` HTTP-Header mit dem KeepAlive-Wert. Eine Anwendung verwendet <xref:System.Net.HttpWebRequest.KeepAlive%2A> um eine permanente Verbindungen bevorzugt anzugeben. Wenn die <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft ist `true`, die Anwendung durchführt, permanente Verbindungen zu den Servern, die sie unterstützen.  
  
> [!NOTE]
>  Bei Verwendung von HTTP/1.1 ist Keep-Alive standardmäßig aktiviert. Festlegen von <xref:System.Net.HttpWebRequest.KeepAlive%2A> auf `false` möglicherweise senden eine `Connection: Close` Header mit dem Server.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.KeepAlive%2A> Eigenschaft `false` zu vermeiden, eine permanente Verbindung mit der Internetressource herstellen.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum number of redirects that the request follows.</summary>
        <value>Die maximale Anzahl von Umleitungsantworten, denen die Anforderung folgt. Der Standardwert ist 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> Eigenschaft legt die maximale Anzahl von umleitungen für die Anforderung, wenn führen die <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> Eigenschaft ist `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel legt den Wert dieser Eigenschaft fest.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value is set to 0 or less.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum allowed length of the response headers.</summary>
        <value>Die Länge der Antwortheader in KB (1024 Bytes).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Länge der Antwortheader enthält die Antwortstatuszeile und keine zusätzlichen Steuerzeichen, die als Teil des HTTP-Protokoll empfangen werden. Ein Wert von-1 bedeutet, dass, die keine auf die Antwortheader Beschränkung. der Wert 0 bedeutet, bei denen alle Anforderungen.  
  
 Wenn die <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> Eigenschaft nicht ausdrücklich festgelegt ist, wird standardmäßig der Wert, der die <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> Eigenschaft.  
  
 Überschreitet die Länge der Antwortheader empfangen den Wert des der <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> -Eigenschaft, die <xref:System.Net.HttpWebRequest.EndGetResponse%2A> oder <xref:System.Net.HttpWebRequest.GetResponse%2A> Methoden lösen eine <xref:System.Net.WebException> mit der <xref:System.Net.WebException.Status%2A> -Eigenschaftensatz auf <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 Das folgende Codebeispiel legt den Wert dieser Eigenschaft fest.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The property is set after the request has already been submitted.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is less than 0 and is not equal to -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the media type of the request.</summary>
        <value>Der Medientyp der Anforderung. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert, der die <xref:System.Net.HttpWebRequest.MediaType%2A> Eigenschaft wirkt sich auf die <xref:System.Net.HttpWebResponse.CharacterSet%2A> Eigenschaft. Beim Festlegen der <xref:System.Net.HttpWebRequest.MediaType%2A> in der Anforderung wird der entsprechende Medientyp aus der Liste der Zeichensätze, die in der Antwort zurückgegebenen ausgewählt `Content-type` HTTP-Header.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the method for the request.</summary>
        <value>Die Anforderungsmethode zum Herstellen der Verbindung mit der Internetressource. Der Standardwert ist GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Method%2A> Eigenschaftensatz können einem beliebigen HTTP 1.1-Protokoll-Verben: GET, HEAD, POST, PUT, DELETE, TRACE oder OPTIONS.  
  
 Wenn die <xref:System.Net.HttpWebRequest.ContentLength%2A> Eigenschaft auf einen anderen Wert als-1 festgelegt ist die <xref:System.Net.HttpWebRequest.Method%2A> Eigenschaft muss festgelegt werden, um eine Protokolleigenschaft, die Daten hochgeladen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.Method%2A> Eigenschaft auf POST.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No method is supplied.  -or-  The method string contains invalid characters.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to pipeline the request to the Internet resource.</summary>
        <value>
          <see langword="true" />, wenn die Anforderung über Pipelineverbindungen gesendet werden soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung verwendet die <xref:System.Net.HttpWebRequest.Pipelined%2A> Eigenschaft, um eine Einstellung dafür pipelineverbindungen anzugeben. Wenn <xref:System.Net.HttpWebRequest.Pipelined%2A> ist `true`, eine Anwendung macht pipelineverbindungen zu den Servern, die sie unterstützen.  
  
 Pipelineverbindungen erfolgen nur, wenn die <xref:System.Net.HttpWebRequest.KeepAlive%2A> -Eigenschaft ist ebenfalls `true`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der ausgibt, die <xref:System.Net.HttpWebRequest.Pipelined%2A> -Eigenschaft in der Konsole.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to send an Authorization header with the request.</summary>
        <value>
          <see langword="true" />, um nach der Authentifizierung einen Authorization-HTTP-Header mit Anforderungen zu senden, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach einer Clientanforderung für einen bestimmten <xref:System.Uri> erfolgreich authentifiziert ist, wenn <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> ist `true` und Anmeldeinformationen angegeben werden, der Authorization-Header wird mit jeder Anforderung gesendet, an ein beliebiges <xref:System.Uri> entspricht den jeweiligen <xref:System.Uri>bis zum letzten Schrägstrich. Wenn die Clientanforderung zu einem bestimmten erfolgreich authentifiziert <xref:System.Uri> , die Folgendes enthält:  
  
 `http://www.contoso.com/firstpath/`  
  
 Wird der Authorization-Header für die Vorauthentifizierung mit jeder Anforderung, um eine der folgenden gesendet wird <xref:System.Uri> Instanzen:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Allerdings der Authorization-Header ist nicht mit den Anforderungen an gesendet keines der folgenden <xref:System.Uri> Instanzen:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Wenn die Clientanforderung zu einem bestimmten <xref:System.Uri> ist nicht erfolgreich authentifiziert die Anforderung Standardauthentifizierung-Prozeduren verwendet.  
  
 Mit Ausnahme der ersten Anforderung der <xref:System.Net.WebRequest.PreAuthenticate%2A> Eigenschaft gibt an, ob Authentifizierungsinformationen mit nachfolgenden Anforderungen zum Senden einer <xref:System.Uri> entspricht den jeweiligen <xref:System.Uri> bis zum letzten Schrägstrich ohne zu warten, werden vom Server behindert.  
  
 Das folgende Dialogfeld zwischen Client und Server werden die Auswirkung dieser Eigenschaft veranschaulicht. Das Dialogfeld wird davon ausgegangen, dass die Standardauthentifizierung verwendet wird.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> ist `false`:  
  
 -Client: GET-someUrl  
  
 Server: 401 WWW-Authenticate Basic  
  
 Client: GET mit Authorization-Header  
  
 Server: 200 OK  
  
 -Client: GET-someUrl  
  
 Server: 401 WWW-Authenticate Basic  
  
 Client: GET mit Authorization-Header  
  
 Server: 200 OK  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> ist `true`:  
  
 -Client: GET-someUrl  
  
 Server: 401 WWW-Authenticate Basic  
  
 Client: GET mit Authorization-Header  
  
 Server: 200 OK  
  
 Client: Abrufen SomeUrl mit Authorization-Header  
  
 Wenn das Authentifizierungsschema Vorauthentifizierung nicht unterstützt, wird der Wert dieser Eigenschaft ignoriert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the version of HTTP to use for the request.</summary>
        <value>Die für die Anforderung zu verwendende HTTP-Version. Die Standardeinstellung ist <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest> -Klasse unterstützt nur die Versionen 1.0 und 1.1 von HTTP. Festlegen von <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> auf eine andere Version löst eine Ausnahme aus.  
  
> [!NOTE]
>  Verwenden Sie zum Festlegen der HTTP-Version der aktuellen Anforderung die <xref:System.Net.HttpVersion.Version10> und <xref:System.Net.HttpVersion.Version11> Felder von der <xref:System.Net.HttpVersion> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> Eigenschaft.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The HTTP version is set to a value other than 1.0 or 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets proxy information for the request.</summary>
        <value>Das <see cref="T:System.Net.IWebProxy" />-Objekt, das als Proxy für die Anforderung verwendet werden soll. Der Standardwert wird durch Aufrufen der <see cref="P:System.Net.GlobalProxySelection.Select" />-Eigenschaft festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.Proxy%2A> Eigenschaft identifiziert die <xref:System.Net.WebProxy> Objekt, das zur Verarbeitung von Anforderungen und Ressourcen im Internet verwendet. Um anzugeben, dass kein Proxy verwendet werden soll, legen die <xref:System.Net.HttpWebRequest.Proxy%2A> -Eigenschaft auf die Proxyinstanz, die zurückgegeben werden, indem Sie die <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> Methode.  
  
 Dem lokalen Computer oder eine Anwendungskonfigurationsdatei kann angeben, dass ein standardmäßige Proxy verwendet werden. Wenn die <xref:System.Net.HttpWebRequest.Proxy%2A> Eigenschaft angegeben ist, klicken Sie dann auf die Proxy-Einstellungen aus der <xref:System.Net.HttpWebRequest.Proxy%2A> Eigenschaft zu überschreiben, dem lokalen Computer oder eine Anwendungskonfigurationsdatei und die <xref:System.Net.HttpWebRequest> Instanz verwendet die angegebenen Proxyeinstellungen. Wenn kein Proxy in eine Datei "App.config" angegeben ist und die <xref:System.Net.HttpWebRequest.Proxy%2A> Eigenschaft ist nicht vorgegeben, die <xref:System.Net.HttpWebRequest> Klasse verwendet die Proxyeinstellungen von Internet Explorer geerbt werden, auf dem lokalen Computer. Wenn es keine Proxyeinstellungen in Internet Explorer sind, wird die Anforderung direkt an den Server gesendet.  
  
 Die <xref:System.Net.HttpWebRequest> -Klasse analysiert eine Proxyumgehungsliste mit Platzhalterzeichen geerbt von Internet Explorer die gleiche wie die Umgehungsliste direkt vom Internet Explorer analysiert wird. Z. B. die <xref:System.Net.HttpWebRequest> -Klasse analysiert eine Umgehungsliste des "nt *" von Internet Explorer als regulären Ausdruck "nt.\*". Daher eine URL "`http://nt.com`" den Proxy mithilfe der <xref:System.Net.HttpWebRequest> -Klasse und Internet Explorer verwenden.  
  
 Die <xref:System.Net.HttpWebRequest> -Klasse unterstützt die Umgehung von lokalen Proxy. Die Klasse hält ein Ziel werden lokal, wenn eine der folgenden Bedingungen erfüllt sind:  
  
-   Das Ziel enthält einen flachen Namen (keine Punkte in der URL).  
  
-   Das Ziel enthält eine Loopbackadresse (<xref:System.Net.IPAddress.Loopback> oder <xref:System.Net.IPAddress.IPv6Loopback>) oder das Ziel enthält eine <xref:System.Net.IPAddress> auf dem lokalen Computer zugewiesen.  
  
-   Das Domänensuffix des Ziels übereinstimmt Domänensuffix des lokalen Computers (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Ändern der <xref:System.Net.HttpWebRequest.Proxy%2A> Eigenschaft nach dem Start der Anforderung durch Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> -Methode löst eine <xref:System.InvalidOperationException>. Informationen über das Proxyelement finden Sie unter [ \&Lt; DefaultProxy\&Gt; -Element (Netzwerkeinstellungen)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Net.HttpWebRequest.Proxy%2A> Methode, um die Proxyinformationen für die Anforderung abzurufen.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.HttpWebRequest.Proxy" /> is set to <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have permission for the requested operation.</exception>
        <permission cref="T:System.Net.WebPermission">Zum Abrufen oder Festlegen der <see cref="P:System.Net.HttpWebRequest.Proxy" /> Eigenschaft. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a time-out in milliseconds when writing to or reading from a stream.</summary>
        <value>Die Anzahl von Millisekunden vor dem Timeout für das Schreiben oder Lesen. Der Standardwert ist 300.000 Millisekunden (5 Minuten).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> Eigenschaft wird beim Schreiben in den von zurückgegebenen Datenstrom verwendet die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Methode oder Lesen des Streams zurückgegebenes die <xref:System.Net.HttpWebResponse.GetResponseStream%2A> Methode.  
  
 Insbesondere die <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> Eigenschaft steuert das Zeitlimit für die <xref:System.IO.Stream.Read%2A> -Methode, die verwendet wird, zum Lesen des Streams zurückgegebenes der <xref:System.Net.HttpWebResponse.GetResponseStream%2A> -Methode, und für die <xref:System.IO.Stream.Write%2A> -Methode, die zum Schreiben in den von der zurückgegebenenDatenstromverwendetwird<xref:System.Net.HttpWebRequest.GetRequestStream%2A>Methode.  
  
 Um die Zeitspanne zu warten, bis zum Abschluss der Anforderung anzugeben, verwenden die <xref:System.Net.HttpWebRequest.Timeout%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>-Eigenschaft festgelegt wird.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has already been sent.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than or equal to zero and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Referer" /> HTTP header.</summary>
        <value>Der Wert des <see langword="Referer" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> Eigenschaft `true`, die <xref:System.Net.HttpWebRequest.Referer%2A> Eigenschaft wird automatisch festgelegt, wenn die Anforderung an einen anderen Standort umgeleitet wird.  
  
 So löschen Sie die `Referer` HTTP-Header festlegen, die <xref:System.Net.HttpWebRequest.Referer%2A> Eigenschaft, um `null`.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Eigenschaft auf <xref:System.Net.HttpWebRequest.Referer%2A> festgelegt.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the original Uniform Resource Identifier (URI) of the request.</summary>
        <value>Ein <see cref="T:System.Uri" /> mit dem URI der Internetressource, der an die <see cref="M:System.Net.WebRequest.Create(System.String)" />-Methode übergeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Uri> an übergebene Objekt <xref:System.Net.HttpWebRequest> durch den Aufruf von <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 Nach einer Umleitung Header ändert sich nicht die <xref:System.Net.HttpWebRequest.RequestUri%2A> Eigenschaft. Um den tatsächlichen URI zu erhalten, die auf die Anforderung reagiert hat, untersuchen die <xref:System.Net.HttpWebRequest.Address%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob die <xref:System.Net.HttpWebRequest> Objekt `req` an einen anderen Speicherort für die Anforderung umgeleitet wurde, und legt den Wert für die `hasChanged` -Variable auf `true` war die Anforderung umgeleitet wurde, andernfalls `hasChanged` festgelegt ist, um `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to send data in segments to the Internet resource.</summary>
        <value>
          <see langword="true" />, um die Daten in Segmenten an die Internetressource zu senden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.HttpWebRequest.SendChunked%2A> ist `true`, der die Anforderung sendet Daten an die Internetressource in Segmenten. Die Internetressource muss das Empfangen von Daten in Segmenten unterstützen.  
  
 Ändern der <xref:System.Net.HttpWebRequest.SendChunked%2A> Eigenschaft nach dem Start der Anforderung durch Aufrufen der <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, oder <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> -Methode löst eine <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.SendChunked%2A> Eigenschaft `true` , damit Daten in Segmenten an die Internetressource gesendet werden können.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a callback function to validate the server certificate.</summary>
        <value>Eine Rückruffunktion zur Überprüfung des Serverzertifikats.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardeinstellung ist, dass keine Rückruffunktion festgelegt ist und die <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> Eigenschaft ist `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the service point to use for the request.</summary>
        <value>Ein <see cref="T:System.Net.ServicePoint" />, der die Netzwerkverbindung mit der Internetressource darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> Eigenschaft ist möglicherweise von anderen <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> , wenn die Anforderung umgeleitet wird.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the request provides support for a <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>
          <see langword="true" />, wenn der Vorgang Unterstützung für einen <see cref="T:System.Net.CookieContainer" /> bietet, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that specifies the destination for this serialization.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Objekte eingeschlossen wurden die <xref:System.Runtime.Serialization.SerializationInfo> automatisch nachverfolgt und vom Formatierungsprogramm serialisiert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the time-out value in milliseconds for the <see cref="M:System.Net.HttpWebRequest.GetResponse" /> and <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> methods.</summary>
        <value>Die Wartezeit in Millisekunden bis zum Timeout der Anforderung. Der Standardwert ist 100.000 Millisekunden (100 Sekunden).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> ist die Anzahl der Millisekunden, die mit eine nachfolgende synchrone Anforderung vorgenommen der <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode, die auf eine Antwort wartet und die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Methode wartet auf einen Stream. Die <xref:System.Net.HttpWebRequest.Timeout%2A> gilt für die gesamte Anforderung und Antwort, nicht einzeln an die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> und <xref:System.Net.HttpWebRequest.GetResponse%2A> Methodenaufrufe. Wenn die Ressource nicht innerhalb des Timeoutzeitraums zurückgegeben wird, löst die Anforderung eine <xref:System.Net.WebException> mit der <xref:System.Net.WebException.Status%2A> -Eigenschaftensatz auf <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 Die <xref:System.Net.HttpWebRequest.Timeout%2A> Eigenschaft muss festgelegt werden, bevor die <xref:System.Net.HttpWebRequest.GetRequestStream%2A> oder <xref:System.Net.HttpWebRequest.GetResponse%2A> -Methode aufgerufen wird. Ändern der <xref:System.Net.HttpWebRequest.Timeout%2A> Eigenschaft nach dem Aufruf der <xref:System.Net.HttpWebRequest.GetRequestStream%2A> oder <xref:System.Net.HttpWebRequest.GetResponse%2A> Methode hat keine Auswirkung  
  
 Die <xref:System.Net.HttpWebRequest.Timeout%2A> Eigenschaft wirkt sich nicht auf asynchrone Anforderungen durch die <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> oder <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Methode.  
  
> [!CAUTION]
>  Im Fall von asynchronen Anforderungen implementiert die Clientanwendung einen eigenen Timeoutmechanismus. Finden Sie im Beispiel in der <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Methode.  
  
 Um anzugeben, die Zeitdauer zum Warten, bevor ein lesen oder Schreiben von Vorgang ein Timeout eintritt, verwenden die <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> Eigenschaft.  
  
 Eine Domain Name System (DNS)-Abfrage kann bis zu 15 Sekunden zurückgegeben oder ein Timeout dauern. Ihre Anforderung enthält einen Hostnamen an, die Lösung erforderlich sind, und legen Sie <xref:System.Net.FileWebRequest.Timeout%2A> auf einen Wert kleiner als 15 Sekunden dauert möglicherweise 15 Sekunden oder mehr vor einer <xref:System.Net.WebException> wird ausgelöst, um ein Timeout für die Anforderung anzugeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.HttpWebRequest.Timeout%2A> Eigenschaft von der <xref:System.Net.HttpWebRequest> Objekt.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than zero and is not <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Transfer-encoding" /> HTTP header.</summary>
        <value>Der Wert des <see langword="Transfer-encoding" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bevor Sie festlegen können die <xref:System.Net.HttpWebRequest.TransferEncoding%2A> -Eigenschaft, müssen Sie zunächst Festlegen der <xref:System.Net.HttpWebRequest.SendChunked%2A> Eigenschaft `true`. Löschen <xref:System.Net.HttpWebRequest.TransferEncoding%2A> durch Festlegen auf `null` hat keine Auswirkung auf den Wert des <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Werte für die <xref:System.Net.HttpWebRequest.TransferEncoding%2A> Eigenschaft ersetzen alle vorhandenen Inhalte.  
  
> [!NOTE]
>  Der Wert für diese Eigenschaft wird in der <xref:System.Net.WebHeaderCollection> gespeichert. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set when <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to the value "Chunked".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to allow high-speed NTLM-authenticated connection sharing.</summary>
        <value>
          <see langword="true" />, um die authentifizierte Verbindung geöffnet zu halten, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für diese Eigenschaft ist `false`, die bewirkt, dass der aktuellen Verbindungs nach Abschluss einer Anforderung geschlossen werden. Die Anwendung muss Authentifizierungssequenz durchlaufen, jedes Mal, wenn sie eine neue Anforderung ausstellt.  
  
 Wenn diese Eigenschaft, um festgelegt wird `true`, die zum Abrufen der Antwort verwendete Verbindung bleibt geöffnet, nachdem die Authentifizierung erfolgt ist. In diesem Fall andere Anforderungen, die diese Eigenschaft auf festgelegt haben `true` kann die Verbindung ohne erneute Authentifizierung verwenden. Das heißt, wenn eine Verbindung für Benutzer A authentifiziert wurde, Benutzer B möglicherweise wiederverwenden-Verbindung. Benutzer B die Anforderung wird erfüllt, basierend auf den Anmeldeinformationen des Benutzers A.  
  
> [!CAUTION]
>  Da es für eine Anwendung, die Verbindung zu verwenden, ohne Authentifizierung möglich ist, müssen Sie darauf achten, keine administrativen Sicherheitslücken in Ihrem System vorhanden ist, beim Festlegen dieser Eigenschaft auf `true`. Wenn Ihre Anwendung Anforderungen für mehrere Benutzer sendet (nimmt mehrere Benutzerkonten) und verlässt sich auf die Authentifizierung beim Schützen von Ressourcen, legen Sie nicht diese Eigenschaft auf `true` außer Verbindungsgruppen verwenden, wie unten beschrieben.  
  
 Sie sollten in Betracht ziehen, aktivieren dieses Verfahren aus, wenn Ihre Probleme bei der Leistung und die Anwendung auf einem Webserver mit integrierter Windows-Authentifizierung ausgeführt wird.  
  
 Wenn Sie diese Einstellung aktivieren, wird das System Sicherheitsrisiken. Wenn Sie festlegen, die <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> Eigenschaft, um `true` Achten Sie darauf, dass Sie die folgenden Vorsichtsmaßnahmen:  
  
-   Verwenden der <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> Eigenschaft zum Verwalten von Verbindungen für verschiedene Benutzer. Dadurch wird die mögliche Verwendung der Verbindung von Anwendungen nicht authentifizierte vermieden. Benutzer A sollte z. B. einen eindeutigen Verbindungsgruppennamen haben, der vom Benutzer b unterscheidet Dies bietet eine Ebene der Isolation für jedes Benutzerkonto.  
  
-   Führen Sie die Anwendung in einer geschützten Umgebung, um zu verhindern, dass mögliche Verbindung-Exploits.  
  
 Wenn Sie die Back-End-Server steuern, als Alternative ggf. Sie authentifizierungspersistenz deaktivieren. Dies verbessert die Leistung in einem geringeren Ausmaß, aber es ist sicherer. Weitere Informationen suchen Sie nach AuthPersistence in der MSDN Library unter [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Wenn beide <xref:System.Net.WebRequest.PreAuthenticate%2A> und <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> festgelegt `true`, jede Anforderung wird mithilfe einer Verbindung aus einem unsicheren Pool, jedoch mit einer Authorization-Header gesendet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Uneingeschränkte Web-Berechtigung ist erforderlich, um diese Eigenschaft festgelegt.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that controls whether default credentials are sent with requests.</summary>
        <value>
          <see langword="true" />, wenn die Standardanmeldeinformationen verwendet werden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf `true` bei Anforderungen von diesem <xref:System.Net.HttpWebRequest> Objekt sollte, wenn vom Server angefordert authentifiziert werden mit den Anmeldeinformationen des angemeldeten Benutzers. Bei Clientanwendungen ist dies das gewünschte Verhalten in den meisten Szenarien. Für Anwendungen der mittleren Ebene, z. B. ASP.NET-Anwendungen, anstatt Sie mithilfe dieser Eigenschaft, legen Sie in der Regel die <xref:System.Net.HttpWebRequest.Credentials%2A> Eigenschaft, um die Anmeldeinformationen des Clients auf, deren Namen die Anforderung erfolgt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You attempted to set this property after the request was sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="User-agent" /> HTTP header.</summary>
        <value>Der Wert des <see langword="User-agent" />-HTTP-Headers. Der Standardwert ist <see langword="null" />.  
  
 <block subset="none" type="note"><para> Der Wert für diese Eigenschaft befindet sich in <see cref="T:System.Net.WebHeaderCollection" />. Wenn WebHeaderCollection festgelegt wird, geht der Eigenschaftswert verloren.  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Eigenschaft auf <xref:System.Net.HttpWebRequest.UserAgent%2A> festgelegt.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>