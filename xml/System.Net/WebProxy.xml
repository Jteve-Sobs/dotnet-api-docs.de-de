<Type Name="WebProxy" FullName="System.Net.WebProxy">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c6137e1a30ddaa9b6583d8b866f92d32399f5f14" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73338290" /></Metadata><TypeSignature Language="C#" Value="public class WebProxy : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit WebProxy extends System.Object implements class System.Net.IWebProxy, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.WebProxy" />
  <TypeSignature Language="VB.NET" Value="Public Class WebProxy&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebProxy : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type WebProxy = class&#xA;    interface ISerializable&#xA;    interface IWebProxy" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.WebProxy</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Net.IWebProxy</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Enthält HTTP-Proxyeinstellungen für die <see cref="T:System.Net.WebRequest" />-Klasse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy>-Klasse enthält die Proxy Einstellungen, die <xref:System.Net.WebRequest>-Instanzen verwenden, um zu bestimmen, ob ein Webproxy zum Senden von Anforderungen verwendet wird. Globale WebProxy Einstellungen können in Computer-und Anwendungs Konfigurationsdateien angegeben werden, und Anwendungen können Instanzen der <xref:System.Net.WebProxy>-Klasse verwenden, um die Verwendung des Webproxys anzupassen. Die <xref:System.Net.WebProxy>-Klasse ist die Basis Implementierung der <xref:System.Net.IWebProxy>-Schnittstelle.  
  
 Zum Abrufen von Instanzen der WebProxy Klasse können Sie eine der folgenden Methoden verwenden:  
  
-   Der <xref:System.Net.WebProxy.%23ctor%2A>-Konstruktor.  
  
-   Die <xref:System.Net.WebProxy.GetDefaultProxy%2A> -Methode.  
  
-   Die <xref:System.Net.GlobalProxySelection.Select%2A> -Methode.  
  
 Diese Methoden stellen jeweils eine <xref:System.Net.WebProxy>-Instanz bereit, die Sie weiter anpassen können. der Unterschied besteht darin, wie die Instanz initialisiert wird, bevor Sie an Ihre Anwendung zurückgegeben wird. Der <xref:System.Net.WebProxy.%23ctor%2A>-Konstruktor gibt eine Instanz der <xref:System.Net.WebProxy>-Klasse zurück, bei der die <xref:System.Net.WebProxy.Address%2A>-Eigenschaft auf `null`festgelegt ist. Wenn eine Anforderung eine <xref:System.Net.WebProxy> Instanz in diesem Zustand verwendet, wird kein Proxy verwendet, um die Anforderung zu senden.  
  
 Die <xref:System.Net.WebProxy.GetDefaultProxy%2A>-Methode gibt eine Instanz der <xref:System.Net.WebProxy>-Klasse zurück, bei der die Eigenschaften <xref:System.Net.WebProxy.Address%2A>, <xref:System.Net.WebProxy.BypassProxyOnLocal%2A>und <xref:System.Net.WebProxy.BypassList%2A> auf die Werte festgelegt sind, die von Internet Explorer 5,5 und höher verwendet werden.  
  
 Die <xref:System.Net.GlobalProxySelection.Select%2A>-Methode gibt eine Instanz der <xref:System.Net.WebProxy>-Klasse zurück, deren Eigenschaften auf eine Kombination von Internet Explorer und Konfigurationsdatei Einstellungen festgelegt sind.  
  
 Die <xref:System.Net.WebProxy>-Klasse unterstützt die automatische Erkennung und Ausführung von Proxy Konfigurations Skripts. Diese Funktion ist auch bekannt als Web Proxy Auto-Discovery (WPAD). Wenn Sie die automatische Proxykonfiguration verwenden, muss ein Konfigurationsskript, das in der Regel "WPAD. dat" genannt wird, gefunden, heruntergeladen, kompiliert und ausgeführt werden. Wenn diese Vorgänge erfolgreich ausgeführt werden, gibt das Skript die Proxys zurück, die für eine Anforderung verwendet werden können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird einer <xref:System.Net.WebRequest> Instanz eine <xref:System.Net.WebProxy> Instanz zugewiesen. Die <xref:System.Net.WebRequest> Instanz verwendet den Proxy, um eine Verbindung mit externen Internet Ressourcen herzustellen. (Ein Beispiel, in dem die Verwendung der WPAD-Funktion veranschaulicht wird, finden Sie in der Dokumentation für die <xref:System.Net.IWebProxyScript>-Klasse.)  
  
 [!code-cpp[Classic WebProxy Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic WebProxy Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebProxy Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic WebProxy Example/CS/source.cs#1)]
 [!code-vb[Classic WebProxy Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic WebProxy Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine leere Instanz der <see cref="T:System.Net.WebProxy" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Parameter lose Konstruktor initialisiert eine leere Instanz der <xref:System.Net.WebProxy>-Klasse, bei der die <xref:System.Net.WebProxy.Address%2A>-Eigenschaft auf `null`festgelegt ist.  
  
 Wenn die <xref:System.Net.WebProxy.Address%2A>-Eigenschaft `null`ist, gibt die <xref:System.Net.WebProxy.IsBypassed%2A>-Methode `true` zurück, und die <xref:System.Net.WebProxy.GetProxy%2A>-Methode gibt die Zieladresse zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#1)]
 [!code-csharp[NCLWebProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Address);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy Address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Address">Der URI des Proxyservers.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit dem angegebenen URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> Instanz wird initialisiert, wobei die Eigenschaft <xref:System.Net.WebProxy.Address%2A> auf eine <xref:System.Uri> Instanz festgelegt ist, die `Address`enthält.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#6)]
 [!code-csharp[NCLWebProxy#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException"><paramref name="Address" /> ist ein ungültiger URI.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (Uri Address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri Address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(Uri ^ Address);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : Uri -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy Address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="Address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="Address">Eine <see cref="T:System.Uri" />-Instanz mit der Adresse des Proxyservers.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit der angegebenen <see cref="T:System.Uri" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> Instanz wird initialisiert, wenn die <xref:System.Net.WebProxy.Address%2A>-Eigenschaft auf den `Address`-Parameter festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#2)]
 [!code-csharp[NCLWebProxy#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WebProxy (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WebProxy(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Die Serialisierungsdaten.</param>
        <param name="streamingContext">Der Kontext für die serialisierten Daten.</param>
        <summary>Initialisiert unter Verwendung zuvor serialisierten Inhalts eine Instanz der <see cref="T:System.Net.WebProxy" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird vom System aufgerufen, um eine <xref:System.Net.WebProxy> Instanz zu deserialisieren. Anwendungen werden nicht aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Address, bool BypassOnLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Address, bool BypassOnLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As String, BypassOnLocal As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Address, bool BypassOnLocal);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string * bool -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.String" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="Address">Der URI des Proxyservers.</param>
        <param name="BypassOnLocal"><see langword="true" />, um den Proxy bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit dem angegebenen URI und der angegebenen Umgehungseinstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> Instanz wird initialisiert, wenn die Eigenschaft <xref:System.Net.WebProxy.Address%2A> auf eine <xref:System.Uri> Instanz mit `Address` und die <xref:System.Net.WebProxy.BypassProxyOnLocal%2A>-Eigenschaft auf `BypassOnLocal`festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#7)]
 [!code-csharp[NCLWebProxy#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException"><paramref name="Address" /> ist ein ungültiger URI.</exception>
        <altmember cref="P:System.Net.WebProxy.BypassProxyOnLocal" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Host, int Port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Host, int32 Port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Host As String, Port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Host, int Port);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string * int -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Host, Port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Host" Type="System.String" />
        <Parameter Name="Port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Host">Der Name des Proxyhosts.</param>
        <param name="Port">Die auf <paramref name="Host" /> zu verwendende Anschlussnummer.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit den Angaben für Host und Anschlussnummer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> Instanz wird initialisiert, wenn die Eigenschaft <xref:System.Net.WebProxy.Address%2A> auf eine <xref:System.Uri> Instanz der Form http://`Host`: `Port`festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#5)]
 [!code-csharp[NCLWebProxy#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">Der durch Kombination von <paramref name="Host" /> und <paramref name="Port" /> erstellte URI ist nicht gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (Uri Address, bool BypassOnLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri Address, bool BypassOnLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Uri,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As Uri, BypassOnLocal As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(Uri ^ Address, bool BypassOnLocal);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : Uri * bool -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="Address" Type="System.Uri" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="Address">Eine <see cref="T:System.Uri" />-Instanz mit der Adresse des Proxyservers.</param>
        <param name="BypassOnLocal"><see langword="true" />, um den Proxy bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit der <see cref="T:System.Uri" />-Instanz und der Umgehungseinstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> Instanz wird initialisiert, wenn die Eigenschaft <xref:System.Net.WebProxy.Address%2A> auf `Address` festgelegt ist und die Eigenschaft <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> auf `BypassOnLocal`festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#3)]
 [!code-csharp[NCLWebProxy#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Address, bool BypassOnLocal, string[] BypassList);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Address, bool BypassOnLocal, string[] BypassList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String,System.Boolean,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As String, BypassOnLocal As Boolean, BypassList As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Address, bool BypassOnLocal, cli::array &lt;System::String ^&gt; ^ BypassList);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string * bool * string[] -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal, BypassList)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.String" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
        <Parameter Name="BypassList" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="Address">Der URI des Proxyservers.</param>
        <param name="BypassOnLocal"><see langword="true" />, um den Proxy bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />.</param>
        <param name="BypassList">Ein Array von Zeichenfolgen regulärer Ausdrücke mit den URIs der zu umgehenden Server.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit dem angegebenen URI, der angegebenen Umgehungseinstellung und der Liste der zu umgehenden URIs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> Instanz wird initialisiert, wenn die Eigenschaft <xref:System.Net.WebProxy.Address%2A> auf eine <xref:System.Uri> Instanz festgelegt ist, die `Address`enthält, die <xref:System.Net.WebProxy.BypassProxyOnLocal%2A>-Eigenschaft auf `BypassOnLocal`festgelegt ist und die <xref:System.Net.WebProxy.BypassList%2A>-Eigenschaft auf `BypassList`festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#8)]
 [!code-csharp[NCLWebProxy#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException"><paramref name="Address" /> ist ein ungültiger URI.</exception>
        <altmember cref="P:System.Net.WebProxy.BypassProxyOnLocal" />
        <altmember cref="P:System.Net.WebProxy.BypassList" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (Uri Address, bool BypassOnLocal, string[] BypassList);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri Address, bool BypassOnLocal, string[] BypassList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Uri,System.Boolean,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As Uri, BypassOnLocal As Boolean, BypassList As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(Uri ^ Address, bool BypassOnLocal, cli::array &lt;System::String ^&gt; ^ BypassList);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : Uri * bool * string[] -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal, BypassList)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="Address" Type="System.Uri" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
        <Parameter Name="BypassList" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="Address">Eine <see cref="T:System.Uri" />-Instanz mit der Adresse des Proxyservers.</param>
        <param name="BypassOnLocal"><see langword="true" />, um den Proxy bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />.</param>
        <param name="BypassList">Ein Array von Zeichenfolgen regulärer Ausdrücke mit den URIs der zu umgehenden Server.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit der angegebenen <see cref="T:System.Uri" />-Instanz, der angegebenen Umgehungseinstellung und der Liste der zu umgehenden URIs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> Instanz wird initialisiert, wenn die Eigenschaft <xref:System.Net.WebProxy.Address%2A> auf `Address`, die <xref:System.Net.WebProxy.BypassProxyOnLocal%2A>-Eigenschaft auf `BypassOnLocal`und die <xref:System.Net.WebProxy.BypassList%2A>-Eigenschaft auf `BypassList`festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#4)]
 [!code-csharp[NCLWebProxy#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Address, bool BypassOnLocal, string[] BypassList, System.Net.ICredentials Credentials);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Address, bool BypassOnLocal, string[] BypassList, class System.Net.ICredentials Credentials) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String,System.Boolean,System.String[],System.Net.ICredentials)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As String, BypassOnLocal As Boolean, BypassList As String(), Credentials As ICredentials)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Address, bool BypassOnLocal, cli::array &lt;System::String ^&gt; ^ BypassList, System::Net::ICredentials ^ Credentials);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string * bool * string[] * System.Net.ICredentials -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal, BypassList, Credentials)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.String" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
        <Parameter Name="BypassList" Type="System.String[]" />
        <Parameter Name="Credentials" Type="System.Net.ICredentials" />
      </Parameters>
      <Docs>
        <param name="Address">Der URI des Proxyservers.</param>
        <param name="BypassOnLocal"><see langword="true" />, um den Proxy bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />.</param>
        <param name="BypassList">Ein Array von Zeichenfolgen regulärer Ausdrücke mit den URIs der zu umgehenden Server.</param>
        <param name="Credentials">Eine für die Authentifizierung an den Proxyserver zu sendende <see cref="T:System.Net.ICredentials" />-Instanz.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit dem angegebenen URI, der angegebenen Umgehungseinstellung, der Liste der zu umgehenden URIs und den Anmeldeinformationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> Instanz wird initialisiert, wenn die Eigenschaft <xref:System.Net.WebProxy.Address%2A> auf eine <xref:System.Uri> Instanz festgelegt ist, die `Address`enthält, die <xref:System.Net.WebProxy.BypassProxyOnLocal%2A>-Eigenschaft auf `BypassOnLocal`festgelegt ist, die <xref:System.Net.WebProxy.BypassList%2A>-Eigenschaft auf `BypassList`festgelegt ist und die <xref:System.Net.WebProxy.Credentials%2A>-Eigenschaft auf festgelegt ist `Credentials`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#9)]
 [!code-csharp[NCLWebProxy#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException"><paramref name="Address" /> ist ein ungültiger URI.</exception>
        <altmember cref="P:System.Net.WebProxy.BypassProxyOnLocal" />
        <altmember cref="P:System.Net.WebProxy.BypassList" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (Uri Address, bool BypassOnLocal, string[] BypassList, System.Net.ICredentials Credentials);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri Address, bool BypassOnLocal, string[] BypassList, class System.Net.ICredentials Credentials) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Uri,System.Boolean,System.String[],System.Net.ICredentials)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As Uri, BypassOnLocal As Boolean, BypassList As String(), Credentials As ICredentials)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(Uri ^ Address, bool BypassOnLocal, cli::array &lt;System::String ^&gt; ^ BypassList, System::Net::ICredentials ^ Credentials);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : Uri * bool * string[] * System.Net.ICredentials -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal, BypassList, Credentials)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.Uri" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
        <Parameter Name="BypassList" Type="System.String[]" />
        <Parameter Name="Credentials" Type="System.Net.ICredentials" />
      </Parameters>
      <Docs>
        <param name="Address">Eine <see cref="T:System.Uri" />-Instanz mit der Adresse des Proxyservers.</param>
        <param name="BypassOnLocal"><see langword="true" />, um den Proxy bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />.</param>
        <param name="BypassList">Ein Array von Zeichenfolgen regulärer Ausdrücke mit den URIs der zu umgehenden Server.</param>
        <param name="Credentials">Eine für die Authentifizierung an den Proxyserver zu sendende <see cref="T:System.Net.ICredentials" />-Instanz.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit der angegebenen <see cref="T:System.Uri" />-Instanz, der angegebenen Umgehungseinstellung, der Liste der zu umgehenden URIs und den Anmeldeinformationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> Instanz wird initialisiert, wenn die Eigenschaft <xref:System.Net.WebProxy.Address%2A> auf `Address`festgelegt ist, die <xref:System.Net.WebProxy.BypassProxyOnLocal%2A>-Eigenschaft auf `BypassOnLocal`festgelegt ist, die <xref:System.Net.WebProxy.BypassList%2A>-Eigenschaft auf `BypassList`festgelegt ist und die <xref:System.Net.WebProxy.Credentials%2A>-Eigenschaft auf `Credentials`festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#13)]
 [!code-csharp[NCLWebProxy#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.Address" />
      <MemberSignature Language="VB.NET" Value="Public Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri with get, set" Usage="System.Net.WebProxy.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Adresse des Proxyservers ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Uri" />-Instanz mit der Adresse des Proxyservers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy.Address%2A>-Eigenschaft enthält die Adresse des Proxy Servers. Wenn die automatische Proxy Erkennung nicht aktiviert ist und kein Automatisches Konfigurationsskript angegeben ist, bestimmen die <xref:System.Net.WebProxy.Address%2A> Eigenschaft und <xref:System.Net.WebProxy.BypassList%2A> den für eine Anforderung verwendeten Proxy.  
  
 Wenn die <xref:System.Net.WebProxy.Address%2A>-Eigenschaft `null`ist, wird der Proxy von Anforderungen umgangen, und eine direkte Verbindung mit dem Zielhost wird hergestellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Eigenschaften eines <xref:System.Net.WebProxy> Objekts, einschließlich seiner <xref:System.Net.WebProxy.Address%2A>, angezeigt.  
  
 [!code-cpp[NCLAutoProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLAutoProxy/CPP/proxy.cpp#1)]
 [!code-csharp[NCLAutoProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAutoProxy/CS/proxy.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BypassArrayList">
      <MemberSignature Language="C#" Value="public System.Collections.ArrayList BypassArrayList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList BypassArrayList" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.BypassArrayList" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BypassArrayList As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ArrayList ^ BypassArrayList { System::Collections::ArrayList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BypassArrayList : System.Collections.ArrayList" Usage="System.Net.WebProxy.BypassArrayList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Liste der Adressen ab, bei denen der Proxyserver nicht verwendet wird.</summary>
        <value>Eine <see cref="T:System.Collections.ArrayList" /> mit einer Liste von <see cref="P:System.Net.WebProxy.BypassList" />-Arrays, die URIs darstellen, für deren Zugriff der Proxyserver nicht verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Net.WebProxy.BypassList%2A> ist eine Array Liste von Zeichen folgen für reguläre Ausdrücke, die die URIs beschreiben, auf die eine <xref:System.Net.WebRequest> Instanz direkt anstatt über den Proxy Server zugreift.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BypassList">
      <MemberSignature Language="C#" Value="public string[] BypassList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] BypassList" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.BypassList" />
      <MemberSignature Language="VB.NET" Value="Public Property BypassList As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ BypassList { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BypassList : string[] with get, set" Usage="System.Net.WebProxy.BypassList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Array von Adressen ab, bei denen der Proxyserver nicht verwendet wird, oder legt diese fest.</summary>
        <value>Ein Array mit der Liste aller regulären Ausdrücke, die URIs beschreiben, für deren Zugriff der Proxyserver nicht verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy.BypassList%2A>-Eigenschaft enthält ein Array von regulären Ausdrücken, die URIs beschreiben, auf die eine <xref:System.Net.WebRequest> Instanz direkt anstatt über den Proxy Server zugreift.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Eigenschaften eines <xref:System.Net.WebProxy> Objekts, einschließlich seiner <xref:System.Net.WebProxy.BypassList%2A>-Eigenschaft.  
  
 [!code-cpp[NCLAutoProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLAutoProxy/CPP/proxy.cpp#1)]
 [!code-csharp[NCLAutoProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAutoProxy/CS/proxy.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.Regex" />
      </Docs>
    </Member>
    <Member MemberName="BypassProxyOnLocal">
      <MemberSignature Language="C#" Value="public bool BypassProxyOnLocal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BypassProxyOnLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.BypassProxyOnLocal" />
      <MemberSignature Language="VB.NET" Value="Public Property BypassProxyOnLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BypassProxyOnLocal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BypassProxyOnLocal : bool with get, set" Usage="System.Net.WebProxy.BypassProxyOnLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob der Proxyserver bei lokalen Adressen umgangen werden soll.</summary>
        <value><see langword="true" />, um den Proxyserver bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einstellung der <xref:System.Net.WebProxy.BypassProxyOnLocal%2A>-Eigenschaft bestimmt, ob <xref:System.Net.WebRequest>-Instanzen den Proxy Server beim Zugriff auf lokale Internet Ressourcen verwenden.  
  
 Wenn <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> `true` ist, wird bei Anforderungen an lokale Internetressourcen der Proxyserver nicht verwendet. Lokale Anforderungen werden durch das Fehlen eines Zeitraums (.) im URI identifiziert, wie in `http://webserver/`, oder auf den lokalen Server zugreifen, einschließlich `http://localhost`, `http://loopback`oder `http://127.0.0.1`. Wenn <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> `false` ist, werden alle Internetanforderungen über den Proxyserver ausgeführt.  
  
> [!NOTE]
>  Anforderungen an einen lokalen Host mit einem URI, der einen Zeitraum enthält, verwenden den Proxy. Um die Verwendung eines Proxys in diesen Fällen zu vermeiden, erstellen Sie einen Eintrag für den Host in der <xref:System.Net.WebProxy.BypassList%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen eines Konstruktors veranschaulicht, der diese Eigenschaft festlegt und den Wert dieser Eigenschaft erhält.  
  
 [!code-cpp[NCLWebProxy#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#7)]
 [!code-csharp[NCLWebProxy#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultProxy">
      <MemberSignature Language="C#" Value="public static System.Net.IWebProxy CreateDefaultProxy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IWebProxy CreateDefaultProxy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.CreateDefaultProxy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDefaultProxy () As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IWebProxy ^ CreateDefaultProxy();" />
      <MemberSignature Language="F#" Value="static member CreateDefaultProxy : unit -&gt; System.Net.IWebProxy" Usage="System.Net.WebProxy.CreateDefaultProxy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.WebProxy.Credentials" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Net.IWebProxy.Credentials</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anmeldeinformationen ab oder legt diese fest, die an den Proxyserver zur Authentifizierung übermittelt werden sollen.</summary>
        <value>Eine <see cref="T:System.Net.ICredentials" />-Instanz mit den für die Authentifizierung an den Proxyserver zu übermittelnden Anmeldeinformationen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy.Credentials%2A>-Eigenschaft enthält die Anmelde Informationen für die Authentifizierung, die als Reaktion auf einen HTTP 407 (Proxy Authorization)-Statuscode an den Proxy Server gesendet werden sollen. In den meisten Client Szenarien sollten Sie den <xref:System.Net.CredentialCache.DefaultCredentials%2A>verwenden, bei dem es sich um die Anmelde Informationen des aktuell angemeldeten Benutzers handelt. Legen Sie zu diesem Zweck die <xref:System.Net.WebProxy.UseDefaultCredentials%2A>-Eigenschaft auf `true` fest, anstatt diese Eigenschaft festzulegen.  
  
> [!NOTE]
>  Wenn Sie die <xref:System.Net.WebProxy.Credentials%2A>-Eigenschaft auf andere Anmelde Informationen als die <xref:System.Net.CredentialCache.DefaultCredentials%2A>festlegen, verursacht das Festlegen der <xref:System.Net.WebProxy.UseDefaultCredentials%2A>-Eigenschaft auf `true` eine <xref:System.InvalidOperationException>. Um dies zu verhindern, müssen Sie die <xref:System.Net.WebProxy.Credentials%2A>-Eigenschaft auf `null` festlegen, bevor die <xref:System.Net.WebProxy.UseDefaultCredentials%2A>-Eigenschaft auf `true`festgelegt wird. Ebenso kann diese Eigenschaft nicht auf einen Wert festgelegt werden, wenn <xref:System.Net.WebProxy.UseDefaultCredentials%2A> `true`ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Sie haben versucht, diese Eigenschaft festzulegen, obwohl die <see cref="P:System.Net.WebProxy.UseDefaultCredentials" />-Eigenschaft auf <see langword="true" /> festgelegt war.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProxy">
      <MemberSignature Language="C#" Value="public static System.Net.WebProxy GetDefaultProxy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.WebProxy GetDefaultProxy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.GetDefaultProxy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProxy () As WebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::WebProxy ^ GetDefaultProxy();" />
      <MemberSignature Language="F#" Value="static member GetDefaultProxy : unit -&gt; System.Net.WebProxy" Usage="System.Net.WebProxy.GetDefaultProxy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use the proxy selected for you by default. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use the proxy selected for you by default. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebProxy</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest die nicht dynamischen Proxyeinstellungen von Internet Explorer.</summary>
        <returns>Eine <see cref="T:System.Net.WebProxy" />-Instanz mit den nicht dynamischen Proxyeinstellungen von Internet Explorer 5.5 und höher.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy.GetDefaultProxy%2A>-Methode liest die nicht dynamischen Proxy Einstellungen, die von Internet Explorer 5,5 und höher gespeichert werden, und erstellt eine <xref:System.Net.WebProxy> Instanz mit diesen Einstellungen.  
  
 Mit der <xref:System.Net.WebProxy.GetDefaultProxy%2A>-Methode werden keine dynamischen Einstellungen übernommen, die aus Skripts generiert werden, die von Internet Explorer, von automatischen Konfigurations Einträgen oder von DHCP-oder DNS-Lookups ausgeführt werden.  
  
 Anwendungen sollten die <xref:System.Net.WebRequest.DefaultWebProxy%2A?displayProperty=nameWithType>-Eigenschaft und die <xref:System.Net.WebRequest.GetSystemWebProxy%2A?displayProperty=nameWithType>-Methode anstelle der <xref:System.Net.WebProxy.GetDefaultProxy%2A>-Methode verwenden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieser Methode veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#11)]
 [!code-csharp[NCLWebProxy#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#11)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Für den uneingeschränkten Zugriff auf Netzwerkressourcen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="webProxy.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Die mit Daten zu füllende <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="streamingContext">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />, der das Ziel für diese Serialisierung angibt.</param>
        <summary>Füllt eine <see cref="T:System.Runtime.Serialization.SerializationInfo" /> mit den Daten auf, die zum Serialisieren des Zielobjekts erforderlich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Objekte, die in der <xref:System.Runtime.Serialization.SerializationInfo> enthalten sind, werden vom Formatierer automatisch nachverfolgt und serialisiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProxy">
      <MemberSignature Language="C#" Value="public Uri GetProxy (Uri destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Uri GetProxy(class System.Uri destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.GetProxy(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProxy (destination As Uri) As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Uri ^ GetProxy(Uri ^ destination);" />
      <MemberSignature Language="F#" Value="abstract member GetProxy : Uri -&gt; Uri&#xA;override this.GetProxy : Uri -&gt; Uri" Usage="webProxy.GetProxy destination" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Net.IWebProxy.GetProxy(System.Uri)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="destination">Die <see cref="T:System.Uri" />-Instanz der angeforderten Internetressource.</param>
        <summary>Gibt den Proxy-URI einer Anforderung zurück.</summary>
        <returns>Die <see cref="T:System.Uri" />-Instanz der Internetressource, wenn die Ressource in der Umgehungsliste aufgeführt ist, andernfalls die <see cref="T:System.Uri" />-Instanz des Proxys.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy.GetProxy%2A>-Methode gibt den URI zurück, den die <xref:System.Net.WebRequest>-Instanz verwendet, um auf die Internet Ressource zuzugreifen.  
  
 <xref:System.Net.WebProxy.GetProxy%2A> vergleicht `destination` mit dem Inhalt von <xref:System.Net.WebProxy.BypassList%2A>mithilfe der <xref:System.Net.WebProxy.IsBypassed%2A>-Methode. Wenn <xref:System.Net.WebProxy.IsBypassed%2A> `true`zurückgibt, gibt <xref:System.Net.WebProxy.GetProxy%2A> `destination` zurück, und die <xref:System.Net.WebRequest> Instanz verwendet den Proxy Server nicht.  
  
 Wenn `destination` nicht in <xref:System.Net.WebProxy.BypassList%2A>ist, wird die <xref:System.Net.WebRequest> Instanz den Proxy Server verwendet, und die <xref:System.Net.WebProxy.Address%2A>-Eigenschaft wird zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Net.WebProxy> Objekt erstellt und diese Methode aufgerufen, um den für eine Ressource ausgewählten Proxy zu erhalten.  
  
 [!code-cpp[NCLAutoProxy#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLAutoProxy/CPP/proxy.cpp#2)]
 [!code-csharp[NCLAutoProxy#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAutoProxy/CS/proxy.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destination" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsBypassed">
      <MemberSignature Language="C#" Value="public bool IsBypassed (Uri host);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsBypassed(class System.Uri host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.IsBypassed(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsBypassed (host As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsBypassed(Uri ^ host);" />
      <MemberSignature Language="F#" Value="abstract member IsBypassed : Uri -&gt; bool&#xA;override this.IsBypassed : Uri -&gt; bool" Usage="webProxy.IsBypassed host" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Net.IWebProxy.IsBypassed(System.Uri)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="host">Die <see cref="T:System.Uri" />-Instanz des Hosts, der auf eine Proxyverwendung überprüft werden soll.</param>
        <summary>Gibt an, ob der Proxyserver für den angegebenen Host verwendet werden soll.</summary>
        <returns><see langword="true" />, wenn der Proxyserver nicht für <paramref name="host" /> verwendet werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy.IsBypassed%2A>-Methode wird verwendet, um zu bestimmen, ob der Proxy Server beim Zugriff auf eine Internet Ressource umgangen werden soll.  
  
 Die Eigenschaften <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> und <xref:System.Net.WebProxy.BypassList%2A> steuern den Rückgabewert der <xref:System.Net.WebProxy.IsBypassed%2A>-Methode.  
  
 <xref:System.Net.WebProxy.IsBypassed%2A> gibt `true` unter den folgenden Bedingungen zurück:  
  
-   Wenn <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> `true` und `host` ein lokaler URI ist. Lokale Anforderungen werden durch das Fehlen eines Zeitraums (.) im URI identifiziert, wie in `http://webserver/`.  
  
-   , Wenn `host` mit einem regulären Ausdruck in <xref:System.Net.WebProxy.BypassList%2A>übereinstimmt.  
  
-   Wenn <xref:System.Net.WebProxy.Address%2A> gleich `null` ist.  
  
 Alle anderen Bedingungen geben `false`zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Net.WebProxy> Objekt erstellt und diese Methode aufgerufen, um zu überprüfen, ob die Umgehungs Liste ordnungsgemäß festgelegt ist.  
  
 [!code-cpp[NCLWebProxy#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#12)]
 [!code-csharp[NCLWebProxy#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="host" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Das mit Daten aufzufüllende <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt.</param>
        <param name="streamingContext">Eine <see cref="T:System.Runtime.Serialization.StreamingContext" />-Struktur, die das Ziel für diese Serialisierung angibt.</param>
        <summary>Erstellt die Serialisierungsdaten und den Serialisierungskontext, die vom System zum Serialisieren eines <see cref="T:System.Net.WebProxy" />-Objekts verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das System ruft diese Methode auf, um ein Objekt zu serialisieren. Anwendungen werden nicht direkt aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.WebProxy.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der steuert, ob mit den Anforderungen <see cref="P:System.Net.CredentialCache.DefaultCredentials" /> gesendet werden, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Standardanmeldeinformationen verwendet werden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf `true` fest, wenn von diesem <xref:System.Net.WebProxy> Objekt vorgenommene Anforderungen durch den Server mithilfe der Anmelde Informationen des aktuell angemeldeten Benutzers authentifiziert werden sollen. Bei Client Anwendungen ist dies das gewünschte Verhalten in den meisten Szenarien. Für Anwendungen der mittleren Ebene, z. b. ASP.NET-Anwendungen, würden Sie die <xref:System.Net.WebProxy.Credentials%2A>-Eigenschaft in der Regel auf die Anmelde Informationen des Clients festlegen, für den die Anforderung gestellt wird, anstatt diese Eigenschaft zu verwenden.  
  
 In der folgenden Tabelle wird gezeigt, welche Auswirkung das Festlegen des <xref:System.Net.WebProxy.UseDefaultCredentials%2A> Werts basierend auf dem Wert der <xref:System.Net.WebProxy.Credentials%2A>-Eigenschaft hat.  
  
|<xref:System.Net.WebProxy.Credentials%2A>-Wert|<xref:System.Net.WebProxy.UseDefaultCredentials%2A>-Wert|Effekt|  
|----------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|------------|  
|<xref:System.Net.CredentialCache.DefaultCredentials%2A>|`true`|Keine Auswirkung.|  
|<xref:System.Net.CredentialCache.DefaultCredentials%2A>|`false`|Für <xref:System.Net.WebProxy.Credentials%2A> ist `null` festgelegt.|  
|`null`|`true`|Für <xref:System.Net.WebProxy.Credentials%2A> ist <xref:System.Net.CredentialCache.DefaultCredentials%2A> festgelegt.|  
|Alle anderen Werte als <xref:System.Net.CredentialCache.DefaultCredentials%2A> oder `null`|`true` oder `false`|Beim Festlegen von <xref:System.Net.WebProxy.UseDefaultCredentials%2A> wird eine Ausnahme ausgelöst.|  
  
 Wenn <xref:System.Net.WebProxy.UseDefaultCredentials%2A> `false`ist, können Sie die Eigenschaft <xref:System.Net.WebProxy.Credentials%2A> in beliebige Anmelde Informationen ändern. Wenn <xref:System.Net.WebProxy.UseDefaultCredentials%2A> `true`wird, wird eine Ausnahme ausgelöst, wenn die Eigenschaft <xref:System.Net.WebProxy.Credentials%2A> von <xref:System.Net.CredentialCache.DefaultCredentials%2A> geändert wird (der Wert, der festgelegt wird, wenn die <xref:System.Net.WebProxy.UseDefaultCredentials%2A>-Eigenschaft auf `true`festgelegt ist).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Sie haben versucht, diese Eigenschaft festzulegen, obwohl die <see cref="P:System.Net.WebProxy.Credentials" />-Eigenschaft andere Anmeldeinformationen als die Standardanmeldeinformationen enthält.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
