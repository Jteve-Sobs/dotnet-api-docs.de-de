<Type Name="WebProxy" FullName="System.Net.WebProxy">
  <Metadata><Meta Name="ms.openlocfilehash" Value="183c2ea72968131dec32dcc608b7b2aaa485cce3" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69090471" /></Metadata><TypeSignature Language="C#" Value="public class WebProxy : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit WebProxy extends System.Object implements class System.Net.IWebProxy, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.WebProxy" />
  <TypeSignature Language="VB.NET" Value="Public Class WebProxy&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebProxy : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type WebProxy = class&#xA;    interface ISerializable&#xA;    interface IWebProxy" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.WebProxy</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Net.IWebProxy</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Enthält HTTP-Proxyeinstellungen für die <see cref="T:System.Net.WebRequest" />-Klasse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> -Klasse enthält die Proxy Einstellungen <xref:System.Net.WebRequest> , die von Instanzen verwendet werden, um zu bestimmen, ob ein Webproxy zum Senden von Anforderungen verwendet wird. Globale WebProxy Einstellungen können in Computer-und Anwendungs Konfigurationsdateien angegeben werden, und Anwendungen können Instanzen der <xref:System.Net.WebProxy> -Klasse verwenden, um die Verwendung von Webproxys anzupassen. Die <xref:System.Net.WebProxy> -Klasse ist die Basis Implementierung <xref:System.Net.IWebProxy> der-Schnittstelle.  
  
 Zum Abrufen von Instanzen der WebProxy Klasse können Sie eine der folgenden Methoden verwenden:  
  
-   Der <xref:System.Net.WebProxy.%23ctor%2A> Konstruktor.  
  
-   Die <xref:System.Net.WebProxy.GetDefaultProxy%2A> -Methode.  
  
-   Die <xref:System.Net.GlobalProxySelection.Select%2A> -Methode.  
  
 Diese Methoden stellen jeweils eine <xref:System.Net.WebProxy> -Instanz bereit, die Sie weiter anpassen können. der Unterschied zwischen Ihnen besteht darin, wie die Instanz initialisiert wird, bevor Sie an Ihre Anwendung zurückgegeben wird. Der <xref:System.Net.WebProxy.%23ctor%2A> -Konstruktor gibt eine Instanz <xref:System.Net.WebProxy> der-Klasse zurück <xref:System.Net.WebProxy.Address%2A> , bei der `null`die-Eigenschaft auf festgelegt ist. Wenn eine Anforderung eine <xref:System.Net.WebProxy> -Instanz in diesem Zustand verwendet, wird kein Proxy verwendet, um die Anforderung zu senden.  
  
 Die <xref:System.Net.WebProxy.GetDefaultProxy%2A> -Methode gibt eine Instanz <xref:System.Net.WebProxy> der-Klasse zurück <xref:System.Net.WebProxy.Address%2A>, bei der <xref:System.Net.WebProxy.BypassList%2A> die Eigenschaften, und auf die Werte festgelegt sind <xref:System.Net.WebProxy.BypassProxyOnLocal%2A>, die von Internet Explorer 5,5 und höher verwendet werden.  
  
 Die <xref:System.Net.GlobalProxySelection.Select%2A> -Methode gibt eine Instanz <xref:System.Net.WebProxy> der-Klasse zurück, deren Eigenschaften auf eine Kombination von Internet Explorer und Konfigurationsdatei Einstellungen festgelegt sind.  
  
 Die <xref:System.Net.WebProxy> -Klasse unterstützt die automatische Erkennung und Ausführung von Proxy Konfigurations Skripts. Diese Funktion ist auch bekannt als Web Proxy Auto-Discovery (WPAD). Wenn Sie die automatische Proxykonfiguration verwenden, muss ein Konfigurationsskript, das in der Regel "WPAD. dat" genannt wird, gefunden, heruntergeladen, kompiliert und ausgeführt werden. Wenn diese Vorgänge erfolgreich ausgeführt werden, gibt das Skript die Proxys zurück, die für eine Anforderung verwendet werden können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Net.WebProxy> -Instanz einer <xref:System.Net.WebRequest> -Instanz zugewiesen. Die <xref:System.Net.WebRequest> -Instanz verwendet den Proxy, um eine Verbindung mit externen Internet Ressourcen herzustellen. (Ein Beispiel zur Veranschaulichung der Verwendung des WPAD-Features finden Sie in der <xref:System.Net.IWebProxyScript> Dokumentation für die-Klasse.)  
  
 [!code-cpp[Classic WebProxy Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic WebProxy Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebProxy Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic WebProxy Example/CS/source.cs#1)]
 [!code-vb[Classic WebProxy Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic WebProxy Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine leere Instanz der <see cref="T:System.Net.WebProxy" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Parameter lose Konstruktor initialisiert eine leere Instanz der <xref:System.Net.WebProxy> -Klasse, bei der die <xref:System.Net.WebProxy.Address%2A> -Eigenschaft `null`auf festgelegt ist.  
  
 Wenn die <xref:System.Net.WebProxy.Address%2A> -Eigenschaft `null`ist, <xref:System.Net.WebProxy.IsBypassed%2A> gibt die `true` Methode zurück <xref:System.Net.WebProxy.GetProxy%2A> , und die-Methode gibt die Zieladresse zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#1)]
 [!code-csharp[NCLWebProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Address);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy Address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Address">Der URI des Proxyservers.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit dem angegebenen URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> -Instanz wird initialisiert, <xref:System.Net.WebProxy.Address%2A> wenn die-Eigenschaft <xref:System.Uri> auf eine `Address`-Instanz mit festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#6)]
 [!code-csharp[NCLWebProxy#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException"><paramref name="Address" /> ist ein ungültiger URI.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (Uri Address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri Address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(Uri ^ Address);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : Uri -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy Address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="Address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="Address">Eine <see cref="T:System.Uri" />-Instanz mit der Adresse des Proxyservers.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit der angegebenen <see cref="T:System.Uri" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> -Instanz wird initialisiert, <xref:System.Net.WebProxy.Address%2A> wenn die-Eigenschaft `Address` auf den-Parameter festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#2)]
 [!code-csharp[NCLWebProxy#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WebProxy (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WebProxy(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Die Serialisierungsdaten.</param>
        <param name="streamingContext">Der Kontext für die serialisierten Daten.</param>
        <summary>Initialisiert unter Verwendung zuvor serialisierten Inhalts eine Instanz der <see cref="T:System.Net.WebProxy" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird vom System aufgerufen, um eine <xref:System.Net.WebProxy> -Instanz zu deserialisieren; Anwendungen nennen Sie Sie nicht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Address, bool BypassOnLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Address, bool BypassOnLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As String, BypassOnLocal As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Address, bool BypassOnLocal);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string * bool -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.String" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="Address">Der URI des Proxyservers.</param>
        <param name="BypassOnLocal"><see langword="true" />, um den Proxy bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit dem angegebenen URI und der angegebenen Umgehungseinstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> -Instanz wird initialisiert, <xref:System.Net.WebProxy.Address%2A> wenn die-Eigenschaft <xref:System.Uri> auf eine- `Address` Instanz, <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> die enthält, `BypassOnLocal`und die-Eigenschaft auf festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#7)]
 [!code-csharp[NCLWebProxy#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException"><paramref name="Address" /> ist ein ungültiger URI.</exception>
        <altmember cref="P:System.Net.WebProxy.BypassProxyOnLocal" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Host, int Port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Host, int32 Port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Host As String, Port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Host, int Port);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string * int -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Host, Port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Host" Type="System.String" />
        <Parameter Name="Port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Host">Der Name des Proxyhosts.</param>
        <param name="Port">Die auf <paramref name="Host" /> zu verwendende Anschlussnummer.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit den Angaben für Host und Anschlussnummer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> -Instanz wird initialisiert, <xref:System.Net.WebProxy.Address%2A> wenn die-Eigenschaft <xref:System.Uri> auf eine Instanz der Form `Host` http:// `Port`: festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#5)]
 [!code-csharp[NCLWebProxy#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">Der durch Kombination von <paramref name="Host" /> und <paramref name="Port" /> erstellte URI ist nicht gültig.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (Uri Address, bool BypassOnLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri Address, bool BypassOnLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Uri,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As Uri, BypassOnLocal As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(Uri ^ Address, bool BypassOnLocal);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : Uri * bool -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="Address" Type="System.Uri" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="Address">Eine <see cref="T:System.Uri" />-Instanz mit der Adresse des Proxyservers.</param>
        <param name="BypassOnLocal"><see langword="true" />, um den Proxy bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit der <see cref="T:System.Uri" />-Instanz und der Umgehungseinstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> -Instanz wird initialisiert, <xref:System.Net.WebProxy.Address%2A> wenn die- `Address` Eigenschaft auf fest <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> gelegt ist und `BypassOnLocal`die-Eigenschaft auf festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#3)]
 [!code-csharp[NCLWebProxy#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Address, bool BypassOnLocal, string[] BypassList);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Address, bool BypassOnLocal, string[] BypassList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String,System.Boolean,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As String, BypassOnLocal As Boolean, BypassList As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Address, bool BypassOnLocal, cli::array &lt;System::String ^&gt; ^ BypassList);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string * bool * string[] -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal, BypassList)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.String" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
        <Parameter Name="BypassList" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="Address">Der URI des Proxyservers.</param>
        <param name="BypassOnLocal"><see langword="true" />, um den Proxy bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />.</param>
        <param name="BypassList">Ein Array von Zeichenfolgen regulärer Ausdrücke mit den URIs der zu umgehenden Server.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit dem angegebenen URI, der angegebenen Umgehungseinstellung und der Liste der zu umgehenden URIs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> -Instanz wird initialisiert, <xref:System.Net.WebProxy.Address%2A> wenn die-Eigenschaft <xref:System.Uri> `Address`auf eine-Instanz fest <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> gelegt ist, `BypassOnLocal`die die- <xref:System.Net.WebProxy.BypassList%2A> Eigenschaft auf fest `BypassList`gelegt ist und die-Eigenschaft auf gesetzt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#8)]
 [!code-csharp[NCLWebProxy#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException"><paramref name="Address" /> ist ein ungültiger URI.</exception>
        <altmember cref="P:System.Net.WebProxy.BypassProxyOnLocal" />
        <altmember cref="P:System.Net.WebProxy.BypassList" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (Uri Address, bool BypassOnLocal, string[] BypassList);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri Address, bool BypassOnLocal, string[] BypassList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Uri,System.Boolean,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As Uri, BypassOnLocal As Boolean, BypassList As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(Uri ^ Address, bool BypassOnLocal, cli::array &lt;System::String ^&gt; ^ BypassList);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : Uri * bool * string[] -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal, BypassList)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="Address" Type="System.Uri" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
        <Parameter Name="BypassList" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="Address">Eine <see cref="T:System.Uri" />-Instanz mit der Adresse des Proxyservers.</param>
        <param name="BypassOnLocal"><see langword="true" />, um den Proxy bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />.</param>
        <param name="BypassList">Ein Array von Zeichenfolgen regulärer Ausdrücke mit den URIs der zu umgehenden Server.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit der angegebenen <see cref="T:System.Uri" />-Instanz, der angegebenen Umgehungseinstellung und der Liste der zu umgehenden URIs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> -Instanz wird initialisiert, <xref:System.Net.WebProxy.Address%2A> wenn die- `Address`Eigenschaft auf <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> festgelegt ist `BypassOnLocal`, die- <xref:System.Net.WebProxy.BypassList%2A> Eigenschaft auf und `BypassList`die-Eigenschaft auf festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#4)]
 [!code-csharp[NCLWebProxy#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Address, bool BypassOnLocal, string[] BypassList, System.Net.ICredentials Credentials);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Address, bool BypassOnLocal, string[] BypassList, class System.Net.ICredentials Credentials) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String,System.Boolean,System.String[],System.Net.ICredentials)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As String, BypassOnLocal As Boolean, BypassList As String(), Credentials As ICredentials)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Address, bool BypassOnLocal, cli::array &lt;System::String ^&gt; ^ BypassList, System::Net::ICredentials ^ Credentials);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string * bool * string[] * System.Net.ICredentials -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal, BypassList, Credentials)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.String" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
        <Parameter Name="BypassList" Type="System.String[]" />
        <Parameter Name="Credentials" Type="System.Net.ICredentials" />
      </Parameters>
      <Docs>
        <param name="Address">Der URI des Proxyservers.</param>
        <param name="BypassOnLocal"><see langword="true" />, um den Proxy bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />.</param>
        <param name="BypassList">Ein Array von Zeichenfolgen regulärer Ausdrücke mit den URIs der zu umgehenden Server.</param>
        <param name="Credentials">Eine für die Authentifizierung an den Proxyserver zu sendende <see cref="T:System.Net.ICredentials" />-Instanz.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit dem angegebenen URI, der angegebenen Umgehungseinstellung, der Liste der zu umgehenden URIs und den Anmeldeinformationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> -Instanz wird mit der <xref:System.Net.WebProxy.Address%2A> -Eigenschaft initialisiert, <xref:System.Uri> die `Address`auf eine-Instanz <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> festgelegt ist `BypassOnLocal`, die <xref:System.Net.WebProxy.BypassList%2A> -Eigenschaft auf `BypassList`festgelegt ist, die-Eigenschaft auf festgelegt ist die <xref:System.Net.WebProxy.Credentials%2A> -Eigenschaft ist `Credentials`auf festgelegt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#9)]
 [!code-csharp[NCLWebProxy#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException"><paramref name="Address" /> ist ein ungültiger URI.</exception>
        <altmember cref="P:System.Net.WebProxy.BypassProxyOnLocal" />
        <altmember cref="P:System.Net.WebProxy.BypassList" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (Uri Address, bool BypassOnLocal, string[] BypassList, System.Net.ICredentials Credentials);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri Address, bool BypassOnLocal, string[] BypassList, class System.Net.ICredentials Credentials) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Uri,System.Boolean,System.String[],System.Net.ICredentials)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As Uri, BypassOnLocal As Boolean, BypassList As String(), Credentials As ICredentials)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(Uri ^ Address, bool BypassOnLocal, cli::array &lt;System::String ^&gt; ^ BypassList, System::Net::ICredentials ^ Credentials);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : Uri * bool * string[] * System.Net.ICredentials -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal, BypassList, Credentials)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.Uri" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
        <Parameter Name="BypassList" Type="System.String[]" />
        <Parameter Name="Credentials" Type="System.Net.ICredentials" />
      </Parameters>
      <Docs>
        <param name="Address">Eine <see cref="T:System.Uri" />-Instanz mit der Adresse des Proxyservers.</param>
        <param name="BypassOnLocal"><see langword="true" />, um den Proxy bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />.</param>
        <param name="BypassList">Ein Array von Zeichenfolgen regulärer Ausdrücke mit den URIs der zu umgehenden Server.</param>
        <param name="Credentials">Eine für die Authentifizierung an den Proxyserver zu sendende <see cref="T:System.Net.ICredentials" />-Instanz.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.WebProxy" />-Klasse mit der angegebenen <see cref="T:System.Uri" />-Instanz, der angegebenen Umgehungseinstellung, der Liste der zu umgehenden URIs und den Anmeldeinformationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy> Instanz wird initialisiert, wenn <xref:System.Net.WebProxy.Address%2A> die-Eigenschaft `Address`auf fest <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> gelegt ist, `BypassOnLocal`die- <xref:System.Net.WebProxy.BypassList%2A> Eigenschaft auf festgelegt ist, <xref:System.Net.WebProxy.Credentials%2A> die-Eigenschaft `BypassList`auf festgelegt ist und die-Eigenschaft auf `Credentials`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieses Konstruktors veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#13)]
 [!code-csharp[NCLWebProxy#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.Address" />
      <MemberSignature Language="VB.NET" Value="Public Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri with get, set" Usage="System.Net.WebProxy.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Adresse des Proxyservers ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Uri" />-Instanz mit der Adresse des Proxyservers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy.Address%2A> -Eigenschaft enthält die Adresse des Proxy Servers. Wenn die automatische Proxy Erkennung nicht aktiviert ist und kein Automatisches Konfigurationsskript angegeben ist, bestimmen <xref:System.Net.WebProxy.Address%2A> Sie die <xref:System.Net.WebProxy.BypassList%2A> -Eigenschaft und bestimmen den Proxy, der für eine Anforderung verwendet wird.  
  
 Wenn die <xref:System.Net.WebProxy.Address%2A> -Eigenschaft `null`ist, wird der Proxy von Anforderungen umgangen, und eine direkte Verbindung mit dem Zielhost wird hergestellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Eigenschaften eines <xref:System.Net.WebProxy> -Objekts, <xref:System.Net.WebProxy.Address%2A>einschließlich des, angezeigt.  
  
 [!code-cpp[NCLAutoProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLAutoProxy/CPP/proxy.cpp#1)]
 [!code-csharp[NCLAutoProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAutoProxy/CS/proxy.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BypassArrayList">
      <MemberSignature Language="C#" Value="public System.Collections.ArrayList BypassArrayList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList BypassArrayList" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.BypassArrayList" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BypassArrayList As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ArrayList ^ BypassArrayList { System::Collections::ArrayList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BypassArrayList : System.Collections.ArrayList" Usage="System.Net.WebProxy.BypassArrayList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Liste der Adressen ab, bei denen der Proxyserver nicht verwendet wird.</summary>
        <value>Eine <see cref="T:System.Collections.ArrayList" /> mit einer Liste von <see cref="P:System.Net.WebProxy.BypassList" />-Arrays, die URIs darstellen, für deren Zugriff der Proxyserver nicht verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei handelt es sich um eine Array Liste von Zeichen folgen für reguläre Ausdrücke, <xref:System.Net.WebRequest> die die URIs beschreiben, auf die eine-Instanz direkt anstatt über den Proxy Server zugreift. <xref:System.Net.WebProxy.BypassList%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BypassList">
      <MemberSignature Language="C#" Value="public string[] BypassList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] BypassList" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.BypassList" />
      <MemberSignature Language="VB.NET" Value="Public Property BypassList As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ BypassList { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BypassList : string[] with get, set" Usage="System.Net.WebProxy.BypassList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Array von Adressen ab, bei denen der Proxyserver nicht verwendet wird, oder legt diese fest.</summary>
        <value>Ein Array mit der Liste aller regulären Ausdrücke, die URIs beschreiben, für deren Zugriff der Proxyserver nicht verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy.BypassList%2A> -Eigenschaft enthält ein Array von regulären Ausdrücken, die URIs beschreiben <xref:System.Net.WebRequest> , auf die eine-Instanz direkt anstatt über den Proxy Server zugreift.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Eigenschaften eines <xref:System.Net.WebProxy> -Objekts, <xref:System.Net.WebProxy.BypassList%2A> einschließlich der-Eigenschaft, angezeigt.  
  
 [!code-cpp[NCLAutoProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLAutoProxy/CPP/proxy.cpp#1)]
 [!code-csharp[NCLAutoProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAutoProxy/CS/proxy.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.Regex" />
      </Docs>
    </Member>
    <Member MemberName="BypassProxyOnLocal">
      <MemberSignature Language="C#" Value="public bool BypassProxyOnLocal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BypassProxyOnLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.BypassProxyOnLocal" />
      <MemberSignature Language="VB.NET" Value="Public Property BypassProxyOnLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BypassProxyOnLocal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BypassProxyOnLocal : bool with get, set" Usage="System.Net.WebProxy.BypassProxyOnLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob der Proxyserver bei lokalen Adressen umgangen werden soll.</summary>
        <value><see langword="true" />, um den Proxyserver bei lokalen Adressen zu umgehen, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einstellung der- <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> Eigenschaft bestimmt, <xref:System.Net.WebRequest> ob-Instanzen beim Zugriff auf lokale Internet Ressourcen den Proxy Server verwenden.  
  
 Wenn <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> `true` ist, wird bei Anforderungen an lokale Internetressourcen der Proxyserver nicht verwendet. Lokale Anforderungen werden durch den Mangel an einem Punkt (.) im URI, wie `http://webserver/`in, oder durch Zugriff auf den lokalen Server, einschließlich `http://localhost`, `http://loopback`oder `http://127.0.0.1`, identifiziert. Wenn <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> `false` ist, werden alle Internetanforderungen über den Proxyserver ausgeführt.  
  
> [!NOTE]
>  Anforderungen an einen lokalen Host mit einem URI, der einen Zeitraum enthält, verwenden den Proxy. Um die Verwendung eines Proxys in diesen Fällen zu vermeiden, erstellen Sie einen Eintrag <xref:System.Net.WebProxy.BypassList%2A>für den Host in der.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen eines Konstruktors veranschaulicht, der diese Eigenschaft festlegt und den Wert dieser Eigenschaft erhält.  
  
 [!code-cpp[NCLWebProxy#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#7)]
 [!code-csharp[NCLWebProxy#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultProxy">
      <MemberSignature Language="C#" Value="public static System.Net.IWebProxy CreateDefaultProxy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IWebProxy CreateDefaultProxy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.CreateDefaultProxy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDefaultProxy () As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IWebProxy ^ CreateDefaultProxy();" />
      <MemberSignature Language="F#" Value="static member CreateDefaultProxy : unit -&gt; System.Net.IWebProxy" Usage="System.Net.WebProxy.CreateDefaultProxy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.WebProxy.Credentials" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Net.IWebProxy.Credentials</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anmeldeinformationen ab oder legt diese fest, die an den Proxyserver zur Authentifizierung übermittelt werden sollen.</summary>
        <value>Eine <see cref="T:System.Net.ICredentials" />-Instanz mit den für die Authentifizierung an den Proxyserver zu übermittelnden Anmeldeinformationen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy.Credentials%2A> -Eigenschaft enthält die Anmelde Informationen für die Authentifizierung, die als Reaktion auf einen HTTP 407 (Proxy Authorization)-Statuscode an den Proxy Server gesendet werden sollen. In den meisten Client Szenarien sollten Sie den <xref:System.Net.CredentialCache.DefaultCredentials%2A>verwenden, bei dem es sich um die Anmelde Informationen des aktuell angemeldeten Benutzers handelt. Legen Sie hierzu die <xref:System.Net.WebProxy.UseDefaultCredentials%2A> -Eigenschaft auf `true` fest, anstatt diese Eigenschaft festzulegen.  
  
> [!NOTE]
>  <xref:System.Net.WebProxy.Credentials%2A> Wenn Sie die-Eigenschaft auf andere Anmelde Informationen <xref:System.Net.WebProxy.UseDefaultCredentials%2A> <xref:System.Net.CredentialCache.DefaultCredentials%2A>als festlegen, bewirkt das Festlegen `true` der- <xref:System.InvalidOperationException>Eigenschaft auf eine. Um dies zu verhindern, müssen Sie die <xref:System.Net.WebProxy.Credentials%2A> -Eigenschaft `null` auf festlegen, <xref:System.Net.WebProxy.UseDefaultCredentials%2A> bevor Sie `true`die-Eigenschaft auf festlegen. Ebenso können Sie diese Eigenschaft nicht auf einen beliebigen Wert festlegen <xref:System.Net.WebProxy.UseDefaultCredentials%2A> , `true`wenn den Wert hat.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Sie haben versucht, diese Eigenschaft festzulegen, obwohl die <see cref="P:System.Net.WebProxy.UseDefaultCredentials" />-Eigenschaft auf <see langword="true" /> festgelegt war.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProxy">
      <MemberSignature Language="C#" Value="public static System.Net.WebProxy GetDefaultProxy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.WebProxy GetDefaultProxy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.GetDefaultProxy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProxy () As WebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::WebProxy ^ GetDefaultProxy();" />
      <MemberSignature Language="F#" Value="static member GetDefaultProxy : unit -&gt; System.Net.WebProxy" Usage="System.Net.WebProxy.GetDefaultProxy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use the proxy selected for you by default. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use the proxy selected for you by default. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebProxy</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest die nicht dynamischen Proxyeinstellungen von Internet Explorer.</summary>
        <returns>Eine <see cref="T:System.Net.WebProxy" />-Instanz mit den nicht dynamischen Proxyeinstellungen von Internet Explorer 5.5 und höher.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy.GetDefaultProxy%2A> -Methode liest die nicht dynamischen Proxy Einstellungen, die von Internet Explorer 5,5 und höher gespeichert werden <xref:System.Net.WebProxy> , und erstellt eine-Instanz mit diesen Einstellungen.  
  
 Von <xref:System.Net.WebProxy.GetDefaultProxy%2A> der-Methode werden keine dynamischen Einstellungen übernommen, die aus Skripts generiert werden, die von Internet Explorer, von automatischen Konfigurations Einträgen oder von DHCP-oder DNS-Lookups ausgeführt werden.  
  
 Anwendungen sollten die <xref:System.Net.WebRequest.DefaultWebProxy%2A?displayProperty=nameWithType> -Eigenschaft und die <xref:System.Net.WebRequest.GetSystemWebProxy%2A?displayProperty=nameWithType> -Methode anstelle <xref:System.Net.WebProxy.GetDefaultProxy%2A> der-Methode verwenden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieser Methode veranschaulicht.  
  
 [!code-cpp[NCLWebProxy#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#11)]
 [!code-csharp[NCLWebProxy#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#11)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">für den uneingeschränkten Zugriff auf Netzwerkressourcen. Zugehörige Enumeration <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />:.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="webProxy.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Die mit Daten zu füllende <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="streamingContext">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />, der das Ziel für diese Serialisierung angibt.</param>
        <summary>Füllt eine <see cref="T:System.Runtime.Serialization.SerializationInfo" /> mit den Daten auf, die zum Serialisieren des Zielobjekts erforderlich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle in <xref:System.Runtime.Serialization.SerializationInfo> enthaltenen Objekte werden vom Formatierer automatisch nachverfolgt und serialisiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProxy">
      <MemberSignature Language="C#" Value="public Uri GetProxy (Uri destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Uri GetProxy(class System.Uri destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.GetProxy(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProxy (destination As Uri) As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Uri ^ GetProxy(Uri ^ destination);" />
      <MemberSignature Language="F#" Value="abstract member GetProxy : Uri -&gt; Uri&#xA;override this.GetProxy : Uri -&gt; Uri" Usage="webProxy.GetProxy destination" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Net.IWebProxy.GetProxy(System.Uri)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="destination">Die <see cref="T:System.Uri" />-Instanz der angeforderten Internetressource.</param>
        <summary>Gibt den Proxy-URI einer Anforderung zurück.</summary>
        <returns>Die <see cref="T:System.Uri" />-Instanz der Internetressource, wenn die Ressource in der Umgehungsliste aufgeführt ist, andernfalls die <see cref="T:System.Uri" />-Instanz des Proxys.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy.GetProxy%2A> -Methode gibt den URI zurück <xref:System.Net.WebRequest> , den die-Instanz für den Zugriff auf die Internet Ressource verwendet.  
  
 <xref:System.Net.WebProxy.GetProxy%2A>vergleicht `destination` mit dem Inhalt von <xref:System.Net.WebProxy.BypassList%2A>mithilfe der <xref:System.Net.WebProxy.IsBypassed%2A> -Methode. Wenn <xref:System.Net.WebProxy.IsBypassed%2A> zurück `true`gibt <xref:System.Net.WebProxy.GetProxy%2A> , gibt zurück `destination` , und die <xref:System.Net.WebRequest> -Instanz verwendet nicht den Proxy Server.  
  
 Wenn `destination` nicht in <xref:System.Net.WebProxy.BypassList%2A>ist, verwendet <xref:System.Net.WebRequest> die-Instanz den Proxy Server, <xref:System.Net.WebProxy.Address%2A> und die-Eigenschaft wird zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Net.WebProxy> -Objekt erstellt und diese Methode aufgerufen, um den für eine Ressource ausgewählten Proxy zu erhalten.  
  
 [!code-cpp[NCLAutoProxy#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLAutoProxy/CPP/proxy.cpp#2)]
 [!code-csharp[NCLAutoProxy#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAutoProxy/CS/proxy.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destination" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsBypassed">
      <MemberSignature Language="C#" Value="public bool IsBypassed (Uri host);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsBypassed(class System.Uri host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.IsBypassed(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsBypassed (host As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsBypassed(Uri ^ host);" />
      <MemberSignature Language="F#" Value="abstract member IsBypassed : Uri -&gt; bool&#xA;override this.IsBypassed : Uri -&gt; bool" Usage="webProxy.IsBypassed host" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Net.IWebProxy.IsBypassed(System.Uri)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="host">Die <see cref="T:System.Uri" />-Instanz des Hosts, der auf eine Proxyverwendung überprüft werden soll.</param>
        <summary>Gibt an, ob der Proxyserver für den angegebenen Host verwendet werden soll.</summary>
        <returns><see langword="true" />, wenn der Proxyserver nicht für <paramref name="host" /> verwendet werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.WebProxy.IsBypassed%2A> -Methode wird verwendet, um zu bestimmen, ob der Proxy Server beim Zugriff auf eine Internet Ressource umgangen werden soll.  
  
 Die <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> - <xref:System.Net.WebProxy.BypassList%2A> Eigenschaft und die-Eigenschaft steuern <xref:System.Net.WebProxy.IsBypassed%2A> den Rückgabewert der-Methode.  
  
 <xref:System.Net.WebProxy.IsBypassed%2A>gibt `true` unter den folgenden Bedingungen zurück:  
  
-   Wenn <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> ist `true` und`host` ein lokaler URI ist. Lokale Anforderungen werden durch das Fehlen eines Zeitraums (.) im URI identifiziert, wie in `http://webserver/`.  
  
-   , `host` Wenn einem regulären Ausdruck in <xref:System.Net.WebProxy.BypassList%2A>entspricht.  
  
-   Wenn <xref:System.Net.WebProxy.Address%2A> gleich `null` ist.  
  
 Alle anderen Bedingungen geben `false`zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Net.WebProxy> -Objekt erstellt und diese Methode aufgerufen, um zu überprüfen, ob die Umgehungs Liste ordnungsgemäß festgelegt ist.  
  
 [!code-cpp[NCLWebProxy#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#12)]
 [!code-csharp[NCLWebProxy#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="host" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Das mit Daten aufzufüllende <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt.</param>
        <param name="streamingContext">Eine <see cref="T:System.Runtime.Serialization.StreamingContext" />-Struktur, die das Ziel für diese Serialisierung angibt.</param>
        <summary>Erstellt die Serialisierungsdaten und den Serialisierungskontext, die vom System zum Serialisieren eines <see cref="T:System.Net.WebProxy" />-Objekts verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das System ruft diese Methode auf, um ein Objekt zu serialisieren. Anwendungen werden nicht direkt aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.WebProxy.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der steuert, ob mit den Anforderungen <see cref="P:System.Net.CredentialCache.DefaultCredentials" /> gesendet werden, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Standardanmeldeinformationen verwendet werden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft `true` auf fest, wenn Anforderungen <xref:System.Net.WebProxy> , die von diesem Objekt angefordert werden, mithilfe der Anmelde Informationen des aktuell angemeldeten Benutzers authentifiziert werden sollen. Bei Client Anwendungen ist dies das gewünschte Verhalten in den meisten Szenarien. Für Anwendungen der mittleren Ebene, z. b. ASP.NET-Anwendungen, würden Sie die <xref:System.Net.WebProxy.Credentials%2A> -Eigenschaft in der Regel auf die Anmelde Informationen des Clients festlegen, für den die Anforderung erfolgt ist, anstatt diese Eigenschaft zu verwenden.  
  
 In der folgenden Tabelle werden die Auswirkungen der fest <xref:System.Net.WebProxy.UseDefaultCredentials%2A> legung des-Werts basierend auf dem Wert <xref:System.Net.WebProxy.Credentials%2A> der-Eigenschaft veranschaulicht.  
  
|<xref:System.Net.WebProxy.Credentials%2A>-Wert|<xref:System.Net.WebProxy.UseDefaultCredentials%2A>-Wert|Effekt|  
|----------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|------------|  
|<xref:System.Net.CredentialCache.DefaultCredentials%2A>|`true`|Keine Auswirkung.|  
|<xref:System.Net.CredentialCache.DefaultCredentials%2A>|`false`|Für <xref:System.Net.WebProxy.Credentials%2A> ist `null` festgelegt.|  
|`null`|`true`|Für <xref:System.Net.WebProxy.Credentials%2A> ist <xref:System.Net.CredentialCache.DefaultCredentials%2A> festgelegt.|  
|Ein anderer Wert als <xref:System.Net.CredentialCache.DefaultCredentials%2A> oder`null`|`true` oder `false`|Durch <xref:System.Net.WebProxy.UseDefaultCredentials%2A> die Einstellung wird eine Ausnahme ausgelöst.|  
  
 Wenn <xref:System.Net.WebProxy.UseDefaultCredentials%2A>den Wert <xref:System.Net.WebProxy.Credentials%2A> hat, können Sie die-Eigenschaft in beliebige Anmelde Informationen ändern. `false` Wenn <xref:System.Net.WebProxy.UseDefaultCredentials%2A> ist <xref:System.Net.CredentialCache.DefaultCredentials%2A> <xref:System.Net.WebProxy.Credentials%2A> <xref:System.Net.WebProxy.UseDefaultCredentials%2A> `true`, wird durch Ändern der-Eigenschaft von (der Wert, der festgelegt wird, wenn die-Eigenschaft auf festgelegt ist) eine Ausnahme ausgelöst. `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Sie haben versucht, diese Eigenschaft festzulegen, obwohl die <see cref="P:System.Net.WebProxy.Credentials" />-Eigenschaft andere Anmeldeinformationen als die Standardanmeldeinformationen enthält.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
