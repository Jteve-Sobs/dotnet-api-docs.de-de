<Type Name="HttpListenerPrefixCollection" FullName="System.Net.HttpListenerPrefixCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f94b2fb81a6abe5db8184e06c36031e71f18ea07" /><Meta Name="ms.sourcegitcommit" Value="ddce15914650a504a7399d539ac1f7cfed3c2caa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="06/07/2019" /><Meta Name="ms.locfileid" Value="66759231" /></Metadata><TypeSignature Language="C#" Value="public class HttpListenerPrefixCollection : System.Collections.Generic.ICollection&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;string&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit HttpListenerPrefixCollection extends System.Object implements class System.Collections.Generic.ICollection`1&lt;string&gt;, class System.Collections.Generic.IEnumerable`1&lt;string&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListenerPrefixCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpListenerPrefixCollection&#xA;Implements ICollection(Of String), IEnumerable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListenerPrefixCollection : System::Collections::Generic::ICollection&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;System::String ^&gt;" />
  <TypeSignature Language="F#" Value="type HttpListenerPrefixCollection = class&#xA;    interface ICollection&lt;string&gt;&#xA;    interface seq&lt;string&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt die Auflistung dar, in der URI-Präfixe (Uniform Resource Identifier) für <see cref="T:System.Net.HttpListener" />-Objekte gespeichert werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListener.Prefixes%2A> Eigenschaft gibt Instanzen dieser Auflistung zurück.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein <xref:System.Net.HttpListener> und fügt benutzerdefinierte Präfixe für die <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string uriPrefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(string uriPrefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Add(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (uriPrefix As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::String ^ uriPrefix);" />
      <MemberSignature Language="F#" Value="abstract member Add : string -&gt; unit&#xA;override this.Add : string -&gt; unit" Usage="httpListenerPrefixCollection.Add uriPrefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriPrefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriPrefix">Eine <see cref="T:System.String" />, die die URI-Informationen identifiziert, die in eingehenden Anforderungen verglichen werden. Das Präfix muss mit einem Schrägstrich ("/") beendet werden.</param>
        <summary>Fügt der Sammlung ein Uniform Resource Identifier-Präfix (URI) hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt ein URI-Präfix auf den Satz von Präfixen, die von der zugeordneten verwalteten <xref:System.Net.HttpListener> Objekt. Bei der Überprüfung `uriPrefix` um sicherzustellen, dass es ist zulässig, die Groß-/Kleinschreibung ignoriert wird.  
  
 Eine URI-Präfix-Zeichenfolge besteht aus einem Schema (http oder Https), einem Host, einem optionalen Port und einen optionalen Pfad, z. B. "`http://www.contoso.com:8080/customerData/`". Das Präfix muss mit einem Schrägstrich ("/") beendet werden. Die <xref:System.Net.HttpListener> mit dem Präfix, das einen angeforderten URI am ehesten entspricht antwortet auf die Anforderung. Mehrere <xref:System.Net.HttpListener> Objekte können nicht das gleiche Präfix hinzugefügt. Ein <xref:System.Net.HttpListenerException> Ausnahme wird ausgelöst, wenn ein <xref:System.Net.HttpListener> hinzufügt, verwenden Sie ein Präfix, das bereits vorhanden ist.  
  
 Wenn ein Port angegeben ist, kann das Hostelement ersetzt werden, mit "`*`" gibt an, dass die <xref:System.Net.HttpListener> akzeptiert Anforderungen an den Port gesendet werden, wenn der angeforderte URI nicht mit einem anderen Präfix übereinstimmt. Beispielsweise erhalten Sie alle Anforderungen gesendet an Port 8080, wenn der angeforderte URI nicht durch einen anderen behandelt <xref:System.Net.HttpListener>, das Präfix ist "`http://*:8080/`". Auf ähnliche Weise an, dass die <xref:System.Net.HttpListener> akzeptiert alle Anforderungen an einen Port gesendet ersetzen Sie das Hostelement mit der "`+`'Character',`https://+:8080/`". Die "`*`"und"`+`" Zeichen in der Präfixe, die Pfade enthalten vorhanden sein können.  
  
 Ab .NET 4.5.3 und Windows 10, werden Platzhalter Unterdomänen in URI-Präfixe, die von verwaltet werden unterstützt eine <xref:System.Net.HttpListener> Objekt. Um eine Unterdomäne Platzhalter anzugeben, verwenden die "\*"-Zeichen als Teil des Hostnamens in eine URI-Präfix: z. B. `http://*.foo.com/`, und dies als Argument an die HttpListenerPrefixCollection.Add-Methode übergeben. Dies funktioniert auf .NET 4.5.3 und Windows 10; in früheren Versionen, erzeugt dies einen <xref:System.Net.HttpListenerException>  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein <xref:System.Net.HttpListener> und fügt benutzerdefinierte Präfixe für die <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriPrefix" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="uriPrefix" /> verwendet nicht das Schema „http://“ oder „https://“. Dies sind die einzigen für <see cref="T:System.Net.HttpListener" />-Objekte unterstützten Schemas.  
  
- oder - 
 <paramref name="uriPrefix" /> ist kein ordnungsgemäß formatiertes URI-Präfix. Stellen Sie sicher, dass die Zeichenfolge mit einem "/" beendet wird.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.HttpListener" />, der dieser Sammlung zugeordnet ist, ist geschlossen.</exception>
        <exception cref="T:System.Net.HttpListenerException">Bei einem Windows-Funktionsaufruf ist ein Fehler aufgetreten. Überprüfen Sie die <see cref="P:System.Net.HttpListenerException.ErrorCode" />-Eigenschaft der Ausnahme, um die Ursache der Ausnahme zu bestimmen. Diese Ausnahme wird ausgelöst, wenn bereits ein anderer <see cref="T:System.Net.HttpListener" /> das <paramref name="uriPrefix" />-Präfix hinzugefügt hat.</exception>
        <permission cref="T:System.Net.WebPermission">Um Netzwerkverbindungen zu akzeptieren. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="httpListenerPrefixCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle URI-Präfixe aus der Auflistung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem Aufrufen dieser Methode kann nicht gestartet werden das zugeordnete <xref:System.Net.HttpListener> ohne neue Präfixe hinzuzufügen; Wenn Sie versuchen, zu diesem Zweck eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Codebeispiel entfernt alle Präfixe in einem <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#6)]  
 [!code-vb[Net_Listener_Basic#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Bei einem Windows-Funktionsaufruf ist ein Fehler aufgetreten. Überprüfen Sie die <see cref="P:System.Net.HttpListenerException.ErrorCode" />-Eigenschaft der Ausnahme, um die Ursache der Ausnahme zu bestimmen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.HttpListener" />, der dieser Sammlung zugeordnet ist, ist geschlossen.</exception>
        <block subset="none" type="usage"><para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string uriPrefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string uriPrefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (uriPrefix As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::String ^ uriPrefix);" />
      <MemberSignature Language="F#" Value="abstract member Contains : string -&gt; bool&#xA;override this.Contains : string -&gt; bool" Usage="httpListenerPrefixCollection.Contains uriPrefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriPrefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriPrefix">Ein <see cref="T:System.String" />, der das zu testende URI-Präfix enthält.</param>
        <summary>Gibt einen <see cref="T:System.Boolean" />-Wert zurück, der angibt, ob das angegebene Präfix in der Auflistung enthalten ist.</summary>
        <returns><see langword="true" />, wenn die Auflistung das durch <paramref name="uriPrefix" /> angegebene Präfix enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das angegebene Präfix muss einen vorhandenen Wert genau übereinstimmen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, ob einem Benutzer angegebenen Präfix, in der Präfix-Auflistung, der enthalten ist eine <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#4)]  
 [!code-vb[Net_Listener_Basic#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriPrefix" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert den Inhalt einer <see cref="T:System.Net.HttpListenerPrefixCollection" /> in das angegebene Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array muss Zeichenfolgen enthalten können, und kann nicht mehrdimensional sein.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, int offset);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int -&gt; unit" Usage="httpListenerPrefixCollection.CopyTo (array, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das die URI-Präfixzeichenfolgen in dieser Auflistung empfängt.</param>
        <param name="offset">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert den Inhalt einer <see cref="T:System.Net.HttpListenerPrefixCollection" /> in das angegebene Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array muss Zeichenfolgen enthalten können, und kann nicht mehrdimensional sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird kopiert, die Präfixe in einem <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#7)]  
 [!code-vb[Net_Listener_Basic#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Diese Auflistung enthält mehr Elemente als in <paramref name="array" /> ab dem <paramref name="offset" /> gespeichert werden können.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.HttpListener" />, der dieser Sammlung zugeordnet ist, ist geschlossen.</exception>
        <exception cref="T:System.InvalidCastException">In <paramref name="array" /> können keine Zeichenfolgenwerte gespeichert werden.</exception>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (string[] array, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(string[] array, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.CopyTo(System.String[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As String(), offset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::String ^&gt; ^ array, int offset);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : string[] * int -&gt; unit&#xA;override this.CopyTo : string[] * int -&gt; unit" Usage="httpListenerPrefixCollection.CopyTo (array, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.String[]" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Zeichenfolgenarray, das die URI-Präfixzeichenfolgen in dieser Auflistung empfängt.</param>
        <param name="offset">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert den Inhalt einer <see cref="T:System.Net.HttpListenerPrefixCollection" /> in das angegebene Zeichenfolgenarray.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Array muss Zeichenfolgen enthalten können, und kann nicht mehrdimensional sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird kopiert, die Präfixe in einem <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#7)]  
 [!code-vb[Net_Listener_Basic#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Diese Auflistung enthält mehr Elemente als in <paramref name="array" /> ab dem <paramref name="offset" /> gespeichert werden können.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.HttpListener" />, der dieser Sammlung zugeordnet ist, ist geschlossen.</exception>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerPrefixCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Net.HttpListenerPrefixCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Präfixe in der Auflistung ab.</summary>
        <value>Ein <see cref="T:System.Int32" />-Typ, der die Anzahl der Präfixe in dieser Auflistung enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel zeigt die Präfixe in einer Auflistung.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;string&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;string&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;System::String ^&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;string&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;string&gt;" Usage="httpListenerPrefixCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Objekt zurück, das zum Durchlaufen der Auflistung verwendet werden kann.</summary>
        <returns>Ein Objekt, das die <see cref="T:System.Collections.IEnumerator" />-Schnittstelle implementiert und Zugriff auf die Zeichenfolgen in dieser Auflistung bereitstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Objekt, das von dieser Methode zurückgegeben wird, ist zunächst vor dem ersten Element in der Auflistung positioniert. Rufen Sie die <xref:System.Collections.IEnumerator.MoveNext%2A> -Methode auf, bevor Sie das erste Element zugreifen können. Wenn das Element an der aktuellen Position zugreifen zu können, rufen die <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft.  
  
 Ändern Sie die Auflistung bei der Verwendung des Enumerators nicht. Wenn die Auflistung geändert wird, während eines Enumerators verwenden, beim Festlegen der Position durch den Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> bewirkt, dass ein <xref:System.InvalidOperationException>.  
  
 Eine ausführliche Beschreibung der Enumeratoren, finden Sie in der Dokumentation für die <xref:System.Collections.IEnumerator> Klasse und die <xref:System.Collections.IEnumerable.GetEnumerator%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Enumeration einer Auflistung. Beachten Sie, dass die Visual Basic- und c#-Beispiele-spezifische Anweisungen verwenden, um das Durchlaufen der Auflistung anstatt durch Abrufen des Enumerators.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerPrefixCollection.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Net.HttpListenerPrefixCollection.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Auflistung schreibgeschützt ist.</summary>
        <value>Gibt immer <see langword="false" /> zurück.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerPrefixCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Net.HttpListenerPrefixCollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die Auflistung synchronisiert (threadsicher) ist.</summary>
        <value>Diese Eigenschaft gibt immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (string uriPrefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(string uriPrefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (uriPrefix As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::String ^ uriPrefix);" />
      <MemberSignature Language="F#" Value="abstract member Remove : string -&gt; bool&#xA;override this.Remove : string -&gt; bool" Usage="httpListenerPrefixCollection.Remove uriPrefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriPrefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriPrefix">Ein <see cref="T:System.String" />, der das zu entfernende URI-Präfix enthält.</param>
        <summary>Entfernt den angegebenen URI aus der Liste der Präfixe, die vom <see cref="T:System.Net.HttpListener" />-Objekt behandelt werden.</summary>
        <returns><see langword="true" />, wenn die <paramref name="uriPrefix" /> in der <see cref="T:System.Net.HttpListenerPrefixCollection" /> gefunden und entfernt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `uriPrefix` ist nicht in der Auflistung, diese Methode führt keine Aktion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriPrefix" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.HttpListenerException">Bei einem Windows-Funktionsaufruf ist ein Fehler aufgetreten. Überprüfen Sie den Fehlercode der Ausnahme, um die Ursache der Ausnahme zu bestimmen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.HttpListener" />, der dieser Sammlung zugeordnet ist, ist geschlossen.</exception>
        <block subset="none" type="usage"><para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Objekt zurück, das zum Durchlaufen der Auflistung verwendet werden kann.</summary>
        <returns>Ein Objekt, das die <see cref="T:System.Collections.IEnumerator" />-Schnittstelle implementiert und Zugriff auf die Zeichenfolgen in dieser Auflistung bereitstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Objekt, das von dieser Methode zurückgegeben wird, ist zunächst vor dem ersten Element in der Auflistung positioniert. Rufen Sie die <xref:System.Collections.IEnumerator.MoveNext%2A> -Methode auf, bevor Sie das erste Element zugreifen können. Wenn das Element an der aktuellen Position zugreifen zu können, rufen die <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft.  
  
 Ändern Sie die Auflistung bei der Verwendung des Enumerators nicht. Wenn die Auflistung geändert wird, während eines Enumerators verwenden, beim Festlegen der Position durch den Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> bewirkt, dass ein <xref:System.InvalidOperationException>.  
  
 Eine ausführliche Beschreibung der Enumeratoren, finden Sie in der Dokumentation für die <xref:System.Collections.IEnumerator> Klasse und die <xref:System.Collections.IEnumerable.GetEnumerator%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
  </Members>
</Type>