<Type Name="HttpListenerResponse" FullName="System.Net.HttpListenerResponse">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="17ff8da533be1a9f528162eedf37875667e00e57" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52245954" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpListenerResponse : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListenerResponse extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListenerResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListenerResponse&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListenerResponse sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type HttpListenerResponse = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Antwort auf eine Anforderung dar, die von einem <see cref="T:System.Net.HttpListener" />-Objekt behandelt wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Client eine Anforderung für eine Ressource wird behandelt, indem ein <xref:System.Net.HttpListener> Objekt ist, wird die Anforderung und Antwort stehen zu Ihrer Anwendung in eine <xref:System.Net.HttpListenerContext> Objekt. Die Anforderung wird durch dargestellt eine <xref:System.Net.HttpListenerRequest> Objekt aus, und finden Sie in der <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> Eigenschaft. Die Antwort wird dargestellt, indem ein <xref:System.Net.HttpListenerResponse> Objekt aus, und finden Sie in der <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Sie können die Antwort anpassen, indem Sie verschiedene Eigenschaften, z. B. festgelegt <xref:System.Net.HttpListenerResponse.StatusCode%2A>, <xref:System.Net.HttpListenerResponse.StatusDescription%2A>, und <xref:System.Net.HttpListenerResponse.Cookies%2A>. Verwenden der <xref:System.Net.HttpListenerResponse.OutputStream%2A?displayProperty=nameWithType> -Eigenschaft zum Abrufen einer <xref:System.IO.Stream> Instanz, die in der Antwort Daten geschrieben werden können. Senden Sie zum Schluss die Antwortdaten an den Client durch Aufrufen der <xref:System.Net.HttpListenerResponse.Close%2A> Methode.  
 
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.HttpListener" />
    <altmember cref="T:System.Net.HttpListenerContext" />
    <altmember cref="T:System.Net.HttpListenerRequest" />
  </Docs>
  <Members>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerResponse.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpListenerResponse.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die Verbindung mit dem Client, ohne eine Antwort zu senden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen dieser Methode für ein Objekt, das bereits geschlossen wurde, hat keine Auswirkungen. Wenn die Antwort nicht bereits geschlossen wurde, wird diese Methode schließt, sie und den zugehörigen <xref:System.Net.HttpListenerRequest> und <xref:System.Net.HttpListenerContext> Objekte. Die Verbindung an den Client ist auch geschlossen, unabhängig von der <xref:System.Net.HttpListenerRequest.KeepAlive%2A> Eigenschaftswert der Anforderung des Clients.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpListenerResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des festzulegenden HTTP-Headers.</param>
        <param name="value">Der Wert des <paramref name="name" />-Headers.</param>
        <summary>Fügt den HTTP-Headern für diese Antwort den angegebenen Header und Wert hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode entspricht dem Aufrufen der <xref:System.Net.WebHeaderCollection.Set%2A> Methode für die Sammlung von zurückgegebenen der <xref:System.Net.HttpListenerResponse.Headers%2A> Eigenschaft.  
  
 Wenn der Header in angegeben `name` ist nicht vorhanden, diese Methode fügt einen neuen Header in der <xref:System.Net.HttpListenerResponse.Headers%2A> der eigenschaftenauflistung. Wenn `name` befindet sich in der Auflistung, die diese Methode ersetzt den vorhandenen Wert durch `value`. Um einen Wert einem vorhandenen Header hinzuzufügen, ohne den vorhandenen Wert zu ersetzen, verwenden Sie die <xref:System.Net.HttpListenerResponse.AppendHeader%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Hinzufügen eines Headers, der mit dieser Eigenschaft.  
  
 [!code-csharp[Net_Listener_Basic#26](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" /> oder eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.ArgumentException">Sie sind nicht berechtigt, einen Wert für den angegebenen Header anzugeben.  
  
- oder -  
 <paramref name="name" /> oder <paramref name="value" /> enthält ungültige Zeichen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> ist länger als 65.535 Zeichen.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
        <altmember cref="T:System.Net.WebHeaderCollection" />
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Net.Cookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Net.Cookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerResponse.AppendCookie(System.Net.Cookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Net::Cookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Net.Cookie -&gt; unit" Usage="httpListenerResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Net.Cookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Das <see cref="T:System.Net.Cookie" />, das der Sammlung hinzugefügt werden soll, die mit dieser Antwort gesendet werden soll.</param>
        <summary>Fügt das angegebene <see cref="T:System.Net.Cookie" /> zur Sammlung von Cookies für diese Antwort hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode entspricht dem Aufrufen der <xref:System.Net.CookieCollection.Add%2A> Methode für die Sammlung von zurückgegebenen der <xref:System.Net.HttpListenerResponse.Cookies%2A> Eigenschaft.  
  
 Wenn das angegebene Cookie nicht, in vorhanden ist der <xref:System.Net.HttpListenerResponse.Cookies%2A> die eigenschaftenauflistung `cookie` hinzugefügt wird. Wenn das Cookie in der Auflistung vorhanden ist `cookie` ersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, eine Antwort einen Cookie hinzugefügt  
  
 [!code-csharp[Net_Listener_Basic#20](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cookie" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpListenerResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des HTTP-Headers, an den <paramref name="value" /> angefügt werden soll.</param>
        <param name="value">Der Wert, der an den <paramref name="name" />-Header angefügt werden soll.</param>
        <summary>Fügt an den angegebenen HTTP-Header, der mit der Antwort gesendet werden soll, einen Wert an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode entspricht dem Aufrufen der <xref:System.Net.WebHeaderCollection.Add%2A> Methode für die Sammlung von zurückgegebenen der <xref:System.Net.HttpListenerResponse.Headers%2A> Eigenschaft.  
  
 Wenn der Header in angegeben `header` ist nicht vorhanden, diese Methode fügt einen neuen Header in der <xref:System.Net.HttpListenerResponse.Headers%2A> der eigenschaftenauflistung. Wenn `header` in der Auflistung vorhanden ist diese Methode fügt `value` an die vorhandenen Werte. Um den Wert des vorhandenen Headers ersetzen möchten, verwenden die <xref:System.Net.HttpListenerResponse.AddHeader%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> ist <see langword="null" /> oder eine leere Zeichenfolge ("").  
  
- oder -  
Sie sind nicht berechtigt, einen Wert für den angegebenen Header anzugeben.  
  
- oder -  
 <paramref name="name" /> oder <paramref name="value" /> enthält ungültige Zeichen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> ist länger als 65.535 Zeichen.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet die Antwort an den Client und gibt die für diese <see cref="T:System.Net.HttpListenerResponse" />-Instanz reservierten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpListenerResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sendet die Antwort an den Client und gibt die für diese <see cref="T:System.Net.HttpListenerResponse" />-Instanz reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode schließt den Antwortstream und <xref:System.Net.HttpListenerRequest> der Antwort zugeordnet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Aufrufen dieser Methode zum Senden einer <xref:System.Net.HttpStatusCode.Forbidden> (403) Antwort an den Client.  
  
 [!code-csharp[NclListener#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#5)]
 [!code-vb[NclListener#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (byte[] responseEntity, bool willBlock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(unsigned int8[] responseEntity, bool willBlock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerResponse.Close(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (responseEntity As Byte(), willBlock As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(cli::array &lt;System::Byte&gt; ^ responseEntity, bool willBlock);" />
      <MemberSignature Language="F#" Value="member this.Close : byte[] * bool -&gt; unit" Usage="httpListenerResponse.Close (responseEntity, willBlock)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="responseEntity" Type="System.Byte[]" />
        <Parameter Name="willBlock" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="responseEntity">Ein <see cref="T:System.Byte" />-Array, das die an den Client zu sendende Antwort enthält.</param>
        <param name="willBlock">
          <see langword="true" />, um die Ausführung zu blockieren, während der Stream an den Client ausgegeben wird, andernfalls <see langword="false" />.</param>
        <summary>Gibt das angegebene Bytearray an den Client zurück und gibt die für diese <see cref="T:System.Net.HttpListenerResponse" />-Instanz reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie Textdaten der Antwort senden, können Sie diese Methode verwenden, zum Senden als eine <xref:System.Byte> Array anstelle von Daten in der Nachricht zum Schreiben der <xref:System.Net.HttpListenerResponse.OutputStream%2A> -Eigenschaft ab, und rufen die <xref:System.Net.HttpListenerResponse.Close%2A> Methode.  
  
 Diese Methode schließt den Antwortstream und <xref:System.Net.HttpListenerRequest> der Antwort zugeordnet.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Aufrufen dieser Methode.  
  
 [!code-csharp[Net_Listener_Basic#24](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="responseEntity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Net.HttpListenerResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Text.Encoding" /> für den <see cref="P:System.Net.HttpListenerResponse.OutputStream" /> der Antwort ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Text.Encoding" />-Objekt, das mit den Daten in der <see cref="P:System.Net.HttpListenerResponse.OutputStream" />-Eigenschaft verwendet werden kann, oder <see langword="null" />, wenn keine Codierung angegeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Text.Encoding> Objekt kann verwendet werden, um Bytesequenzen in Zeichensätzen (Codepages) und die Zeichen in Bytesequenzen zu konvertieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht die Verwendung dieser Eigenschaft.  
  
 [!code-csharp[NclListener#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#5)]
 [!code-vb[NclListener#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength64">
      <MemberSignature Language="C#" Value="public long ContentLength64 { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength64" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerResponse.ContentLength64" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentLength64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ContentLength64 { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength64 : int64 with get, set" Usage="System.Net.HttpListenerResponse.ContentLength64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Bytes in den in der Antwort enthaltenen Textdaten ab oder legt diese fest.</summary>
        <value>Der Wert des <see langword="Content-Length" />-Headers der Antwort.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Content-Length` -Header gibt die Länge in Bytes, der Textdaten der Antwort. Wenn unter Verwendung eines Formats, die keine Daten sendet segmentiert oder raw, müssen Sie festlegen, die <xref:System.Net.HttpListenerResponse.ContentLength64%2A> Eigenschaft. Wenn Sie nicht, führen Sie die <xref:System.Net.HttpListener> sendet die Antwortdaten nicht.  
  
 Eine vollständige Liste der Antwortheader, finden Sie unter den <xref:System.Net.HttpResponseHeader> Enumeration.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen des Werts dieser Eigenschaft.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen set-Vorgang angegebene Wert ist kleiner als 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Die Antwort wird bereits gesendet.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpListenerResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den MIME-Typ des zurückgegebenen Inhalts ab oder legt diesen fest.</summary>
        <value>Eine <see cref="T:System.String" />-Instanz, die den Text des <see langword="Content-Type" />-Headers der Antwort enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Kommunikation mit einem Webbrowser sollten explizit festlegen dieser Eigenschaft bei der jedes Inhaltstyps als Rückgabe `text/html`.  
  
 Eine vollständige Liste der Antwortheader, finden Sie unter den <xref:System.Net.HttpResponseHeader> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der für einen SET-Vorgang festgelegte Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für einen set-Vorgang angegebene Wert ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Net.CookieCollection Cookies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public Property Cookies As CookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::CookieCollection ^ Cookies { System::Net::CookieCollection ^ get(); void set(System::Net::CookieCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Net.CookieCollection with get, set" Usage="System.Net.HttpListenerResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der mit der Antwort zurückgegebenen Cookies ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Net.CookieCollection" /> mit den Cookies, die mit der Antwort gesendet werden. Die Auflistung ist leer, wenn der Antwort keine Cookies hinzugefügt wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Cookie ist Name/Wert-Text-Daten von einem Webserver, der auf dem Computer lokalen (Client-) gespeichert sind. Die folgenden Cookieformate werden unterstützt: Netscape, RFC 2109 und RFC 2965. Die Netscape-Cookie-Spezifikation finden Sie unter http://wp.netscape.com/newsref/std/cookie_spec.html; die RFC-Dokumente finden Sie unter [ https://www.rfc-editor.org/ ](https://www.rfc-editor.org/).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Anforderung für ein Cookie überprüft und ein neues Cookie mit der Antwort zurückgegeben, wenn die Anforderung kein Zertifikat haben.  
  
 [!code-csharp[Net_Listener_Basic#20](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="CopyFrom">
      <MemberSignature Language="C#" Value="public void CopyFrom (System.Net.HttpListenerResponse templateResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFrom(class System.Net.HttpListenerResponse templateResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerResponse.CopyFrom(System.Net.HttpListenerResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFrom (templateResponse As HttpListenerResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFrom(System::Net::HttpListenerResponse ^ templateResponse);" />
      <MemberSignature Language="F#" Value="member this.CopyFrom : System.Net.HttpListenerResponse -&gt; unit" Usage="httpListenerResponse.CopyFrom templateResponse" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templateResponse" Type="System.Net.HttpListenerResponse" />
      </Parameters>
      <Docs>
        <param name="templateResponse">Die zu kopierende <see cref="T:System.Net.HttpListenerResponse" />-Instanz.</param>
        <summary>Kopiert Eigenschaften aus der angegebenen <see cref="T:System.Net.HttpListenerResponse" /> in diese Antwort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie regelmäßig viele Eigenschaften die Standardwerte auf einen festen Satz von neuen Werten ändern, ist es praktisch, verwenden eine <xref:System.Net.HttpListenerResponse> Instanz als Vorlage. Passen Sie die Vorlagenantwort einmal und, anstatt jede Antwort separat zu konfigurieren, rufen Sie die <xref:System.Net.HttpListenerResponse.CopyFrom%2A> Methode so konfigurieren Sie eine neue Antwort auf der Grundlage von Eigenschaftswerten in der Vorlagenantwort.  
  
 Die folgenden Eigenschaften werden von kopiert `templateResponse` mit der aktuellen Instanz.  
  
-   <xref:System.Net.HttpListenerResponse.Headers%2A>  
  
-   <xref:System.Net.HttpListenerResponse.ContentLength64%2A>  
  
-   <xref:System.Net.HttpListenerResponse.StatusCode%2A>  
  
-   <xref:System.Net.HttpListenerResponse.StatusDescription%2A>  
  
-   <xref:System.Net.HttpListenerResponse.KeepAlive%2A>  
  
-   <xref:System.Net.HttpListenerResponse.ProtocolVersion%2A>  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Erstellen einer Antwort durch Kopieren einer Vorlagenantwort.  
  
 [!code-csharp[NCLListener#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#5)]
 [!code-vb[NCLListener#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpListenerResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung der vom Server zurückgegebenen Name-Wert-Paare für Header ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Net.WebHeaderCollection" />-Instanz, die alle explizit festgelegten HTTP-Header enthält, die in der Antwort enthalten sein sollen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antwortheader enthalten Metadaten wie z. B. das Datum und Uhrzeit der Antwort, die Identität der antwortende Server und den MIME-Typ der Daten, die im Antworttext.  
  
 Eine vollständige Liste der Antwortheader, finden Sie unter den <xref:System.Net.HttpResponseHeader> Enumeration.  
  
> [!NOTE]
>  Wenn Sie versuchen, legen Sie einen Content-Length-Keep-Alive "," Transfer-Encoding- oder WWW-Authenticate-Header, die mithilfe der Header-Eigenschaft, eine Ausnahme ausgelöst. Verwenden der <xref:System.Net.HttpListenerResponse.KeepAlive%2A> oder <xref:System.Net.HttpListenerResponse.ContentLength64%2A> Eigenschaften, die diese Header festgelegt. Sie können nicht manuell der Transfer-Encoding oder WWW-Authenticate-Header festlegen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Anzeigen der Header in einer <xref:System.Net.WebHeaderCollection>.  
  
 [!code-csharp[Net_Listener_Basic#23](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die für einen set-Vorgang angegebene <see cref="T:System.Net.WebHeaderCollection" />-Instanz ist für eine Antwort nicht gültig.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerResponse.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpListenerResponse.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Server eine permanente Verbindung anfordert, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Server eine permanente Verbindung anfordert, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein HTTP-Client und Server erwarten mehrmals innerhalb eines kurzen Zeitraums Datenaustausch, beschleunigt eine permanente Verbindung deren Kommunikation durch, sodass sie zur Vermeidung des Mehraufwands für das Öffnen und schließen eine TCP-Verbindung für jede Nachricht. Permanente Verbindungen sind weit verbreitete verwendet bei der Kommunikation zwischen der modernen Webbrowsern und Webservern.  
  
 Permanente Verbindungen werden in der HTTP/1.1-Protokollspezifikation (RFC 2616) auf die RTF-Editor-Website ausführlich beschrieben ([https://www.rfc-editor.org/](https://www.rfc-editor.org/)).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen des Werts dieser Eigenschaft.  
  
 [!code-csharp[NclListener#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#7)]
 [!code-vb[NclListener#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Net.HttpListenerResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.IO.Stream" />-Objekt ab, in das eine Antwort geschrieben werden kann.</summary>
        <value>Ein <see cref="T:System.IO.Stream" />-Objekt, in das eine Antwort geschrieben werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListenerResponse.ContentLength64%2A> Eigenschaft muss explizit festgelegt werden, vor dem Schreiben auf das zurückgegebene <xref:System.IO.Stream> Objekt.  
  
> [!NOTE]
>  Schließen die Anforderung wird von dieser Eigenschaft zurückgegebenen Datenstrom nicht geschlossen werden. Wenn Sie den Stream nicht mehr benötigen, sollten Sie es schließen, durch den Aufruf der Close-Methode.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Aufrufen dieser Methode.  
  
 [!code-csharp[Net_Listener_Basic#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerResponse.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpListenerResponse.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für die Antwort verwendete HTTP-Version ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Version" />-Objekt, das die für die Antwort an den Client verwendete HTTP-Version angibt. Beachten Sie, dass diese Eigenschaft jetzt veraltet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionen anderer HTTP-Versionen werden angegeben, in den Dokumenten, die unter [ https://www.ietf.org ](https://www.ietf.org).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen des Werts dieser Eigenschaft.  
  
 [!code-csharp[NclListener#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#5)]
 [!code-vb[NclListener#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der für einen SET-Vorgang festgelegte Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Version.Major" />-Eigenschaft des für einen set-Vorgang angegebenen Werts ist nicht auf 1 festgelegt, oder die <see cref="P:System.Version.Minor" />-Eigenschaft des Werts ist nicht auf 0 oder 1 festgelegt.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpListenerResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Die URL, die der Client zum Suchen der angeforderten Ressource verwenden soll.</param>
        <summary>Konfiguriert die Antwort für die Weiterleitung des Clients zur angegebenen URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListenerResponse.Redirect%2A> Methode wird verwendet, um einen Client an den neuen Speicherort für eine Ressource weiterzuleiten. Diese Methode legt fest, der Antwort `Location` Header `url`, wird die <xref:System.Net.HttpListenerResponse.StatusCode%2A> Eigenschaft <xref:System.Net.HttpStatusCode.Redirect>, und die <xref:System.Net.HttpListenerResponse.StatusDescription%2A> Eigenschaft "Gefunden".  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Aufrufen dieser Methode.  
  
 [!code-csharp[Net_Listener_Basic#27](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#27)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Net.HttpListenerResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des HTTP-<see langword="Location" />-Headers in der Antwort ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.String" />, der die absolute URL enthält, die im <see langword="Location" />-Header an den Client gesendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Location` -Header gibt die URL, zu dem der Client geleitet wird, um eine angeforderte Ressource zu suchen.  
  
> [!NOTE]
>  Diese Eigenschaft nicht automatisch festgelegt wird. die Einstellung der <xref:System.Net.HttpListenerResponse.StatusCode%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen dieser Eigenschaft.  
  
 [!code-csharp[Net_Listener_Basic#25](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der für einen set-Vorgang angegebene Wert ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerResponse.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpListenerResponse.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob für die Antwort segmentierte Übertragungscodierung verwendet wird.</summary>
        <value>
          <see langword="true" />, wenn für die Antwort die Verwendung segmentierter Übertragungscodierung festgelegt ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Text, der eine segmentierte Nachricht besteht aus einer Reihe von Blöcken. Jeder Block besteht aus zwei Teilen – die Größe der Block Daten und die tatsächlichen Daten. Bei Festlegung auf true fest, die Antwort gesendet werden mithilfe der aufgeteilten übertragungscodierung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Net.Cookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Net.Cookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerResponse.SetCookie(System.Net.Cookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Net::Cookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Net.Cookie -&gt; unit" Usage="httpListenerResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Net.Cookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Ein <see cref="T:System.Net.Cookie" /> für diese Antwort.</param>
        <summary>Fügt der Auflistung von mit dieser Antwort gesendeten Cookies ein <see cref="T:System.Net.Cookie" /> hinzu oder aktualisiert dieses in der Auflistung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Cookies gelten dieselbe, wenn die Werte ihrer <xref:System.Net.Cookie.Name%2A>, <xref:System.Net.Cookie.Domain%2A>, und <xref:System.Net.Cookie.Path%2A> Eigenschaften entsprechen. Wenn diese drei Arten von Informationen identisch sind, versucht die Methode, um das Cookie zu aktualisieren. Vergleiche und der Domäne sind nicht in der Groß-/Kleinschreibung beachtet, aber die pfadvergleich wird die Groß-/Kleinschreibung beachtet.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Aufrufen dieser Methode.  
  
 [!code-csharp[Net_Listener_Basic#28](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cookie" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das Cookie ist bereits in der Auflistung vorhanden und konnte nicht ersetzt werden.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Net.HttpListenerResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den an den Client zurückzugebenden HTTP-Statuscode ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Int32" />-Wert, der den HTTP-Statuscode für die angeforderte Ressource angibt. Der Standardwert ist <see cref="F:System.Net.HttpStatusCode.OK" /> und gibt an, dass der Server die Anforderung des Clients erfolgreich verarbeitet und die angeforderte Ressource in den Antworttext eingefügt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Clients verwenden den vom Server zurückgegebenen Statuscode zu um entscheiden, wie ein, um den Vorgang fortzusetzen. Der Wert <xref:System.Net.HttpStatusCode.OK> gibt an, dass der Server erfolgreich die Anforderung des Clients verarbeitet und die angeforderte Ressource im Antworttext enthalten. Andere häufig verwendete Statuscodes sind <xref:System.Net.HttpStatusCode.NotFound>, der angibt, die die angeforderte Ressource nicht, auf dem Server gefunden wurde und <xref:System.Net.HttpStatusCode.NotModified>, gibt an, dass die angeforderte Ressource im Antworttext zurückgegeben werden, da es sich bei dem Zwischenspeicher Kopie des Clients nicht erforderlich war die Ressource ist auf dem neuesten Stand.  
  
 Eine vollständige Liste der möglichen Statuscodes, finden Sie unter den <xref:System.Net.HttpStatusCode> Enumeration.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen des Werts dieser Eigenschaft.  
  
 [!code-csharp[Net_Listener_Basic#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">Der für einen set-Vorgang angegebene Wert ist ungültig. Gültige Werte liegen zwischen 100 und einschließlich 999.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Net.HttpListenerResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Textbeschreibung des an den Client zurückgegebenen HTTP-Statuscodes ab oder legt diese fest.</summary>
        <value>Die Textbeschreibung des an den Client zurückgegebenen HTTP-Statuscodes. Der Standardwert ist die RFC 2616-Beschreibung des <see cref="P:System.Net.HttpListenerResponse.StatusCode" />-Eigenschaftswerts oder eine leere Zeichenfolge (""), falls keine RFC 2616-Beschreibung vorhanden ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statusbeschreibung enthält in der Regel Details, die erläutern, die <xref:System.Net.HttpListenerResponse.StatusCode%2A> Wert.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen des Werts dieser Eigenschaft.  
  
 [!code-csharp[NclListener#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#7)]
 [!code-vb[NclListener#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der für einen SET-Vorgang festgelegte Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der für einen set-Vorgang angegebene Wert enthält nicht druckbare Zeichen.</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerResponse.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom <see cref="T:System.Net.HttpListenerResponse" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Net.HttpListenerResponse.Close%2A> Methode, um die Antwort zu senden und Freigeben von Ressourcen frei, die eine <xref:System.Net.HttpListenerResponse>. Verwenden Sie zum Verwerfen der Antwort und die Ressourcen frei, die von dieser Instanz, die <xref:System.Net.HttpListenerResponse.Abort%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerRequest" />
      </Docs>
    </Member>
  </Members>
</Type>