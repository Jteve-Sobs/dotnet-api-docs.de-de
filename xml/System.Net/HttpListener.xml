<Type Name="HttpListener" FullName="System.Net.HttpListener">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e88ba57dbda4386b2b36295ceaee5985d31eb0c0" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52231472" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpListener : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListener extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListener" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListener&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListener sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type HttpListener = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen einfachen, programmgesteuerten HTTP-Protokolllistener bereit. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mithilfe der <xref:System.Net.HttpListener> -Klasse verwenden, erstellen Sie einen einfachen HTTP-Listener-Protokoll, der auf HTTP-Anforderungen reagiert. Der Listener aktiv ist, für die Lebensdauer des der <xref:System.Net.HttpListener> Objekt und führt innerhalb Ihrer Anwendung mit seinen Berechtigungen.
   
 Mit <xref:System.Net.HttpListener>, erstellen Sie eine neue Instanz der Klasse mit der <xref:System.Net.HttpListener> Konstruktor und die Verwendung der <xref:System.Net.HttpListener.Prefixes%2A> Eigenschaft für den Zugriff auf die Auflistung, die die Zeichenfolgen enthält, die angeben, welche Uniform Resource Identifier (URI) das Präfix der <xref:System.Net.HttpListener>verarbeitet werden soll.
  
 Eine URI-Präfix-Zeichenfolge besteht aus einem Schema (http oder Https), einem Host, einem optionalen Port und einen optionalen Pfad. Ist ein Beispiel für eine vollständige Präfixzeichenfolge *http://www.contoso.com:8080/customerData/*. Präfixe müssen mit einem Schrägstrich ("/") enden. Die <xref:System.Net.HttpListener> Objekt mit dem Präfix an, die am ehesten einen angeforderten URI übereinstimmt, antwortet auf die Anforderung. Mehrere <xref:System.Net.HttpListener> Objekte können nicht das gleiche Präfix hinzufügen, ein <xref:System.ComponentModel.Win32Exception> Ausnahme wird ausgelöst, wenn eine <xref:System.Net.HttpListener> hinzufügt, verwenden Sie ein Präfix, das bereits vorhanden ist.
  
 Wenn ein Port angegeben ist, kann das Hostelement ersetzt werden, mit "\*" gibt an, dass die <xref:System.Net.HttpListener> akzeptiert Anforderungen an den Port gesendet werden, wenn der angeforderte URI nicht mit einem anderen Präfix übereinstimmt. Beispielsweise erhalten Sie alle Anforderungen gesendet an Port 8080, wenn der angeforderte URI nicht von einem behandelt <xref:System.Net.HttpListener>, das Präfix ist *http://\*: 8080 /*. Auf ähnliche Weise an, dass der <xref:System.Net.HttpListener> akzeptiert alle Anforderungen gesendet, um einen Port, ersetzen Sie den Hostelement mit dem Zeichen "+". Beispiel: *https://+:8080* Die "\*" und "+" Zeichen in der Präfixe, die Pfade enthalten vorhanden sein können.
  
 Ab .NET Core 2.0 oder .NET Framework 4.6 auf Windows 10, werden Platzhalter Unterdomänen in URI-Präfixe, die von verwaltet werden unterstützt eine <xref:System.Net.HttpListener> Objekt. Um eine Unterdomäne Platzhalter anzugeben, verwenden die "\*"-Zeichen als Teil des Hostnamens in eine URI-Präfix. Z. B. *http://\*.foo.com/*. Übergeben als Argument für die <xref:System.Net.HttpListenerPrefixCollection.Add%2A> Methode. Dies funktioniert ab .NET Core 2.0 oder .NET Framework 4.6 auf Windows 10; in früheren Versionen wurde dies generiert eine <xref:System.Net.HttpListenerException>.

 > [!WARNING]
 > Allgemeine platzhalterbindungen (*http://\*: 8080 /* und *http://+:8080*) sollten **nicht** verwendet werden. Platzhalterbindungen auf oberster Ebene gefährden die Sicherheit Ihrer App. Dies gilt für starke und schwache Platzhalter. Verwenden Sie statt Platzhaltern explizite Hostnamen. Platzhalterbindungen in untergeordneten Domänen (z.B. `*.mysub.com`) verursachen kein Sicherheitsrisiko, wenn Sie die gesamte übergeordnete Domäne steuern (im Gegensatz zu `*.com`, das angreifbar ist). Weitere Informationen finden Sie unter [rfc7230 im Abschnitt 5.4](https://tools.ietf.org/html/rfc7230#section-5.4).
  
 Zum Lauschen auf Anforderungen von Clients beginnen, fügen Sie die URI-Präfixe, auf die Sammlung und den Aufruf der <xref:System.Net.HttpListener.Start%2A> Methode. <xref:System.Net.HttpListener> Bietet synchrone und asynchrone Modelle für die Verarbeitung von Clientanforderungen an. Anforderungen und die zugehörigen Antworten erfolgt mit der <xref:System.Net.HttpListenerContext> zurückgegebenes Objekt der <xref:System.Net.HttpListener.GetContext%2A> -Methode oder die asynchrone Gegenstücke, die <xref:System.Net.HttpListener.BeginGetContext%2A> und <xref:System.Net.HttpListener.EndGetContext%2A> Methoden.
  
 Das synchrone Modell eignet sich, wenn Ihre Anwendung beim Warten auf einer Clientanforderungs blockiert werden soll, und wenn Sie nur eine Anforderung gleichzeitig verarbeiten möchten. Rufen Sie das synchrone Modell mit den <xref:System.Net.HttpListener.GetContext%2A> -Methode, die für einen Client zum Senden einer Anforderung wartet. Die Methode gibt ein <xref:System.Net.HttpListenerContext> -Objekt zur Verarbeitung, wenn bei mindestens einem tritt auf.
  
 Im komplexere asynchrone Modell wird Ihre Anwendung nicht blockiert, während in einem eigenen Ausführungsthread warten auf Anfragen und jede Anforderung verarbeitet wird. Verwenden der <xref:System.Net.HttpListener.BeginGetContext%2A> Methode an eine Anwendung definierte Methode, die für jede eingehende Anforderung aufgerufen werden. Rufen Sie in dieser Methode die <xref:System.Net.HttpListener.EndGetContext%2A> Methode, um die Anforderung abrufen, verarbeiten und zu reagieren.
  
 Bei beiden Modellen eingehende Anforderungen erfolgt mit der <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> -Eigenschaft und sind durch dargestellt <xref:System.Net.HttpListenerRequest> Objekte. Auf ähnliche Weise Antworten erfolgt mit der <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=nameWithType> -Eigenschaft und sind durch dargestellt <xref:System.Net.HttpListenerResponse> Objekte. Diese Objekte nutzen einige Funktionen, mit der <xref:System.Net.HttpWebRequest> und <xref:System.Net.HttpWebResponse> Objekte, aber die zweite Objekte können nicht in Verbindung mit verwendet werden <xref:System.Net.HttpListener> , da sie Clients, nicht Serververhalten implementieren.
  
 Ein <xref:System.Net.HttpListener> können Clientauthentifizierung erforderlich. Sie können entweder angeben, ein bestimmtes Schema für die Authentifizierung verwenden, oder können Sie angeben, ein Delegat, der bestimmt, das Schema verwenden. Sie müssen eine Form der Authentifizierung zum Abrufen von Informationen über die Identität des Clients erfordern. Weitere Informationen finden Sie unter den <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, und <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> Eigenschaften.
  
> [!NOTE]
> Bei der Erstellung einer <xref:System.Net.HttpListener> mithilfe von Https, müssen Sie ein Serverzertifikat für diesen Listener auswählen. Andernfalls ein <xref:System.Net.HttpWebRequest> dieses <xref:System.Net.HttpListener> schlägt mit einem unerwarteten Schließen der Verbindung.
  
> [!NOTE]
> Sie können die Serverzertifikate und andere Listeneroptionen konfigurieren, mithilfe von Network Shell (netsh.exe). Finden Sie unter [Netzwerkshell (Netsh)](/windows-server/networking/technologies/netsh/netsh) Weitere Details. Die ausführbare Datei wurde im Lieferumfang von Windows Server 2008 und Windows Vista.
  
> [!NOTE]
> Wenn Sie angeben, dass mehrere Authentifizierungsschemen für die <xref:System.Net.HttpListener>, der Listener werden Clients in der folgenden Reihenfolge Herausforderung: `Negotiate`, `NTLM`, `Digest`, und klicken Sie dann `Basic`.
  
   
  
## Examples
 Das folgende Codebeispiel veranschaulicht die Verwendung einer <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Änderungen an der NTLM-Authentifizierung für "HttpWebRequest" in Version 3.5 SP1</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.HttpListener" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie vor der Verwendung der Instanz, die von diesem Konstruktor zurückgegeben, dessen <xref:System.Net.HttpListener.Start%2A> Methode.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.HttpListener> Konstruktor zum Erstellen eines neuen <xref:System.Net.HttpListener> Objekt. Das vollständige Beispiel finden Sie unter den <xref:System.Net.HttpListener> Thema-Klasse.  
  
 [!code-csharp[Net_listener_Basic#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Diese Klasse kann nicht auf dem aktuellen Betriebssystem verwendet werden. Für die Verwendung von Instanzen dieser Klasse ist Windows Server 2003 oder Windows XP SP2 erforderlich.</exception>
        <block subset="none" type="usage">
          <para>Hinweis: Dieser Member gibt Ablaufverfolgungsinformationen, wenn Sie die netzwerkablaufverfolgung in Ihrer Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpListener.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet sofort das <see cref="T:System.Net.HttpListener" />-Objekt und verwirft alle Anforderungen, die sich gegenwärtig in der Warteschlange befinden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt alle Ressourcen frei, die von diesem Listener frei. Alle ausstehenden Anforderungen werden kann nicht abgeschlossen.  
  
 Nach dem Aufrufen dieser Methode erhalten Sie eine <xref:System.ObjectDisposedException> Wenn Sie versuchen, dieses <xref:System.Net.HttpListener>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Aufrufen dieser Methode.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemes">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.AuthenticationSchemes AuthenticationSchemes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemes" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemes As AuthenticationSchemes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemes AuthenticationSchemes { System::Net::AuthenticationSchemes get(); void set(System::Net::AuthenticationSchemes value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemes : System.Net.AuthenticationSchemes with get, set" Usage="System.Net.HttpListener.AuthenticationSchemes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Schema ab, das zum Authentifizieren von Clients verwendet wird, oder legt dieses fest.</summary>
        <value>Eine bitweise Kombination von <see cref="T:System.Net.AuthenticationSchemes" />-Enumerationswerten, die angibt, wie Clients authentifiziert werden sollen. Der Standardwert ist <see cref="F:System.Net.AuthenticationSchemes.Anonymous" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListener> das angegebene Schema verwendet, um alle eingehenden Anforderungen zu authentifizieren. Die <xref:System.Net.HttpListener.GetContext%2A> und <xref:System.Net.HttpListener.EndGetContext%2A> Methoden eine eingehende Clientanforderung nur zurück, wenn die <xref:System.Net.HttpListener> erfolgreich authentifiziert die Anforderung.  
  
 Die Identität eines erfolgreich authentifizierten Clients können mithilfe von Abfragen die <xref:System.Net.HttpListenerContext.User%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn Sie möchten eine <xref:System.Net.HttpListener> Objekt, das verschiedene Authentifizierungsmechanismen auf der Grundlage von Eigenschaften der empfangenen Anforderungen (z. B. der Anforderung <xref:System.Net.HttpListenerRequest.Url%2A> oder <xref:System.Net.HttpListenerRequest.UserHostName%2A> Eigenschaft), müssen Sie eine Methode, die auswählt implementieren die Authentifizierungsschema. Anleitungen hierzu finden Sie unter den <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> Dokumentation zur Eigenschaft.  
  
> [!NOTE]
>  Zum Festlegen dieser Eigenschaft zum Aktivieren von Digest, NTLM oder Negotiate erfordert die <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.HttpListener.AuthenticationSchemes%2A> Eigenschaft, um ein anderes Authentifizierungsschema anzugeben.  
  
 [!code-csharp[Net_listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemeSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemeSelectorDelegate As AuthenticationSchemeSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemeSelector ^ AuthenticationSchemeSelectorDelegate { System::Net::AuthenticationSchemeSelector ^ get(); void set(System::Net::AuthenticationSchemeSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemeSelectorDelegate : System.Net.AuthenticationSchemeSelector with get, set" Usage="System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemeSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Delegaten ab, der zum Bestimmen des für die Authentifizierung von Clients verwendeten Protokolls aufgerufen wird, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Net.AuthenticationSchemeSelector" />-Delegat, der die zum Auswählen eines Authentifizierungsprotokolls verwendete Methode aufruft. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn Sie das gleiche Authentifizierungsprotokoll für alle Anforderungen verarbeitet, die von einer bestimmten Instanz verwendet werden soll <xref:System.Net.HttpListener>, Sie müssen sich nicht, diese Eigenschaft festzulegen. Um ein Protokoll für alle Clientanforderungen zu verwendende anzugeben, verwenden die <xref:System.Net.HttpListener.AuthenticationSchemes%2A> Eigenschaft.  
  
 Wenn der Client keine Authentifizierungsinformationen in den Headern angegeben hat die <xref:System.Net.HttpListener> Ruft den angegebenen Delegaten für jede nicht authentifizierte eingehende Anforderung, um zu bestimmen, die ggf. Protokoll zum Authentifizieren des Clients verwenden. Die <xref:System.Net.HttpListener.GetContext%2A> und <xref:System.Net.HttpListener.EndGetContext%2A> Methoden zurückgeben einer eingehenden Anforderung nur, wenn die <xref:System.Net.HttpListener> die Anforderung erfolgreich authentifiziert. Wenn eine Anforderung nicht authentifiziert werden kann, die <xref:System.Net.HttpListener> automatisch sendet eine 401-Antwort zurück. Sie erhalten die Identität eines erfolgreich authentifizierten Clients, die mit der <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die Möglichkeit, delegieren die Auswahl der Authentifizierungsprotokoll auf eine anwendungsspezifische Methode ist nützlich, wenn Sie eine Instanz von <xref:System.Net.HttpListener> verschiedener Authentifizierungsprotokolle abhängig von den Charakteristika der Anforderungen verwenden (bei Empfang Beispiel, in der Anforderung <xref:System.Net.HttpListenerRequest.Url%2A> oder <xref:System.Net.HttpListenerRequest.UserHostAddress%2A> Eigenschaft).  
  
> [!NOTE]
>  Zum Festlegen dieser Eigenschaft zum Aktivieren von Digest, NTLM oder Negotiate erfordert die <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 Das folgende Codebeispiel legt den Wert dieser Eigenschaft fest.  
  
 [!code-csharp[NclListener#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#2)]
 [!code-vb[NclListener#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#2)]  
  
 Das folgende Codebeispiel stellt eine Implementierung einer Methode aufgerufen, indem ein <xref:System.Net.AuthenticationSchemeSelector> delegieren.  
  
 [!code-csharp[NclListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#1)]
 [!code-vb[NclListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetContext">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetContext (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetContext(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetContext (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetContext(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginGetContext : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpListener.BeginGetContext (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die aufgerufen werden soll, wenn eine Clientanforderung verfügbar ist.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="callback" />-Delegaten übergeben.</param>
        <summary>Startet den asynchronen Abruf einer eingehenden Anforderung.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListener.BeginGetContext%2A> -Methode beginnt einen asynchronen Aufruf der (nicht blockierende) auf eingehende Clientanforderungen empfangen. Sie müssen vor dem Aufrufen dieser Methode aufrufen der <xref:System.Net.HttpListener.Start%2A> Methode und mindestens ein Uniform Resource Identifier (URI)-Präfix überwachen, indem Sie die URI-Zeichenfolgen hinzufügen der <xref:System.Net.HttpListenerPrefixCollection> zurückgegebenes der <xref:System.Net.HttpListener.Prefixes%2A> Eigenschaft.  
  
 Der asynchrone Vorgang abgeschlossen werden muss, durch den Aufruf der <xref:System.Net.HttpListener.EndGetContext%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `callback` delegieren.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen ist. Rufen Sie eine eingehende Anforderung und blockieren, bis der Vorgang abgeschlossen ist, rufen Sie die <xref:System.Net.HttpListener.GetContext%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.HttpListener.BeginGetContext%2A> Methode, um eine Callback-Methode anzugeben, die eingehende Clientanforderungen behandelt.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 Das folgende Codebeispiel implementiert eine Callback-Methode.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Bei einem Win32-Funktionsaufruf ist ein Fehler aufgetreten. Überprüfen Sie die <see cref="P:System.Net.HttpListenerException.ErrorCode" />-Eigenschaft der Ausnahme, um die Ursache der Ausnahme zu bestimmen.</exception>
        <exception cref="T:System.InvalidOperationException">Dieses Objekt wurde nicht gestartet oder ist gegenwärtig angehalten.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <block subset="none" type="usage">
          <para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpListener.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fährt den <see cref="T:System.Net.HttpListener" /> herunter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem Aufrufen dieser Methode können Sie nicht mehr die <xref:System.Net.HttpListener> Objekt. Vorübergehend anhalten einer <xref:System.Net.HttpListener> -Objekts die <xref:System.Net.HttpListener.Stop%2A> Methode.  
  
 Schließen Sie diese Methode auf der Zeitebene der <xref:System.Net.HttpListener> Objekt ohne Verarbeitung von Anforderungen in der Warteschlange. Alle ausstehenden Anforderungen werden kann nicht abgeschlossen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Aufrufen dieser Methode.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultServiceNames">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.DefaultServiceNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultServiceNames As ServiceNameCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ DefaultServiceNames { System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultServiceNames : System.Security.Authentication.ExtendedProtection.ServiceNameCollection" Usage="System.Net.HttpListener.DefaultServiceNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ServiceNameCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft entsprechend den registrierten Präfixen eine Standardliste von Dienstanbieternamen (Service Provider Names, SPNs) ab.</summary>
        <value>Eine <see cref="T:System.Security.Authentication.ExtendedProtection.ServiceNameCollection" />, die eine Liste von Dienstanbieternamen enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListener.DefaultServiceNames%2A> Eigenschaft wird mit der integrierten Windows-Authentifizierung verwendet, um erweiterten Schutz zu bieten. Die Liste der SPNs über initialisiert wird die <xref:System.Net.HttpListener.Prefixes%2A> Eigenschaft beim Zugriff auf und gelöscht, wenn neue Präfixe hinzugefügt werden die <xref:System.Net.HttpListener.Prefixes%2A> Eigenschaft.  
  
 Die <xref:System.Net.HttpListener.DefaultServiceNames%2A> Eigenschaft wird verwendet, wenn eine Anwendung festlegen, nicht die <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> Eigenschaft für die erweiterte Schutzrichtlinie.  
  
 Die <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> abgerufen, die mit der <xref:System.Net.HttpListener.DefaultServiceNames%2A> Eigenschaft basiert auf dem die <xref:System.Net.HttpListener.Prefixes%2A> Eigenschaft gemäß den folgenden Regeln:  
  
1.  Wenn der Hostname ist "+", "*", oder eine IPv4- oder IPv6-Literal (entspricht "\*" jedoch beschränkt auf eine bestimmte lokale Schnittstelle), wird der folgende SPN hinzugefügt:  
  
 `"HTTP/"` außerdem den vollqualifizierten Domänennamen des Computers.  
  
1.  Wenn der Hostname keine Punkte (ohne Domänen oder Unterdomänen) enthält, wird versucht, den vollständig qualifizierten Domänennamen, der mithilfe von DNS aufgelöst (das gleiche Verhalten ein, die <xref:System.Net.HttpWebRequest>). Wenn Sie der vollqualifizierten Domänennamen aufgelöst werden kann, werden die folgenden SPN hinzugefügt:  
  
 `"HTTP/"` Darüber hinaus den Hostnamen (kurzer Name).  
  
 `"HTTP/"` außerdem den vollständig qualifizierten Domänennamen für den Hostnamen.  
  
1.  Wenn der Hostname keine Punkte (ohne Domänen oder Unterdomänen enthält) und ein vollständig qualifizierten Domänennamen kann nicht aufgelöst werden, wird der folgende SPN hinzugefügt:  
  
 `"HTTP/"` Darüber hinaus den Hostnamen.  
  
1.  Wenn der Hostname, Punkte (Domänen oder Unterdomänen) enthält, wird der folgende SPN hinzugefügt:  
  
 `"HTTP/"` Darüber hinaus den Hostnamen.  
  
 Die <xref:System.Net.HttpListener.DefaultServiceNames%2A> Eigenschaft kann von einer Anwendung verwendet werden, um die Liste der Standard-SPNs zu überprüfen, die für die Authentifizierung verwendet wird, wenn keine benutzerdefinierte Liste angegeben ist. Wenn andere SPNs erforderlich sind, kann eine Anwendung hinzufügen mithilfe eines der <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> Methoden.  
  
 Es ist nicht sicher, wenn der erweiterte Schutz mithilfe von Richtlinien Entscheidungen basierend auf der angeforderten URL an, da dies manipuliert werden kann. Stattdessen sollten Anwendungen basieren, auf die <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> oder <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> Eigenschaften, die diese Richtlinie Entscheidungen zu treffen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext EndGetContext(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetContext (asyncResult As IAsyncResult) As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ EndGetContext(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndGetContext : IAsyncResult -&gt; System.Net.HttpListenerContext" Usage="httpListener.EndGetContext asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />-Objekt, das beim Starten des asynchronen Vorgangs abgerufen wurde.</param>
        <summary>Schließt einen asynchronen Vorgang ab, um eine eingehende Clientanforderung abzurufen.</summary>
        <returns>Ein <see cref="T:System.Net.HttpListenerContext" />-Objekt, das die Clientanforderung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListener.EndGetContext%2A> Methode aufgerufen wird, in der Regel innerhalb einer anwendungsdefinierten Rückrufmethode aufgerufen, indem ein Delegat, zum Abrufen der <xref:System.Net.HttpListenerContext> Objekt, das eine eingehende Clientanforderung und die zugeordnete Antwort enthält. Diese Methode ausgeführt wird, einen Vorgang bereits gestartet wurde, durch den Aufruf der <xref:System.Net.HttpListener.BeginGetContext%2A> Methode. Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Da Aufrufen der <xref:System.Net.HttpListener.EndGetContext%2A> Methode erfordert die <xref:System.Net.HttpListener> Objekt ist, wird dieses Objekt wird in der Regel übergeben an eine Rückrufmethode, die durch das übergebene Zustandsobjekt, das mit der <xref:System.Net.HttpListener.BeginGetContext%2A> Methode. Sie können dieses Zustandsobjekt abrufen, indem Sie mit der <xref:System.IAsyncResult.AsyncState%2A> Eigenschaft der `asyncResult` Objekt.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Implementierung einer Rückrufmethode, die Aufrufe der <xref:System.Net.HttpListener.EndGetContext%2A> Methode.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> wurde nicht durch Aufruf der <see cref="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />-Methode abgerufen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />-Methode wurde bereits für das angegebene <paramref name="asyncResult" />-Objekt aufgerufen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <block subset="none" type="usage">
          <para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionPolicy As ExtendedProtectionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ ExtendedProtectionPolicy { System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ get(); void set(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionPolicy : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy with get, set" Usage="System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("not used anywhere in the implementation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> für den erweiterten Schutz einer Sitzung ab oder legt sie fest.</summary>
        <value>Eine <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, die die für erweiterten Schutz zu verwendende Richtlinie angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Eigenschaft wird mit der integrierten Windows-Authentifizierung verwendet, um erweiterten Schutz zu bieten. Die <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Eigenschaft ermöglicht die Konfiguration der erweiterten Schutzrichtlinie für den gesamten <xref:System.Net.HttpListener> Sitzung. Die <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> Eigenschaft ermöglicht die Konfiguration der erweiterten Schutzrichtlinie für jede einzelne Anforderung.  
  
 Die <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>-Eigenschaft muss `null` sein. Die <xref:System.Net.HttpListener> Instanz ruft das Channelbindungstoken (CBT) direkt über eine eigene TLS-Sitzung ab, sofern vorhanden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />-Eigenschaft festzulegen, die <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" />-Eigenschaft war jedoch nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />-Eigenschaft auf <see langword="null" /> festzulegen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />-Eigenschaft festzulegen, nachdem die <see cref="M:System.Net.HttpListener.Start" />-Methode bereits aufgerufen wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement" />-Eigenschaft wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform, die keinen erweiterten Schutz unterstützt, festgelegt.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListener/ExtendedProtectionSelector ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionSelectorDelegate As HttpListener.ExtendedProtectionSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListener::ExtendedProtectionSelector ^ ExtendedProtectionSelectorDelegate { System::Net::HttpListener::ExtendedProtectionSelector ^ get(); void set(System::Net::HttpListener::ExtendedProtectionSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionSelectorDelegate : System.Net.HttpListener.ExtendedProtectionSelector with get, set" Usage="System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListener+ExtendedProtectionSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Delegaten ab, der aufgerufen wird, um die <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> für jede Anforderung zu bestimmen, oder legt ihn fest.</summary>
        <value>Eine <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, die die für erweiterten Schutz zu verwendende Richtlinie angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Eigenschaft wird mit der integrierten Windows-Authentifizierung verwendet, um erweiterten Schutz zu bieten. Die <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Eigenschaft ermöglicht die Konfiguration der erweiterten Schutzrichtlinie für den gesamten <xref:System.Net.HttpListener> Sitzung. Die <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> Eigenschaft ermöglicht die Konfiguration der erweiterten Schutzrichtlinie für jede einzelne Anforderung.  
  
 Die <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>-Eigenschaft muss `null` sein. Die <xref:System.Net.HttpListener> Instanz ruft das Channelbindungstoken (CBT) direkt über eine eigene TLS-Sitzung ab, sofern vorhanden.  
  
 Bei jeder Anforderung der Delegaten können den Einstellungen, die die <xref:System.Net.HttpListener> -Instanz verwendet, um erweiterten Schutz zu bieten.  
  
 Wenn Sie ein Delegaten zurückgibt `null` für diese Eigenschaft stellt dies eine <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy> die der <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> -Eigenschaft auf festgelegt <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />-Eigenschaft festzulegen, die <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" />-Eigenschaft muss jedoch <see langword="null" /> sein.</exception>
        <exception cref="T:System.ArgumentNullException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />-Eigenschaft auf <see langword="null" /> festzulegen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />-Eigenschaft festzulegen, nachdem die <see cref="M:System.Net.HttpListener.Start" />-Methode bereits aufgerufen wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />-Eigenschaft auf einer Plattform festzulegen, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung mit erweitertem Schutz</related>
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContext () As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ GetContext();" />
      <MemberSignature Language="F#" Value="member this.GetContext : unit -&gt; System.Net.HttpListenerContext" Usage="httpListener.GetContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wartet auf eine eingehende Anforderung und wird beendet, wenn eine Anforderung empfangen wird.</summary>
        <returns>Ein <see cref="T:System.Net.HttpListenerContext" />-Objekt, das eine Clientanforderung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen vor dem Aufrufen dieser Methode aufrufen der <xref:System.Net.HttpListener.Start%2A> Methode und fügen Sie mindestens eine URI-Präfix zum Überwachen, indem Sie die URI-Zeichenfolgen hinzufügen der <xref:System.Net.HttpListenerPrefixCollection> zurückgegebenes der <xref:System.Net.HttpListener.Prefixes%2A> Eigenschaft. Eine detaillierte Beschreibung der Präfixe, finden Sie unter den <xref:System.Net.HttpListener> Übersicht über die Klasse.  
  
 Diese Methode blockiert, während des Wartens auf einer eingehenden Anforderung. Wenn eingehende Anforderungen asynchron (in separaten Threads) verarbeitet werden, damit Ihre Anwendung nicht blockiert werden sollen, verwenden Sie die <xref:System.Net.HttpListener.BeginGetContext%2A> Methode.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Aufrufen dieser Methode.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Bei einem Win32-Funktionsaufruf ist ein Fehler aufgetreten. Überprüfen Sie die <see cref="P:System.Net.HttpListenerException.ErrorCode" />-Eigenschaft der Ausnahme, um die Ursache der Ausnahme zu bestimmen.</exception>
        <exception cref="T:System.InvalidOperationException">Dieses Objekt wurde nicht gestartet oder ist gegenwärtig angehalten.  
  
- oder -  
Der <see cref="T:System.Net.HttpListener" /> verfügt über keine URI (Uniform Resource Identifier)-Präfixe, auf die geantwortet werden kann.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <block subset="none" type="usage">
          <para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetContextAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt; GetContextAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.HttpListenerContext&gt; GetContextAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContextAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextAsync () As Task(Of HttpListenerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::HttpListenerContext ^&gt; ^ GetContextAsync();" />
      <MemberSignature Language="F#" Value="member this.GetContextAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;" Usage="httpListener.GetContextAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wartet auf eine eingehende Anforderung als asynchrone Operation.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task`1" />zurück.  
  
Das Aufgabenobjekt, das den asynchronen Vorgang darstellt. Die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft im Aufgabenobjekt gibt ein <see cref="T:System.Net.HttpListenerContext" />-Objekt zurück, das eine Clientanforderung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurückgegebene <xref:System.Threading.Tasks.Task%601> Objekt wird abgeschlossen, wenn die eingehende Anforderung empfangen wurde.  
  
 Sie müssen vor dem Aufrufen dieser Methode aufrufen der <xref:System.Net.HttpListener.Start%2A> Methode und fügen Sie mindestens eine URI-Präfix zum Überwachen, indem Sie die URI-Zeichenfolgen hinzufügen der <xref:System.Net.HttpListenerPrefixCollection> zurückgegebenes der <xref:System.Net.HttpListener.Prefixes%2A> Eigenschaft. Eine detaillierte Beschreibung der Präfixe, finden Sie unter den <xref:System.Net.HttpListener> Übersicht über die Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListenerContext" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWriteExceptions">
      <MemberSignature Language="C#" Value="public bool IgnoreWriteExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWriteExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWriteExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWriteExceptions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreWriteExceptions : bool with get, set" Usage="System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob die Anwendung Ausnahmen empfängt, die auftreten, wenn ein <see cref="T:System.Net.HttpListener" /> die Antwort an den Client sendet, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn dieser <see cref="T:System.Net.HttpListener" /> keine Ausnahmen zurückgeben soll, die beim Senden der Antwort an den Client auftreten, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf `true` , wenn Ihre Anwendung nicht erforderlich ist, dass eine Antwort wurde erfolgreich an jeden Client gesendet wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen dieser Eigenschaft.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsListening">
      <MemberSignature Language="C#" Value="public bool IsListening { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsListening" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsListening" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsListening As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsListening { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsListening : bool" Usage="System.Net.HttpListener.IsListening" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.HttpListener" /> gestartet wurde.</summary>
        <value>
          <see langword="true" />, wenn der <see cref="T:System.Net.HttpListener" /> gestartet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Starten einer <xref:System.Net.HttpListener>, rufen Sie die <xref:System.Net.HttpListener.Start%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht die Verwendung dieser Eigenschaft zum Ermitteln des überwachenden Status einer Instanz.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupported">
      <MemberSignature Language="C#" Value="public static bool IsSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsSupported" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsSupported { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSupported : bool" Usage="System.Net.HttpListener.IsSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Net.HttpListener" /> mit dem aktuellen Betriebssystem verwendet werden kann.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Net.HttpListener" /> unterstützt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse ist nur auf Computern unter den Betriebssystemen Windows XP SP2 oder Windows Server 2003 verfügbar.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.HttpListener.IsSupported%2A> Eigenschaft, um zu erkennen, ob ein <xref:System.Net.HttpListener> Objekt kann mit dem aktuellen Betriebssystem verwendet werden.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixes">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerPrefixCollection Prefixes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerPrefixCollection Prefixes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Prefixes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Prefixes As HttpListenerPrefixCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerPrefixCollection ^ Prefixes { System::Net::HttpListenerPrefixCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefixes : System.Net.HttpListenerPrefixCollection" Usage="System.Net.HttpListener.Prefixes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerPrefixCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die von diesem <see cref="T:System.Net.HttpListener" />-Objekt behandelten URI-Präfixe (Uniform Resource Identifier) ab.</summary>
        <value>Eine <see cref="T:System.Net.HttpListenerPrefixCollection" /> mit den URI-Präfixen, für deren Behandlung dieses <see cref="T:System.Net.HttpListener" />-Objekt konfiguriert ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Präfixe sind in kanonischer Form. Eine detaillierte Beschreibung der Präfixe, finden Sie unter den <xref:System.Net.HttpListener> Übersicht über die Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.HttpListener.Prefixes%2A> Eigenschaft zum Abrufen und Drucken die URI-Präfixe, die verarbeitet werden.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Realm">
      <MemberSignature Language="C#" Value="public string Realm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Realm" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Realm" />
      <MemberSignature Language="VB.NET" Value="Public Property Realm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Realm { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Realm : string with get, set" Usage="System.Net.HttpListener.Realm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Bereich oder die Ressourcenpartition ab, der bzw. die diesem <see cref="T:System.Net.HttpListener" />-Objekt zugeordnet ist, oder legt den Bereich bzw. die Partition fest.</summary>
        <value>Ein <see cref="T:System.String" />-Wert, der den Namen des dem <see cref="T:System.Net.HttpListener" />-Objekt zugeordneten Bereichs enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Server verwenden Bereiche zum Partitionieren geschützter Ressourcen; Jede Partition kann es sich um eine eigene Authentifizierung Authentifizierungsschema und/oder Autorisierung der Datenbank verfügen. Bereiche werden nur für die Standard- und Hashwertauthentifizierung verwendet. Nach der erfolgreichen Authentifizierung eines Clients ist die Authentifizierung für alle Ressourcen in einem bestimmten Bereich gültig. Eine ausführliche Beschreibung der Bereiche finden Sie unter RFC 2617 unter [ https://www.ietf.org/ ](https://www.ietf.org/).  
  
 Eine Instanz von <xref:System.Net.HttpListener> verfügt über nur einen zugeordneten Bereich.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen der <xref:System.Net.HttpListener.Realm%2A> Eigenschaft.  
  
 [!code-csharp[Net_Listener_Basic#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="httpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht das Empfangen eingehender Anforderungen durch diese Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode muss aufgerufen werden, vor dem Aufruf der <xref:System.Net.HttpListener.GetContext%2A> oder <xref:System.Net.HttpListener.BeginGetContext%2A> Methode.  
  
 Nachdem Sie gestartet haben eine <xref:System.Net.HttpListener> -Objekts verwenden Sie die <xref:System.Net.HttpListener.Stop%2A> Methode zu beenden.  
  
> [!NOTE]
>  Wenn Https von diesem warteschlangenlistener-Instanz verwendet wird, müssen Sie installieren, und wählen Sie ein Serverzertifikat. Andernfalls ein <xref:System.Net.HttpWebRequest> dieses <xref:System.Net.HttpListener> schlägt mit einem unerwarteten Schließen der Verbindung. Sie können die Serverzertifikate und andere Listeneroptionen konfigurieren, mit HttpCfg.exe. Finden Sie unter [ http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp ](https://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) Weitere Details.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.HttpListener.Start%2A> Methode, um die Verarbeitung eingehender Anforderungen zu beginnen.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Bei einem Win32-Funktionsaufruf ist ein Fehler aufgetreten. Überprüfen Sie die <see cref="P:System.Net.HttpListenerException.ErrorCode" />-Eigenschaft der Ausnahme, um die Ursache der Ausnahme zu bestimmen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <block subset="none" type="usage">
          <para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="httpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass diese Instanz keine eingehenden Anforderungen mehr empfängt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Instanz bereits beendet ist, hat das Aufrufen dieser Methode keine Auswirkungen.  
  
 Nachdem Sie beendet haben eine <xref:System.Net.HttpListener> -Objekts verwenden Sie die <xref:System.Net.HttpListener.Start%2A> Methode, um ihn neu zu starten.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.HttpListener.Stop%2A> Methode zum Beenden der Verarbeitung eingehender Anforderungen.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <block subset="none" type="usage">
          <para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die für dieses <see cref="T:System.Net.HttpListener" />-Objekt reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anwendungen sollten verwenden die <xref:System.Net.HttpListener.Close%2A> anstelle dieser Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeoutManager">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerTimeoutManager TimeoutManager" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.TimeoutManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeoutManager As HttpListenerTimeoutManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerTimeoutManager ^ TimeoutManager { System::Net::HttpListenerTimeoutManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeoutManager : System.Net.HttpListenerTimeoutManager" Usage="System.Net.HttpListener.TimeoutManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerTimeoutManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Timeout-Manager für diese <see cref="T:System.Net.HttpListener" /> Instanz .</summary>
        <value>Gibt <see cref="T:System.Net.HttpListenerTimeoutManager" />zurück.  
  
Der Timeout-Manager für diese <see cref="T:System.Net.HttpListener" /> Instanz .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Timeout-Manager definiert den Timeout verbindungsbeschränkungen für diesen <xref:System.Net.HttpListener> Instanz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeConnectionNtlmAuthentication">
      <MemberSignature Language="C#" Value="public bool UnsafeConnectionNtlmAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeConnectionNtlmAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeConnectionNtlmAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeConnectionNtlmAuthentication : bool with get, set" Usage="System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Support for NTLM needs some loving.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der steuert, ob bei Verwendung von NTLM zusätzliche Anforderungen, die dieselbe TCP (Transmission Control Protocol)-Verbindung verwenden, authentifiziert werden müssen, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="T:System.Security.Principal.IIdentity" /> der ersten Anforderung für nachfolgende Anforderungen über dieselbe Verbindung verwendet wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf festgelegt ist `true` und die erste Anforderung über eine bestimmte TCP-Verbindung mit NTLM authentifiziert wird, werden nachfolgende Anforderungen über dieselbe TCP-Verbindung unter Verwendung der Authentifizierungsinformationen verarbeitet (<xref:System.Security.Principal.IIdentity>) der ursprünglichen Anforderung.  
  
 Diese Eigenschaft hat keine Auswirkungen, wenn das Authentifizierungsprotokoll nicht NTLM ist. Wenn als Authentifizierungsprotokoll aushandeln angegeben wird, wirkt sich diese Eigenschaft nur dann, wenn NTLM das tatsächliche Protokoll für die Authentifizierung verwendet wird.  
  
> [!NOTE]
>  Beim Festlegen dieser Eigenschaft auf `true` erhöht die Leistung, da die <xref:System.Net.HttpListener> nicht senden zusätzliche NTLM-authentifizierungsaufforderungen ist, gibt es ein Sicherheitsrisiko in alle Anforderungen zum Bereitstellen von Authentifizierungsinformationen. Sie müssen bestimmen, ob die Erhöhung der Leistung dieses Risiko wert ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Festlegen dieser Eigenschaft.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
  </Members>
</Type>