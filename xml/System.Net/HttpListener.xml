<Type Name="HttpListener" FullName="System.Net.HttpListener">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c1f32d7b4a7bfc00a02eee9b3a16d41e324d5115" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83537089" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpListener : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListener extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListener" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListener&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListener sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type HttpListener = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Net.HttpListener" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen einfachen, programmgesteuerten HTTP-Protokolllistener bereit. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

 Mit der <xref:System.Net.HttpListener>-Klasse können Sie einen einfachen HTTP-Protokolllistener erstellen, der auf HTTP-Anforderungen antwortet. Der Listener ist für die Lebensdauer des <xref:System.Net.HttpListener> Objekts aktiv und wird innerhalb der Anwendung mit seinen Berechtigungen ausgeführt.
   
 Um <xref:System.Net.HttpListener>zu verwenden, erstellen Sie eine neue Instanz der-Klasse mithilfe des <xref:System.Net.HttpListener>-Konstruktors, und verwenden Sie die <xref:System.Net.HttpListener.Prefixes%2A>-Eigenschaft, um Zugriff auf die Auflistung zu erhalten, die die Zeichen folgen enthält, die angeben, welche Uniform Resource Identifier (URI) Präfixe der <xref:System.Net.HttpListener> verarbeiten soll.
  
 Eine URI-Präfix Zeichenfolge besteht aus einem Schema (http oder HTTPS), einem Host, einem optionalen Port und einem optionalen Pfad. Ein Beispiel für eine komplette Präfix Zeichenfolge ist *http://www.contoso.com:8080/customerData/*. Präfixe müssen mit einem Schrägstrich ("/") enden. Das <xref:System.Net.HttpListener>-Objekt mit dem Präfix, das am ehesten mit einem angeforderten URI übereinstimmt, antwortet auf die Anforderung. Mehrere <xref:System.Net.HttpListener> Objekte können nicht dasselbe Präfix hinzufügen. eine <xref:System.ComponentModel.Win32Exception> Ausnahme wird ausgelöst, wenn ein <xref:System.Net.HttpListener> ein Präfix hinzufügt, das bereits verwendet wird.
  
 Wenn ein Port angegeben wird, kann das Host Element durch "\*" ersetzt werden, um anzugeben, dass der <xref:System.Net.HttpListener> Anforderungen akzeptiert, die an den Port gesendet werden, wenn der angeforderte URI keinem anderen Präfix entspricht. Wenn Sie z. b. alle Anforderungen empfangen möchten, die an den Port 8080 gesendet werden, wenn der angeforderte URI nicht von einem <xref:System.Net.HttpListener>behandelt wird, ist das Präfix *http://\*: 8080/*. Wenn Sie angeben möchten, dass der <xref:System.Net.HttpListener> alle an einen Port gesendeten Anforderungen akzeptiert, ersetzen Sie das Host Element durch das Zeichen "+". Beispiel: *https://+:8080* Die Zeichen "\*" und "+" können in Präfixen vorhanden sein, die Pfade enthalten.
  
 Ab .net Core 2,0 oder .NET Framework 4,6 unter Windows 10 werden Platzhalter Unterdomänen in URI-Präfixen unterstützt, die von einem <xref:System.Net.HttpListener>-Objekt verwaltet werden. Um eine Platzhalter Unterdomäne anzugeben, verwenden Sie das Zeichen "\*" als Teil des Host namens in einem URI-Präfix. Beispiel: *http://\*. foo.com/*. Übergeben Sie dies als Argument an die <xref:System.Net.HttpListenerPrefixCollection.Add%2A>-Methode. Dies funktioniert ab .net Core 2,0 oder .NET Framework 4,6 unter Windows 10. in früheren Versionen wird hierdurch eine <xref:System.Net.HttpListenerException>generiert.

 > [!WARNING]
 > Platzhalter Bindungen auf oberster Ebene (*http://\*: 8080/* und *http://+:8080*) dürfen **nicht** verwendet werden. Platzhalterbindungen auf oberster Ebene gefährden die Sicherheit Ihrer App. Dies gilt für starke und schwache Platzhalter. Verwenden Sie statt Platzhaltern explizite Hostnamen. Platzhalterbindungen in untergeordneten Domänen (z.B. `*.mysub.com`) verursachen kein Sicherheitsrisiko, wenn Sie die gesamte übergeordnete Domäne steuern (im Gegensatz zu `*.com`, das angreifbar ist). Weitere Informationen finden Sie unter [rfc7230 im Abschnitt 5.4](https://tools.ietf.org/html/rfc7230#section-5.4).
  
 Um mit der Überwachung von Clients zu beginnen, fügen Sie die URI-Präfixe der Auflistung hinzu, und rufen Sie die <xref:System.Net.HttpListener.Start%2A>-Methode auf. <xref:System.Net.HttpListener> bietet synchrone und asynchrone Modelle für die Verarbeitung von Client Anforderungen. Auf Anforderungen und ihre zugehörigen Antworten wird mithilfe des <xref:System.Net.HttpListenerContext> Objekts zugegriffen, das von der <xref:System.Net.HttpListener.GetContext%2A>-Methode oder Ihren asynchronen Entsprechungen, den <xref:System.Net.HttpListener.BeginGetContext%2A>-und <xref:System.Net.HttpListener.EndGetContext%2A>-Methoden zurückgegeben wird.
  
 Das synchrone Modell ist geeignet, wenn die Anwendung während des Wartens auf eine Client Anforderung blockiert werden soll, und wenn Sie jeweils nur eine Anforderung verarbeiten möchten. Verwenden Sie das synchrone Modell, um die <xref:System.Net.HttpListener.GetContext%2A>-Methode aufzurufen, die darauf wartet, dass ein Client eine Anforderung sendet. Die-Methode gibt ein <xref:System.Net.HttpListenerContext>-Objekt für die Verarbeitung zurück, wenn ein solches auftritt.
  
 Im komplexeren asynchronen Modell wird Ihre Anwendung nicht blockiert, während auf Anforderungen gewartet wird, und jede Anforderung wird in einem eigenen Ausführungs Thread verarbeitet. Verwenden Sie die <xref:System.Net.HttpListener.BeginGetContext%2A>-Methode, um eine Anwendungs definierte Methode anzugeben, die für jede eingehende Anforderung aufgerufen werden soll. Rufen Sie in dieser Methode die <xref:System.Net.HttpListener.EndGetContext%2A>-Methode auf, um die Anforderung zu erhalten, zu verarbeiten und zu antworten.
  
 In beiden Modellen wird auf eingehende Anforderungen mithilfe der <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType>-Eigenschaft zugegriffen, und Sie werden durch <xref:System.Net.HttpListenerRequest>-Objekte dargestellt. Auf ähnliche Weise wird auf Antworten mithilfe der <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=nameWithType>-Eigenschaft zugegriffen, und Sie werden durch <xref:System.Net.HttpListenerResponse>-Objekte dargestellt. Diese Objekte verfügen über einige Funktionen mit den <xref:System.Net.HttpWebRequest>-und <xref:System.Net.HttpWebResponse> Objekten, aber die letzteren Objekte können nicht zusammen mit <xref:System.Net.HttpListener> verwendet werden, da Sie Client-und nicht Server Verhalten implementieren.
  
 Eine <xref:System.Net.HttpListener> kann eine Client Authentifizierung erfordern. Sie können entweder ein bestimmtes Schema angeben, das für die Authentifizierung verwendet werden soll, oder Sie können einen Delegaten angeben, der das zu verwendende Schema bestimmt. Zum Abrufen von Informationen über die Identität des Clients benötigen Sie eine bestimmte Form der Authentifizierung. Weitere Informationen finden Sie unter den Eigenschaften <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>und <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>.
  
> [!NOTE]
> Wenn Sie einen <xref:System.Net.HttpListener> mithilfe von HTTPS erstellen, müssen Sie ein Server Zertifikat für diesen Listener auswählen. Andernfalls schlägt eine <xref:System.Net.HttpWebRequest> Abfrage dieses <xref:System.Net.HttpListener> mit einem unerwarteten Verbindungs Ende fehl.
  
> [!NOTE]
> Mithilfe der Netzwerkshell (Netsh. exe) können Sie Server Zertifikate und andere Listeneroptionen konfigurieren. Weitere Informationen finden Sie unter [Network Shell (Netsh)](/windows-server/networking/technologies/netsh/netsh) . Die ausführbare Datei wurde mit Windows Server 2008 und Windows Vista ausgeliefert.
  
> [!NOTE]
> Wenn Sie mehrere Authentifizierungs Schemas für die <xref:System.Net.HttpListener>angeben, fordert der Listener Clients in der folgenden Reihenfolge auf: `Negotiate`, `NTLM`, `Digest`und dann `Basic`.

### <a name="httpsys"></a>HTTP.sys

Die <xref:System.Net.HttpListener>-Klasse basiert auf `HTTP.sys`, bei dem es sich um den Kernelmoduslistener handelt, der den gesamten HTTP-Datenverkehr für Windows verarbeitet.
`HTTP.sys` bietet Verbindungs Verwaltung, Bandbreiten Einschränkung und Webserver Protokollierung.
Verwenden Sie das Tool [Httpcfg. exe](/windows/win32/http/httpcfg-exe) , um SSL-Zertifikate hinzuzufügen.
  
## Examples
 Im folgenden Codebeispiel wird die Verwendung eines <xref:System.Net.HttpListener>veranschaulicht.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/network-programming/changes-to-ntlm-authentication-for-httpwebrequest-in-version-3-5-sp1.md">Änderungen an der NTLM-Authentifizierung für "HttpWebRequest" in Version 3,5 SP1</related>
    <related type="Article" href="/windows/win32/http/httpcfg-exe">HttpCfg.exe</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.HttpListener" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vor der Verwendung der-Instanz, die von diesem Konstruktor zurückgegeben wird, müssen Sie die <xref:System.Net.HttpListener.Start%2A>-Methode aufrufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.HttpListener>-Konstruktors zum Erstellen eines neuen <xref:System.Net.HttpListener>-Objekts veranschaulicht. Das komplette Beispiel finden Sie im Thema <xref:System.Net.HttpListener>-Klasse.  
  
 [!code-csharp[Net_listener_Basic#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#9)]  
 [!code-vb[Net_Listener_Basic#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Diese Klasse kann nicht auf dem aktuellen Betriebssystem verwendet werden. Für die Verwendung von Instanzen dieser Klasse ist Windows Server 2003 oder Windows XP SP2 erforderlich.</exception>
        <block subset="none" type="usage"><para>Hinweis: Dieser Member gibt Ablauf Verfolgungs Informationen aus, wenn Sie die Netzwerk Ablauf Verfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpListener.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet sofort das <see cref="T:System.Net.HttpListener" />-Objekt und verwirft alle Anforderungen, die sich gegenwärtig in der Warteschlange befinden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt alle von diesem Listener reservierten Ressourcen frei. Ausstehende Anforderungen können nicht abgeschlossen werden.  
  
 Nachdem Sie diese Methode aufgerufen haben, erhalten Sie eine <xref:System.ObjectDisposedException>, wenn Sie versuchen, diese <xref:System.Net.HttpListener>zu verwenden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieser Methode veranschaulicht.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
 [!code-vb[Net_Listener_Basic#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemes">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.AuthenticationSchemes AuthenticationSchemes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemes" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemes As AuthenticationSchemes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemes AuthenticationSchemes { System::Net::AuthenticationSchemes get(); void set(System::Net::AuthenticationSchemes value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemes : System.Net.AuthenticationSchemes with get, set" Usage="System.Net.HttpListener.AuthenticationSchemes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Schema ab, das zum Authentifizieren von Clients verwendet wird, oder legt dieses fest.</summary>
        <value>Eine bitweise Kombination von <see cref="T:System.Net.AuthenticationSchemes" />-Enumerationswerten, die angibt, wie Clients authentifiziert werden sollen. Standardwert: <see cref="F:System.Net.AuthenticationSchemes.Anonymous" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Net.HttpListener> verwendet das angegebene Schema, um alle eingehenden Anforderungen zu authentifizieren. Die Methoden <xref:System.Net.HttpListener.GetContext%2A> und <xref:System.Net.HttpListener.EndGetContext%2A> geben eine eingehende Client Anforderung nur dann zurück, wenn der <xref:System.Net.HttpListener> die Anforderung erfolgreich authentifiziert hat.  
  
 Sie können die Identität eines erfolgreich authentifizierten Clients mithilfe der <xref:System.Net.HttpListenerContext.User%2A?displayProperty=nameWithType>-Eigenschaft Abfragen.  
  
 Wenn Sie möchten, dass ein <xref:System.Net.HttpListener> Objekt basierend auf den Merkmalen der empfangenen Anforderungen verschiedene Authentifizierungsmechanismen verwendet (z. b. die <xref:System.Net.HttpListenerRequest.Url%2A>-oder <xref:System.Net.HttpListenerRequest.UserHostName%2A>-Eigenschaft der Anforderung), müssen Sie eine Methode implementieren, die das Authentifizierungsschema auswählt. Anweisungen dazu finden Sie in der Dokumentation zur <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>-Eigenschaft.  
  
> [!NOTE]
>  Zum Festlegen dieser Eigenschaft, um Digest, NTLM oder aushandeln zu aktivieren, ist die <xref:System.Security.Permissions.SecurityPermission><xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>erforderlich.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Net.HttpListener.AuthenticationSchemes%2A>-Eigenschaft zum Angeben eines Authentifizierungs Schemas veranschaulicht.  
  
 [!code-csharp[Net_listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemeSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemeSelectorDelegate As AuthenticationSchemeSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemeSelector ^ AuthenticationSchemeSelectorDelegate { System::Net::AuthenticationSchemeSelector ^ get(); void set(System::Net::AuthenticationSchemeSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemeSelectorDelegate : System.Net.AuthenticationSchemeSelector with get, set" Usage="System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemeSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Delegaten ab, der zum Bestimmen des für die Authentifizierung von Clients verwendeten Protokolls aufgerufen wird, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Net.AuthenticationSchemeSelector" />-Delegat, der die zum Auswählen eines Authentifizierungsprotokolls verwendete Methode aufruft. Standardwert: <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn Sie für alle Anforderungen, die von einer bestimmten Instanz von <xref:System.Net.HttpListener>behandelt werden sollen, dasselbe Authentifizierungsprotokoll verwenden möchten, müssen Sie diese Eigenschaft nicht festlegen. Verwenden Sie die <xref:System.Net.HttpListener.AuthenticationSchemes%2A>-Eigenschaft, um ein Protokoll anzugeben, das für alle Client Anforderungen verwendet werden soll.  
  
 Wenn der Client in seinen Headern keine Authentifizierungsinformationen angegeben hat, ruft der <xref:System.Net.HttpListener> den angegebenen Delegaten für jede nicht authentifizierte eingehende Anforderung auf, um zu bestimmen, welches Protokoll, wenn überhaupt, zum Authentifizieren des Clients verwendet werden soll. Die Methoden <xref:System.Net.HttpListener.GetContext%2A> und <xref:System.Net.HttpListener.EndGetContext%2A> geben eine eingehende Anforderung nur dann zurück, wenn der <xref:System.Net.HttpListener> die Anforderung erfolgreich authentifiziert hat. Wenn eine Anforderung nicht authentifiziert werden kann, sendet der <xref:System.Net.HttpListener> automatisch eine 401-Antwort zurück. Sie können die Identität eines erfolgreich authentifizierten Clients mithilfe der <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=nameWithType>-Eigenschaft erhalten.  
  
 Die Möglichkeit, die Auswahl des Authentifizierungs Protokolls an eine anwendungsspezifische Methode zu delegieren, ist nützlich, wenn Sie möchten, dass eine Instanz von <xref:System.Net.HttpListener> unterschiedliche Authentifizierungsprotokolle verwendet, je nach den Merkmalen der empfangenen Anforderungen (z. b. <xref:System.Net.HttpListenerRequest.Url%2A> oder <xref:System.Net.HttpListenerRequest.UserHostAddress%2A>-Eigenschaft der Anforderung).  
  
> [!NOTE]
>  Zum Festlegen dieser Eigenschaft, um Digest, NTLM oder aushandeln zu aktivieren, ist die <xref:System.Security.Permissions.SecurityPermission><xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>erforderlich.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert dieser Eigenschaft festgelegt.  
  
 [!code-csharp[NclListener#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#2)]
 [!code-vb[NclListener#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#2)]  
  
 Im folgenden Codebeispiel wird eine Implementierung einer Methode bereitstellt, die von einem <xref:System.Net.AuthenticationSchemeSelector> Delegaten aufgerufen wird.  
  
 [!code-csharp[NclListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#1)]
 [!code-vb[NclListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetContext">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetContext (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetContext(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetContext (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetContext(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginGetContext : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpListener.BeginGetContext (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die aufgerufen werden soll, wenn eine Clientanforderung verfügbar ist.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Vorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="callback" />-Delegaten übergeben.</param>
        <summary>Startet den asynchronen Abruf einer eingehenden Anforderung.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den Status des asynchronen Vorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListener.BeginGetContext%2A>-Methode startet einen asynchronen (nicht blockierenden)-Befehl, um eingehende Client Anforderungen zu empfangen. Bevor Sie diese Methode aufrufen, müssen Sie die <xref:System.Net.HttpListener.Start%2A>-Methode aufrufen und mindestens ein Uniform Resource Identifier-Präfix (URI) hinzufügen, um zu lauschen, indem Sie die URI-Zeichen folgen dem <xref:System.Net.HttpListenerPrefixCollection> hinzufügen, das von der <xref:System.Net.HttpListener.Prefixes%2A>-Eigenschaft zurückgegeben  
  
 Der asynchrone Vorgang muss abgeschlossen werden, indem die <xref:System.Net.HttpListener.EndGetContext%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `callback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, während der Vorgang abgeschlossen wird. Um eine eingehende Anforderung abzurufen und zu blockieren, bis der Vorgang abgeschlossen ist, können Sie die <xref:System.Net.HttpListener.GetContext%2A>-Methode abrufen.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Net.HttpListener.BeginGetContext%2A>-Methode zum Angeben einer Rückruf Methode veranschaulicht, die eingehende Client Anforderungen verarbeitet.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
 [!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 Im folgenden Codebeispiel wird eine Rückruf Methode implementiert.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
 [!code-vb[Net_Listener_Basic#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Bei einem Win32-Funktionsaufruf ist ein Fehler aufgetreten. Überprüfen Sie die <see cref="P:System.Net.HttpListenerException.ErrorCode" />-Eigenschaft der Ausnahme, um die Ursache der Ausnahme zu bestimmen.</exception>
        <exception cref="T:System.InvalidOperationException">Dieses Objekt wurde nicht gestartet oder ist gegenwärtig angehalten.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <block subset="none" type="usage"><para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpListener.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fährt den <see cref="T:System.Net.HttpListener" /> herunter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem Sie diese Methode aufgerufen haben, können Sie das <xref:System.Net.HttpListener>-Objekt nicht mehr verwenden. Verwenden Sie die <xref:System.Net.HttpListener.Stop%2A>-Methode, um ein <xref:System.Net.HttpListener> Objekt vorübergehend anzuhalten.  
  
 Diese Methode schließt das <xref:System.Net.HttpListener>-Objekt ohne Verarbeitung von Anforderungen in der Warteschlange ab. Ausstehende Anforderungen können nicht abgeschlossen werden.  
  
## Examples  

Im folgenden Codebeispiel wird das Aufrufen der `Close`-Methode veranschaulicht:
  
[!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
[!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DefaultServiceNames">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.DefaultServiceNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultServiceNames As ServiceNameCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ DefaultServiceNames { System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultServiceNames : System.Security.Authentication.ExtendedProtection.ServiceNameCollection" Usage="System.Net.HttpListener.DefaultServiceNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ServiceNameCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft entsprechend den registrierten Präfixen eine Standardliste von Dienstanbieternamen (Service Provider Names, SPNs) ab.</summary>
        <value>Eine <see cref="T:System.Security.Authentication.ExtendedProtection.ServiceNameCollection" />, die eine Liste von Dienstanbieternamen enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListener.DefaultServiceNames%2A>-Eigenschaft wird mit der integrierten Windows-Authentifizierung verwendet, um erweiterten Schutz bereitzustellen. Die Liste der SPNs wird von der <xref:System.Net.HttpListener.Prefixes%2A>-Eigenschaft initialisiert, wenn auf Sie zugegriffen wird und Sie gelöscht wird, wenn der <xref:System.Net.HttpListener.Prefixes%2A>-Eigenschaft neue Präfixe hinzugefügt werden.  
  
 Die <xref:System.Net.HttpListener.DefaultServiceNames%2A>-Eigenschaft wird verwendet, wenn eine Anwendung die <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A>-Eigenschaft nicht für die erweiterte Schutzrichtlinie festgelegt hat.  
  
 Der <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection>, der mit der <xref:System.Net.HttpListener.DefaultServiceNames%2A>-Eigenschaft abgerufen wird, wird gemäß den folgenden Regeln aus der <xref:System.Net.HttpListener.Prefixes%2A>-Eigenschaft erstellt:  
  
1.  Wenn der Hostname "+", "*" oder ein IPv4-oder IPv6-Literalformat (entspricht "\*", aber auf eine bestimmte lokale Schnittstelle beschränkt) ist, wird der folgende SPN hinzugefügt:  
  
 `"HTTP/"` plus den voll qualifizierten Domänen Namen des Computers.  
  
1.  Wenn der Hostname keine Punkte (keine Domänen oder Unterdomänen) enthält, wird versucht, den voll qualifizierten Domänen Namen mithilfe von DNS aufzulösen (das gleiche Verhalten, das von <xref:System.Net.HttpWebRequest>verwendet wird). Wenn der voll qualifizierte Domänen Name aufgelöst werden kann, werden die folgenden SPNs hinzugefügt:  
  
 `"HTTP/"` plus den Hostnamen (Kurzname).  
  
 `"HTTP/"` plus den voll qualifizierten Domänen Namen für den Hostnamen.  
  
1.  Wenn der Hostname keine Punkte (keine Domänen oder Unterdomänen) enthält und ein voll qualifizierter Domänen Name nicht aufgelöst werden kann, wird der folgende SPN hinzugefügt:  
  
 `"HTTP/"` plus den Hostnamen.  
  
1.  Wenn der Hostname Punkte (Domänen oder Unterdomänen) enthält, wird der folgende SPN hinzugefügt:  
  
 `"HTTP/"` plus den Hostnamen.  
  
 Die <xref:System.Net.HttpListener.DefaultServiceNames%2A>-Eigenschaft kann von einer Anwendung verwendet werden, um die Liste der Standard-SPNs zu überprüfen, die für die Authentifizierung verwendet werden, wenn keine benutzerdefinierte Liste angegeben wird. Wenn andere SPNs benötigt werden, kann eine Anwendung Sie mithilfe einer der <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> Methoden hinzufügen.  
  
 Dies ist nicht sicher, wenn der erweiterte Schutz verwendet wird, um Richtlinien Entscheidungen auf Grundlage der angeforderten URL zu treffen, da dies manipuliert werden kann. Stattdessen sollten sich Anwendungen auf die <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A>-oder <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> Eigenschaften stützen, um Richtlinien Entscheidungen zu treffen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung unter Verwendung von "Erweiterter Schutz" (möglicherweise auf Englisch)</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext EndGetContext(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetContext (asyncResult As IAsyncResult) As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ EndGetContext(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndGetContext : IAsyncResult -&gt; System.Net.HttpListenerContext" Usage="httpListener.EndGetContext asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />-Objekt, das beim Starten des asynchronen Vorgangs abgerufen wurde.</param>
        <summary>Schließt einen asynchronen Vorgang ab, um eine eingehende Clientanforderung abzurufen.</summary>
        <returns>Ein <see cref="T:System.Net.HttpListenerContext" />-Objekt, das die Clientanforderung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListener.EndGetContext%2A>-Methode wird aufgerufen, in der Regel innerhalb einer von einem Delegaten aufgerufenen Anwendungs definierten Rückruf Methode, um das <xref:System.Net.HttpListenerContext> Objekt abzurufen, das eine eingehende Client Anforderung und die zugehörige Antwort enthält. Diese Methode schließt einen Vorgang ab, der zuvor durch Aufrufen der <xref:System.Net.HttpListener.BeginGetContext%2A>-Methode gestartet wurde. Wenn der Vorgang nicht abgeschlossen wurde, wird diese Methode blockiert, bis dies erfolgt.  
  
 Da das Aufrufen der <xref:System.Net.HttpListener.EndGetContext%2A> Methode das <xref:System.Net.HttpListener>-Objekt erfordert, wird dieses Objekt in der Regel mithilfe des Zustands Objekts, das an die <xref:System.Net.HttpListener.BeginGetContext%2A>-Methode übertragen wird, an eine Rückruf Methode übermittelt. Sie können dieses Zustands Objekt abrufen, indem Sie die <xref:System.IAsyncResult.AsyncState%2A>-Eigenschaft des `asyncResult`-Objekts verwenden.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) .  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Implementierung einer Rückruf Methode, die die <xref:System.Net.HttpListener.EndGetContext%2A>-Methode aufruft.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
 [!code-vb[Net_Listener_Basic#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch Aufruf der <see cref="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />-Methode abgerufen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Net.HttpListenerException">Bei einem Win32-Funktionsaufruf ist ein Fehler aufgetreten. Überprüfen Sie die <see cref="P:System.Net.HttpListenerException.ErrorCode" />-Eigenschaft der Ausnahme, um die Ursache der Ausnahme zu bestimmen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />-Methode wurde bereits für das angegebene <paramref name="asyncResult" />-Objekt aufgerufen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <block subset="none" type="usage"><para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionPolicy As ExtendedProtectionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ ExtendedProtectionPolicy { System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ get(); void set(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionPolicy : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy with get, set" Usage="System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("not used anywhere in the implementation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> für den erweiterten Schutz einer Sitzung ab oder legt sie fest.</summary>
        <value>Eine <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, die die für erweiterten Schutz zu verwendende Richtlinie angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>-Eigenschaft wird mit der integrierten Windows-Authentifizierung verwendet, um erweiterten Schutz bereitzustellen. Die <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>-Eigenschaft ermöglicht die Konfiguration der erweiterten Schutzrichtlinie für die gesamte <xref:System.Net.HttpListener> Sitzung. Die <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A>-Eigenschaft ermöglicht die Konfiguration der erweiterten Schutzrichtlinie für jede einzelne Anforderung.  
  
 Die <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>-Eigenschaft muss `null` sein. Die <xref:System.Net.HttpListener> Instanz Ruft das channelbindungstoken (CBT) direkt aus der eigenen TLS-Sitzung ab, sofern vorhanden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />-Eigenschaft festzulegen, die <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" />-Eigenschaft war jedoch nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />-Eigenschaft auf <see langword="null" /> festzulegen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />-Eigenschaft festzulegen, nachdem die <see cref="M:System.Net.HttpListener.Start" />-Methode bereits aufgerufen wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement" />-Eigenschaft wurde auf <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> auf einer Plattform, die keinen erweiterten Schutz unterstützt, festgelegt.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung unter Verwendung von "Erweiterter Schutz" (möglicherweise auf Englisch)</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListener/ExtendedProtectionSelector ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionSelectorDelegate As HttpListener.ExtendedProtectionSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListener::ExtendedProtectionSelector ^ ExtendedProtectionSelectorDelegate { System::Net::HttpListener::ExtendedProtectionSelector ^ get(); void set(System::Net::HttpListener::ExtendedProtectionSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionSelectorDelegate : System.Net.HttpListener.ExtendedProtectionSelector with get, set" Usage="System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListener+ExtendedProtectionSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Delegaten ab, der aufgerufen wird, um die <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> für jede Anforderung zu bestimmen, oder legt ihn fest.</summary>
        <value>Eine <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, die die für erweiterten Schutz zu verwendende Richtlinie angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>-Eigenschaft wird mit der integrierten Windows-Authentifizierung verwendet, um erweiterten Schutz bereitzustellen. Die <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>-Eigenschaft ermöglicht die Konfiguration der erweiterten Schutzrichtlinie für die gesamte <xref:System.Net.HttpListener> Sitzung. Die <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A>-Eigenschaft ermöglicht die Konfiguration der erweiterten Schutzrichtlinie pro einzelner Anforderung.  
  
 Die <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>-Eigenschaft muss `null` sein. Die <xref:System.Net.HttpListener> Instanz Ruft das channelbindungstoken (CBT) direkt aus der eigenen TLS-Sitzung ab, sofern vorhanden.  
  
 Der Delegat kann für jede Anforderung die Einstellungen auswählen, die von der <xref:System.Net.HttpListener> Instanz verwendet werden, um erweiterten Schutz bereitzustellen.  
  
 Wenn ein Delegat `null` für diese Eigenschaft zurückgibt, stellt dies einen dar <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy> der die Eigenschaft <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> auf <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>festgelegt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />-Eigenschaft festzulegen, die <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" />-Eigenschaft muss jedoch <see langword="null" /> sein.</exception>
        <exception cref="T:System.ArgumentNullException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />-Eigenschaft auf <see langword="null" /> festzulegen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />-Eigenschaft festzulegen, nachdem die <see cref="M:System.Net.HttpListener.Start" />-Methode bereits aufgerufen wurde.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Es wurde versucht, die <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />-Eigenschaft auf einer Plattform festzulegen, die keinen erweiterten Schutz unterstützt.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Integrierte Windows-Authentifizierung unter Verwendung von "Erweiterter Schutz" (möglicherweise auf Englisch)</related>
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContext () As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ GetContext();" />
      <MemberSignature Language="F#" Value="member this.GetContext : unit -&gt; System.Net.HttpListenerContext" Usage="httpListener.GetContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wartet auf eine eingehende Anforderung und wird beendet, wenn eine Anforderung empfangen wird.</summary>
        <returns>Ein <see cref="T:System.Net.HttpListenerContext" />-Objekt, das eine Clientanforderung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bevor Sie diese Methode aufrufen, müssen Sie die <xref:System.Net.HttpListener.Start%2A>-Methode aufrufen und mindestens ein URI-Präfix hinzufügen, das überwacht werden soll, indem Sie die URI-Zeichen folgen der von der <xref:System.Net.HttpListener.Prefixes%2A>-Eigenschaft zurückgegebenen <xref:System.Net.HttpListenerPrefixCollection> hinzufügen Eine ausführliche Beschreibung der Präfixe finden Sie in der Übersicht über <xref:System.Net.HttpListener>-Klasse.  
  
 Diese Methode wird während des Wartens auf eine eingehende Anforderung blockiert. Wenn eingehende Anforderungen asynchron verarbeitet werden sollen (in separaten Threads), damit die Anwendung nicht blockiert wird, verwenden Sie die <xref:System.Net.HttpListener.BeginGetContext%2A>-Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieser Methode veranschaulicht.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Bei einem Win32-Funktionsaufruf ist ein Fehler aufgetreten. Überprüfen Sie die <see cref="P:System.Net.HttpListenerException.ErrorCode" />-Eigenschaft der Ausnahme, um die Ursache der Ausnahme zu bestimmen.</exception>
        <exception cref="T:System.InvalidOperationException">Dieses Objekt wurde nicht gestartet oder ist gegenwärtig angehalten.  
  
- oder - 
Der <see cref="T:System.Net.HttpListener" /> verfügt über keine URI (Uniform Resource Identifier)-Präfixe, auf die geantwortet werden kann.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <block subset="none" type="usage"><para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetContextAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt; GetContextAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.HttpListenerContext&gt; GetContextAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContextAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextAsync () As Task(Of HttpListenerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::HttpListenerContext ^&gt; ^ GetContextAsync();" />
      <MemberSignature Language="F#" Value="member this.GetContextAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;" Usage="httpListener.GetContextAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wartet auf eine eingehende Anforderung als asynchrone Operation.</summary>
        <returns>Das Taskobjekt, das den asynchronen Vorgang darstellt. Die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft im Aufgabenobjekt gibt ein <see cref="T:System.Net.HttpListenerContext" />-Objekt zurück, das eine Clientanforderung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurückgegebene <xref:System.Threading.Tasks.Task%601> Objekt wird abgeschlossen, wenn die eingehende Anforderung empfangen wurde.  
  
 Bevor Sie diese Methode aufrufen, müssen Sie die <xref:System.Net.HttpListener.Start%2A>-Methode aufrufen und mindestens ein URI-Präfix hinzufügen, das überwacht werden soll, indem Sie die URI-Zeichen folgen der von der <xref:System.Net.HttpListener.Prefixes%2A>-Eigenschaft zurückgegebenen <xref:System.Net.HttpListenerPrefixCollection> hinzufügen Eine ausführliche Beschreibung der Präfixe finden Sie in der Übersicht über <xref:System.Net.HttpListener>-Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListenerContext" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWriteExceptions">
      <MemberSignature Language="C#" Value="public bool IgnoreWriteExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWriteExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWriteExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWriteExceptions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreWriteExceptions : bool with get, set" Usage="System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob die Anwendung Ausnahmen empfängt, die auftreten, wenn ein <see cref="T:System.Net.HttpListener" /> die Antwort an den Client sendet, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn diese <see cref="T:System.Net.HttpListener" /> keine Ausnahmen zurückgeben soll, die beim Senden der Antwort an den Client auftreten. Andernfalls <see langword="false" />. Standardwert: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf `true` fest, wenn Ihre Anwendung nicht erfordert, dass eine Antwort erfolgreich an jeden Client gesendet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Festlegen dieser Eigenschaft veranschaulicht.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsListening">
      <MemberSignature Language="C#" Value="public bool IsListening { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsListening" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsListening" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsListening As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsListening { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsListening : bool" Usage="System.Net.HttpListener.IsListening" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.HttpListener" /> gestartet wurde.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.HttpListener" /> gestartet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um einen <xref:System.Net.HttpListener>zu starten, müssen Sie die <xref:System.Net.HttpListener.Start%2A>-Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie diese Eigenschaft verwendet wird, um den Empfangs Zustand einer Instanz zu bestimmen.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupported">
      <MemberSignature Language="C#" Value="public static bool IsSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsSupported" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsSupported { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSupported : bool" Usage="System.Net.HttpListener.IsSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Net.HttpListener" /> mit dem aktuellen Betriebssystem verwendet werden kann.</summary>
        <value><see langword="true" /> auf allen Plattformen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.HttpListener.IsSupported%2A>-Eigenschaft, um zu ermitteln, ob ein <xref:System.Net.HttpListener> Objekt mit dem aktuellen Betriebssystem verwendet werden kann.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixes">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerPrefixCollection Prefixes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerPrefixCollection Prefixes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Prefixes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Prefixes As HttpListenerPrefixCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerPrefixCollection ^ Prefixes { System::Net::HttpListenerPrefixCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefixes : System.Net.HttpListenerPrefixCollection" Usage="System.Net.HttpListener.Prefixes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerPrefixCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die von diesem <see cref="T:System.Net.HttpListener" />-Objekt behandelten URI-Präfixe (Uniform Resource Identifier) ab.</summary>
        <value>Eine <see cref="T:System.Net.HttpListenerPrefixCollection" /> mit den URI-Präfixen, für deren Behandlung dieses <see cref="T:System.Net.HttpListener" />-Objekt konfiguriert ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Präfixe befinden sich in kanonischer Form. Eine ausführliche Beschreibung der Präfixe finden Sie in der Übersicht über <xref:System.Net.HttpListener>-Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Net.HttpListener.Prefixes%2A>-Eigenschaft zum Abrufen und Ausdrucken der zu behandelnden URI-Präfixe veranschaulicht.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Realm">
      <MemberSignature Language="C#" Value="public string Realm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Realm" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Realm" />
      <MemberSignature Language="VB.NET" Value="Public Property Realm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Realm { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Realm : string with get, set" Usage="System.Net.HttpListener.Realm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Bereich oder die Ressourcenpartition ab, der bzw. die diesem <see cref="T:System.Net.HttpListener" />-Objekt zugeordnet ist, oder legt den Bereich bzw. die Partition fest.</summary>
        <value>Ein <see cref="T:System.String" />-Wert, der den Namen des dem <see cref="T:System.Net.HttpListener" />-Objekt zugeordneten Bereichs enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Server verwenden Bereiche zum Partitionieren geschützter Ressourcen. jede Partition kann über ein eigenes Authentifizierungsschema und/oder eine Autorisierungs Datenbank verfügen. Bereiche werden nur für die Standard- und Hashwertauthentifizierung verwendet. Nach der erfolgreichen Authentifizierung eines Clients ist die Authentifizierung für alle Ressourcen in einem bestimmten Bereich gültig. Eine ausführliche Beschreibung der Bereiche finden Sie unter RFC 2617 unter [https://www.ietf.org/](https://www.ietf.org/).  
  
 Eine Instanz von <xref:System.Net.HttpListener> hat nur einen zugeordneten Bereich.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Festlegen der <xref:System.Net.HttpListener.Realm%2A>-Eigenschaft veranschaulicht.  
  
 [!code-csharp[Net_Listener_Basic#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#10)]  
 [!code-vb[Net_Listener_Basic#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="httpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht das Empfangen eingehender Anforderungen durch diese Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode muss aufgerufen werden, bevor Sie die <xref:System.Net.HttpListener.GetContext%2A>-oder <xref:System.Net.HttpListener.BeginGetContext%2A>-Methode aufrufen.  
  
 Nachdem Sie ein <xref:System.Net.HttpListener> Objekt gestartet haben, können Sie es mit der <xref:System.Net.HttpListener.Stop%2A>-Methode beenden.  
  
> [!NOTE]
>  Wenn diese listenerinstanz HTTPS verwendet, müssen Sie ein Server Zertifikat installieren und auswählen. Andernfalls schlägt eine <xref:System.Net.HttpWebRequest> Abfrage dieses <xref:System.Net.HttpListener> mit einem unerwarteten Verbindungs Ende fehl. Sie können Server Zertifikate und andere Listeneroptionen mithilfe von "Httpcfg. exe" konfigurieren. Weitere Informationen finden Sie unter [https://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp](https://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) .  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.HttpListener.Start%2A>-Methode, um mit der Verarbeitung eingehender Anforderungen zu beginnen.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
 [!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Bei einem Win32-Funktionsaufruf ist ein Fehler aufgetreten. Überprüfen Sie die <see cref="P:System.Net.HttpListenerException.ErrorCode" />-Eigenschaft der Ausnahme, um die Ursache der Ausnahme zu bestimmen.</exception>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt ist geschlossen.</exception>
        <block subset="none" type="usage"><para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="httpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass diese Instanz keine neuen eingehenden Anforderungen mehr empfängt, und beendet die Verarbeitung aller laufenden Anforderungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Instanz bereits beendet wurde, hat das Aufrufen dieser Methode keine Auswirkungen.  
  
 Nachdem Sie ein <xref:System.Net.HttpListener> Objekt beendet haben, können Sie es mit der <xref:System.Net.HttpListener.Start%2A>-Methode neu starten.  
  
   
  
## Examples  
 
Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.HttpListener.Stop%2A>-Methode, um die Verarbeitung eingehender Anforderungen zu verhindern.  
 
[!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
[!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
        <block subset="none" type="usage"><para>Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberSignature Language="F#" Value="abstract member System.IDisposable.Dispose : unit -&gt; unit&#xA;override this.System.IDisposable.Dispose : unit -&gt; unit" Usage="httpListener.System.IDisposable.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die für dieses <see cref="T:System.Net.HttpListener" />-Objekt reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anwendungen sollten die <xref:System.Net.HttpListener.Close%2A>-Methode verwenden, anstatt diese Methode aufrufen zu müssen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeoutManager">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerTimeoutManager TimeoutManager" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.TimeoutManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeoutManager As HttpListenerTimeoutManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerTimeoutManager ^ TimeoutManager { System::Net::HttpListenerTimeoutManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeoutManager : System.Net.HttpListenerTimeoutManager" Usage="System.Net.HttpListener.TimeoutManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerTimeoutManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Timeout-Manager für diese <see cref="T:System.Net.HttpListener" /> Instanz .</summary>
        <value>Der Timeout-Manager für diese <see cref="T:System.Net.HttpListener" /> Instanz .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Timeout-Manager definiert die Verbindungs Timeout Limits für diese <xref:System.Net.HttpListener> Instanz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeConnectionNtlmAuthentication">
      <MemberSignature Language="C#" Value="public bool UnsafeConnectionNtlmAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeConnectionNtlmAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeConnectionNtlmAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeConnectionNtlmAuthentication : bool with get, set" Usage="System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Support for NTLM needs some loving.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der steuert, ob bei Verwendung von NTLM zusätzliche Anforderungen, die dieselbe TCP (Transmission Control Protocol)-Verbindung verwenden, authentifiziert werden müssen, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Security.Principal.IIdentity" /> der ersten Anforderung für nachfolgende Anforderungen über dieselbe Verbindung verwendet wird, andernfalls <see langword="false" />. Standardwert: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf `true` festgelegt ist und die erste Anforderung über eine bestimmte TCP-Verbindung mithilfe von NTLM authentifiziert wird, werden nachfolgende Anforderungen über dieselbe TCP-Verbindung mithilfe der Authentifizierungsinformationen (<xref:System.Security.Principal.IIdentity>) der ursprünglichen Anforderung verarbeitet.  
  
 Diese Eigenschaft hat keine Auswirkungen, wenn das Authentifizierungsprotokoll nicht NTLM ist. Wenn aushandeln als Authentifizierungsprotokoll angegeben wird, hat diese Eigenschaft nur Auswirkungen, wenn NTLM das eigentliche Protokoll ist, das für die Authentifizierung verwendet wird.  
  
> [!NOTE]
>  Beim Festlegen dieser Eigenschaft auf `true` wird die Leistung gesteigert, da der <xref:System.Net.HttpListener> keine zusätzlichen NTLM-Authentifizierungs Herausforderungen sendet, besteht ein Sicherheitsrisiko darin, dass nicht alle Anforderungen Authentifizierungsinformationen bereitstellen müssen. Sie müssen bestimmen, ob die Erhöhung der Leistung dieses Risiko wert ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Festlegen dieser Eigenschaft veranschaulicht.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde geschlossen.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
