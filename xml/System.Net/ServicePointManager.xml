<Type Name="ServicePointManager" FullName="System.Net.ServicePointManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ac865cd62ee1a2da2e68a3afa52cbbe4e5a6a082" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75108765" /></Metadata><TypeSignature Language="C#" Value="public class ServicePointManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ServicePointManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.ServicePointManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ServicePointManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServicePointManager" />
  <TypeSignature Language="F#" Value="type ServicePointManager = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.ServicePoint</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Verwaltet die Auflistung von <see cref="T:System.Net.ServicePoint" />-Objekten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager> ist eine statische Klasse, die verwendet wird, um Instanzen der <xref:System.Net.ServicePoint>-Klasse zu erstellen, zu verwalten und zu löschen.  
  
 Wenn eine Anwendung über das <xref:System.Net.ServicePointManager>-Objekt eine Verbindung mit einem Internet Ressourcen Uniform Resource Identifier (URI) anfordert, gibt die <xref:System.Net.ServicePointManager> ein <xref:System.Net.ServicePoint> Objekt zurück, das Verbindungsinformationen für den Host und das Schema enthält, die durch den URI identifiziert werden. Wenn ein vorhandenes <xref:System.Net.ServicePoint> Objekt für diesen Host und dieses Schema vorhanden ist, gibt das <xref:System.Net.ServicePointManager> Objekt das vorhandene <xref:System.Net.ServicePoint> Objekt zurück. Andernfalls erstellt das <xref:System.Net.ServicePointManager>-Objekt ein neues <xref:System.Net.ServicePoint>-Objekt.  
  
 Der .NET Framework 4,6 umfasst ein neues Sicherheits Feature, das unsichere Verschlüsselungs-und Hash Algorithmen für Verbindungen blockiert. Anwendungen, die TLS/SSL über APIs verwenden, wie z. b. <xref:System.Net.Http.HttpClient>, <xref:System.Net.HttpWebRequest>, <xref:System.Net.FtpWebRequest>, <xref:System.Net.Mail.SmtpClient>, <xref:System.Net.Security.SslStream>usw. und Ziel .NET Framework 4,6, erhalten standardmäßig das sicherere Verhalten.  
  
 Entwickler möchten dieses Verhalten möglicherweise ablehnen, um die Interoperabilität mit Ihren vorhandenen SSL3 Services-oder TLS-/RC4-Diensten aufrechtzuerhalten. In [diesem Artikel](https://support.microsoft.com/kb/3069494) wird erläutert, wie Sie den Code so ändern, dass das neue Verhalten deaktiviert ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Net.ServicePoint>-Objekt für Verbindungen mit dem URI-`www.contoso.com`erstellt.  
  
 [!code-cpp[Classic ServicePoint Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePoint Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePoint Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePoint Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePoint Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePoint Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.ServicePoint" />
    <related type="Article" href="https://msdn.microsoft.com/library/6e5def51-3646-4ef6-a7bd-c69151321bec">ServicePointManager-Element (Netzwerkeinstellungen)</related>
  </Docs>
  <Members>
    <Member MemberName="CertificatePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.ICertificatePolicy CertificatePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.ICertificatePolicy CertificatePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CertificatePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CertificatePolicy As ICertificatePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::ICertificatePolicy ^ CertificatePolicy { System::Net::ICertificatePolicy ^ get(); void set(System::Net::ICertificatePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CertificatePolicy : System.Net.ICertificatePolicy with get, set" Usage="System.Net.ServicePointManager.CertificatePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use ServerCertificateValidationCallback instead", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("CertificatePolicy is obsoleted for this type, please use ServerCertificateValidationCallback instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICertificatePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Richtlinie für Serverzertifikate ab oder legt diese fest.</summary>
        <value>Ein Objekt, das die <see cref="T:System.Net.ICertificatePolicy" />-Schnittstelle implementiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Net.ServicePointManager.CertificatePolicy%2A>-Eigenschaft auf ein <xref:System.Net.ICertificatePolicy> Interface-Objekt festgelegt ist, verwendet das <xref:System.Net.ServicePointManager>-Objekt die in dieser Instanz definierte Zertifikat Richtlinie anstelle der Standard Zertifikat Richtlinie.  
  
 Die Standard Zertifikat Richtlinie ermöglicht gültige Zertifikate und gültige Zertifikate, die abgelaufen sind.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie eine Zertifikat Richtlinien Ausnahme für eine benutzerdefinierte Zertifikat Richtlinie abgefangen wird. Dabei wird davon ausgegangen, dass das Zertifikat Richtlinien Objekt definiert wurde, dass die Uniform Resource Identifier (URI) für die Webressource in der Variablen `myUri`enthalten ist und dass eine Methode mit dem Namen `ProcessResponse` vorhanden ist, die die Arbeit der Anwendung ausführt.  
  
 [!code-cpp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Um die <see cref="P:System.Net.ServicePointManager.CertificatePolicy" />-Eigenschaft festzulegen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="CheckCertificateRevocationList">
      <MemberSignature Language="C#" Value="public static bool CheckCertificateRevocationList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckCertificateRevocationList" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckCertificateRevocationList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckCertificateRevocationList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckCertificateRevocationList : bool with get, set" Usage="System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("CRL checks not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob das Zertifikat anhand der Sperrliste der Zertifizierungsstelle überprüft wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Zertifikatsperrliste überprüft wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Net.ServicePointManager.CheckCertificateRevocationList%2A> `true`ist, wird das Zertifikat im Rahmen der Zertifikat Überprüfung anhand der Sperr Liste der Zertifizierungsstelle überprüft. Der Standardwert lautet `false`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft festgelegt.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Zum Festlegen dieser Eigenschaft. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ClientCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ClientCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ClientCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ClientCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ClientCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultConnectionLimit">
      <MemberSignature Language="C#" Value="public static int DefaultConnectionLimit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultConnectionLimit" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultConnectionLimit As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultConnectionLimit { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultConnectionLimit : int with get, set" Usage="System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Anzahl von gleichzeitigen Verbindungen ab, die für ein <see cref="T:System.Net.ServicePoint" />-Objekt zulässig sind, oder legt diese fest.</summary>
        <value>Die maximale Anzahl von gleichzeitigen Verbindungen, die für ein <see cref="T:System.Net.ServicePoint" />-Objekt zulässig sind. Die standardmäßige Verbindungs Beschränkung beträgt 10 für ASP.net Hosted Applications und 2 für alle anderen. Beim Ausführen einer App als ASP.NET-Host ist es nicht möglich, den Wert dieser Eigenschaft über die Konfigurationsdatei zu ändern, wenn die autoConfig-Eigenschaft auf <see langword="true" /> festgelegt ist. Allerdings können Sie den Wert programmgesteuert ändern, wenn die Eigenschaft "autoConfig" <see langword="true" /> lautet. Legen Sie den bevorzugten Wert beim Laden von AppDomain einmal fest.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A>-Eigenschaft legt die standardmäßige maximale Anzahl von gleichzeitigen Verbindungen fest, die das <xref:System.Net.ServicePointManager>-Objekt beim Erstellen von <xref:System.Net.ServicePoint> Objekten der <xref:System.Net.ServicePoint.ConnectionLimit%2A>-Eigenschaft zuweist.  
  
 Das Ändern der <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> Eigenschaft hat keine Auswirkung auf vorhandene <xref:System.Net.ServicePoint> Objekte. Er wirkt sich nur auf <xref:System.Net.ServicePoint> Objekte aus, die nach der Änderung initialisiert werden. Wenn der Wert dieser Eigenschaft weder direkt noch über die Konfiguration festgelegt wurde, wird der Wert standardmäßig auf den konstanten <xref:System.Net.ServicePointManager.DefaultPersistentConnectionLimit>festgelegt.  
  
> [!NOTE]
>  Änderungen an der <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A>-Eigenschaft wirken sich sowohl auf HTTP 1,0-als auch auf HTTP 1,1-Verbindungen aus. Es ist nicht möglich, das Verbindungs Limit für HTTP 1,0-und HTTP 1,1-Protokolle separat zu ändern.
  
   
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft festgelegt.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> ist kleiner oder gleich 0.</exception>
        <permission cref="T:System.Net.WebPermission">für uneingeschränkte Webberechtigungen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="DefaultNonPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultNonPersistentConnectionLimit = (4)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultNonPersistentConnectionLimit As Integer  = 4" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="F#" Value="val mutable DefaultNonPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>Die Standardanzahl von nicht permanenten Verbindungen (4), die für ein <see cref="T:System.Net.ServicePoint" />-Objekt zulässig sind, das mit einem Server mit HTTP/1.0 oder höher verbunden ist. Dieses Feld ist konstant, wird aber in .NET Framework 2.0 nicht mehr verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultPersistentConnectionLimit = 2;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultPersistentConnectionLimit = (2)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultPersistentConnectionLimit As Integer  = 2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultPersistentConnectionLimit = 2;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="val mutable DefaultPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberSignature Language="C#" Value="public const int DefaultPersistentConnectionLimit = 10;" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultPersistentConnectionLimit = (10)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultPersistentConnectionLimit As Integer  = 10" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultPersistentConnectionLimit = 10;" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Die Standardanzahl von permanenten Verbindungen (2), die für ein <see cref="T:System.Net.ServicePoint" />-Objekt zulässig sind, das mit einem Server mit HTTP/1.1 oder höher verbunden ist. Dieses Feld ist konstant und wird zum Initialisieren der <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" />-Eigenschaft verwendet, wenn der Wert der <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" />-Eigenschaft weder direkt noch über die Konfiguration festgelegt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A>-Eigenschaft mithilfe dieses Felds festgelegt.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DnsRefreshTimeout">
      <MemberSignature Language="C#" Value="public static int DnsRefreshTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DnsRefreshTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DnsRefreshTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DnsRefreshTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DnsRefreshTimeout : int with get, set" Usage="System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zeitspanne angibt, für die eine DNS (Domain Name Service)-Auflösung als gültig angesehen wird, oder legt diesen fest.</summary>
        <value>Der Timeoutwert in Millisekunden. Der Wert -1 gibt ein unendliches Timeout an. Der Standardwert ist 120.000 Millisekunden (zwei Minuten).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft festgelegt.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EnableDnsRoundRobin">
      <MemberSignature Language="C#" Value="public static bool EnableDnsRoundRobin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableDnsRoundRobin" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableDnsRoundRobin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableDnsRoundRobin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableDnsRoundRobin : bool with get, set" Usage="System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die DNS (Domain Name Service)-Auflösung abwechselnd die anwendbaren IP (Internet Protocol)-Adressen verwendet, oder legt diesen fest.</summary>
        <value><see langword="false" />, wenn eine DNS-Auflösung immer die erste IP-Adresse für einen bestimmten Host zurückgibt, andernfalls <see langword="true" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn einem Hostnamen mehr als eine IP-Adresse zugeordnet ist, gibt eine DNS-Auflösung normalerweise nur die erste IP-Adresse zurück. Wenn Sie diese Eigenschaft auf `true`festlegen, durchlaufen nachfolgende DNS-Auflösungen alle verfügbaren IP-Adressen für einen bestimmten Host. Diese Option ist nützlich, wenn ein Dienst DNS als Lasten Ausgleichsmechanismus zwischen Servern oder Server Clustern verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft festgelegt.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionPolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Security.EncryptionPolicy EncryptionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.Security.EncryptionPolicy EncryptionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EncryptionPolicy As EncryptionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::EncryptionPolicy EncryptionPolicy { System::Net::Security::EncryptionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionPolicy : System.Net.Security.EncryptionPolicy" Usage="System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Always returns EncryptionPolicy.RequireEncryption.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.EncryptionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Net.Security.EncryptionPolicy" /> für diese <see cref="T:System.Net.ServicePointManager" />-Instanz ab.</summary>
        <value>Die Verschlüsselungsrichtlinie für diese <see cref="T:System.Net.ServicePointManager" />-Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn in der Konfigurationsdatei kein Wert angegeben ist, wird die <xref:System.Net.ServicePointManager.EncryptionPolicy%2A>-Eigenschaft standardmäßig auf <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType>festgelegt. Dies wird auf eine SSL/TLS-Sitzung in dieser <xref:System.Net.ServicePointManager> Instanz angewendet.  
  
 Die Verwendung des NULL-Chiffre ist erforderlich, wenn die Verschlüsselungs Richtlinie auf <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>festgelegt ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="P:System.Net.Configuration.ServicePointManagerElement.EncryptionPolicy" />
        <altmember cref="T:System.Net.Security.EncryptionPolicy" />
        <related type="Article" href="https://msdn.microsoft.com/library/6e5def51-3646-4ef6-a7bd-c69151321bec">ServicePointManager-Element (Netzwerkeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="Expect100Continue">
      <MemberSignature Language="C#" Value="public static bool Expect100Continue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Expect100Continue" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.Expect100Continue" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Expect100Continue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Expect100Continue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Expect100Continue : bool with get, set" Usage="System.Net.ServicePointManager.Expect100Continue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der bestimmt, ob 100-Continue-Verhalten verwendet wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, um 100-Continue-Verhalten zu aktivieren. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf `true`festgelegt ist, wird 100-Continue-Verhalten verwendet. Client Anforderungen, die die Methoden `PUT` und `POST` verwenden, fügen der Anforderung einen erwarteten Header hinzu, wenn die <xref:System.Net.ServicePointManager.Expect100Continue%2A>-Eigenschaft `true` und <xref:System.Net.HttpWebRequest.ContentLength%2A>-Eigenschaft größer als 0 (null) ist oder die <xref:System.Net.HttpWebRequest.SendChunked%2A>-Eigenschaft den Wert true aufweist. Der Client erwartet eine 100-Continue-Antwort vom Server, um anzugeben, dass die zu sendenden Daten vom Client gesendet werden sollen. Dieser Mechanismus ermöglicht es Clients, große Datenmengen über das Netzwerk zu senden, wenn der Server, basierend auf den Anforderungs Headern, die Anforderung ablehnen soll.  
  
 Nehmen Sie beispielsweise an, dass die <xref:System.Net.ServicePointManager.Expect100Continue%2A>-Eigenschaft `false`ist. Wenn die Anforderung an den Server gesendet wird, enthält Sie die Daten. Wenn der Server nach dem Lesen der Anforderungs Header eine Authentifizierung erfordert und eine 401-Antwort senden muss, muss der Client die Daten mit den richtigen Authentifizierungs Headern erneut senden.  
  
 Wenn diese Eigenschaft `true`ist, werden die Anforderungs Header an den Server gesendet. Wenn der Server die Anforderung nicht abgelehnt hat, sendet er eine 100-Continue-Antwort, die signalisiert, dass die Daten übertragen werden können. Wenn der Server wie im vorherigen Beispiel eine Authentifizierung erfordert, sendet er die 401-Antwort, und der Client hat die Daten nicht unnötig übertragen.  
  
 Wenn Sie den Wert dieser Eigenschaft ändern, wirkt sich dies nicht auf vorhandene <xref:System.Net.ServicePoint> Objekte aus. Nur neue <xref:System.Net.ServicePoint> Objekte, die nach der Änderung erstellt werden, sind betroffen.  
  
 Das 100-Continue-Verhalten wird nicht für HTTP 1,0-Anforderungen verwendet, auch wenn diese Eigenschaft auf `true`festgelegt ist.  
  
 Das erwartete 100-Continue-Verhalten ist im Abschnitt IETF RFC 2616 (Abschnitt 10.1.1) vollständig beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft festgelegt.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindServicePoint">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht ein vorhandenes <see cref="T:System.Net.ServicePoint" />-Objekt oder erstellt ein neues <see cref="T:System.Net.ServicePoint" />-Objekt, um die Kommunikation für diese Anforderung zu verwalten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="address">Das <see cref="T:System.Uri" />-Objekt der Internetressource, mit der eine Verbindung hergestellt werden soll.</param>
        <summary>Sucht ein vorhandenes <see cref="T:System.Net.ServicePoint" />-Objekt oder erstellt ein neues <see cref="T:System.Net.ServicePoint" />-Objekt, um die Kommunikation mit dem angegebenen <see cref="T:System.Uri" />-Objekt zu verwalten.</summary>
        <returns>Das <see cref="T:System.Net.ServicePoint" />-Objekt, das die Kommunikation für die Anforderung verwaltet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.ServicePointManager.FindServicePoint%2A>-Methode gibt das <xref:System.Net.ServicePoint>-Objekt zurück, das dem angegebenen Internet Hostnamen zugeordnet ist. Wenn kein <xref:System.Net.ServicePoint> Objekt für diesen Host vorhanden ist, erstellt das <xref:System.Net.ServicePointManager> Objekt ein Objekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die in <see cref="T:System.Net.ServicePoint" /> definierte maximale Anzahl von <see cref="P:System.Net.ServicePointManager.MaxServicePoints" />-Objekten wurde erreicht.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (string uriString, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(string uriString, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.String,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (uriString As String, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(System::String ^ uriString, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : string * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (uriString, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="uriString">Der URI der Internetressource, mit der eine Verbindung hergestellt werden soll.</param>
        <param name="proxy">Die Proxydaten für diese Anforderung.</param>
        <summary>Sucht ein vorhandenes <see cref="T:System.Net.ServicePoint" />-Objekt oder erstellt ein neues <see cref="T:System.Net.ServicePoint" />-Objekt, um die Kommunikation mit dem angegebenen URI (Uniform Resource Identifier) zu verwalten.</summary>
        <returns>Das <see cref="T:System.Net.ServicePoint" />-Objekt, das die Kommunikation für die Anforderung verwaltet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.ServicePointManager.FindServicePoint%2A>-Methode gibt das <xref:System.Net.ServicePoint>-Objekt zurück, das dem angegebenen Internet Hostnamen zugeordnet ist. Wenn kein <xref:System.Net.ServicePoint> Objekt für diesen Host vorhanden ist, erstellt das <xref:System.Net.ServicePointManager> Objekt ein Objekt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Aufrufen dieser Methode zum Zugreifen auf ein <xref:System.Net.ServicePoint> Objekt veranschaulicht.  
  
 [!code-cpp[System.Net.ServicePoint#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#7)]
 [!code-csharp[System.Net.ServicePoint#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#7)]
 [!code-vb[System.Net.ServicePoint#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">Der in <paramref name="uriString" /> angegebene URI ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Die in <see cref="T:System.Net.ServicePoint" /> definierte maximale Anzahl von <see cref="P:System.Net.ServicePointManager.MaxServicePoints" />-Objekten wurde erreicht.</exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (address, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="address">Ein <see cref="T:System.Uri" />-Objekt mit der Adresse der Internetressource, mit der eine Verbindung hergestellt werden soll.</param>
        <param name="proxy">Die Proxydaten für diese Anforderung.</param>
        <summary>Sucht ein vorhandenes <see cref="T:System.Net.ServicePoint" />-Objekt oder erstellt ein neues <see cref="T:System.Net.ServicePoint" />-Objekt, um die Kommunikation mit dem angegebenen <see cref="T:System.Uri" />-Objekt zu verwalten.</summary>
        <returns>Das <see cref="T:System.Net.ServicePoint" />-Objekt, das die Kommunikation für die Anforderung verwaltet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.ServicePointManager.FindServicePoint%2A>-Methode gibt das <xref:System.Net.ServicePoint>-Objekt zurück, das dem angegebenen Internet Hostnamen zugeordnet ist. Wenn kein <xref:System.Net.ServicePoint> Objekt für diesen Host vorhanden ist, erstellt das <xref:System.Net.ServicePointManager> Objekt ein Objekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die in <see cref="T:System.Net.ServicePoint" /> definierte maximale Anzahl von <see cref="P:System.Net.ServicePointManager.MaxServicePoints" />-Objekten wurde erreicht.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePointIdleTime">
      <MemberSignature Language="C#" Value="public static int MaxServicePointIdleTime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePointIdleTime" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePointIdleTime As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePointIdleTime { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePointIdleTime : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Leerlaufzeit eines <see cref="T:System.Net.ServicePoint" />-Objekts ab oder legt diese fest.</summary>
        <value>Die maximale Leerlaufzeit eines <see cref="T:System.Net.ServicePoint" />-Objekts in Millisekunden. Der Standardwert ist 100.000 Millisekunden (100 Sekunden).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.ServicePointManager.MaxServicePointIdleTime%2A>-Eigenschaft legt die maximale Leerlaufzeit fest, die das <xref:System.Net.ServicePointManager>-Objekt bei der Erstellung von <xref:System.Net.ServicePoint> Objekten der <xref:System.Net.ServicePoint.MaxIdleTime%2A>-Eigenschaft zuweist. Änderungen an diesem Wert wirken sich nur auf <xref:System.Net.ServicePoint> Objekte aus, die nach dem Ändern des Werts initialisiert werden.  
  
 Nachdem ein <xref:System.Net.ServicePoint>-Objekt für die in <xref:System.Net.ServicePoint.MaxIdleTime%2A>angegebene Zeit in den Leerlauf versetzt wurde, ist es für Garbage Collection geeignet. Ein <xref:System.Net.ServicePoint>-Objekt befindet sich im Leerlauf, wenn die Liste der dem <xref:System.Net.ServicePoint>-Objekt zugeordneten Verbindungen leer ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft festgelegt.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Net.ServicePointManager.MaxServicePointIdleTime" /> ist kleiner als <see cref="F:System.Threading.Timeout.Infinite" /> oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">für uneingeschränkte Webberechtigungen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePoints">
      <MemberSignature Language="C#" Value="public static int MaxServicePoints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePoints" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePoints" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePoints As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePoints { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePoints : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Anzahl von <see cref="T:System.Net.ServicePoint" />-Objekten ab, die jederzeit verwaltet werden sollen, oder legt diese fest.</summary>
        <value>Die maximale Anzahl der zu verwaltenden <see cref="T:System.Net.ServicePoint" />-Objekte. Der Standardwert ist 0, d. h., dass die Anzahl der <see cref="T:System.Net.ServicePoint" />-Objekte unbegrenzt ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Net.ServicePointManager.MaxServicePoints%2A>-Eigenschaft unterhalb der Anzahl von <xref:System.Net.ServicePoint> Objekten verringern, die derzeit vorhanden sind, löscht die <xref:System.Net.ServicePointManager> die <xref:System.Net.ServicePoint> Objekte mit den längsten Leerlaufzeiten. Wenn die Anzahl von <xref:System.Net.ServicePoint> Objekten mit aktiven Verbindungen größer ist als der Wert von <xref:System.Net.ServicePointManager.MaxServicePoints%2A>, löscht das <xref:System.Net.ServicePointManager> Objekt die <xref:System.Net.ServicePoint> Objekte, da Sie sich im Leerlauf befinden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft festgelegt.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> ist kleiner als 0 oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">für uneingeschränkte Webberechtigungen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="ReusePort">
      <MemberSignature Language="C#" Value="public static bool ReusePort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ReusePort" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ReusePort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ReusePort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ReusePort { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReusePort : bool with get, set" Usage="System.Net.ServicePointManager.ReusePort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Durch Festlegen dieses Eigenschaftswerts auf <see langword="true" /> verwenden alle ausgehenden TCP-Verbindungen von HttpWebRequest die systemeigene Socketoption SO_REUSE_UNICASTPORT für den Socket. Dies bewirkt, dass die zugrunde liegenden ausgehenden Ports gemeinsam verwendet werden. Dies ist hilfreich in Szenarien, in denen eine große Anzahl von ausgehenden Verbindungen in kurzer Zeit hergestellt wird und die App über nicht genügend Ports verfügt.</summary>
        <value>Gibt <see cref="T:System.Boolean" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert ist `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityProtocol">
      <MemberSignature Language="C#" Value="public static System.Net.SecurityProtocolType SecurityProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.SecurityProtocolType SecurityProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.SecurityProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityProtocol As SecurityProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::SecurityProtocolType SecurityProtocol { System::Net::SecurityProtocolType get(); void set(System::Net::SecurityProtocolType value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityProtocol : System.Net.SecurityProtocolType with get, set" Usage="System.Net.ServicePointManager.SecurityProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.SecurityProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Sicherheitsprotokoll ab, das von den vom <see cref="T:System.Net.ServicePoint" />-Objekt verwalteten <see cref="T:System.Net.ServicePointManager" />-Objekten verwendet wird, oder legt dieses fest.</summary>
        <value>Einer der in der <see cref="T:System.Net.SecurityProtocolType" />-Enumeration definierten Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Mit dieser Eigenschaft wird die Version des Secure Sockets Layer (SSL) oder Transport Layer Security Protokoll (TLS) ausgewählt, die für neue Verbindungen verwendet werden soll. vorhandene Verbindungen werden nicht geändert.  
  
Beginnend mit dem .NET Framework 4,7 lautet der Standardwert dieser Eigenschaft <xref:System.Net.SecurityProtocolType.SystemDefault?displayProperty=nameWithType>. Dadurch können .NET Framework Netzwerk-APIs basierend auf <xref:System.Net.Security.SslStream> (z. b. FTP, http und SMTP) die Standard Sicherheitsprotokolle vom Betriebssystem oder von benutzerdefinierten Konfigurationen erben, die von einem Systemadministrator ausgeführt werden. Informationen dazu, welche SSL/TLS-Protokolle für jede Version des Windows-Betriebssystems standardmäßig aktiviert sind, finden Sie unter [Protokolle in TLS/SSL (Schannel SSP)](https://msdn.microsoft.com/library/windows/desktop/mt808159.aspx).
 
Für Versionen der .NET Framework über die .NET Framework 4.6.2 wird kein Standardwert für diese Eigenschaft aufgelistet. Die Sicherheitslandschaft ändert sich ständig, und die Standardprotokolle und-Schutz Ebenen werden im Laufe der Zeit geändert, um bekannte Schwächen zu vermeiden. Die Standardwerte variieren je nach Computerkonfiguration, installierter Software und angewendeten Patches.  
  
 Ihr Code sollte nie implizit von der Verwendung einer bestimmten Schutz Ebene abhängig sein oder davon ausgegangen werden, dass standardmäßig eine bestimmte Sicherheitsstufe verwendet wird. Wenn Ihre APP von der Verwendung einer bestimmten Sicherheitsstufe abhängt, müssen Sie diese Ebene explizit angeben und dann überprüfen, ob Sie tatsächlich für die festgelegte Verbindung verwendet wird. Außerdem sollte der Code so konzipiert sein, dass er bei Änderungen, die unterstützt werden, robust ist, da diese Änderungen häufig mit geringfügigen Vorgängen vorgenommen werden, um neue Bedrohungen zu verringern.  
  
 Der .NET Framework 4,6 umfasst ein neues Sicherheits Feature, das unsichere Verschlüsselungs-und Hash Algorithmen für Verbindungen blockiert. Anwendungen, die TLS/SSL über APIs wie z. b. HttpClient, HttpWebRequest, FtpClient, SmtpClient, SslStream usw. und das Ziel .NET Framework 4,6 verwenden, erhalten standardmäßig das sicherere Verhalten.  
  
 Entwickler möchten dieses Verhalten möglicherweise ablehnen, um die Interoperabilität mit Ihren vorhandenen SSL3 Services-oder TLS-/RC4-Diensten aufrechtzuerhalten. In [diesem Artikel](https://support.microsoft.com/kb/3069494) wird erläutert, wie Sie den Code so ändern, dass das neue Verhalten deaktiviert ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der zum Festlegen der Eigenschaft angegebene Wert ist kein gültiger <see cref="T:System.Net.SecurityProtocolType" />-Enumerationswert.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.SecurityProtocolType" />
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public static System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Rückruf zum Überprüfen eines Serverzertifikats ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" />. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Eine Anwendung kann die <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A>-Eigenschaft auf eine Methode festlegen, die vom Client des Serverzertifikats für die benutzerdefinierte Validierung verwendet werden soll. Wenn Sie eine benutzerdefinierte Validierung durchgeführt haben, kann der `sender` Parameter, der an die <xref:System.Net.Security.RemoteCertificateValidationCallback> übergeben wird, ein Host Zeichen folgen Name oder ein Objekt sein, das von <xref:System.Net.WebRequest> abgeleitet ist (z. b.<xref:System.Net.HttpWebRequest><xref:System.Net.ServicePointManager.CertificatePolicy%2A>).  
  
Wenn die benutzerdefinierte Überprüfung nicht verwendet wird, wird der Zertifikat Name mit dem Hostnamen verglichen, der zum Erstellen der Anforderung verwendet wird. Wenn <xref:System.Net.WebRequest.Create%28System.String%29> z. b. einen Parameter `"https://www.contoso.com/default.html"`übergeben wurde, ist das Standardverhalten, wenn der Client das Zertifikat mit `www.contoso.com`prüft.  

Obwohl es sich bei einem Multicast Delegaten um einen Multicast Delegaten handelt, wird nur der vom zuletzt ausgeführten Ereignishandler zurückgegebene Wert als Mit anderen Worten, Sie können mehrere Delegaten anfügen und alle einen Rückruf von <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A>erhalten. Jeder Rückruf gibt einen Wert zurück, der angibt, ob das Zertifikat akzeptiert wird. Allerdings wird nur der Wert aus dem letzten Delegaten beachtet.
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Um die <see cref="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" />-Eigenschaft festzulegen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ServerCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ServerCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ServerCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ServerCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTcpKeepAlive">
      <MemberSignature Language="C#" Value="public static void SetTcpKeepAlive (bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTcpKeepAlive(bool enabled, int32 keepAliveTime, int32 keepAliveInterval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.SetTcpKeepAlive(System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTcpKeepAlive (enabled As Boolean, keepAliveTime As Integer, keepAliveInterval As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="F#" Value="static member SetTcpKeepAlive : bool * int * int -&gt; unit" Usage="System.Net.ServicePointManager.SetTcpKeepAlive (enabled, keepAliveTime, keepAliveInterval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="keepAliveTime" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="keepAliveInterval" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="enabled">Bei TRUE wird die TCP-Keep-Alive-Option für eine TCP-Verbindung mit den angegebenen <paramref name="keepAliveTime" />- und <paramref name="keepAliveInterval" />-Werten aktiviert.  
  
Bei false wird die TCP-Keep-Alive-Option deaktiviert, und die verbleibenden Parameter werden ignoriert.  
  
Der Standardwert ist false.</param>
        <param name="keepAliveTime">Gibt das Timeout, in Millisekunden, ohne Aktivität an, bis das erste Keep-Alive-Paket gesendet wird.  
  
Der Wert muss größer als 0 sein.  Wenn ein Wert übergeben wird, der kleiner oder gleich 0 (null) ist, wird eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst.</param>
        <param name="keepAliveInterval">Gibt das Intervall, in Millisekunden, an, in dem folgende Keep-Alive-Pakete gesendet werden, wenn keine Bestätigung empfangen wird.  
  
Der Wert muss größer als 0 sein.  Wenn ein Wert übergeben wird, der kleiner oder gleich 0 (null) ist, wird eine <see cref="T:System.ArgumentOutOfRangeException" /> ausgelöst.</param>
        <summary>Aktiviert oder deaktiviert die Keep-Alive-Option für eine TCP-Verbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung kann anfordern, dass ein TCP/IP-Anbieter die Verwendung von Keep-Alive-Paketen in einer TCP-Verbindung ermöglicht. Der Standardwert ist, dass die Verwendung von Keep-Alive-Paketen für eine TCP-Verbindung deaktiviert ist.  
  
 Die Standardeinstellungen beim Initialisieren eines TCP-Sockets legt den Keep-Alive-Timeout auf 2 Stunden und das Keep-Alive-Intervall auf 1 Sekunde fest. Der `keepAliveTime`-Parameter gibt den Timeout Wert (in Millisekunden) ohne Aktivität an, bis das erste Keep-Alive-Paket gesendet wird. Der `keepAliveInterval`-Parameter gibt das Intervall in Millisekunden zwischen dem Senden der nachfolgenden Keep-Alive-Pakete an, wenn keine Bestätigung empfangen wird. Die Anzahl der Keep-Alive-Tests kann nicht geändert werden, und wird auf 10 festgelegt.  
  
 Wenn eine TCP-Verbindung als Ergebnis von Keep-Alives gelöscht wird, wird ein <xref:System.Net.Sockets.SocketError> <xref:System.Net.Sockets.SocketError.NetworkReset> an alle Aufrufe zurückgegeben, die im Socket ausgeführt werden, und bei allen nachfolgenden Aufrufen tritt ein <xref:System.Net.Sockets.SocketError> <xref:System.Net.Sockets.SocketError.NotConnected>auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für den <paramref name="keepAliveTime" />-Parameter oder den <paramref name="keepAliveInterval" />-Parameter angegebene Wert ist kleiner oder gleich 0.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="UseNagleAlgorithm">
      <MemberSignature Language="C#" Value="public static bool UseNagleAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseNagleAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseNagleAlgorithm As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseNagleAlgorithm { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseNagleAlgorithm : bool with get, set" Usage="System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt, ob der Nagle-Algorithmus von den Dienstpunkten verwendet wird, die von diesem <see cref="T:System.Net.ServicePointManager" />-Objekt verwaltet werden.</summary>
        <value><see langword="true" />, wenn der Nagle-Algorithmus verwendet werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Nagle-Algorithmus wird verwendet, um den Netzwerk Datenverkehr zu verringern, indem kleine Datenpakete gepuffert und als ein einzelnes Paket übertragen werden. Dieser Prozess wird auch als "nageln" bezeichnet. Sie wird häufig verwendet, da Sie die Anzahl der übertragenen Pakete verringert und den Aufwand pro Paket verringert.  
  
 Wenn Sie den Wert dieser Eigenschaft ändern, wirkt sich dies nicht auf vorhandene <xref:System.Net.ServicePoint> Objekte aus. Nur neue Dienst Punkte, die nach der Änderung erstellt werden, sind betroffen.  
  
 Der Nagle-Algorithmus ist vollständig in IETF RFC 896 beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird diese Eigenschaft festgelegt.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
  </Members>
</Type>
