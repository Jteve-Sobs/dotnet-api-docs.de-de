<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f5aa225b69b444cb534e1070e69f68d9226ede50" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53221978" /></Metadata><TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Passt das Rendering für das abgeleitete Steuerelement an, an das der Adapter angefügt ist, um das Standardmarkup oder Standardverhalten für bestimmte Browser zu ändern, und ist die Basisklasse, die alle Steuerelementadapter erben.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelementadapter sind Komponenten, die bestimmte überschreiben <xref:System.Web.UI.Control> Klasse, Methoden und Ereignisse in dessen Lebenszyklus bei der Ausführung, die Browser- oder Markup-spezifische Verarbeitung zu ermöglichen. .NET Framework ordnet einen einzelnen abgeleiteten Steuerelementadapter zu einem <xref:System.Web.UI.Control> Objekt für jede Clientanforderung.  
  
 Ein Adapter ändert ein Steuerelement für einen bestimmten Browser bzw. der Browser oder fungiert als eine beliebige Filter für einige Funktionen. In der Regel wird der Adapter durch die Markupsprache definiert, die der Browser (z. B., XHTML oder HTML 3.2) verwendet. Ein Großteil der Renderingverhaltens kann gekapselt werden, in die speziellen aus abgeleiteten Klassen der <xref:System.Web.UI.HtmlTextWriter> Klasse. Daher ist es wahrscheinlich, dass ein einzelner Adapter für eine Reihe von Browserklassenverhalten oder diese Einbeziehung der Anpassungsfähigkeit beim verwendet werden kann die <xref:System.Web.UI.HtmlTextWriter> Klassen konnte, die Verwendung von einem ControlAdapter nicht erforderlich.  
  
 Ein Adapter für eine Steuerelementklasse gilt für alle Steuerelemente, die von dieser Klasse erben, es sei denn, spezialisiertere Adapter vorhanden sind. Z. B. einen Adapter für die <xref:System.Web.UI.WebControls.BaseValidator> Klasse kann verwendet werden, für alle `Validator` Objekte.  
  
 Adapter in der Regel erben nicht direkt von der <xref:System.Web.UI.Adapters.ControlAdapter> -Klasse, sondern eine des Adapters zielspezifische Basisklassen, die zusätzliche Funktionen, die spezifisch für das Steuerelement und den Browser an, oder das erforderliche Rendering.  
  
 Steuerelemente selbst ist einen Adapter nicht unbedingt erforderlich. Wenn bei der Zusammensetzung Steuerelemente erweitert werden, sind die untergeordneten Steuerelement-Adapter in der Regel ausreichend.  
  
 Jedes Steuerelement hat explizite Zuordnungen für Adapter über die Browser-Definitionsdateien. Daher wird bei jedem Zugriff auf die <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> Eigenschaft verwendet die <xref:System.Web.HttpBrowserCapabilities> Objekt aus die Browserdefinitionsdateien zum Ausführen der Suche nach der Zuordnung des Adapters zum Steuerelement extrahiert.  
  
 Während der Verarbeitung fängt das .NET Framework Aufrufe der überschreibbaren Methoden eines Steuerelements, die Ziel-spezifische sein kann. Wenn ein Steuerelementadapter angefügt ist, ruft der .NET Framework die zugehörigen Adapter-Methoden.  
  
 Der Adapter führt das Rendering für das Steuerelement über die <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> Methode. Wenn überschrieben, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> potenziell sollte nicht aufrufen, die basisklassenimplementierung da, die einen Aufruf an führt die <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> Methode. Dadurch kann das Rendering und einmal durch den Adapter und einmal vom Steuerelement auftreten.  
  
 Die <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> Methodenaufrufe auf Basis der <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> Methode des Steuerelements. Also, wenn Sie außer Kraft setzen <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, sollten Sie die basisklassenimplementierung nicht aufrufen, es sei denn, das Rendering, die Sie implementieren, die vom bereitgestellten <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> des Steuerelements.  
  
 Sie müssen sicherstellen, dass .NET Framework die Abfangfunktion für Adapter, der die untergeordneten Steuerelemente ausführt. Sie erreichen dies durch den Aufruf der <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> Basis-Methode, die Aufrufe der <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> Methode des Steuerelements aus Ihrer <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> außer Kraft setzen.  
  
 Die <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> und <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> Methoden werden vom Steuerelement aufgerufen, unmittelbar vor und nach (bzw.) das Steuerelement ruft die <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> Methode. Wenn Pre- und sind die einzige Browser-spezifischen Verarbeitung von Aufgaben erforderlich sind, mit <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> und <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> machen außerdem Änderungen überschreiben unnötig <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>. Das Standardverhalten der <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> und <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> Methoden ist, rufen Sie die entsprechenden Methoden für die <xref:System.Web.UI.HtmlTextWriter>.  
  
 Um die eigenen Statusinformationen zu gewährleisten, kann ein ControlAdapter überschreiben die <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, und <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> Methoden. <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, und <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> werden aufgerufen, wenn die private Steuerelement- und Ansichtszustands Status gespeichert und wird, bzw. geladen.  
  
 Die <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, und <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> Basis-Methoden zurück, in der entsprechenden <xref:System.Web.UI.Control> -Klassenmethoden. Daher keine dieser Optionen <xref:System.Web.UI.Adapters.ControlAdapter> Methoden, die überschrieben werden, müssen die Basismethoden aufrufen; andernfalls das Ereignis zugeordneten der <xref:System.Web.UI.Control> Klassenmethode wird nicht ausgelöst.  
  
 Steuerelemente und Adapter implementieren Sie optional die <xref:System.Web.UI.IPostBackDataHandler> und <xref:System.Web.UI.IPostBackEventHandler> Schnittstellen. .NET Framework bestimmt, ob ein Adapter vorhanden ist, und gibt an, ob der Adapter diese Schnittstellen implementiert. Wenn dies der Fall ist, sollte der Adapter überschreiben die <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, und <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> Methoden, nach Bedarf. Wenn die Daten im Adapter nicht erkannt werden, muss für das Steuerelement zur Verarbeitung wieder aufgerufen. Nachfolgende Ereignishandler müssen auch wieder auf das Steuerelement aufrufen.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Beim Erben von der <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> -Klasse, sollte ein Steuerelement, das allgemeine Adapterfunktionalität erfordert einen entsprechenden Adapter, die Basis-Klasse, mit dem Namen in das Muster haben <paramref name="ControlType" /> <see langword="Adapter" /> (z. B. <see langword="TextBoxAdapter" />). Der Adapter sollte mindestens zurückgeben eine stark typisierte Instanz des Steuerelements durch seine <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> Eigenschaft.  
  
1.  Steuerelementadapter für ein bestimmtes Steuerelement und eine angegebene Markupsprache, die im Muster benannt werden sollen <paramref name="MarkupControlType" /> <see langword="Adapter" /> (z. B. <see langword="XhtmlTextBoxAdapter" />). Adapter für ein Steuerelement implementiert werden ein <see langword="Adapters" /> Namespace.  
  
Steuerelementadapter aus der entsprechenden Basisklasse erben sollen, und führen Sie das gleiche Vererbungsmodell als das Steuerelement. Z. B. einen Adapter für ein Steuerelement, das erben von der <see cref="T:System.Web.UI.Control" /> Basisklasse erbt, von der <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> Klasse oder das entsprechende <paramref name="ControlType" /> <see langword="Adapter" /> Klasse.  
  
Alle für das spezielle Steuerelement unter allen Knoten Geräte im Configuration-Browser-Dateien definiert werden.  
  
Ein ordnungsgemäß implementiertes Steuerelement sollten nicht davon ausgehen, dass ein Adapter angefügt ist, oder der angefügten Adapter eine bestimmte Schnittstelle implementiert. Stattdessen sollten sie diese vor dem Aufruf überprüfen.  
  
Es ist möglich, simulieren Überschreibungsmethoden geschütztes Ereignis in das Steuerelement, z. B. die <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> Methode der <see cref="T:System.Web.UI.WebControls.LinkButton" />. Erstellen Sie zunächst eine Adapterklasse, die mit einem <c>OnClick</c> Methode. Erstellen Sie dann ein neues Steuerelement abgeleitet <see cref="T:System.Web.UI.WebControls.LinkButton" /> und überschreiben die <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> Methode. Die außer Kraft gesetzte <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> Methodenaufrufe der <c>OnClick</c> -Methode des Adapters. Der Hostnetzwerkadapter-Objekt steht über das geschützte <see cref="P:System.Web.UI.Control.Adapter" /> Eigenschaft der <see cref="T:System.Web.UI.Control" /> Klasse. Die <see cref="P:System.Web.UI.Control.Adapter" /> -Eigenschaft des Steuerelements ist <see langword="null" /> keine zugeordneten Adapter vorhanden ist, also keinen Code überprüfen beim für diese Bedingung vor dem Aufrufen von Methoden des Adapters.</para></block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.UI.Adapters.ControlAdapter" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework intern dieser Adapter erstellt, beim Erstellen der entsprechenden <xref:System.Web.UI.Control> Objekt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der <see cref="T:System.Web.UI.HtmlTextWriter" />, der Methoden für das Rendering der zielspezifischen Ausgabe enthält.</param>
        <summary>Wird vor dem Rendering eines Steuerelements aufgerufen. Generiert in einer abgeleiteten Adapterklasse öffnende Tags, die für ein bestimmtes Ziel erforderlich sind, von HTML-Browsern jedoch nicht benötigt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> Methode wird aufgerufen, kurz bevor die <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> -Methode und dient zum Ausführen der zielspezifische vorverarbeitung vor dem Rendern des Steuerelements.  
  
 Verwenden der <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> -Methode in Kombination mit der <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> Methode, um sicherzustellen, öffnen und schließen die Konsistenz.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Erben von der <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> -Klasse, die <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> -Basismethode ruft die <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> Methode. Daher überschreibungen der der <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> Methodenaufruf sollte die <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> Basis-Methode nur, wenn die Verarbeitung nicht anstelle von, sondern zusätzlich zu den <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> Methode.</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf die Browserfunktionen des Clients ab, durch den die aktuelle HTTP-Anforderung erfolgt.</summary>
        <value><see cref="T:System.Web.HttpBrowserCapabilities" /> mit den Angaben zu den Clientbrowser- und Markupfunktionen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Web.UI.Adapters.ControlAdapter> Objekt bestimmt die Browserfunktionen des Clients aus der <xref:System.Web.HttpBrowserCapabilities> von zurückgegebene Objekt der <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> Eigenschaft. Dies ermöglicht die <xref:System.Web.UI.Adapters.ControlAdapter> Objekts, das Browser-spezifisches Markup gerendert oder anderweitig ändern das Verhalten von der <xref:System.Web.UI.Control>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> Eigenschaft, um die Details der im anfordernden Browser zuzugreifen. In diesem Beispiel überprüft der Code um zu bestimmen, ob der Browser kompatibel mit JavaScript ist, und klicken Sie dann dem Entwickler ermöglicht, die in diesem Fall angepasste Ausgabe zu rendern.  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf das Steuerelement ab, an das dieser Steuerelementadapter angefügt ist.</summary>
        <value>Das <see cref="T:System.Web.UI.Control" />, an das <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> angefügt ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn auf ein Steuerelement ein abgeleiteten Steuerelementadapter angefügt ist, ruft der .NET Framework bestimmte Adaptermember anstelle der Elemente des Steuerelements.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein benutzerdefiniertes Steuerelement aus Ableiten der <xref:System.Web.UI.Control> Klasse, und erstellen Sie einen entsprechenden Adapter, die von erbt die <xref:System.Web.UI.Adapters.ControlAdapter> Klasse. Der Adapter überschreibt die <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> Eigenschaft und gibt einen stark typisierten Verweis auf das Steuerelement.  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Erben von der <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> -Klasse, implementieren Sie mindestens eine <see langword="Control" /> Eigenschaft, um eine stark typisierte Instanz des Steuerelements zurückzugeben, wie im Beispiel gezeigt.</para></block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt die zielspezifischen untergeordneten Steuerelemente für ein zusammengesetztes Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt es ein Adapter abgeleitete Steuerelement an angefügt eine <xref:System.Web.UI.Control> Objekt und die <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> -Methode überschrieben wird, die Außerkraftsetzung wird aufgerufen, statt die <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> Methode. Daher <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> können verwendet werden, um einen zielspezifischen untergeordneten Steuerelement-Satz zu erstellen.  
  
 Weitere Informationen zum Kombinieren von Steuerelementen zum Erstellen eines neuen Steuerelements finden Sie unter [zusammengesetzte Steuerelemente](https://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie eine erbende Klasse erstellen, und überschreiben die <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> -Methode, rufen Sie die Basismethode, wenn Sie diese Steuerelemente hinzufügen möchten, von der Basismethode erstellt. Andernfalls können Sie zwei Sätze von untergeordneten Steuerelementen erstellen.</para></block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der <see cref="T:System.Web.UI.HtmlTextWriter" />, der Methoden für das Rendering der zielspezifischen Ausgabe enthält.</param>
        <summary>Wird nach dem Rendering eines Steuerelements aufgerufen. Generiert in einer abgeleiteten Adapterklasse schließende Tags, die für ein bestimmtes Ziel erforderlich sind, von HTML-Browsern jedoch nicht benötigt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> Methode wird aufgerufen, unmittelbar nach der <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> -Methode und dient zum Ausführen von zielspezifische Nachbearbeitung nach dem Rendering des Steuerelements.  
  
 Verwenden der <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> -Methode in Kombination mit der <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> Methode, um sicherzustellen, öffnen und schließen die Konsistenz.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Erben von der <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> -Klasse, die <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> -Basismethode ruft die <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> Methode. Daher überschreibungen der der <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> Methodenaufruf sollte die <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> Basis-Methode nur, wenn die Verarbeitung nicht anstelle von, sondern zusätzlich zu den <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> Methode.</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Ein <see cref="T:System.Object" />, das die Steuerelementzustandsinformationen des Adapters als <see cref="T:System.Web.UI.StateBag" /> enthält.</param>
        <summary>Lädt Steuerelementzustandsinformationen des Adapters, die von <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> während einer vorherigen Anforderung der Seite, auf der sich das diesem Steuerelementadapter zugeordnete Steuerelement befindet, gespeichert wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelementzustand ist die wichtige Zustandsinformationen, die erforderlich sind, auch wenn der Ansichtszustand deaktiviert ist. Wenn ein Adapter eine eigene Informationen über den Steuerelementzustand beibehalten muss, können sie überschreiben die <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> und <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> Methoden.  
  
 Ein Adapter müssen für den Unterhalt Steuerelementzustandsinformationen stehen Funktionen, die Zustand beibehalten, die für Anforderungen, unabhängig vom Zustand des zugeordneten Steuerelements haben müssen. Z. B. eines zusammengesetzten Steuerelements mit einer großen Textanzeige und eine Gruppe von <xref:System.Web.UI.WebControls.RadioButton> Steuerelemente ggf. als einzelne Sicht auf desktopcomputerbrowser gerendert. Für andere Browser kann es sein Rendering - eine Ansicht der Textanzeige und die andere für die Optionsfeldgruppe unterteilt. Der Adapter müssen eine eigene zielspezifische Informationen über die derzeit aktive Ansicht zu verwalten.  
  
 Die <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> Methode wird aufgerufen, unmittelbar nach der <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> Methode in der `LoadState` Lebenszyklusphase. Zustand des Adapters ist getrennt, und es wird zusätzlich zu den Steuerelementzustand des Steuerelements.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Ein <see cref="T:System.Object" />, das die Adapteransichtszustandsinformationen als <see cref="T:System.Web.UI.StateBag" /> enthält.</param>
        <summary>Lädt Ansichtszustandsinformationen des Adapters, die von <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> während einer vorherigen Anforderung der Seite, auf der sich das diesem Steuerelementadapter zugeordnete Steuerelement befindet, gespeichert wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Adapter eine eigene Informationen zum Ansichtszustand beibehalten muss, können sie überschreiben die <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> und <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> Methoden.  
  
 Ein Adapter muss sich die Informationen zum Ansichtszustand beibehalten, wenn Daten, die für Anforderungen, unabhängig von den Ansichtszustand des zugeordneten Steuerelements beibehalten werden müssen. Beispielsweise kann ein Rastersteuerelement in desktop-PC-Browsern als eine einzige Ansicht der Zeilen und Spalten mit Werten gerendert. Für andere Browser kann es sein Rendering in mehrere separate Ansichten, z. B. eine Liste von Zeilen und Details zu einer einzelnen Zeile aufgeteilt. Der Adapter müssen die Daten für die Ansichten zu verwalten, die im Ansichtszustand nicht derzeit aktiv sind.  
  
 Die <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> Methode wird aufgerufen, unmittelbar bevor die <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> -Methode in der die `LoadState` Lebenszyklusphase. Der Ansichtszustand des Adapters ist getrennt, und es wird zusätzlich zu den Ansichtszustand des Steuerelements.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Überschreibt die <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />-Methode für das zugeordnete Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liegt ein Adapter angefügt, um eine <xref:System.Web.UI.Control> Objekt und die <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> -Methode überschrieben wird, das die Überschreibungsmethode heißt anstelle von der <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> Methode.  
  
 Außer Kraft setzen <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> auszuführenden spezifischen Verarbeitung in die `Initialize` Phasen des Steuerelementlebenszyklus. In der Regel sind diese Funktionen, die ausgeführt werden, wenn ein Steuerelement erstellt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird einen benutzerdefiniertes Steuerelement-Adapter aus abgeleitet der <xref:System.Web.UI.Adapters.ControlAdapter> Klasse. Klicken Sie dann überschreibt es die <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> Methode, um eine Eigenschaft des zugeordneten Steuerelements festlegen, und rufen Sie die Basismethode, um den Abschluss der Initialisierung des Steuerelements.  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Erben von der <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> -Klasse und die Adapter-Außerkraftsetzungen der <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> -Methode, muss der Adapter die entsprechende Basisklassenmethode, das wiederum aufruft Aufrufen der <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> Methode. Wenn die <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> Methode nicht aufgerufen wird, die <see cref="E:System.Web.UI.Control.Init" /> Ereignis nicht ausgelöst.</para></block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Überschreibt die <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />-Methode für das zugeordnete Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liegt ein Adapter angefügt, um eine <xref:System.Web.UI.Control> Objekt und die <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> -Methode überschrieben wird, das die Überschreibungsmethode heißt anstelle von der <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> Methode.  
  
 Überschreiben der <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> Methode zum Durchführen der spezifischen Verarbeitung in die `Load` Phasen des Steuerelementlebenszyklus. In der Regel sind diese Funktionen, die für jede Clientanforderung ausgeführt werden soll.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Erben von der <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> -Klasse und die Adapter-Außerkraftsetzungen der <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> -Methode, muss der Adapter die entsprechende Basisklassenmethode, das wiederum aufruft Aufrufen der <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> Methode. Wenn <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> nicht aufgerufen wird, die <see cref="E:System.Web.UI.Control.Load" /> Ereignis nicht ausgelöst.</para></block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Überschreibt die <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />-Methode für das zugeordnete Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liegt ein Adapter angefügt, um eine <xref:System.Web.UI.Control> Objekt und die <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> -Methode überschrieben wird, das die Überschreibungsmethode heißt anstelle von der <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> Methode.  
  
 Überschreiben der <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> Methode zum Durchführen der spezifischen Verarbeitung in die `PreRender` Phasen des Steuerelementlebenszyklus. In der Regel sind diese Funktionen, die unmittelbar vor der Darstellung der Ausgabe des Steuerelements.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Erben von der <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> -Klasse und die Adapter-Außerkraftsetzungen der <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> -Methode, muss der Adapter die entsprechende Basisklassenmethode, das wiederum aufruft Aufrufen der <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> Methode. Wenn die <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> Methode nicht aufgerufen wird, die <see cref="E:System.Web.UI.Control.PreRender" /> Ereignis nicht ausgelöst.</para></block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Überschreibt die <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />-Methode für das zugeordnete Steuerelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liegt ein Adapter angefügt, um eine <xref:System.Web.UI.Control> Objekt und die <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> -Methode überschrieben wird, das die Überschreibungsmethode heißt anstelle von der <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> Methode.  
  
 Überschreiben der <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> Methode, die Ziel-spezifische Verarbeitung die `Unload` Phasen des Steuerelementlebenszyklus. In der Regel sind dies die Bereinigungsfunktionen, die vor der Löschung des Steuerelements.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Erben von der <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> -Klasse und die Adapter-Außerkraftsetzungen der <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> -Methode, muss der Adapter die entsprechende Basisklassenmethode, das wiederum aufruft Aufrufen der <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> Methode. Wenn <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> nicht aufgerufen wird, die <see cref="E:System.Web.UI.Control.Unload" /> Ereignis nicht ausgelöst.</para></block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf die Seite ab, auf der sich das diesem Adapter zugeordnete Steuerelement befindet.</summary>
        <value>Eine <see cref="T:System.Web.UI.Page" />, die den Zugriff auf die Instanz der Seite ermöglicht, auf der sich das zugeordnete Steuerelement befindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> Eigenschaft bietet Zugriff auf die <xref:System.Web.UI.Page?displayProperty=nameWithType> Objekt, in dem das Steuerelement befindet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf den Seitenadapter für die Seite ab, auf der sich das zugeordnete Steuerelement befindet.</summary>
        <value>Ein <see cref="T:System.Web.UI.Adapters.PageAdapter" /> für die Seite, auf der sich das dem aktuellen <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> zugeordnete Steuerelement befindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> Eigenschaft bietet Zugriff auf die <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> -Objekt für die <xref:System.Web.UI.Page> Objekt, in denen die <xref:System.Web.UI.Control> Objekt verknüpft ist, mit dem aktuellen <xref:System.Web.UI.Adapters.ControlAdapter> Objekt befindet.  
  
 Die <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> Eigenschaft kann verwendet werden, Zugriff auf andere Elemente auf Seitenadapterebene, wie z. B. allgemeine Ziel-spezifische Funktionen, die auf verschiedene Steuerelement auf der Seite anwenden könnten.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der für das Rendering der zielspezifischen Ausgabe zu verwendende <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <summary>Generiert das zielspezifische Markup für das Steuerelement, an das der Steuerelementadapter angefügt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben der <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> Methode, um das zielspezifische Markup zum Senden an den Clientbrowser zu generieren. Die <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> Methode wird aufgerufen, anstelle von der <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> Methode Wenn eine <xref:System.Web.UI.Adapters.ControlAdapter> Objekt angefügt ist eine <xref:System.Web.UI.Control> Objekt.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Erben von der <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> -Klasse, die <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> -Basismethode ruft die <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> Methode. Daher überschreibungen der der <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> Methodenaufruf sollte die <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> Basis-Methode nur, wenn die Verarbeitung nicht anstelle von, sondern zusätzlich zu den <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> Methode.  
  
Für ein zusammengesetztes Steuerelement ist muss der Adapterentwickler sicherstellen, dass die untergeordneten Steuerelemente gerendert werden. Wenn die <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> Methode bewirkt, dass die untergeordneten Steuerelemente gerendert werden, aber kein Markup generiert, möglicherweise für die <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> Methode, um die Basismethode aufrufen. Wenn das Rendering der zielspezifischen untergeordneten Steuerelemente erforderlich ist, sollte der Adapter implementiert die <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> Methode, und rufen die <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> Methode aus der <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> Methode.</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der für das Rendering der zielspezifischen Ausgabe zu verwendende <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <summary>Generiert das zielspezifische Markup für die untergeordneten Steuerelemente in einem zusammengesetzten Steuerelement, an das der Steuerelementadapter angefügt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben der <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> Methode, wenn zum Generieren von zielspezifische Markup für die Gruppe der untergeordneten Steuerelemente eines zusammengesetzten Steuerelements darüber hinaus das Markup für die einzelnen untergeordneten Steuerelemente erforderlich ist.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Erben von der <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> -Klasse, bei einem zusammengesetzten Steuerelement der Adapterentwickler muss sicherstellen, dass die untergeordneten Steuerelemente gerendert werden. Wenn der Adapter überschreibt die <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> -Methode, die sie aufrufen sollten die <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> eine Überschreibung der Methode die <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> Methode.  
  
Wenn die <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> Methode bewirkt, dass die untergeordneten Steuerelemente gerendert werden, aber kein Markup generiert, es kann zweckmäßig für sein der <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> Methode, um die Basismethode aufrufen, die Aufrufe der <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> anstelle eines implementieren eine Außerkraftsetzung für die <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> Methode.</para></block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert Steuerelementzustandsinformationen für den Steuerelementadapter.</summary>
        <returns>Ein <see cref="T:System.Object" />, das die Steuerelementzustandsinformationen des Adapters als <see cref="T:System.Web.UI.StateBag" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelementzustand ist die wichtige Zustandsinformationen, die erforderlich sind, auch wenn der Ansichtszustand deaktiviert ist. Wenn ein Adapter eine eigene Informationen über den Steuerelementzustand beibehalten muss, können sie überschreiben die <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> und <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> Methoden.  
  
 Ein Adapter müssen für den Unterhalt Steuerelementzustandsinformationen stehen Funktionen, die Zustand beibehalten, die für Anforderungen, unabhängig vom Zustand des zugeordneten Steuerelements haben müssen. Z. B. eines zusammengesetzten Steuerelements mit einer großen Textanzeige und eine Gruppe von <xref:System.Web.UI.WebControls.RadioButton> Steuerelemente ggf. als einzelne Sicht auf desktopcomputerbrowser gerendert. Für andere Browser kann es sein Rendering - eine Ansicht der Textanzeige und die andere für die Optionsfeldgruppe unterteilt. Der Adapter müssen eine eigene zielspezifische Informationen über die derzeit aktive Ansicht zu verwalten.  
  
 Die <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> Methode wird aufgerufen, unmittelbar nach der <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> -Methode in der die `SaveState` Lebenszyklusphase. Zustand des Adapters ist getrennt, und es wird zusätzlich zu den Steuerelementzustand des Steuerelements.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert Ansichtszustandsinformationen für den Steuerelementadapter.</summary>
        <returns>Ein <see cref="T:System.Object" />, das die Adapteransichtszustandsinformationen als <see cref="T:System.Web.UI.StateBag" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Adapter eine eigene Informationen zum Ansichtszustand beibehalten muss, können sie überschreiben die <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> und <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> Methoden.  
  
 Ein Adapter muss sich die Informationen zum Ansichtszustand beibehalten, wenn Daten, die für Anforderungen, unabhängig von der zugeordneten Ansichtszustand des Steuerelements beibehalten werden müssen. Beispielsweise kann ein Rastersteuerelement in desktop-PC-Browsern als eine einzige Ansicht der Zeilen und Spalten mit Werten gerendert. Für andere Browser kann es sein Rendering in mehrere separate Ansichten, z. B. eine Liste von Zeilen und Details zu einer einzelnen Zeile aufgeteilt. Der Adapter müssen die Daten für die Ansichten zu verwalten, die im Ansichtszustand nicht derzeit aktiv sind.  
  
 Die <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> Methode wird aufgerufen, unmittelbar bevor die <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> -Methode in der die `SaveState` Lebenszyklusphase. Der Ansichtszustand des Adapters ist getrennt, und es wird zusätzlich zu den Ansichtszustand des Steuerelements.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>