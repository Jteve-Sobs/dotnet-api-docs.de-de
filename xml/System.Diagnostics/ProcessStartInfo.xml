<Type Name="ProcessStartInfo" FullName="System.Diagnostics.ProcessStartInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c8f1ccd8bea734c57d532d5c8554d083d648c4f1" />
    <Meta Name="ms.sourcegitcommit" Value="22c9818dc4a11ae279d13a36bc98a3c6852e9316" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/20/2018" />
    <Meta Name="ms.locfileid" Value="39169329" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ProcessStartInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ProcessStartInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessStartInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ProcessStartInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessStartInfo sealed" />
  <TypeSignature Language="F#" Value="type ProcessStartInfo = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gibt eine Wertemenge an, die beim Starten eines Prozesses verwendet wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessStartInfo> dient zusammen mit den <xref:System.Diagnostics.Process> Komponente. Wenn Sie starten einen Prozess mit der <xref:System.Diagnostics.Process> -Klasse, haben Sie Zugriff auf die verfügbaren Informationen zu verarbeiten, beim Anfügen an einen laufenden Prozess.  
  
 Sie können die <xref:System.Diagnostics.ProcessStartInfo> -Klasse für eine bessere Kontrolle über den Prozess, die Sie starten. Sie müssen mindestens festlegen, die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft muss entweder manuell oder mithilfe des Konstruktors. Der Dateiname ist Anwendung oder ein Dokument. Hier ist ein Dokument definiert, um einen beliebigen Dateityp, die eine offene oder Standardaktion zugeordnet. Sie können registrierte Dateitypen und der zugehörigen Anwendung für den Computer anzeigen, indem Sie mit der **Ordneroptionen** dieses Dialogfeld wird über das Betriebssystem verfügbar ist. Die **erweitert** Schaltfläche führt zu einem Dialogfeld, das anzeigt, ob eine open-Aktion einen bestimmten registrierten Dateityp zugeordnet ist.  
  
 Darüber hinaus können Sie andere Eigenschaften festlegen, die Aktionen an, die mit dieser Datei zu definieren. Geben Sie einen Wert, der spezifisch für den Typ des der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> -Eigenschaft für die <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Eigenschaft. Beispielsweise können Sie angeben, "print" für eine "Document". Darüber hinaus können Sie angeben <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Eigenschaftswerte an die Befehlszeilenargumente an der Datei öffnen-Prozedur übergeben werden. Angenommen, Sie geben Sie eine Text-Editor-Anwendung in der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> -Eigenschaft, die Sie verwenden die <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> -Eigenschaft an eine Textdatei, die vom Editor geöffnet werden.  
  
 Standardeingabe wird in der Regel die Tastatur, und die Standardausgabe und Standardfehler sind in der Regel auf dem Bildschirm überwachen. Sie können jedoch die <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>, und <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> Eigenschaften, die dazu führen, dass der Vorgang zum Abrufen von Eingabe oder Ausgabe an eine Datei oder einem anderen Gerät zurückgegeben. Bei Verwendung der <xref:System.Diagnostics.Process.StandardInput%2A>, <xref:System.Diagnostics.Process.StandardOutput%2A>, oder <xref:System.Diagnostics.Process.StandardError%2A> Eigenschaften für die <xref:System.Diagnostics.Process> -Komponente, Sie müssen zuerst den entsprechenden Wert für Festlegen der <xref:System.Diagnostics.ProcessStartInfo> Eigenschaft. Andernfalls löst das System eine Ausnahme beim Lesen oder in den Stream schreiben.  
  
 Legen Sie die <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Eigenschaft, um anzugeben, ob den Prozess gestartet wird, mit der Shell des Betriebssystems. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> nastaven NA hodnotu `false`, erbt der neue Prozess die Standardeingabe, Standard für die Ausgabe und Standardfehlerstreams der aufrufenden zu verarbeiten, es sei denn, die <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>, oder <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> Eigenschaften, bzw. festgelegt werden `true`. 
  
 Sie können den Wert eines beliebigen ändern <xref:System.Diagnostics.ProcessStartInfo> Eigenschaft bis zum Zeitpunkt der Prozess gestartet wird. Nachdem der Prozess gestartet wurde, hat das Ändern dieser Werte keine Auswirkungen.  
  
> [!NOTE]
>  Diese Klasse enthält einen Linkaufruf auf Klassenebene, die für alle Elemente gilt. Ein <xref:System.Security.SecurityException> wird ausgelöst, wenn der direkte Aufrufer keine Berechtigung mit vollständiger Vertrauenswürdigkeit. Weitere Informationen zu sicherheitsanforderungen, finden Sie unter [Verknüpfungsaufrufe](~/docs/framework/misc/link-demands.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Diagnostics.ProcessStartInfo> Klasse, um das Starten von Internet Explorer, und die Ziel-URLs als <xref:System.Diagnostics.ProcessStartInfo> Argumente.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von Membern <see cref="T:System.Diagnostics.ProcessStartInfo" />. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; [NIB: benannte Berechtigungssätze](http://msdn.microsoft.com/library/08250d67-c99d-4ab0-8d2b-b0e12019f6e3): <see langword="FullTrust" />.</permission>
    <altmember cref="T:System.Diagnostics.Process" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.ProcessStartInfo" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.ProcessStartInfo" />-Klasse, ohne einen Dateinamen anzugeben, mit dem der Prozess gestartet werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen festlegen, mindestens die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft, bevor Sie den Prozess starten. Der Dateiname ist Anwendung oder ein Dokument. In diesem Fall wird ein Dokument definiert, um einen beliebigen Dateityp, die eine offene oder Standardaktion zugeordnet. Sie können registrierte Dateitypen und der zugehörigen Anwendung für den Computer anzeigen, indem Sie mit der **Ordneroptionen** dieses Dialogfeld wird über das Betriebssystem verfügbar ist. Die **erweitert** Schaltfläche führt zu einem Dialogfeld, das anzeigt, ob eine open-Aktion einen bestimmten registrierten Dateityp zugeordnet ist.  
  
 Optional können Sie auch andere Eigenschaften festlegen, bevor Sie den Prozess starten. Die <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Eigenschaft stellt Aktionen bereit, z. B. "Drucken", mit der angegebenen Datei dem <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft. Die <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Eigenschaft bietet die Möglichkeit, auf die Datei Befehlszeilenargumente übergeben werden, wenn das System geöffnet wird.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.ProcessStartInfo : string -&gt; System.Diagnostics.ProcessStartInfo" Usage="new System.Diagnostics.ProcessStartInfo fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Eine Anwendung oder ein Dokument, mit der bzw. dem ein Prozess gestartet wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.ProcessStartInfo" />-Klasse und gibt einen Dateinamen an, mit dem der Prozess gestartet werden soll, z. B. eine Anwendung oder ein Dokument.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Dateiname ist Anwendung oder ein Dokument. In diesem Fall wird ein Dokument definiert, um einen beliebigen Dateityp, die eine offene oder Standardaktion zugeordnet. Sie können registrierte Dateitypen und der zugehörigen Anwendung für den Computer anzeigen, indem Sie mit der **Ordneroptionen** dieses Dialogfeld wird über das Betriebssystem verfügbar ist. Die **erweitert** Schaltfläche führt zu einem Dialogfeld, das anzeigt, ob eine open-Aktion einen bestimmten registrierten Dateityp zugeordnet ist.  
  
 Sie können ändern, die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft nach dem Aufrufen dieses Konstruktors, bis zum Zeitpunkt der Prozess gestartet wird. Nachdem der Prozess gestartet wurde, hat das Ändern dieser Werte keine Auswirkungen.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, arguments As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.ProcessStartInfo : string * string -&gt; System.Diagnostics.ProcessStartInfo" Usage="new System.Diagnostics.ProcessStartInfo (fileName, arguments)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Eine Anwendung, mit der ein Prozess gestartet wird.</param>
        <param name="arguments">Befehlszeilenargumente, die beim Starten des Prozesses an die Anwendung übergeben werden sollen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.ProcessStartInfo" />-Klasse und gibt einen Anwendungsdateinamen an, mit dem der Prozess gestartet wird, sowie einen Satz von Befehlszeilenargumenten, die an die Anwendung übergeben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Dateiname ist Anwendung oder ein Dokument. In diesem Fall wird ein Dokument definiert, um einen beliebigen Dateityp, die eine offene oder Standardaktion zugeordnet. Sie können registrierte Dateitypen und der zugehörigen Anwendung für den Computer anzeigen, indem Sie mit der **Ordneroptionen** dieses Dialogfeld wird über das Betriebssystem verfügbar ist. Die **erweitert** Schaltfläche führt zu einem Dialogfeld, das anzeigt, ob eine open-Aktion einen bestimmten registrierten Dateityp zugeordnet ist.  
  
 Sie können ändern, die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> oder <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Eigenschaften aufzurufen, nachdem Sie diesen Konstruktor, bis zum Zeitpunkt der Prozess gestartet wird. Nachdem der Prozess gestartet wurde, hat das Ändern dieser Werte keine Auswirkungen.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ArgumentList">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; ArgumentList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; ArgumentList" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ArgumentList" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArgumentList As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ ArgumentList { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ArgumentList : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.Diagnostics.ProcessStartInfo.ArgumentList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Arguments">
      <MemberSignature Language="C#" Value="public string Arguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Arguments" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Arguments" />
      <MemberSignature Language="VB.NET" Value="Public Property Arguments As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Arguments { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Arguments : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.Arguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Command line arguments that will be passed to the application specified by the FileName property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Satz von Befehlszeilenargumenten ab, die beim Starten der Anwendung verwendet werden sollen, oder legt diesen fest.</summary>
        <value>Eine einzelne Zeichenfolge, die die Argumente enthält, die an die in der <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft angegebene Zielanwendung übergeben werden sollen. Der Standardwert ist eine leere Zeichenfolge (""). Unter Windows Vista und früheren Versionen des Windows-Betriebssystems muss die Länge der Argumente, die der Länge des vollständigen Pfads des Prozesses hinzugefügt werden, kleiner sein als 2080. Unter Windows 7 und höheren Versionen muss die Länge kleiner als 32699 sein.  Argumente werden von der Zielanwendung analysiert und interpretiert und müssen daher den Erwartungen der betreffenden Anwendung entsprechen. Bei .NET-Anwendungen, wie sie in den Beispielen unten dargestellt sind, werden Leerzeichen als Trennzeichen zwischen Argumenten interpretiert. Ein einzelnes Argument, das Leerzeichen enthält, muss in Anführungszeichen eingeschlossen sein, diese Anführungszeichen werden jedoch nicht an die Zielanwendung übergeben. Eingeschlossene Anführungszeichen, die in das endgültige analysierte Argument aufgenommen werden sollen, müssen dreifach escaped werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das erste Beispiel unten wird eine kleine Anwendung (argsecho.exe) erstellt, ausgegeben sein Argument an die Konsole. Im zweite Beispiel erstellt eine Anwendung, die argsecho.exe zur Veranschaulichung der verschiedenen Varianten für die Eigenschaft Argumente aufruft.  
  
 [!code-cpp[Process.Start_static#3](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#3)]
 [!code-csharp[Process.Start_static#3](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#3)]
 [!code-vb[Process.Start_static#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#3)]  
  
 [!code-cpp[Process.Start_static#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#2)]
 [!code-csharp[Process.Start_static#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#2)]
 [!code-vb[Process.Start_static#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNoWindow">
      <MemberSignature Language="C#" Value="public bool CreateNoWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CreateNoWindow" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.CreateNoWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property CreateNoWindow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CreateNoWindow { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CreateNoWindow : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.CreateNoWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to start the process without creating a new window to contain it.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Prozess in einem neuen Fenster gestartet werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn der Prozess ohne Erstellung eines neuen, für ihn bestimmten Fensters gestartet werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> -Eigenschaft ist `true` oder <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> und <xref:System.Diagnostics.ProcessStartInfo.Password%2A> Eigenschaften sind nicht `null`, <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> Eigenschaftswert wird ignoriert, und ein neues Fenster erstellt wird.  

 .NET Core unterstützt nicht das Erstellen von Windows direkt auf Unix-ähnlichen-Plattformen, einschließlich MacOS und Linux. Diese Eigenschaft wird auf diese Plattformen ignoriert.
  
   
  
## Examples  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public string Domain { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Domain { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Domain : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Domäne kennzeichnet, die beim Starten des Prozesses verwendet werden soll, oder legt diesen fest. Wenn dieser Wert <see langword="null" /> ist, muss die <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" />-Eigenschaft im UPN-Format angegeben werden.</summary>
        <value>Die Active Directory-Domäne, die beim Starten des Prozesses verwendet werden soll. Wenn dieser Wert <see langword="null" /> ist, muss die <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" />-Eigenschaft im UPN-Format angegeben werden.</value>
        <remarks>Diese Eigenschaft ist in erster Linie für Benutzer von Interesse in unternehmensumgebungen, in denen Active Directory verwenden.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Environment">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; Environment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; Environment" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Environment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Environment As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ Environment { System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Environment : System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="System.Diagnostics.ProcessStartInfo.Environment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Umgebungsvariablen ab, die für diesen Prozess und seine untergeordneten Prozesse gelten.</summary>
        <value>Ein generisches Wörterbuch, das die Umgebungsvariablen enthält, die für diesen Prozess und seine untergeordneten Prozesse gelten. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Umgebungsvariablen werden Suchpfade für Dateien, Verzeichnisse für temporäre Dateien, anwendungsspezifische Optionen und andere ähnliche Informationen enthalten. Obwohl Sie direkt festlegen können nicht die <xref:System.Diagnostics.ProcessStartInfo.Environment%2A> -Eigenschaft, können Sie das generische Wörterbuch, das von der Eigenschaft zurückgegebenen ändern. Der folgende Code fügt z. B. eine TEMP-Umgebungsvariable: `myProcess.StartInfo.Environment.Add("TempPath", "C:\\Temp")`.  Sie müssen festlegen, der <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Eigenschaft `false` zum Starten des Prozesses nach dem Ändern der <xref:System.Diagnostics.ProcessStartInfo.Environment%2A> Eigenschaft. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true`, <xref:System.InvalidOperationException> wird ausgelöst, wenn die <xref:System.Diagnostics.Process.Start%2A> Methode wird aufgerufen.  
  
 In .NET Framework-Anwendungen mithilfe der <xref:System.Diagnostics.ProcessStartInfo.Environment%2A> Eigenschaft ist identisch mit der <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="EnvironmentVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.StringDictionary EnvironmentVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.StringDictionary EnvironmentVariables" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EnvironmentVariables As StringDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::StringDictionary ^ EnvironmentVariables { System::Collections::Specialized::StringDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnvironmentVariables : System.Collections.Specialized.StringDictionary" Usage="System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.StringDictionaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Set of environment variables that apply to this process and child processes.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.StringDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Suchpfade für Dateien, Verzeichnisse für temporäre Dateien, anwendungsspezifische Optionen und andere ähnliche Informationen ab.</summary>
        <value>Ein Zeichenfolgenwörterbuch, das Umgebungsvariablen für diesen Prozess und untergeordnete Prozesse bereitstellt. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl Sie nicht festlegen können die <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> -Eigenschaft, die Sie ändern die <xref:System.Collections.Specialized.StringDictionary> von der Eigenschaft zurückgegebenen. Der folgende Code fügt z. B. eine TEMP-Umgebungsvariable: `myProcess.StartInfo.EnvironmentVariables.Add("TempPath", "C:\\Temp")`.  Sie müssen festlegen, der <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Eigenschaft `false` zum Starten des Prozesses nach dem Ändern der <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> Eigenschaft. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true`, <xref:System.InvalidOperationException> wird ausgelöst, wenn die <xref:System.Diagnostics.Process.Start%2A> Methode wird aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorDialog">
      <MemberSignature Language="C#" Value="public bool ErrorDialog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ErrorDialog" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ErrorDialog" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorDialog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ErrorDialog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ErrorDialog : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.ErrorDialog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to show an error dialog to the user if there is an error.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dem Benutzer ein Fehlerdialogfeld angezeigt wird, wenn der Prozess nicht gestartet werden kann, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn auf dem Bildschirm ein Fehlerdialogfeld angezeigt werden soll, wenn der Prozess nicht gestartet werden kann, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> muss `true` , wenn Sie festlegen möchten <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> zu `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorDialogParentHandle">
      <MemberSignature Language="C#" Value="public IntPtr ErrorDialogParentHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ErrorDialogParentHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorDialogParentHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ErrorDialogParentHandle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ErrorDialogParentHandle : nativeint with get, set" Usage="System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Fensterhandle ab, das beim Anzeigen eines Fehlerdialogfelds für einen fehlgeschlagenen Prozessstart verwendet wird, oder legt dieses fest.</summary>
        <value>Ein Zeiger auf das Handle des Fehlerdialogfelds, das aus einem fehlerhaften Prozessstart resultiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> ist `true`, <xref:System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle%2A> Eigenschaft gibt an, das übergeordnete Fenster für das Dialogfeld, das angezeigt wird. Es ist hilfreich, geben Sie ein übergeordnetes Element, um das Dialogfeld vor der Anwendung zu halten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FileName">
      <MemberSignature Language="C#" Value="public string FileName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.FileName" />
      <MemberSignature Language="VB.NET" Value="Public Property FileName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FileName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FileName : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.FileName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.StartFileNameEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the application, document or URL to start.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die zu startende Anwendung oder das zu startende Dokument ab oder legt die Anwendung bzw. das Dokument fest.</summary>
        <value>Der Name der zu startenden Anwendung oder der Dokumentname eines einer Anwendung zugeordneten Dateityps, für den eine Standard-Öffnen-Aktion verfügbar ist. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen festlegen, mindestens die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft, bevor Sie den Prozess starten. Der Dateiname ist Anwendung oder ein Dokument. Ein Dokument wird definiert, um einen beliebigen Dateityp, die eine offene oder Standardaktion zugeordnet. Sie können registrierte Dateitypen und der zugehörigen Anwendung für den Computer anzeigen, indem Sie mit der **Ordneroptionen** dieses Dialogfeld wird über das Betriebssystem verfügbar ist. Die **erweitert** Schaltfläche führt zu einem Dialogfeld, das anzeigt, ob eine open-Aktion einen bestimmten registrierten Dateityp zugeordnet ist.  
  
 Der Satz von Dateitypen, die Ihnen zur Verfügung, richtet sich teilweise auf dem Wert der <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Eigenschaft. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true`, Sie können jedes Dokument und Ausführen von Vorgängen für die Datei, z. B. drucken, mit der <xref:System.Diagnostics.Process> Komponente. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `false`, können Sie nur ausführbare Dateien mit starten die <xref:System.Diagnostics.Process> Komponente.  
  
 Sie können eine ClickOnce-Anwendung starten, indem die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft, um den Speicherort (z. B. eine Webadresse), von dem Sie die Anwendung ursprünglich installiert haben. Starten Sie eine ClickOnce-Anwendung nicht durch Angabe der entsprechenden Speicherort auf Ihrer Festplatte.  
  
   
  
## Examples  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadUserProfile">
      <MemberSignature Language="C#" Value="public bool LoadUserProfile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadUserProfile" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.LoadUserProfile" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadUserProfile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LoadUserProfile { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LoadUserProfile : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.LoadUserProfile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Windows-Benutzerprofil aus der Registrierung geladen werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn das Windows-Benutzerprofil geladen werden soll; andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird verwiesen, wenn der Prozess gestartet wird, mit dem Benutzernamen, Kennwort und Domäne.  
  
 Wenn der Wert ist `true`, das Profil des Benutzers in der `HKEY_USERS` Registrierungsschlüssel wird geladen. Laden das Profil kann sehr zeitaufwendig sein. Es wird daher empfohlen, diesen Wert verwenden, nur dann, wenn Sie die Informationen in zugreifen müssen die `HKEY_CURRENT_USER` Registrierungsschlüssel.  
  
 In Windows Server 2003 und Windows 2000 ist das Profil entladen, nachdem der neue Prozess beendet wurde, unabhängig davon, ob der untergeordnete Prozesse erstellt wurde.  
  
 In Windows XP das Profil wird entladen, nachdem der neue Prozess aus, und alle untergeordneten Prozesse, die von die ihm erstellten wurde beendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Password">
      <MemberSignature Language="C#" Value="public System.Security.SecureString Password { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.SecureString Password" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Password" />
      <MemberSignature Language="VB.NET" Value="Public Property Password As SecureString" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::SecureString ^ Password { System::Security::SecureString ^ get(); void set(System::Security::SecureString ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Password : System.Security.SecureString with get, set" Usage="System.Diagnostics.ProcessStartInfo.Password" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecureString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine sichere Zeichenfolge ab, die das Benutzerkennwort enthält, das beim Starten des Prozesses verwendet werden soll, oder legt diese fest.</summary>
        <value>Das beim Starten des Prozesses zu verwendende Kennwort.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Die <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Eigenschaft muss festgelegt werden, wenn <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> und <xref:System.Diagnostics.ProcessStartInfo.Password%2A> bereitgestellt werden. Wenn die Eigenschaft nicht festgelegt ist, ist das standardmäßige Arbeitsverzeichnis % SYSTEMROOT%\system32 an.  
  
> [!NOTE]
>  Festlegen der <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, und die <xref:System.Diagnostics.ProcessStartInfo.Password%2A> Eigenschaften in einem <xref:System.Diagnostics.ProcessStartInfo> Objekt ist die empfohlene Vorgehensweise für das Starten eines Prozesses mit Anmeldeinformationen des Benutzers.  
  
 Ein <xref:System.Security.SecureString> -Objekt ähnelt einer <xref:System.String> Objekt, dass es sich um einen Textwert besitzt. Allerdings den Wert des einem <xref:System.Security.SecureString> Objekt wird automatisch verschlüsselt und kann geändert werden kann, bis der Anwendung als schreibgeschützt markiert und von Ihrer Anwendung oder der .NET Framework-Garbagecollector aus dem Computerspeicher gelöscht werden kann.  
  
 Weitere Informationen zu sicheren Zeichenfolgen und verdeutlicht, wie Sie ein Kennwort zum Festlegen dieser Eigenschaft zu erhalten, finden Sie unter den <xref:System.Security.SecureString> Klasse.  
  
> [!NOTE]
>  Wenn Sie einen Wert für die <xref:System.Diagnostics.ProcessStartInfo.Password%2A> -Eigenschaft, die <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> -Eigenschaft muss sein `false`, oder ein <xref:System.InvalidOperationException> ausgelöst, wenn die <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> Methode wird aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PasswordInClearText">
      <MemberSignature Language="C#" Value="public string PasswordInClearText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PasswordInClearText" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.PasswordInClearText" />
      <MemberSignature Language="VB.NET" Value="Public Property PasswordInClearText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PasswordInClearText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PasswordInClearText : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.PasswordInClearText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen des unverschlüsselten Benutzerkennworts, das beim Starten des Prozesses verwendet werden soll.</summary>
        <value>Das unverschlüsselte Benutzerkennwort.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardError">
      <MemberSignature Language="C#" Value="public bool RedirectStandardError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectStandardError : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process's error output is written to the Process instance's StandardError member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Fehlerausgabe einer Anwendung in den <see cref="P:System.Diagnostics.Process.StandardError" />-Datenstrom geschrieben wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die Fehlerausgabe in <see cref="P:System.Diagnostics.Process.StandardError" /> geschrieben werden soll; andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Diagnostics.Process> schreibt Text in der Standardfehlerstream, dass Text in der Regel in der Konsole angezeigt wird. Durch das Umleiten der <xref:System.Diagnostics.Process.StandardError%2A> Stream können Sie bearbeiten oder die Fehlerausgabe eines Prozesses zu unterdrücken. Sie können z. B. den Text zu filtern, anders formatieren oder Schreiben der Ausgabe in der Konsole und einer angegebenen Protokolldatei.  
  
> [!NOTE]
>  Sie müssen festlegen, <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> zu `false` , wenn Sie festlegen möchten <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> zu `true`. Andernfalls Lesen aus der <xref:System.Diagnostics.Process.StandardError%2A> Datenstrom löst eine Ausnahme aus.  
  
 Im umgeleiteten <xref:System.Diagnostics.Process.StandardError%2A> Stream synchron oder asynchron gelesen werden kann. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A> und <xref:System.IO.StreamReader.ReadToEnd%2A> synchrone Lesevorgänge den Fehlerausgabestream des Prozesses führen. Diese synchrone gelesen, bis der zugeordneten Vorgänge nicht vollständig <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardError%2A> streamen oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> startet asynchrone Lesevorgänge auf dem <xref:System.Diagnostics.Process.StandardError%2A> Stream. Diese Methode ermöglicht es einen angegebenen Ereignishandler für die Streamausgabe und gibt sofort zurück, an den Aufrufer und der andere Aufgaben durchführen kann, während die Streamausgabe an den Ereignishandler geleitet wird.  
  
> [!NOTE]
>  Die Anwendung, die die asynchrone Ausgabe verarbeitet aufrufen, sollte die <xref:System.Diagnostics.Process.WaitForExit%2A> Methode, um sicherzustellen, dass der Ausgabepuffer geleert wurde.  
  
 Synchrone Lesevorgänge verursachen eine Abhängigkeit zwischen dem Aufrufer, die beim Lesen aus der <xref:System.Diagnostics.Process.StandardError%2A> Stream und dem untergeordneten Element verarbeitet das Schreiben in den Stream. Diese Abhängigkeiten können dazu führen, dass Deadlock-Bedingungen. Wenn der Aufrufer aus dem umgeleiteten Stream von einem untergeordneten Prozess liest, ist es das untergeordnete Element abhängig. Der Aufrufer wartet den Lesevorgang, bis das untergeordnete Element in den Stream schreibt oder den Stream schließt. Wenn der untergeordnete Prozess genügend Daten zum Füllen von seinen umgeleiteten-Streams schreibt, ist es vom übergeordneten Element abhängig. Der untergeordnete Prozess wartet der nächste Schreibvorgang, bis das übergeordnete Element aus der vollständige Stream gelesen oder den Stream schließt. Die Deadlockbedingung entsteht, wenn es sich bei dem Aufrufer und dem untergeordneten Prozess, der jeweils anderen zum Abschließen eines Vorgangs warten, und wenn keines von beiden. Sie können Deadlocks vermeiden, durch die Auswertung der Abhängigkeiten zwischen dem Aufrufer und dem untergeordneten Prozess.  
  
 Der folgende C#-Code zeigt beispielsweise das Lesen aus einem Datenstrom umgeleitet und warten Sie, bis des untergeordnete Prozess zu beenden.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 Im Codebeispiel wird eine Deadlockbedingung vermieden, durch den Aufruf `p.StandardError.ReadToEnd` vor `p.WaitForExit`. Eine Deadlock-Bedingung kann dazu führen, wenn das übergeordnete Element Aufrufe verarbeiten `p.WaitForExit` vor `p.StandardError.ReadToEnd` und der untergeordneten Prozess genug Text zum Ausfüllen des umgeleiteten Streams schreibt. Der übergeordnete Prozess würde für den untergeordneten Prozess zu beenden, unbegrenzt warten. Der untergeordnete Prozess würde auf unbestimmte Zeit warten, für das übergeordnete Element zum Lesen aus der vollständigen <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Es ist ein ähnliches Problem auf, wenn es sich bei Sie gesamten Text sowohl die Standardausgabe und Standardfehlerstreams gelesen werden. Beispielsweise führt der folgende C#-Code einen Lesevorgang für beide Streams.  
  
```csharp  
// Do not perform a synchronous read to the end of both  
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 Im Codebeispiel wird die Deadlockbedingung vermieden, indem asynchrone Lesevorgänge auf dem <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Eine Deadlock-Bedingung führt, wenn das übergeordnete Element Aufrufe verarbeiten `p.StandardOutput.ReadToEnd` gefolgt von `p.StandardError.ReadToEnd` und der untergeordneten Prozess schreibt genug Text zum Fehlerstreams zu füllen. Der übergeordnete Prozess würde auf unbestimmte Zeit warten, für den untergeordneten Prozess zu schließen die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Der untergeordnete Prozess würde auf unbestimmte Zeit warten, für das übergeordnete Element zum Lesen aus der vollständigen <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Sie können asynchrone Lesevorgänge verwenden, um diese Abhängigkeiten und deren potenzielle Deadlocks zu vermeiden. Alternativ können Sie die Deadlockbedingung vermeiden, durch das Erstellen von zwei Threads, und Lesen der Ausgabe der einzelnen Datenströme in einem separaten Thread.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `net use` Befehl zusammen mit einer vom Benutzer angegebenen Argument eine Netzwerkressource zugeordnet. Anschließend den Standardfehlerstream des Befehls net liest und schreibt in die Konsole.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardInput">
      <MemberSignature Language="C#" Value="public bool RedirectStandardInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardInput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectStandardInput : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process command input is read from the Process instance's StandardInput member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Eingabe für eine Anwendung aus dem <see cref="P:System.Diagnostics.Process.StandardInput" />-Datenstrom gelesen wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die Eingabe von <see cref="P:System.Diagnostics.Process.StandardInput" /> gelesen werden soll; andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Diagnostics.Process> können Sie die eingegebenen Text aus der standard-Eingabedatenstrom, in der Regel auf der Tastatur gelesen. Durch das Umleiten der <xref:System.Diagnostics.Process.StandardInput%2A> Stream, Sie können programmgesteuert angeben, die Eingabe eines Prozesses. Beispielsweise können Sie anstelle von Tastatureingaben, Text aus dem Inhalt einer angegebenen Datei oder die Ausgabe aus einer anderen Anwendung bereitstellen.  
  
> [!NOTE]
>  Sie müssen festlegen, <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> zu `false` , wenn Sie festlegen möchten <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A> zu `true`. Andernfalls Schreiben in die <xref:System.Diagnostics.Process.StandardInput%2A> Datenstrom löst eine Ausnahme aus.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht, wie Sie die Umleitung der <xref:System.Diagnostics.Process.StandardInput%2A> Stream eines Prozesses. Die `sort` Befehl ist eine Konsolenanwendung, die gelesen und Texteingabe sortiert.  
  
 Das Beispiel beginnt die `sort` Befehl mit umgeleiteter Eingabe. Anschließend fordert den Benutzer für den Text, und den Text, der die `sort` -Prozess durch im umgeleiteten <xref:System.Diagnostics.Process.StandardInput%2A> Stream. Die `sort` Ergebnisse werden an den Benutzer in der Konsole angezeigt.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardOutput">
      <MemberSignature Language="C#" Value="public bool RedirectStandardOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectStandardOutput : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process output is written to the Process instance's StandardOutput member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Textausgabe einer Anwendung in den <see cref="P:System.Diagnostics.Process.StandardOutput" />-Datenstrom geschrieben wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die Ausgabe in <see cref="P:System.Diagnostics.Process.StandardOutput" /> geschrieben werden soll; andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Diagnostics.Process> schreibt Text in den standard-Stream, dass Text in der Regel in der Konsole angezeigt wird. Durch Festlegen von <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> zu `true` zum Umleiten der <xref:System.Diagnostics.Process.StandardOutput%2A> Stream können Sie bearbeiten oder unterdrückt die Ausgabe eines Prozesses. Sie können z. B. den Text zu filtern, anders formatieren oder Schreiben der Ausgabe in der Konsole und einer angegebenen Protokolldatei.  
  
> [!NOTE]
>  Sie müssen festlegen, <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> zu `false` , wenn Sie festlegen möchten <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> zu `true`. Andernfalls Lesen aus der <xref:System.Diagnostics.Process.StandardOutput%2A> Datenstrom löst eine Ausnahme aus.  
  
 Im umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream synchron oder asynchron gelesen werden kann. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, und <xref:System.IO.StreamReader.ReadToEnd%2A> synchrone Lesevorgänge in den Ausgabestream des Prozesses führen. Diese synchrone gelesen, bis der zugeordneten Vorgänge nicht vollständig <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardOutput%2A> streamen oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> startet asynchrone Lesevorgänge auf dem <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Mit dieser Methode können Sie einen angegebenen Ereignishandler (finden Sie unter <xref:System.Diagnostics.Process.OutputDataReceived>) für die Stream-Ausgabe und sofort zurückgegeben wird, um den Aufrufer, können die andere Arbeiten ausführen, während die Streamausgabe an den Ereignishandler geleitet wird.  
  
> [!NOTE]
>  Die Anwendung, die die asynchrone Ausgabe verarbeitet aufrufen, sollte die <xref:System.Diagnostics.Process.WaitForExit%2A> Methode, um sicherzustellen, dass der Ausgabepuffer geleert wurde.  
  
 Synchrone Lesevorgänge verursachen eine Abhängigkeit zwischen dem Aufrufer, die beim Lesen aus der <xref:System.Diagnostics.Process.StandardOutput%2A> Stream und dem untergeordneten Element verarbeitet das Schreiben in den Stream. Diese Abhängigkeiten können dazu führen, dass Deadlock-Bedingungen. Wenn der Aufrufer aus dem umgeleiteten Stream von einem untergeordneten Prozess liest, ist es das untergeordnete Element abhängig. Der Aufrufer wartet den Lesevorgang, bis das untergeordnete Element in den Stream schreibt oder den Stream schließt. Wenn der untergeordnete Prozess genügend Daten zum Füllen von seinen umgeleiteten-Streams schreibt, ist es vom übergeordneten Element abhängig. Der untergeordnete Prozess wartet der nächste Schreibvorgang, bis das übergeordnete Element aus der vollständige Stream gelesen oder den Stream schließt. Die Deadlockbedingung entsteht, wenn es sich bei dem Aufrufer und dem untergeordneten Prozess, der jeweils anderen zum Abschließen eines Vorgangs warten, und wenn keines von beiden. Sie können Deadlocks vermeiden, durch die Auswertung der Abhängigkeiten zwischen dem Aufrufer und dem untergeordneten Prozess.  
  
 Der folgende C#-Code zeigt beispielsweise das Lesen aus einem Datenstrom umgeleitet und warten Sie, bis des untergeordnete Prozess zu beenden.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 Im Codebeispiel wird eine Deadlockbedingung vermieden, durch den Aufruf `p.StandardOutput.ReadToEnd` vor `p.WaitForExit`. Eine Deadlock-Bedingung kann dazu führen, wenn das übergeordnete Element Aufrufe verarbeiten `p.WaitForExit` vor `p.StandardOutput.ReadToEnd` und der untergeordneten Prozess genug Text zum Ausfüllen des umgeleiteten Streams schreibt. Der übergeordnete Prozess würde für den untergeordneten Prozess zu beenden, unbegrenzt warten. Der untergeordnete Prozess würde auf unbestimmte Zeit warten, für das übergeordnete Element zum Lesen aus der vollständigen <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  
  
 Es ist ein ähnliches Problem auf, wenn es sich bei Sie gesamten Text sowohl die Standardausgabe und Standardfehlerstreams gelesen werden. Beispielsweise führt der folgende C#-Code einen Lesevorgang für beide Streams.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 Im Codebeispiel wird die Deadlockbedingung vermieden, indem asynchrone Lesevorgänge auf dem <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Eine Deadlock-Bedingung führt, wenn das übergeordnete Element Aufrufe verarbeiten `p.StandardOutput.ReadToEnd` gefolgt von `p.StandardError.ReadToEnd` und der untergeordneten Prozess schreibt genug Text zum Fehlerstreams zu füllen. Der übergeordnete Prozess würde auf unbestimmte Zeit warten, für den untergeordneten Prozess zu schließen die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Der untergeordnete Prozess würde auf unbestimmte Zeit warten, für das übergeordnete Element zum Lesen aus der vollständigen <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Sie können asynchrone Lesevorgänge verwenden, um diese Abhängigkeiten und deren potenzielle Deadlocks zu vermeiden. Alternativ können Sie die Deadlockbedingung vermeiden, durch das Erstellen von zwei Threads, und Lesen der Ausgabe der einzelnen Datenströme in einem separaten Thread.  
  
   
  
## Examples  
 [!code-cpp[ProcessOneStream#1](~/samples/snippets/cpp/VS_Snippets_CLR/ProcessOneStream/CPP/stdstr.cpp#1)]
 [!code-csharp[ProcessOneStream#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessOneStream/CS/stdstr.cs#1)]
 [!code-vb[ProcessOneStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessOneStream/VB/stdstr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
      </Docs>
    </Member>
    <Member MemberName="StandardErrorEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardErrorEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardErrorEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardErrorEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardErrorEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StandardErrorEncoding : System.Text.Encoding with get, set" Usage="System.Diagnostics.ProcessStartInfo.StandardErrorEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die bevorzugte Codierung für die Fehlerausgabe ab oder legt diese fest.</summary>
        <value>Ein Objekt, das die bevorzugte Codierung für die Fehlerausgabe darstellt. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert des der <xref:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding%2A> Eigenschaft `null`, der Prozess verwendet die Standardfehler standardcodierung für Fehler bei der Ausgabe. Die <xref:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding%2A> Eigenschaft muss festgelegt werden, bevor der Prozess gestartet wurde. Durch Festlegen dieser Eigenschaft garantiert nicht, dass der Prozess verwendet die angegebene Codierung verwendet. der Prozess wird nur diese Codierungen verwenden, die es unterstützt. Die Anwendung sollte getestet werden, um zu bestimmen, welche Codierungen unterstützt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardInputEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardInputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardInputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardInputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardInputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardInputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StandardInputEncoding : System.Text.Encoding with get, set" Usage="System.Diagnostics.ProcessStartInfo.StandardInputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardOutputEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardOutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardOutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardOutputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardOutputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutputEncoding : System.Text.Encoding with get, set" Usage="System.Diagnostics.ProcessStartInfo.StandardOutputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die bevorzugte Codierung für die Standardausgabe ab oder legt diese fest.</summary>
        <value>Ein Objekt, das die bevorzugte Codierung für die Standardausgabe darstellt. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert des der <xref:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding%2A> Eigenschaft `null`, der Prozess verwendet die standard-Ausgabedatenstrom standardcodierung für die Standardausgabe. Die <xref:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding%2A> Eigenschaft muss festgelegt werden, bevor der Prozess gestartet wurde. Durch Festlegen dieser Eigenschaft garantiert nicht, dass der Prozess der angegebenen Codierung verwendet wird. Um zu bestimmen, welche Codierungen der Prozess unterstützt, sollte die Anwendung getestet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public string UserName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den beim Starten des Prozesses zu verwendenden Benutzernamen ab oder legt diesen fest. Wenn Sie das UPN-Format (<paramref name="user" />@<paramref name="DNS_domain_name" />) verwenden, muss die <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" />-Eigenschaft <see langword="null" /> sein.</summary>
        <value>Der beim Starten des Prozesses zu verwendende Benutzername. Wenn Sie das UPN-Format (<paramref name="user" />@<paramref name="DNS_domain_name" />) verwenden, muss die <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" />-Eigenschaft <see langword="null" /> sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Die <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Eigenschaft muss festgelegt werden, wenn <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> und <xref:System.Diagnostics.ProcessStartInfo.Password%2A> bereitgestellt werden. Wenn die Eigenschaft nicht festgelegt ist, ist das standardmäßige Arbeitsverzeichnis % SYSTEMROOT%\system32 an.  
  
 Wenn die <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> Eigenschaft ist nicht `null` oder eine leere Zeichenfolge, die <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> -Eigenschaft muss sein `false`, oder ein <xref:System.InvalidOperationException> ausgelöst, wenn die <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> Methode wird aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseShellExecute">
      <MemberSignature Language="C#" Value="public bool UseShellExecute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseShellExecute" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
      <MemberSignature Language="VB.NET" Value="Public Property UseShellExecute As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseShellExecute { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseShellExecute : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.UseShellExecute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to use the operating system shell to start the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob zum Starten des Prozesses die Betriebssystemshell verwendet werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn beim Starten des Prozesses die Shell verwendet werden soll; <see langword="false" />, wenn der Prozess direkt von der ausführbaren Datei aus erstellt werden soll. Der Standardwert ist <see langword="true" /> auf .NET Framework-apps und <see langword="false" /> auf .NET Core-apps.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[## Remarks

Wenn diese Eigenschaft auf `false` ermöglicht es Ihnen, Eingabe, Ausgabe und Fehler Datenströme umgeleitet werden.

> [!NOTE]
> <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> muss `false` Wenn die <xref:System.Diagnostics.ProcessStartInfo.UserName> Eigenschaft ist nicht `null` oder eine leere Zeichenfolge oder ein <xref:System.InvalidOperationException> ausgelöst, wenn die <xref:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)?displayProperty=nameWithType> Methode wird aufgerufen.

Wenn Sie die Shell des Betriebssystems verwenden, um Prozesse zu starten, können Sie jedes Dokument (die alle registrierten Dateityp zugeordneten eine ausführbare Datei, die eine Standard-öffnen-Aktion verfügt) und Vorgänge für die Datei, z. B. drucken, mit der <xref:System.Diagnostics.Process> -Objekt. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> ist `false`, Sie können zunächst, dass nur ausführbare Dateien mithilfe der <xref:System.Diagnostics.Process> Objekt.

> [!NOTE]
> <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> muss `true` setzen Sie die <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog> Eigenschaft `true`.

Setzen Sie die <xref:System.Diagnostics.ProcessStartInfo.WindowStyle> zu <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>, <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> muss festgelegt werden, um `true`.

### <a name="workingdirectory"></a>WorkingDirectory

Die <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory> Eigenschaft verhält sich unterschiedlich, abhängig vom Wert der <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> Eigenschaft. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> ist `true`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory> Eigenschaft gibt den Speicherort der ausführbaren Datei. Wenn <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory*> ist eine leere Zeichenfolge ist, davon aus, dass das aktuelle Verzeichnis die ausführbaren Datei enthält.

Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> ist `false`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory> Eigenschaft wird nicht verwendet, um die ausführbare Datei zu finden. Stattdessen wird er nur vom Prozess verwendet, die gestartet wird und nur im Kontext des neuen Prozesses von Bedeutung. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute> ist `false`, <xref:System.Diagnostics.ProcessStartInfo.FileName> Eigenschaft kann entweder einen vollqualifizierten Pfad zur ausführbaren Datei oder ein einfacher ausführbarer Name, der versucht wird, finden Sie in Ordnern, die durch den PATH-Umgebungsvariablen angegeben sein.

## Examples

[!code-cpp[ProcessOneStream#1](~/samples/snippets/cpp/VS_Snippets_CLR/ProcessOneStream/CPP/stdstr.cpp#1)]
[!code-csharp[ProcessOneStream#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessOneStream/CS/stdstr.cs#1)]
[!code-vb[ProcessOneStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessOneStream/VB/stdstr.vb#1)]]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Ein Versuch, den Wert für UWP-Apps (Universal Windows Platform) auf <see langword="true" /> festzulegen, wird unternommen.</exception>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="Verb">
      <MemberSignature Language="C#" Value="public string Verb { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Verb" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Verb" />
      <MemberSignature Language="VB.NET" Value="Public Property Verb As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Verb { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Verb : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.Verb" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.VerbConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The verb to apply to the document specified by the FileName property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Verb ab, das beim Öffnen der in der <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft angegebenen Anwendung oder des in dieser Eigenschaft angegebenen Dokuments verwendet wird, oder legt dieses fest.</summary>
        <value>Die Aktion, die mit der vom Prozess geöffneten Datei durchzuführen ist. Der Standardwert ist eine leere Zeichenfolge (""), die keine Aktion angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Erweiterung weist einen eigenen Satz von Verben, die mithilfe von abgerufen werden können die <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> Eigenschaft. Z. B. die "`print`" Verb Druckt ein Dokument mithilfe von angegeben <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Das Standardverb kann angegeben werden, mit der eine leere Zeichenfolge (""). Beispiele von Verben sind "Bearbeiten", "Öffnen", "OpenAsReadOnly", "Print" und "Printto". Nur Verben, die in der Gruppe von Verben, die vom angezeigt werden. verwenden Sie die <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> Eigenschaft.  
  
 Bei Verwendung der <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> -Eigenschaft, müssen Sie die Dateinamenerweiterung einschließen, wenn Sie den Wert der Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft. Der Dateiname ohne Erweiterung erforderlich, wenn Sie manuell einen Wert für die <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird startet einen neuen Prozess mithilfe des angegebenen Verbs und den Dateinamen an. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> Eigenschaft.  
  
 [!code-csharp[ProcessVerbs_Diagnostics#4](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessVerbs_Diagnostics/CS/source.cs#4)]
 [!code-vb[ProcessVerbs_Diagnostics#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessVerbs_Diagnostics/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.Verbs" />
      </Docs>
    </Member>
    <Member MemberName="Verbs">
      <MemberSignature Language="C#" Value="public string[] Verbs { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Verbs" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Verbs" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Verbs As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Verbs { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Verbs : string[]" Usage="System.Diagnostics.ProcessStartInfo.Verbs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Satz der Verben ab, der dem durch die <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft angegebenen Dateityp zugeordnet ist.</summary>
        <value>Die Aktionen, die das System auf die durch die <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Eigenschaft angegebene Datei anwenden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> Eigenschaft können Sie die Verben, die mit der angegebenen Datei verwendet werden können, bestimmen die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft. Sie können festlegen, die <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> -Eigenschaft auf den Wert eines beliebigen Verbs in der Gruppe. Beispiele von Verben sind "Bearbeiten", "Öffnen", "OpenAsReadOnly", "Print" und "Printto".  
  
 Bei Verwendung der <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> -Eigenschaft, müssen Sie die Dateinamenerweiterung einschließen, wenn Sie den Wert der Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft. Die Dateierweiterung bestimmt den Satz von möglichen Verben.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die definierten Verben für den ausgewählten Dateinamen. Wenn der Benutzer eine der definierten Verben auswählt, startet das Beispiel einen neuen Prozess mit das ausgewählte Verb und Namens der Eingabedatei.  
  
 [!code-csharp[ProcessVerbs_Diagnostics#3](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessVerbs_Diagnostics/CS/source.cs#3)]
 [!code-vb[ProcessVerbs_Diagnostics#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessVerbs_Diagnostics/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.Verb" />
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessWindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessWindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As ProcessWindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessWindowStyle WindowStyle { System::Diagnostics::ProcessWindowStyle get(); void set(System::Diagnostics::ProcessWindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Diagnostics.ProcessWindowStyle with get, set" Usage="System.Diagnostics.ProcessStartInfo.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("How the main window should be created when the process starts.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessWindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Fensterzustand ab, der beim Starten des Prozesses verwendet werden soll, oder legt diesen fest.</summary>
        <value>Einer der Enumerationswerte, der angibt, ob der Prozess in einem maximierten, minimierten, normalen (weder maximierten noch minimierten) oder in einem nicht sichtbaren Fenster gestartet wird. Der Standardwert ist <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der Fensterstil gehört nicht zu den <see cref="T:System.Diagnostics.ProcessWindowStyle" />-Enumerationsmembern.</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkingDirectory">
      <MemberSignature Language="C#" Value="public string WorkingDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WorkingDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.WorkingDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkingDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WorkingDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WorkingDirectory : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.WorkingDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.WorkingDirectoryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The initial working directory for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Arbeitsverzeichnis für den zu startenden Prozess ab oder legt es fest, wenn die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> Eigenschaft <see langword="false" /> ist. Ruft das Verzeichnis ab, das den zu startenden Prozess enthält, oder legt es fest, wenn <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /><see langword="true" /> ist.</summary>
        <value>Wenn <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /><see langword="true" /> ist, der voll gekennzeichnete Name des Verzeichnisses, das den zu startenden Prozess enthält. Wenn die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> Eigenschaft <see langword="false" /> ist, das Arbeitsverzeichnis für den zu startenden Prozess. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Die <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Eigenschaft muss festgelegt werden, wenn <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> und <xref:System.Diagnostics.ProcessStartInfo.Password%2A> bereitgestellt werden. Wenn die Eigenschaft nicht festgelegt ist, ist das standardmäßige Arbeitsverzeichnis % SYSTEMROOT%\system32 an.  
  
 Wenn das Verzeichnis bereits die Systemvariable Path gehört, müssen Sie keinen Speicherort des Verzeichnisses, in dieser Eigenschaft wiederholt werden soll.  
  
 Die <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Eigenschaft verhält sich anders, wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true` als bei <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `false`. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Eigenschaft gibt den Speicherort der ausführbaren Datei. Wenn <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> ist eine leere Zeichenfolge und das aktuelle Verzeichnis wird angenommen, dass die ausführbare Datei.  
  
> [!NOTE]
>  Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true`, das Arbeitsverzeichnis der Anwendung, die die ausführbare Datei gestartet wird, ist auch das Arbeitsverzeichnis der ausführbaren Datei.  
  
 Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `false`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Eigenschaft wird nicht verwendet, um die ausführbare Datei zu finden. Stattdessen gilt der Wert der Prozess, der gestartet wird und nur im Kontext des neuen Prozesses von Bedeutung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>