<Type Name="ProcessThread" FullName="System.Diagnostics.ProcessThread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="934ffb4cd762cfa7b76b16d6e969c275fc9ede64" /><Meta Name="ms.sourcegitcommit" Value="c7fba4a529a39ce5480e57ff2519295822f78c1d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/15/2020" /><Meta Name="ms.locfileid" Value="83413170" /></Metadata><TypeSignature Language="C#" Value="public class ProcessThread : System.ComponentModel.Component" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProcessThread extends System.ComponentModel.Component" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessThread" />
  <TypeSignature Language="VB.NET" Value="Public Class ProcessThread&#xA;Inherits Component" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessThread : System::ComponentModel::Component" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type ProcessThread = class&#xA;    inherit Component" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public class ProcessThread" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProcessThread extends System.Object" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Class ProcessThread" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessThread" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="F#" Value="type ProcessThread = class" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Diagnostics.Process" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-1.0;netcore-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Prozessthread für ein Betriebssystem dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Diagnostics.ProcessThread>, um Informationen zu einem Thread abzurufen, der derzeit auf dem System ausgeführt wird. Auf diese Weise können Sie z. b. die Leistungsmerkmale des Threads überwachen.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle. Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
  
 Ein Thread ist ein Ausführungs Pfad durch ein Programm. Dies ist die kleinste Ausführungs Einheit, die von Win32 geplant wird. Sie besteht aus einem Stapel, dem Status der CPU-Register und einem Eintrag in der Ausführungs Liste des System Planers.  
  
 Ein Prozess besteht aus einem oder mehreren Threads und dem Code, den Daten und anderen Ressourcen eines Programms im Arbeitsspeicher. Typische Programmressourcen sind geöffnete Dateien, Semaphoren und dynamisch zugeordneter Speicher. Jede Ressource eines Prozesses wird von allen Threads dieses Prozesses gemeinsam genutzt.  
  
 Ein Programm wird ausgeführt, wenn der Systemplaner die Ausführungs Steuerung an eines der Threads des Programms übergibt. Der Planer bestimmt, welche Threads ausgeführt werden sollen und wann. Ein Thread mit niedrigerer Priorität ist möglicherweise gezwungen, zu warten, während Threads mit höherer Priorität ihre Aufgaben erfüllen. Auf Multiprozessorcomputern kann der Planer einzelne Threads auf verschiedene Prozessoren verschieben und so die CPU-Auslastung ausgleichen.  
  
 Jeder Prozess beginnt mit einem einzelnen Thread, der als primärer Thread bezeichnet wird. Jeder Thread kann zusätzliche Threads generieren. Alle Threads innerhalb eines Prozesses verwenden den Adressraum dieses Prozesses gemeinsam.  
  
 Der primäre Thread befindet sich nicht notwendigerweise am ersten Index in der Auflistung.  
  
> [!NOTE]
>  Ab der .NET Framework Version 2,0 wurde die Möglichkeit, auf die Leistungsdaten auf anderen Computern zu verweisen, für viele der .NET Framework Methoden und-Eigenschaften beseitigt. Diese Änderung wurde vorgenommen, um die Leistung zu verbessern und nicht-Administratoren die Verwendung der <xref:System.Diagnostics.ProcessThread>-Klasse zu ermöglichen. Daher erhalten einige Anwendungen, die in früheren Versionen der .NET Framework keine Ausnahmen erhalten haben, jetzt möglicherweise eine <xref:System.NotSupportedException>. Die betroffenen Methoden und Eigenschaften sind zu groß, um hier aufgeführt zu werden. die Ausnahme Informationen wurden jedoch den Themen zu betroffenen Elementen hinzugefügt.  
  
 Die Threads eines Prozesses werden einzeln ausgeführt und sind sich nicht gegenseitig, es sei denn, Sie machen Sie gegenseitig sichtbar. Threads, die gemeinsame Ressourcen gemeinsam nutzen, müssen ihre Arbeit jedoch mithilfe von Semaphoren oder einer anderen Methode der prozessübergreifenden Kommunikation koordinieren.  
  
 Um eine Sammlung aller <xref:System.Diagnostics.ProcessThread>-Objekte zu erhalten, die dem aktuellen Prozess zugeordnet sind, können Sie die <xref:System.Diagnostics.Process.Threads%2A>-Eigenschaft der <xref:System.Diagnostics.Process> Instanz von erhalten.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.Process" />
    <altmember cref="P:System.Diagnostics.Process.Threads" />
  </Docs>
  <Members>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.ProcessThread.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The base priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Basispriorität des Threads ab.</summary>
        <value>Die Basispriorität des Threads, die vom Betriebssystem durch Kombinieren der Prioritätsklasse des Prozesses mit der Prioritätsebene des zugeordneten Threads errechnet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Diagnostics.ProcessThread.BasePriority%2A> ist die Anfangs Priorität für den Prozess Thread. Sie können Informationen über die Basis Priorität mithilfe des Prioritäts Basis Zählers des System Monitors anzeigen.  
  
 Das Betriebssystem berechnet die Basis Priorität eines Threads, indem der Prioritäts Bereich des Threads mit der Prioritäts Klasse des Prozesses kombiniert wird. Sie können die <xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=nameWithType>-Eigenschaft des Prozesses auf einen der Werte in der <xref:System.Diagnostics.ProcessPriorityClass>-Enumeration festlegen, die <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>oder <xref:System.Diagnostics.ProcessPriorityClass.RealTime>sind. Sie können die <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A>-Eigenschaft des Threads auf einen Wertebereich festlegen, der die Basis Priorität des Threads einschränkt. Win32 verwendet vier Prioritäts Klassen mit sieben Basis Prioritätsstufen pro Klasse.  
  
 Die aktuelle Priorität des Threads kann von der Basis Priorität abweichen. Das Betriebssystem kann z. b. die <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A>-Eigenschaft basierend auf der verstrichenen Zeit ändern oder eine andere, wenn ein Prozess für den Zugriff auf den Prozessor vor anderen versetzt werden muss. Außerdem können Sie die <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>-Eigenschaft festlegen, um zu bewirken, dass das System die Priorität eines Threads vorübergehend erhöht, wenn der Prozess den Wartezustand verlässt. Die Priorität wird zurückgesetzt, wenn der Prozess in den Wartezustand zurückkehrt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="CurrentPriority">
      <MemberSignature Language="C#" Value="public int CurrentPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentPriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentPriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPriority : int" Usage="System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The current priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadCurrentPriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Priorität des Threads ab.</summary>
        <value>Die aktuelle Priorität des Threads. Abhängig davon, wie das Betriebssystem den Thread plant, kann diese Priorität von der Basispriorität abweichen. Die Priorität kann für einen aktiven Thread vorübergehend erhöht werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle Priorität des Threads kann von der Basis Priorität abweichen. Das Betriebssystem kann z. b. die <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A>-Eigenschaft basierend auf der verstrichenen Zeit oder anderen Steigerungen ändern, wenn ein Prozess für den Zugriff auf den Prozessor vor anderen versetzt werden muss. Außerdem können Sie die <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>-Eigenschaft festlegen, um zu bewirken, dass das System die Priorität eines Threads vorübergehend erhöht, wenn der Prozess den Wartezustand verlässt. Die Priorität wird zurückgesetzt, wenn der Prozess in den Wartezustand zurückkehrt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.ProcessThread.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The ID of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den eindeutigen Bezeichner des Threads ab.</summary>
        <value>Der eindeutige Bezeichner, der dem angegebenen Thread zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem verwendet Thread-IDs wieder, die Threads nur während ihrer Lebensdauer identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdealProcessor">
      <MemberSignature Language="C#" Value="public int IdealProcessor { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IdealProcessor" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Property IdealProcessor As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IdealProcessor {  void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IdealProcessor : int" Usage="System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den bevorzugten Prozessor fest, auf dem dieser Thread ausgeführt werden soll.</summary>
        <value>Der bevorzugte Prozessor für den Thread, der bei der Threadplanung des Systems verwendet wird, die bestimmt, auf welchem Prozessor der Thread ausgeführt werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>-Wert ist NULL basiert.  Wenn Sie also die Thread Affinität für den ersten Prozessor festlegen möchten, legen Sie die-Eigenschaft auf 0 (null) fest.  
  
 Das System plant, wenn möglich, Threads auf Ihren bevorzugten Prozessoren.  
  
 Ein Prozess Thread kann von Prozessor zu Prozessor migrieren, wobei jede Migration den Prozessor Cache erneut lädt. Durch die Angabe eines Prozessors für einen Thread kann die Leistung bei hoher System Auslastung verbessert werden, indem die Anzahl der erneuten Ladevorgänge des Prozessor Caches verringert wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>-Eigenschaft für eine Instanz von Notepad auf den ersten Prozessor festgelegt wird.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Das System konnte die Ausführung des Threads nicht auf den angegebenen Prozessor festlegen.</exception>
        <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Thread gets a priority boot when interactively used by a user.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Betriebssystem die Priorität des zugeordneten Threads vorübergehend erhöhen soll, sobald das Hauptfenster des Threadprozesses den Fokus hat, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn die Priorität des Threads bei Interaktion des Benutzers mit der Schnittstelle erhöht werden soll, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> `true`ist, erhöht das System vorübergehend die Priorität des Threads, wenn der zugehörige Prozess den Wartezustand verlässt. Durch diese Aktion wird verhindert, dass andere Prozesse die Verarbeitung des aktuellen Threads unterbrechen. Die <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> Einstellung wirkt sich auf alle vorhandenen Threads sowie auf alle Threads aus, die anschließend vom Prozess erstellt werden. Um das normale Verhalten wiederherzustellen, legen Sie die <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>-Eigenschaft auf `false`fest.  
  
 <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> wirkt sich nur dann aus, wenn der Thread in einem Prozess ausgeführt wird, für den ein <xref:System.Diagnostics.Process.PriorityClass%2A> auf einen der Werte der dynamischen Prioritäts Enumeration (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>oder <xref:System.Diagnostics.ProcessPriorityClass.RealTime>) festgelegt ist.  
  
> [!NOTE]
>  Wenn die Priorität zu hoch erhöht wird, können Ressourcen von wichtigen Betriebssystem-und Netzwerkfunktionen ausgeglichen werden. Dies kann Probleme mit anderen Betriebssystem Tasks verursachen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Die Informationen zur Prioritätserhöhung konnten nicht abgerufen werden.  
  
 Oder  
  
 Die Informationen zur Prioritätserhöhung konnten nicht festgelegt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
      </Docs>
    </Member>
    <Member MemberName="PriorityLevel">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadPriorityLevel PriorityLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadPriorityLevel PriorityLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityLevel As ThreadPriorityLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadPriorityLevel PriorityLevel { System::Diagnostics::ThreadPriorityLevel get(); void set(System::Diagnostics::ThreadPriorityLevel value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityLevel : System.Diagnostics.ThreadPriorityLevel with get, set" Usage="System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority level of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadPriorityLevel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadPriorityLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Prioritätsebene des Threads ab oder legt diese fest.</summary>
        <value>Einer der <see cref="T:System.Diagnostics.ThreadPriorityLevel" />-Werte, der einen Bereich für die Begrenzung der Priorität des Threads angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Prioritätsstufe ist kein einzelner Wert, sondern ein Wertebereich. Das Betriebssystem berechnet die Basis Priorität des Threads mithilfe des <xref:System.Diagnostics.Process.PriorityClass%2A> des Prozesses, um einen Wert aus dem Bereich auszuwählen, der in der <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A>-Eigenschaft angegeben ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Die Informationen für die Prioritätsebene des Threads konnten nicht abgerufen werden.  
  
 Oder  
  
 Die Prioritätsebene für den Thread konnte nicht festgelegt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in privileged mode.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeit ab, während der der Thread im Betriebssystemkern Code ausgeführt hat.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die angibt, wie lange der Thread im Betriebssystemkern Code ausgeführt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows verwendet mehrere verschiedene Schutzmechanismen, und im Stamm davon ist all der Unterschied zwischen Benutzermodus und privilegiertem Modus. <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> entspricht der Zeitspanne, die für die Ausführung der Anwendung im privilegierten Modus innerhalb des Betriebssystemkerns aufgewendet wurde. Die <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>-Eigenschaft gibt die Zeitspanne an, die die Anwendung für die Ausführung von Code im Benutzermodus außerhalb des System Kerns aufgewendet hat.  
  
 Der Benutzermodus schränkt die Anwendung auf zwei wichtige Weise ein. Erstens kann die Anwendung nicht direkt auf die Peripheriegeräte zugreifen, sondern muss stattdessen den Betriebssystem Kern aufrufen, um Peripherie Daten abzurufen oder festzulegen. Das Betriebssystem kann somit sicherstellen, dass von einer Anwendung keine Peripherie Daten zerstört werden, die von einer anderen Anwendung benötigt werden. Zweitens kann die Anwendung keine Daten lesen oder ändern, die vom Betriebssystem selbst verwaltet werden. Diese Einschränkung verhindert, dass Anwendungen den Kern versehentlich oder absichtlich beschädigen. Wenn die Anwendung das Betriebssystem zum Ausführen eines Vorgangs benötigt, ruft Sie eine der Routinen des Systems auf. Viele davon wechseln in den privilegierten Modus, führen den Vorgang aus und kehren reibungslos in den Benutzermodus zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Die Threadzeit konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity {  void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint" Usage="System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die Prozessoren fest, auf denen der zugeordnete Thread ausgeführt werden kann.</summary>
        <value>Ein <see cref="T:System.IntPtr" />, das auf eine Gruppe von Bits zeigt, wovon jedes einzelne einen Prozessor darstellt, auf dem der Thread ausgeführt werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Prozessor Affinität eines Threads ist der Satz von Prozessoren, zu denen er eine Beziehung hat. Dies bedeutet, dass für die Ausführung geplant werden kann.  
  
 <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> stellt jeden Prozessor als Bit dar. Bit 0 stellt den Prozessor 1 dar, Bit 1 steht für Prozessor 2 usw. In der folgenden Tabelle wird eine Teilmenge der möglichen <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> für ein System mit vier Prozessoren angezeigt.  
  
|Eigenschafts Wert (in Hexadezimal)|Gültige Prozessoren|  
|---------------------------------------|----------------------|  
|0x0001|1|  
|0x0002|2|  
|0x0003|1 oder 2|  
|0x0004|3|  
|0x0005|1 oder 3|  
|0x0007|1, 2 oder 3|  
|0x000F|1, 2, 3 oder 4|  
  
 Sie können auch den einzelnen bevorzugten Prozessor für einen Thread angeben, indem Sie die <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>-Eigenschaft festlegen. Ein Prozess Thread kann von Prozessor zu Prozessor migrieren, wobei jede Migration den Prozessor Cache erneut lädt. Durch die Angabe eines Prozessors für einen Thread kann die Leistung bei hoher System Auslastung verbessert werden, indem die Anzahl der erneuten Ladevorgänge des Prozessor Caches verringert wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A>-Eigenschaft für eine Instanz von Notepad auf den ersten Prozessor festlegen.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Die Prozessoraffinität konnte nicht festgelgt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="ResetIdealProcessor">
      <MemberSignature Language="C#" Value="public void ResetIdealProcessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetIdealProcessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessThread.ResetIdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetIdealProcessor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetIdealProcessor();" />
      <MemberSignature Language="F#" Value="member this.ResetIdealProcessor : unit -&gt; unit" Usage="processThread.ResetIdealProcessor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den für diesen Thread idealen Prozessor zurück, um anzugeben, dass kein einzelner idealer Prozessor vorhanden ist. Das heißt, dass jeder Prozessor ideal sein kann.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Der ideale Prozessor konnte nicht zurückgesetzt werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="StartAddress">
      <MemberSignature Language="C#" Value="public IntPtr StartAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int StartAddress" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartAddress As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr StartAddress { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.StartAddress : nativeint" Usage="System.Diagnostics.ProcessThread.StartAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The start address in memory of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadStartAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Speicheradresse der Funktion ab, die vom Betriebssystem aufgerufen wurde, das diesen Thread gestartet hat.</summary>
        <value>Die Anfangsadresse des Threads, die auf die vom Thread ausgeführte anwendungsdefinierte Funktion zeigt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Prozess beginnt mit einem einzelnen Thread, der als primärer Thread bezeichnet wird. Jeder Thread kann zusätzliche Threads generieren.  
  
 Ein Prozess verfügt über einen virtuellen Adressraum, einen ausführbaren Code, Daten, Objekt Handles, Umgebungsvariablen, eine Basis Priorität und die minimalen und maximalen workingsetgrößen. Alle Threads eines Prozesses verwenden den virtuellen Adressraum und die Systemressourcen gemeinsam. Außerdem verwaltet jeder Thread Ausnahmehandler, eine Planungs Priorität und einen Satz von Strukturen, in denen das System den Thread Kontext speichert, während der Thread darauf wartet, geplant zu werden. Der Thread Kontext enthält den Thread Satz der Computer Register, den Kernel Stapel, einen Thread Umgebungsblock und einen Benutzer Stapel im Adressraum des Thread Prozesses.  
  
 Jeder Windows-Thread startet die Ausführung in einer vom System bereitgestellten Funktion und nicht in der von der Anwendung bereitgestellten Funktion. Die Startadresse für den primären Thread ist daher identisch (da Sie die Adresse der vom System bereitgestellten Funktion darstellt) für jeden Windows-Prozess im System. Die <xref:System.Diagnostics.ProcessThread.StartAddress%2A>-Eigenschaft ermöglicht es Ihnen jedoch, die für Ihre Anwendung spezifische Start Funktions Adresse zu erhalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.ProcessThread.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time this thread was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeit ab, zu der das Betriebssystem den Thread gestartet hat.</summary>
        <value>Eine <see cref="T:System.DateTime" />, die die Zeit auf dem System darstellt, zu der das Betriebssystem den Thread gestartet hat.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Die Threadzeit konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadState ThreadState { System::Diagnostics::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Diagnostics.ThreadState" Usage="System.Diagnostics.ProcessThread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The current state of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadThreadState")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den aktuellen Zustand dieses Threads ab.</summary>
        <value>Ein <see cref="T:System.Diagnostics.ThreadState" />, der die Ausführung des Threads angibt, z. B. wird ausgeführt, wartet oder wurde beendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Diagnostics.ProcessThread.WaitReason%2A>-Eigenschafts Wert ist nur gültig, wenn der <xref:System.Diagnostics.ProcessThread.ThreadState%2A> Wert <xref:System.Diagnostics.ThreadState.Wait>ist. Überprüfen Sie daher den <xref:System.Diagnostics.ProcessThread.ThreadState%2A> Wert, bevor Sie die <xref:System.Diagnostics.ProcessThread.WaitReason%2A>-Eigenschaft erhalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The total amount of CPU time used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamte Zeit ab, während der der Thread den Prozessor verwendet hat.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die die Zeit angibt, während der Thread den Prozessor gesteuert hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A>-Eigenschaft gibt die Gesamtzeit an, die das System den Thread aus dem Wartezustand entfernt hat, und hat ihm die Priorität für einen beliebigen Prozessor eingeräumt. Auf einem Multiprozessorsystem würde dieser Wert die für jeden Prozessor aufgewendeten Zeit einschließen, wenn der Thread mehr als einen Prozessor verwendet hat.  
  
 Die <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A>-Eigenschaft ist die Summe der Eigenschaften <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> und <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Die Threadzeit konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in user mode.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeit ab, während der der zugeordnete Thread in der Anwendung Code ausgeführt hat.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die angibt, wie lange der Thread Code in der Anwendung (im Gegensatz zum Betriebssystemkern) ausgeführt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Windows NT werden verschiedene Schutzmechanismen verwendet, und im Stamm davon ist all der Unterschied zwischen Benutzermodus und privilegiertem Modus. <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> entspricht der Zeitspanne, die für die Ausführung der Anwendung im Benutzermodus außerhalb des Betriebssystemkerns aufgewendet wurde. Der <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> entspricht der Zeitspanne, die die Anwendung für die Ausführung von Code im privilegierten Modus innerhalb des System Kerns aufgewendet hat.  
  
 Der Benutzermodus schränkt die Anwendung auf zwei wichtige Weise ein. Erstens kann die Anwendung nicht direkt auf die Peripheriegeräte zugreifen, sondern muss stattdessen den Betriebssystem Kern aufrufen, um Peripherie Daten abzurufen oder festzulegen. Das Betriebssystem kann somit sicherstellen, dass von einer Anwendung keine Peripherie Daten zerstört werden, die von einer anderen Anwendung benötigt werden. Zweitens kann die Anwendung keine Daten lesen oder ändern, die vom Betriebssystem selbst verwaltet werden. Diese Einschränkung verhindert, dass Anwendungen den Kern versehentlich oder absichtlich beschädigen. Wenn die Anwendung das Betriebssystem zum Ausführen eines Vorgangs benötigt, ruft Sie eine der Routinen des Systems auf. Viele davon wechseln in den privilegierten Modus, führen den Vorgang aus und kehren reibungslos in den Benutzermodus zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Die Threadzeit konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="WaitReason">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadWaitReason WaitReason { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadWaitReason WaitReason" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.WaitReason" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitReason As ThreadWaitReason" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadWaitReason WaitReason { System::Diagnostics::ThreadWaitReason get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitReason : System.Diagnostics.ThreadWaitReason" Usage="System.Diagnostics.ProcessThread.WaitReason" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The reason why this thread is waiting.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadWaitReason")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadWaitReason</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Ursache für den Wartezustand des Threads ab.</summary>
        <value>Eine <see cref="T:System.Diagnostics.ThreadWaitReason" />, die die Ursache für den Wartezustand des Threads darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.ProcessThread.WaitReason%2A>-Eigenschaft ist nur gültig, wenn die <xref:System.Diagnostics.ProcessThread.ThreadState%2A> <xref:System.Diagnostics.ThreadState.Wait>ist. Überprüfen Sie daher den <xref:System.Diagnostics.ProcessThread.ThreadState%2A> Wert, bevor Sie die <xref:System.Diagnostics.ProcessThread.WaitReason%2A>-Eigenschaft erhalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Thread befindet sich nicht im Wartezustand.</exception>
        <exception cref="T:System.NotSupportedException">Der Prozess wird auf einem Remotecomputer ausgeführt.</exception>
        <altmember cref="T:System.Diagnostics.ThreadWaitReason" />
        <altmember cref="P:System.Diagnostics.ProcessThread.ThreadState" />
      </Docs>
    </Member>
  </Members>
</Type>
