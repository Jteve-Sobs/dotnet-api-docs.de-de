<Type Name="ProcessThread" FullName="System.Diagnostics.ProcessThread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b5c2d800faf6ad6248644d895554e406af3900d9" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37767204" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ProcessThread : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProcessThread extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessThread" />
  <TypeSignature Language="VB.NET" Value="Public Class ProcessThread&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessThread : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ProcessThread = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents an operating system process thread.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Diagnostics.ProcessThread> zum Abrufen von Informationen über einen Thread, der derzeit auf dem System ausgeführt wird. Auf diese Weise können Sie z. B. zum Überwachen von Leistungsmerkmalen des Threads.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mit dem Typ haben, sollten Sie es entweder direkt oder indirekt freigeben. Damit des Typs direkt freigegeben werden, rufen Sie die <xref:System.IDisposable.Dispose%2A> -Methode in einer `try` / `catch` Block. Um sie indirekt löschen, verwenden Sie ein Sprachkonstrukt wie `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "mithilfe von ein-Objekt, das implementiert" IDisposable "" in der <xref:System.IDisposable> schnittstellenthema.  
  
 Ein Thread ist ein Ausführungspfad über ein Programm. Es ist die kleinste Einheit der Ausführung, das Win32 plant. Es besteht aus einem Stapel, den Zustand der CPU-Register, und einen Eintrag in der Ausführungsliste des Zeitplanungsmoduls System.  
  
 Ein Prozess besteht aus einem oder mehreren Threads und den Code, Daten und andere Ressourcen eines Programms im Arbeitsspeicher. Typische Programmressourcen sind geöffneten Dateien, Semaphoren und dynamisch zugeordneten Speicher. Jede Ressource eines Prozesses wird von der alle Prozessthreads gemeinsam genutzt.  
  
 Ein Programm ausgeführt wird, wenn der Systemscheduler Steuerung der Ausführung eines Threads für das Programm bietet. Der Scheduler bestimmt, welche Threads ausgeführt werden soll und wann. Ein Thread mit niedrigerer Priorität möglicherweise gezwungen, warten Sie, während Threads mit höherer Priorität der Erledigung von Aufgaben. Auf Multiprozessorcomputern kann der Planer einzelne Threads auf verschiedene Prozessoren verschieben daher die CPU-Last.  
  
 Jeder Prozess beginnt mit einem einzelnen Thread, der als der primäre Thread bezeichnet wird. Jeder Thread kann zusätzliche Threads generieren. Alle Threads innerhalb eines Prozesses gemeinsam nutzen, den Adressraum des Prozesses.  
  
 Der primäre Thread befindet sich nicht unbedingt auf den ersten Index in der Auflistung.  
  
> [!NOTE]
>  Ab .NET Framework, Version 2.0, wurde die Möglichkeit, Verweis Leistungsindikatordaten auf anderen Computern für viele der Eigenschaften und Methoden in .NET Framework entfernt. Diese Änderung wurde vorgenommen, zur Verbesserung der Leistung und Aktivieren von nicht-Administratoren verwenden die <xref:System.Diagnostics.ProcessThread> Klasse. Einige Anwendungen, die in früheren Versionen von .NET Framework nicht Ausnahmen erzielen erhalten daher jetzt eine <xref:System.NotSupportedException>. Die Methoden und Eigenschaften zu zahlreich sind, um hier aufgeführt sind, aber die Ausnahmeinformationen in den Themen für die betroffene Mitglied hinzugefügt wurde.  
  
 Die Threads eines Prozesses einzeln ausführen und des jeweils anderen nicht bewusst sind, es sei denn, Sie füreinander sichtbar machen. Threads, die gemeinsamen Ressourcen müssen jedoch mithilfe von Semaphoren oder eine andere Methode für die prozessübergreifende Kommunikation auf ihre Arbeit koordinieren.  
  
 Zum Abrufen einer Auflistung aller der <xref:System.Diagnostics.ProcessThread> Objekte zugeordnet sind und der aktuelle Prozess, erhalten die <xref:System.Diagnostics.Process.Threads%2A> Eigenschaft der <xref:System.Diagnostics.Process> Instanz.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.Process" />
    <altmember cref="P:System.Diagnostics.Process.Threads" />
  </Docs>
  <Members>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.ProcessThread.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The base priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the base priority of the thread.</summary>
        <value>Die Basispriorität des Threads, die das Betriebssystem durch Kombinieren der Prioritätsklasse des Prozesses mit der Prioritätsebene des zugeordneten Threads berechnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.ProcessThread.BasePriority%2A> ist die Priorität ab, für den Thread des Prozesses. Sie können Informationen über die Basispriorität, die über den Systemmonitor Priorität Basisindikator anzeigen.  
  
 Das Betriebssystem berechnet die Basispriorität des Threads durch die Kombination von Bereich der Ebene Priorität des Threads mit der Prioritätsklasse des Prozesses. Sie können festlegen, dass des Prozess des <xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=nameWithType> -Eigenschaft auf einen der Werte in der <xref:System.Diagnostics.ProcessPriorityClass> -Enumeration, die sind <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, oder <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. Sie können festlegen, dass die Threads <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> Eigenschaft, um einen Bereich von Werten, die Basispriorität des Threads begrenzt. Win32 verwendet vier Prioritätsklassen mit sieben Basisprioritätsebenen pro Klasse.  
  
 Aktuelle Priorität des Threads möglicherweise von der Basispriorität abweichen. Das Betriebssystem können ändern, z. B. die <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> Eigenschaft basierend auf der Zeit verstrichen oder andere steigert, wenn ein Prozess müssen gesetzt werden vor anderen für den Zugriff auf den Prozessor. Sie können außerdem festlegen der <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Eigenschaft dazu führen, dass das System die Priorität eines Threads vorübergehend erhöhen, wenn der Prozess den Wartezustand herausgenommen wird. Die Priorität wird immer dann zurückgesetzt, wenn der Prozess in den Wartezustand zurückkehrt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="CurrentPriority">
      <MemberSignature Language="C#" Value="public int CurrentPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentPriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentPriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPriority : int" Usage="System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current priority of the thread.</summary>
        <value>Die aktuelle Priorität des Threads, die von der Basispriorität basierend auf wie das Betriebssystem den Thread plant abweichen kann. Die Priorität kann für einen aktiven Thread vorübergehend erhöht werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aktuelle Priorität des Threads möglicherweise von der Basispriorität abweichen. Das Betriebssystem können ändern, z. B. die <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> Eigenschaft basierend auf der Zeit verstrichen oder andere steigert, wenn ein Prozess müssen gesetzt werden vor anderen für den Zugriff auf den Prozessor. Sie können außerdem festlegen der <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Eigenschaft dazu führen, dass das System die Priorität eines Threads vorübergehend erhöhen, wenn der Prozess den Wartezustand herausgenommen wird. Die Priorität wird immer dann zurückgesetzt, wenn der Prozess in den Wartezustand zurückkehrt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.ProcessThread.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The ID of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the unique identifier of the thread.</summary>
        <value>Der eindeutige Bezeichner, der einem bestimmten Thread zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem verwendet die Thread-IDs, die nur während ihrer Lebensdauer Threads zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdealProcessor">
      <MemberSignature Language="C#" Value="public int IdealProcessor { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IdealProcessor" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Property IdealProcessor As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IdealProcessor {  void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IdealProcessor : int" Usage="System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the preferred processor for this thread to run on.</summary>
        <value>Der bevorzugte Prozessor für den Thread, der verwendet wird, wenn das System plant die Threads, um zu bestimmen, welcher Prozessor der Thread ausgeführt werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> Wert ist nullbasiert.  Das heißt, um die Threadaffinität für den ersten Prozessor festzulegen, legen Sie die Eigenschaft auf 0 (null).  
  
 Das System plant Threads auf ihre bevorzugte Prozessoren, wann immer möglich.  
  
 Ein Prozessthread kann nach Prozessor, wobei bei jeder Migration der Prozessorcache migrieren. Angeben von einem Prozessor für einen Thread kann die Leistung verbessern starker Auslastung durch Verringern der Anzahl der Häufigkeit, mit die Cache des Prozessors geladen wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Festlegen der <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> -Eigenschaft für eine Instanz von Editor auf den ersten Prozessor.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The system could not set the thread to start on the specified processor.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Thread gets a priority boot when interactively used by a user.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the operating system should temporarily boost the priority of the associated thread whenever the main window of the thread's process receives the focus.</summary>
        <value>
          <see langword="true" /> um die Priorität des Threads zu steigern, wenn der Benutzer interagiert, mit dem Prozess der Schnittstelle. andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> ist `true`, erhöht das System vorübergehend die Priorität des Threads, wenn der zugeordnete Prozess, den Wartezustand ausgeführt wird. Dadurch wird verhindert, dass andere Prozesse die Verarbeitung des aktuellen Threads zu unterbrechen. Die <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> Einstellung wirkt sich auf alle vorhandenen Threads sowie alle Threads, die anschließend durch den Prozess erstellt. Um das normale Verhalten wiederherzustellen, legen die <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Eigenschaft `false`.  
  
 <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> wirkt sich nur, wenn der Thread in einem Prozess ausgeführt wird, die eine <xref:System.Diagnostics.Process.PriorityClass%2A> auf einer der Enumerationswerte dynamische Priorität festgelegt (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, oder <xref:System.Diagnostics.ProcessPriorityClass.RealTime>).  
  
> [!NOTE]
>  Die Priorität zu stark angehoben, kann Ressourcen von wichtigen Betriebssystem- und Netzwerkfunktionen abzuleiten. Dies kann Probleme mit anderer betriebssystemtasks führen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The priority boost information could not be retrieved.  -or-  The priority boost information could not be set.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
      </Docs>
    </Member>
    <Member MemberName="PriorityLevel">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadPriorityLevel PriorityLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadPriorityLevel PriorityLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityLevel As ThreadPriorityLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadPriorityLevel PriorityLevel { System::Diagnostics::ThreadPriorityLevel get(); void set(System::Diagnostics::ThreadPriorityLevel value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityLevel : System.Diagnostics.ThreadPriorityLevel with get, set" Usage="System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority level of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadPriorityLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the priority level of the thread.</summary>
        <value>Eines der <see cref="T:System.Diagnostics.ThreadPriorityLevel" /> Werte, die einen Bereich für die die Priorität des Threads angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Prioritätsstufe ist nicht auf, einen einzelnen Wert, sondern stattdessen einen Bereich von Werten. Das Betriebssystem berechnet die Basispriorität des Threads des Prozesses mit <xref:System.Diagnostics.Process.PriorityClass%2A> einen Wert aus dem im angegebenen Bereich aus der <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The thread priority level information could not be retrieved.  -or-  The thread priority level could not be set.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in privileged mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of time that the thread has spent running code inside the operating system core.</summary>
        <value>Ein <see cref="T:System.TimeSpan" /> , der angibt, die Menge an Zeit, der Thread im Betriebssystemkern Code ausgeführt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows verwendet verschiedene Schutzmechanismen und im Stamm von allen ist der Unterschied zwischen Benutzer und privilegierte Modus. <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> entspricht der Menge an Zeit, die Anwendung wurde im privilegierten Modus, in den Kern des Betriebssystems ausgeführt wird. Die <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> Eigenschaft gibt an, die Zeitspanne, die die Anwendung ausgeführten Code im Benutzermodus, außerhalb des aufgewendet hat.  
  
 User-Modus schränkt die Anwendung in zwei wichtigen Punkten. Zunächst die Anwendung kann nicht direkt auf die Peripheriegeräten zugreifen, aber stattdessen muss im Betriebssystemkern zum Abrufen oder Festlegen der periphere Daten aufrufen. Das Betriebssystem können daher sicherstellen, dass eine Anwendung nicht periphere Daten zerstört, die von einem anderen erforderlich ist. Andererseits kann nicht die Anwendung zu lesen oder Ändern von Daten, die das Betriebssystem selbst verwaltet. Diese Einschränkung verhindert, dass Anwendungen absichtlich oder versehentlich beschädigt die Core. Wenn die Anwendung das Betriebssystem zum Ausführen eines Vorgangs benötigt wird, ruft sie eine Routine des Systems. Viele dieser Übergang zu privilegierten Modus führen Sie den Vorgang und reibungslos Benutzermodus zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The thread time could not be retrieved.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity {  void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint" Usage="System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the processors on which the associated thread can run.</summary>
        <value>Ein <see cref="T:System.IntPtr" /> , verweist auf einen Satz von Bits, von denen jedes einen Prozessor, der der Thread ausgeführt werden kann, auf darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Prozessoraffinität eines Threads ist die Gruppe von Prozessoren, die, denen es sich um eine Beziehung zu aufweist. Das heißt, die sie für die Ausführung auf eingeplant werden kann.  
  
 <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> Jeder Prozessor darstellt als Bitfeld. Bit 0 stellt Prozessor 1, Bit 1 darstellt, Prozessor 2 und So weiter. Die folgende Tabelle zeigt eine Teilmenge der möglichen <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> für ein System mit vier Prozessoren.  
  
|Eigenschaftenwert (im Hexadezimalformat)|Gültige Prozessoren|  
|---------------------------------------|----------------------|  
|0x0001|1|  
|0x0002|2|  
|0x0003|1 oder 2|  
|0x0004|3|  
|0x0005|1 oder 3|  
|0x0007|1, 2 oder 3|  
|0x000F|1, 2, 3 oder 4|  
  
 Sie können auch den einzelnen, bevorzugte Prozessor für einen Thread angeben, durch Festlegen der <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> Eigenschaft. Ein Prozessthread kann nach Prozessor, wobei bei jeder Migration der Prozessorcache migrieren. Angeben von einem Prozessor für einen Thread kann die Leistung verbessern starker Auslastung durch Verringern der Anzahl der Häufigkeit, mit die Cache des Prozessors geladen wird.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die legen Sie die <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> -Eigenschaft für eine Instanz von Editor auf den ersten Prozessor.  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The processor affinity could not be set.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="ResetIdealProcessor">
      <MemberSignature Language="C#" Value="public void ResetIdealProcessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetIdealProcessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessThread.ResetIdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetIdealProcessor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetIdealProcessor();" />
      <MemberSignature Language="F#" Value="member this.ResetIdealProcessor : unit -&gt; unit" Usage="processThread.ResetIdealProcessor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the ideal processor for this thread to indicate that there is no single ideal processor. In other words, so that any processor is ideal.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The ideal processor could not be reset.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="StartAddress">
      <MemberSignature Language="C#" Value="public IntPtr StartAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int StartAddress" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartAddress As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr StartAddress { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.StartAddress : nativeint" Usage="System.Diagnostics.ProcessThread.StartAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The start address in memory of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the memory address of the function that the operating system called that started this thread.</summary>
        <value>Die Anfangsadresse des Threads, die für die anwendungsdefinierte Funktion verweist, die der Thread ausgeführt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Prozess beginnt mit einem einzelnen Thread, der als der primäre Thread bezeichnet wird. Jeder Thread kann zusätzliche Threads generieren.  
  
 Ein Prozess verfügt über einen virtuellen Adressraum, ausführbaren Code, Daten, Objekthandles, Umgebungsvariablen, einem Basispriorität an, und minimalen und maximalen Arbeitsseitengrößen festzulegen. Alle Threads eines Prozesses gemeinsam nutzen, die virtuelle Adresse und die Systemressourcen. Darüber hinaus behält jeder Thread Ausnahmehandler, eine Planungspriorität und eine Reihe von Strukturen, die in denen das System den Threadkontext speichert, während es sich bei den Wartezustand des Threads geplant werden. Der Threadkontext enthält die Gruppe der Computer registriert, die Kernelstapel, einen Threadumgebungsblock und einen Benutzerstapel im Adressraum des Threadprozesses.  
  
 Jeder Windows-Thread beginnt tatsächlich die Ausführung in einer vom System bereitgestellten-Funktion nicht die der Anwendung bereitgestellte Funktion. Die Startadresse für den primären Thread gilt, daher (wie er die Adresse der Funktion vom System bereitgestellten darstellt) für jeden Windows-Prozess im System. Allerdings die <xref:System.Diagnostics.ProcessThread.StartAddress%2A> Eigenschaft können Sie die Startadresse der Funktion, die für Ihre Anwendung spezifisch ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.ProcessThread.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time this thread was started.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the operating system started the thread.</summary>
        <value>Ein <see cref="T:System.DateTime" /> , die den Zeitpunkt an, die auf dem System war, wenn das Betriebssystem den Thread gestartet.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The thread time could not be retrieved.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadState ThreadState { System::Diagnostics::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Diagnostics.ThreadState" Usage="System.Diagnostics.ProcessThread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current state of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current state of this thread.</summary>
        <value>Ein <see cref="T:System.Diagnostics.ThreadState" /> , die angibt, dass seine Ausführung, z. B. ausgeführt, wartend oder wurde beendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.ProcessThread.WaitReason%2A> Eigenschaftswert ist nur gültig, wenn die <xref:System.Diagnostics.ProcessThread.ThreadState%2A> Wert <xref:System.Diagnostics.ThreadState.Wait>. Überprüfen Sie daher die <xref:System.Diagnostics.ProcessThread.ThreadState%2A> Wert, bevor Sie erhalten die <xref:System.Diagnostics.ProcessThread.WaitReason%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The total amount of CPU time used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the total amount of time that this thread has spent using the processor.</summary>
        <value>Ein <see cref="T:System.TimeSpan" /> , die die Zeitspanne, dass der Thread den Prozessor gesteuert hat angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> Eigenschaft gibt die Gesamtmenge der Zeit, dass das System den Wartezustand des Threads entnommen und ihm Priorität für einen beliebigen Prozessor. Auf einem System mit mehreren Prozessoren würde dieser Wert für jeden Prozessor, aufgewendete Zeit enthalten, wenn der Thread, mehrere Prozessoren verwendet.  
  
 Die <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> -Eigenschaft ist die Summe der <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> und <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> Eigenschaften.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The thread time could not be retrieved.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in user mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of time that the associated thread has spent running code inside the application.</summary>
        <value>Ein <see cref="T:System.TimeSpan" /> , der angibt, die Menge an Zeit, der Thread Code in der Anwendung ausgeführt hat, im Gegensatz zu in den Kern des Betriebssystems.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows NT verwendet verschiedene Schutzmechanismen und im Stamm von allen ist der Unterschied zwischen Benutzer und privilegierte Modus. <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> entspricht die Zeitspanne, die für die Anwendung ausgeführt wird, im Benutzermodus, außerhalb des Betriebssystemkerns aufgewendet hat. Die <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> entspricht der Menge an Zeit, die Anwendung ausgeführten Code im privilegierten Modus, in der System-Kern hat.  
  
 User-Modus schränkt die Anwendung in zwei wichtigen Punkten. Zunächst die Anwendung kann nicht direkt auf die Peripheriegeräten zugreifen, aber stattdessen muss im Betriebssystemkern zum Abrufen oder Festlegen der periphere Daten aufrufen. Das Betriebssystem können daher sicherstellen, dass eine Anwendung nicht periphere Daten zerstört, die von einem anderen erforderlich ist. Andererseits kann nicht die Anwendung zu lesen oder Ändern von Daten, die das Betriebssystem selbst verwaltet. Diese Einschränkung verhindert, dass Anwendungen absichtlich oder versehentlich beschädigt die Core. Wenn die Anwendung das Betriebssystem zum Ausführen eines Vorgangs benötigt wird, ruft sie eine Routine des Systems. Viele dieser Übergang zu privilegierten Modus führen Sie den Vorgang und reibungslos Benutzermodus zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The thread time could not be retrieved.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="WaitReason">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadWaitReason WaitReason { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadWaitReason WaitReason" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.WaitReason" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitReason As ThreadWaitReason" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadWaitReason WaitReason { System::Diagnostics::ThreadWaitReason get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitReason : System.Diagnostics.ThreadWaitReason" Usage="System.Diagnostics.ProcessThread.WaitReason" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The reason why this thread is waiting.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadWaitReason</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the reason that the thread is waiting.</summary>
        <value>Ein <see cref="T:System.Diagnostics.ThreadWaitReason" /> , die den Grund für das der Thread im Wartezustand ist darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.ProcessThread.WaitReason%2A> Eigenschaft ist nur gültig, wenn die <xref:System.Diagnostics.ProcessThread.ThreadState%2A> ist <xref:System.Diagnostics.ThreadState.Wait>. Überprüfen Sie daher die <xref:System.Diagnostics.ProcessThread.ThreadState%2A> Wert, bevor Sie erhalten die <xref:System.Diagnostics.ProcessThread.WaitReason%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The thread is not in the wait state.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.NotSupportedException">The process is on a remote computer.</exception>
        <altmember cref="T:System.Diagnostics.ThreadWaitReason" />
        <altmember cref="P:System.Diagnostics.ProcessThread.ThreadState" />
      </Docs>
    </Member>
  </Members>
</Type>