<Type Name="Stopwatch" FullName="System.Diagnostics.Stopwatch">
  <Metadata><Meta Name="ms.openlocfilehash" Value="83c3b607978c70bd0cc3214d68c2e0ae69e2403b" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75137235" /></Metadata><TypeSignature Language="C#" Value="public class Stopwatch" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Stopwatch extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Stopwatch" />
  <TypeSignature Language="VB.NET" Value="Public Class Stopwatch" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stopwatch" />
  <TypeSignature Language="F#" Value="type Stopwatch = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine Gruppe von Methoden und Eigenschaften bereit, mit denen die verstrichene Zeit exakt gemessen werden kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Diagnostics.Stopwatch> Instanz kann die verstrichene Zeit für ein Intervall oder die Summe der verstrichenen Zeit über mehrere Intervalle hinweg messen. In einem typischen <xref:System.Diagnostics.Stopwatch> Szenario wird die <xref:System.Diagnostics.Stopwatch.Start%2A>-Methode aufgerufen, schließlich wird die <xref:System.Diagnostics.Stopwatch.Stop%2A>-Methode aufgerufen, und anschließend wird die verstrichene Zeit mithilfe der <xref:System.Diagnostics.Stopwatch.Elapsed%2A>-Eigenschaft überprüft.  
  
 Eine <xref:System.Diagnostics.Stopwatch> Instanz wird entweder ausgeführt oder beendet. Verwenden Sie <xref:System.Diagnostics.Stopwatch.IsRunning%2A>, um den aktuellen Status einer <xref:System.Diagnostics.Stopwatch>zu bestimmen. Verwenden Sie <xref:System.Diagnostics.Stopwatch.Start%2A>, um die verstrichene Zeit zu messen Verwenden Sie <xref:System.Diagnostics.Stopwatch.Stop%2A>, um die verstrichene Zeit zu messen Fragen Sie den verstrichenen Zeitwert über die Eigenschaften <xref:System.Diagnostics.Stopwatch.Elapsed%2A>, <xref:System.Diagnostics.Stopwatch.ElapsedMilliseconds%2A>oder <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A>ab. Sie können die verstrichenen Zeiteigenschaften Abfragen, während die Instanz ausgeführt wird oder beendet wird. Die verstrichenen Zeit werden während der Ausführung der <xref:System.Diagnostics.Stopwatch> konstant erhöht. Sie bleiben konstant, wenn die Instanz beendet wird.  
  
 Standardmäßig ist der verstrichene Zeitwert einer <xref:System.Diagnostics.Stopwatch> Instanz gleich der Summe aller gemessenen Zeitintervalle. Jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Start%2A> beginnt mit der Zählung der kumulativen verstrichenen Zeit. Jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Stop%2A> beendet die aktuelle Intervallmessung und friert den kumulativen Wert für die verstrichene Zeit ein. Verwenden Sie die <xref:System.Diagnostics.Stopwatch.Reset%2A>-Methode, um die kumulierte verstrichene Zeit in einer vorhandenen <xref:System.Diagnostics.Stopwatch> Instanz zu löschen.  
  
 Der <xref:System.Diagnostics.Stopwatch> misst die verstrichene Zeit, indem Zeit Geber Ticks im zugrunde liegenden Zeit Geber Mechanismus gezählt werden. Wenn die installierte Hardware und das Betriebssystem einen Leistungs Bearbeiter mit hoher Auflösung unterstützen, verwendet die <xref:System.Diagnostics.Stopwatch> Klasse diesen Leistungs Bearbeiter, um die verstrichene Zeit zu messen. Andernfalls verwendet die <xref:System.Diagnostics.Stopwatch> Klasse den systemtimer, um die verstrichene Zeit zu messen. Verwenden Sie die Felder <xref:System.Diagnostics.Stopwatch.Frequency> und <xref:System.Diagnostics.Stopwatch.IsHighResolution>, um die Genauigkeit und Auflösung der Implementierung der <xref:System.Diagnostics.Stopwatch> zeitlichen Steuerung zu bestimmen.  
  
 Die <xref:System.Diagnostics.Stopwatch>-Klasse unterstützt die Bearbeitung zeitbezogener Leistungsindikatoren in verwaltetem Code. Insbesondere können das <xref:System.Diagnostics.Stopwatch.Frequency>-Feld und <xref:System.Diagnostics.Stopwatch.GetTimestamp%2A>-Methode anstelle der nicht verwalteten Windows-APIs `QueryPerformanceFrequency` und `QueryPerformanceCounter`verwendet werden.  
  
> [!NOTE]
>  Auf einem Multiprozessorcomputer ist es unerheblich, in welchem Prozessor der Thread ausgeführt wird. Aufgrund von Fehlern im BIOS oder der Hardware Abstraktionsschicht (HAL) können Sie jedoch unterschiedliche Zeit Steuerungs Ergebnisse für verschiedene Prozessoren erhalten. Um die Prozessor Affinität für einen Thread anzugeben, verwenden Sie die <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A?displayProperty=nameWithType>-Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Diagnostics.Stopwatch>-Klasse verwendet wird, um die Ausführungszeit für eine Anwendung zu bestimmen.  
  
 [!code-csharp[System.Diagnostics.Stopwatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/CS/source.cs#1)]
 [!code-vb[System.Diagnostics.Stopwatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/VB/source.vb#1)]  
  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Diagnostics.Stopwatch>-Klasse, um Leistungsdaten zu berechnen.  
  
 [!code-cpp[StopWatchPerfSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/StopWatchPerfSample/CPP/source.cpp#1)]
 [!code-csharp[StopWatchPerfSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/StopWatchPerfSample/CS/source.cs#1)]
 [!code-vb[StopWatchPerfSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StopWatchPerfSample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.TimeSpan" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stopwatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stopwatch();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.Stopwatch" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene <xref:System.Diagnostics.Stopwatch> Instanz wurde beendet, und die verstrichene Zeit Eigenschaft der-Instanz ist 0 (null).  
  
 Verwenden Sie die <xref:System.Diagnostics.Stopwatch.Start%2A>-Methode, um mit der Messung der verstrichenen Zeit mit der neuen <xref:System.Diagnostics.Stopwatch>-Instanz Verwenden Sie die <xref:System.Diagnostics.Stopwatch.StartNew%2A>-Methode, um eine neue <xref:System.Diagnostics.Stopwatch> Instanz zu initialisieren und sofort zu starten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Diagnostics.Stopwatch> Instanz mithilfe eines einfachen Klassenkonstruktors initialisiert.  
  
 [!code-csharp[System.Diagnostics.Stopwatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/CS/source.cs#1)]
 [!code-vb[System.Diagnostics.Stopwatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Stopwatch.StartNew" />
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public TimeSpan Elapsed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan Elapsed" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Stopwatch.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Elapsed As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan Elapsed { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.Elapsed : TimeSpan" Usage="System.Diagnostics.Stopwatch.Elapsed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamte verstrichene Zeit ab, die von der aktuellen Instanz gemessen wurde.</summary>
        <value>Eine schreibgeschützte <see cref="T:System.TimeSpan" />, die die gesamte, von der aktuellen Instanz gemessene verstrichene Zeit darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In einem typischen <xref:System.Diagnostics.Stopwatch> Szenario wird die <xref:System.Diagnostics.Stopwatch.Start%2A>-Methode aufgerufen, schließlich wird die <xref:System.Diagnostics.Stopwatch.Stop%2A>-Methode aufgerufen, und anschließend wird die verstrichene Zeit mithilfe der <xref:System.Diagnostics.Stopwatch.Elapsed%2A>-Eigenschaft überprüft.  
  
 Verwenden Sie die <xref:System.Diagnostics.Stopwatch.Elapsed%2A>-Eigenschaft, um den Wert für die verstrichene Zeit mithilfe <xref:System.TimeSpan> Methoden und Eigenschaften abzurufen. Beispielsweise können Sie die zurückgegebene <xref:System.TimeSpan> Instanz in eine Textdarstellung formatieren oder an eine andere Klasse übergeben, die einen <xref:System.TimeSpan>-Parameter erfordert.  
  
 Sie können die Eigenschaften <xref:System.Diagnostics.Stopwatch.Elapsed%2A>, <xref:System.Diagnostics.Stopwatch.ElapsedMilliseconds%2A>und <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A> Abfragen, während die <xref:System.Diagnostics.Stopwatch> Instanz ausgeführt oder beendet wird. Die verstrichenen Zeit werden während der Ausführung der <xref:System.Diagnostics.Stopwatch> konstant erhöht. Sie bleiben konstant, wenn die Instanz beendet wird.  
  
 Standardmäßig ist der verstrichene Zeitwert einer <xref:System.Diagnostics.Stopwatch> Instanz gleich der Summe aller gemessenen Zeitintervalle. Jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Start%2A> beginnt mit der Zählung der kumulativen verstrichenen Zeit. Jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Stop%2A> beendet die aktuelle Intervallmessung und friert den kumulativen Wert für die verstrichene Zeit ein. Verwenden Sie die <xref:System.Diagnostics.Stopwatch.Reset%2A>-Methode, um die kumulierte verstrichene Zeit in einer vorhandenen <xref:System.Diagnostics.Stopwatch> Instanz zu löschen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Diagnostics.Stopwatch.Elapsed%2A>-Eigenschaft verwendet wird, um die Ausführungszeit für eine Anwendung zu bestimmen.  
  
 [!code-csharp[System.Diagnostics.Stopwatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/CS/source.cs#1)]
 [!code-vb[System.Diagnostics.Stopwatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="P:System.Diagnostics.Stopwatch.ElapsedMilliseconds" />
        <altmember cref="P:System.Diagnostics.Stopwatch.ElapsedTicks" />
      </Docs>
    </Member>
    <Member MemberName="ElapsedMilliseconds">
      <MemberSignature Language="C#" Value="public long ElapsedMilliseconds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ElapsedMilliseconds" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Stopwatch.ElapsedMilliseconds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ElapsedMilliseconds As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ElapsedMilliseconds { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ElapsedMilliseconds : int64" Usage="System.Diagnostics.Stopwatch.ElapsedMilliseconds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamte verstrichene Zeit in Millisekunden ab, die von der aktuellen Instanz gemessen wurde.</summary>
        <value>Eine schreibgeschützte Long-Integer-Zahl, die die Gesamtanzahl der von der aktuellen Instanz gemessenen Millisekunden angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft stellt die verstrichene Zeit dar, die auf den nächsten ganzzahligen Wert gerundet wurde. Verwenden Sie für Messungen mit höherer Genauigkeit die Eigenschaften <xref:System.Diagnostics.Stopwatch.Elapsed%2A> oder <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A>.  
  
 Sie können die Eigenschaften <xref:System.Diagnostics.Stopwatch.Elapsed%2A>, <xref:System.Diagnostics.Stopwatch.ElapsedMilliseconds%2A>und <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A> Abfragen, während die <xref:System.Diagnostics.Stopwatch> Instanz ausgeführt oder beendet wird. Die verstrichenen Zeit werden während der Ausführung der <xref:System.Diagnostics.Stopwatch> konstant erhöht. Sie bleiben konstant, wenn die Instanz beendet wird.  
  
 Standardmäßig ist der verstrichene Zeitwert einer <xref:System.Diagnostics.Stopwatch> Instanz gleich der Summe aller gemessenen Zeitintervalle. Jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Start%2A> beginnt mit der Zählung der kumulativen verstrichenen Zeit. Jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Stop%2A> beendet die aktuelle Intervallmessung und friert den kumulativen Wert für die verstrichene Zeit ein. Verwenden Sie die <xref:System.Diagnostics.Stopwatch.Reset%2A>-Methode, um die kumulierte verstrichene Zeit in einer vorhandenen <xref:System.Diagnostics.Stopwatch> Instanz zu löschen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Diagnostics.Stopwatch>-Klasse verwendet, um die Leistung von vier verschiedenen Implementierungen zum Durchsuchen einer Ganzzahl aus einer Zeichenfolge zu messen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Diagnostics.Stopwatch>-Klasse bereitgestellt wird.  
  
 [!code-cpp[StopWatchPerfSample#3](~/samples/snippets/cpp/VS_Snippets_CLR/StopWatchPerfSample/CPP/source.cpp#3)]
 [!code-csharp[StopWatchPerfSample#3](~/samples/snippets/csharp/VS_Snippets_CLR/StopWatchPerfSample/CS/source.cs#3)]
 [!code-vb[StopWatchPerfSample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/StopWatchPerfSample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Stopwatch.Elapsed" />
        <altmember cref="P:System.Diagnostics.Stopwatch.ElapsedTicks" />
      </Docs>
    </Member>
    <Member MemberName="ElapsedTicks">
      <MemberSignature Language="C#" Value="public long ElapsedTicks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ElapsedTicks" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Stopwatch.ElapsedTicks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ElapsedTicks As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ElapsedTicks { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ElapsedTicks : int64" Usage="System.Diagnostics.Stopwatch.ElapsedTicks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamte verstrichene Zeit, die von der aktuellen Instanz gemessen wurde, in Zeitgeberintervallen (Ticks) ab.</summary>
        <value>Eine schreibgeschützte Long-Integer-Zahl, die die Gesamtanzahl der von der aktuellen Instanz gemessenen Zeitgeberintervalle angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft stellt die Anzahl der im zugrunde liegenden Zeit Geber Mechanismus verstrichenen Ticks dar. Ein Tick ist die kleinste Zeiteinheit, die der <xref:System.Diagnostics.Stopwatch> Timer messen kann. Verwenden Sie das <xref:System.Diagnostics.Stopwatch.Frequency> Feld, um den <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A> Wert in eine Anzahl von Sekunden zu konvertieren.  
  
 Sie können die Eigenschaften <xref:System.Diagnostics.Stopwatch.Elapsed%2A>, <xref:System.Diagnostics.Stopwatch.ElapsedMilliseconds%2A>und <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A> Abfragen, während die <xref:System.Diagnostics.Stopwatch> Instanz ausgeführt oder beendet wird. Die verstrichenen Zeit werden während der Ausführung der <xref:System.Diagnostics.Stopwatch> konstant erhöht. Sie bleiben konstant, wenn die Instanz beendet wird.  
  
 Standardmäßig ist der verstrichene Zeitwert einer <xref:System.Diagnostics.Stopwatch> Instanz gleich der Summe aller gemessenen Zeitintervalle. Jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Start%2A> beginnt mit der Zählung der kumulativen verstrichenen Zeit. Jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Stop%2A> beendet die aktuelle Intervallmessung und friert den kumulativen Wert für die verstrichene Zeit ein. Verwenden Sie die <xref:System.Diagnostics.Stopwatch.Reset%2A>-Methode, um die kumulierte verstrichene Zeit in einer vorhandenen <xref:System.Diagnostics.Stopwatch> Instanz zu löschen.  
  
> [!NOTE]
>  <xref:System.Diagnostics.Stopwatch> Ticks unterscheiden sich von <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType>. Jeder Tick im <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> Wert stellt 1 100-Nanosekunden-Intervall dar. Jeder Tick im <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A> Wert gibt das Zeitintervall an, das gleich 1 Sekunde dividiert durch die <xref:System.Diagnostics.Stopwatch.Frequency>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Diagnostics.Stopwatch>-Klasse verwendet, um die Leistung von vier verschiedenen Implementierungen zum Durchsuchen einer Ganzzahl aus einer Zeichenfolge zu messen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Diagnostics.Stopwatch>-Klasse bereitgestellt wird.  
  
 [!code-cpp[StopWatchPerfSample#4](~/samples/snippets/cpp/VS_Snippets_CLR/StopWatchPerfSample/CPP/source.cpp#4)]
 [!code-csharp[StopWatchPerfSample#4](~/samples/snippets/csharp/VS_Snippets_CLR/StopWatchPerfSample/CS/source.cs#4)]
 [!code-vb[StopWatchPerfSample#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/StopWatchPerfSample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Stopwatch.Elapsed" />
        <altmember cref="P:System.Diagnostics.Stopwatch.ElapsedMilliseconds" />
        <altmember cref="F:System.Diagnostics.Stopwatch.Frequency" />
      </Docs>
    </Member>
    <Member MemberName="Frequency">
      <MemberSignature Language="C#" Value="public static readonly long Frequency;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 Frequency" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.Stopwatch.Frequency" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Frequency As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long Frequency;" />
      <MemberSignature Language="F#" Value=" staticval mutable Frequency : int64" Usage="System.Diagnostics.Stopwatch.Frequency" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Frequenz des Timers als Anzahl von Ticks pro Sekunde ab. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeit Geber Frequenz gibt die Zeit Geber Genauigkeit und-Auflösung an. Eine Zeit Geber Frequenz von 2 Millionen Ticks pro Sekunde ist beispielsweise eine Zeit Geber Auflösung von 500 Nanosekunden pro Tick. Das heißt, weil eine Sekunde gleich 1 Milliarde Nanosekunden ist, entspricht eine Zeit Geber Häufigkeit von 2 Millionen Ticks pro Sekunde 2 Millionen Ticks pro 1 Milliarde nanoseconds. Dies kann zu einer weiteren Vereinfachung auf 1 Tick pro 500 nanoseconds werden.  
  
 Der <xref:System.Diagnostics.Stopwatch.Frequency> Wert hängt von der Auflösung des zugrunde liegenden Zeit Steuerungsmechanismus ab. Wenn die installierte Hardware und das Betriebssystem einen Leistungs Bewert mit hoher Auflösung unterstützen, gibt der <xref:System.Diagnostics.Stopwatch.Frequency> Wert die Häufigkeit dieses Leistungs Zählers an. Andernfalls basiert der <xref:System.Diagnostics.Stopwatch.Frequency> Wert auf der Systemzeit Geber Frequenz.  
  
 Da die <xref:System.Diagnostics.Stopwatch> Häufigkeit von der installierten Hardware und dem Betriebssystem abhängt, bleibt der <xref:System.Diagnostics.Stopwatch.Frequency> Wert konstant, während das System ausgeführt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Häufigkeit und Auflösung eines <xref:System.Diagnostics.Stopwatch> Timers angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Diagnostics.Stopwatch>-Klasse bereitgestellt wird.  
  
 [!code-cpp[StopWatchPerfSample#2](~/samples/snippets/cpp/VS_Snippets_CLR/StopWatchPerfSample/CPP/source.cpp#2)]
 [!code-csharp[StopWatchPerfSample#2](~/samples/snippets/csharp/VS_Snippets_CLR/StopWatchPerfSample/CS/source.cs#2)]
 [!code-vb[StopWatchPerfSample#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/StopWatchPerfSample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Diagnostics.Stopwatch.IsHighResolution" />
      </Docs>
    </Member>
    <Member MemberName="GetTimestamp">
      <MemberSignature Language="C#" Value="public static long GetTimestamp ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTimestamp() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.GetTimestamp" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTimestamp () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTimestamp();" />
      <MemberSignature Language="F#" Value="static member GetTimestamp : unit -&gt; int64" Usage="System.Diagnostics.Stopwatch.GetTimestamp " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die aktuelle Anzahl der Ticks im Timermechanismus ab.</summary>
        <returns>Eine Long-Integer-Zahl, die den Tickzählerwert des zugrunde liegenden Zeitgebermechanismus angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Diagnostics.Stopwatch> Klasse einen Leistungs Bearbeiter mit hoher Auflösung verwendet, gibt <xref:System.Diagnostics.Stopwatch.GetTimestamp%2A> den aktuellen Wert dieses Leistungs Zählers zurück. Wenn die <xref:System.Diagnostics.Stopwatch>-Klasse den System-Timer verwendet, gibt <xref:System.Diagnostics.Stopwatch.GetTimestamp%2A> die aktuelle <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType>-Eigenschaft der <xref:System.DateTime.Now%2A?displayProperty=nameWithType> Instanz zurück.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Diagnostics.Stopwatch.GetTimestamp%2A>-Methode zum Aktualisieren eines Leistungs Zählers.  
  
 [!code-cpp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CPP/elapsedtime.cpp#2)]
 [!code-csharp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CS/elapsedtime.cs#2)]
 [!code-vb[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/VB/elapsedtime.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Diagnostics.Stopwatch.IsHighResolution" />
      </Docs>
    </Member>
    <Member MemberName="IsHighResolution">
      <MemberSignature Language="C#" Value="public static readonly bool IsHighResolution;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly bool IsHighResolution" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.Stopwatch.IsHighResolution" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsHighResolution As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly bool IsHighResolution;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsHighResolution : bool" Usage="System.Diagnostics.Stopwatch.IsHighResolution" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Timer auf einem hochauflösenden Leistungsindikator basiert. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von der <xref:System.Diagnostics.Stopwatch>-Klasse verwendete Timer hängt von der System Hardware und dem Betriebssystem ab. <xref:System.Diagnostics.Stopwatch.IsHighResolution> ist `true`, wenn der <xref:System.Diagnostics.Stopwatch> Timer auf einem Leistungs Zähler mit hoher Auflösung basiert. Andernfalls wird <xref:System.Diagnostics.Stopwatch.IsHighResolution> `false`, was darauf hinweist, dass der <xref:System.Diagnostics.Stopwatch> Timer auf dem systemtimer basiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Häufigkeit und Auflösung eines <xref:System.Diagnostics.Stopwatch> Timers angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Diagnostics.Stopwatch>-Klasse bereitgestellt wird.  
  
 [!code-cpp[StopWatchPerfSample#2](~/samples/snippets/cpp/VS_Snippets_CLR/StopWatchPerfSample/CPP/source.cpp#2)]
 [!code-csharp[StopWatchPerfSample#2](~/samples/snippets/csharp/VS_Snippets_CLR/StopWatchPerfSample/CS/source.cs#2)]
 [!code-vb[StopWatchPerfSample#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/StopWatchPerfSample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Diagnostics.Stopwatch.Frequency" />
      </Docs>
    </Member>
    <Member MemberName="IsRunning">
      <MemberSignature Language="C#" Value="public bool IsRunning { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRunning" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Stopwatch.IsRunning" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRunning As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRunning { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRunning : bool" Usage="System.Diagnostics.Stopwatch.IsRunning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Diagnostics.Stopwatch" />-Timer ausgeführt wird.</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Diagnostics.Stopwatch" />-Instanz derzeit ausgeführt wird und die verstrichene Zeit für ein Intervall misst, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Diagnostics.Stopwatch> Instanz wird mit einem <xref:System.Diagnostics.Stopwatch.Start%2A>-oder <xref:System.Diagnostics.Stopwatch.StartNew%2A>-aufrufenden gestartet. Die Instanz wird mit einem <xref:System.Diagnostics.Stopwatch.Stop%2A>-oder <xref:System.Diagnostics.Stopwatch.Reset%2A>aufgerufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Stopwatch.StartNew" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Stop" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Start" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; unit" Usage="stopwatch.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Zeitintervallmessung und setzt die verstrichene Zeit auf 0 (null) zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Diagnostics.Stopwatch> Instanz berechnet und bewahrt die kumulierte verstrichene Zeit über mehrere Zeiträume hinweg, bis die Instanz zurückgesetzt wird. Verwenden Sie <xref:System.Diagnostics.Stopwatch.Stop%2A>, um die aktuelle Intervallmessung anzuhalten und den kumulativen Wert für die verstrichene Zeit beizubehalten. Verwenden Sie <xref:System.Diagnostics.Stopwatch.Reset%2A>, um die laufende Intervallmessung zu beenden und den verstrichenen Zeitwert zu löschen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Stopwatch.StartNew" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Stop" />
        <altmember cref="P:System.Diagnostics.Stopwatch.IsRunning" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Start" />
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Restart();" />
      <MemberSignature Language="F#" Value="member this.Restart : unit -&gt; unit" Usage="stopwatch.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Zeitintervallmessung, setzt die verstrichene Zeit auf 0 (null) zurück, und startet die Messung der verstrichenen Zeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Diagnostics.Stopwatch> Instanz berechnet und bewahrt die kumulierte verstrichene Zeit über mehrere Zeitintervalle hinweg, bis die Instanz zurückgesetzt oder neu gestartet wird. Verwenden Sie <xref:System.Diagnostics.Stopwatch.Stop%2A>, um die aktuelle Intervallmessung anzuhalten und den kumulativen Wert für die verstrichene Zeit beizubehalten. Verwenden Sie <xref:System.Diagnostics.Stopwatch.Reset%2A>, um die laufende Intervallmessung zu beenden und den verstrichenen Zeitwert zu löschen. Verwenden Sie <xref:System.Diagnostics.Stopwatch.Restart%2A>, um die aktuelle Intervallmessung anzuhalten und eine neue Intervallmessung zu starten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="stopwatch.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet den Messvorgang der verstrichenen Zeit für ein Intervall oder nimmt diesen wieder auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In einem typischen <xref:System.Diagnostics.Stopwatch> Szenario wird die <xref:System.Diagnostics.Stopwatch.Start%2A>-Methode aufgerufen, schließlich wird die <xref:System.Diagnostics.Stopwatch.Stop%2A>-Methode aufgerufen, und anschließend wird die verstrichene Zeit mithilfe der <xref:System.Diagnostics.Stopwatch.Elapsed%2A>-Eigenschaft überprüft.  
  
 Nach dem Start misst ein <xref:System.Diagnostics.Stopwatch> Timer das aktuelle Intervall (in den verstrichenen Zeiteinheiten Ticks), bis die Instanz beendet oder zurückgesetzt wird. Beim Starten einer <xref:System.Diagnostics.Stopwatch>, die bereits ausgeführt wird, wird der Zeit Geber Zustand nicht geändert, oder die abgelaufenen Zeiteigenschaften werden zurückgesetzt.  
  
 Wenn eine <xref:System.Diagnostics.Stopwatch> Instanz mehr als ein Intervall misst, setzt die <xref:System.Diagnostics.Stopwatch.Start%2A>-Methode die Mess Zeit des aktuell verstrichenen Zeitwerts fort. Eine <xref:System.Diagnostics.Stopwatch> Instanz berechnet und bewahrt die kumulierte verstrichene Zeit über mehrere Zeiträume hinweg, bis die Instanz zurückgesetzt wird. Verwenden Sie die <xref:System.Diagnostics.Stopwatch.Reset%2A>-Methode, bevor Sie <xref:System.Diagnostics.Stopwatch.Start%2A> aufrufen, um die kumulierte Zeitspanne in einer <xref:System.Diagnostics.Stopwatch> Instanz zu löschen. Verwenden Sie die <xref:System.Diagnostics.Stopwatch.Restart%2A>-Methode, um die <xref:System.Diagnostics.Stopwatch> mit einem einzigen Befehl zu <xref:System.Diagnostics.Stopwatch.Reset%2A> und zu <xref:System.Diagnostics.Stopwatch.Start%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Diagnostics.Stopwatch.Start%2A>-Methode verwendet wird, um einen Timer zu starten, der die Ausführungszeit einer Anwendung misst.  
  
 [!code-csharp[System.Diagnostics.Stopwatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/CS/source.cs#1)]
 [!code-vb[System.Diagnostics.Stopwatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Stopwatch.StartNew" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Stop" />
        <altmember cref="P:System.Diagnostics.Stopwatch.IsRunning" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Reset" />
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Stopwatch StartNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Stopwatch StartNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.StartNew" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StartNew () As Stopwatch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Stopwatch ^ StartNew();" />
      <MemberSignature Language="F#" Value="static member StartNew : unit -&gt; System.Diagnostics.Stopwatch" Usage="System.Diagnostics.Stopwatch.StartNew " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Stopwatch</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue <see cref="T:System.Diagnostics.Stopwatch" />-Instanz, legt die Eigenschaft der verstrichenen Zeit auf 0 (null) fest und beginnt mit dem Messen der verstrichenen Zeit.</summary>
        <returns>Eine <see cref="T:System.Diagnostics.Stopwatch" />, die gerade mit dem Messen der verstrichenen Zeit begonnen hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht dem Aufrufen des <xref:System.Diagnostics.Stopwatch>-Konstruktors und dem anschließenden Aufrufen von <xref:System.Diagnostics.Stopwatch.Start%2A> für die neue-Instanz.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Diagnostics.Stopwatch>-Klasse verwendet, um die Leistung von vier verschiedenen Implementierungen zum Durchsuchen einer Ganzzahl aus einer Zeichenfolge zu messen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Diagnostics.Stopwatch>-Klasse bereitgestellt wird.  
  
 [!code-cpp[StopWatchPerfSample#4](~/samples/snippets/cpp/VS_Snippets_CLR/StopWatchPerfSample/CPP/source.cpp#4)]
 [!code-csharp[StopWatchPerfSample#4](~/samples/snippets/csharp/VS_Snippets_CLR/StopWatchPerfSample/CS/source.cs#4)]
 [!code-vb[StopWatchPerfSample#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/StopWatchPerfSample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Stopwatch.Start" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Stop" />
        <altmember cref="P:System.Diagnostics.Stopwatch.IsRunning" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="stopwatch.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet das Messen der verstrichenen Zeit für ein Intervall.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In einem typischen <xref:System.Diagnostics.Stopwatch> Szenario wird die <xref:System.Diagnostics.Stopwatch.Start%2A>-Methode aufgerufen, schließlich wird die <xref:System.Diagnostics.Stopwatch.Stop%2A>-Methode aufgerufen, und anschließend wird die verstrichene Zeit mithilfe der <xref:System.Diagnostics.Stopwatch.Elapsed%2A>-Eigenschaft überprüft.  
  
 Die <xref:System.Diagnostics.Stopwatch.Stop%2A>-Methode beendet die aktuelle Zeitintervall Messung. Wenn Sie einen <xref:System.Diagnostics.Stopwatch> beenden, der nicht ausgeführt wird, wird der Zeit Geber Zustand nicht geändert, oder die abgelaufenen Zeiteigenschaften werden zurückgesetzt.  
  
 Wenn eine <xref:System.Diagnostics.Stopwatch> Instanz mehr als ein Intervall misst, entspricht die <xref:System.Diagnostics.Stopwatch.Stop%2A>-Methode dem Anhalten der verstrichenen Zeitmessung. Bei einem nachfolgenden Aufruf von <xref:System.Diagnostics.Stopwatch.Start%2A> wird die Mess Zeit des aktuellen verstrichenen Zeitwerts fortgesetzt. Verwenden Sie die <xref:System.Diagnostics.Stopwatch.Reset%2A>-Methode, um die kumulierte verstrichene Zeit in einer <xref:System.Diagnostics.Stopwatch> Instanz zu löschen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie mit der <xref:System.Diagnostics.Stopwatch.Stop%2A>-Methode einen Timer beenden, der die Ausführungszeit einer Anwendung misst.  
  
 [!code-csharp[System.Diagnostics.Stopwatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/CS/source.cs#1)]
 [!code-vb[System.Diagnostics.Stopwatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Stopwatch.StartNew" />
        <altmember cref="P:System.Diagnostics.Stopwatch.IsRunning" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Start" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Reset" />
      </Docs>
    </Member>
  </Members>
</Type>
