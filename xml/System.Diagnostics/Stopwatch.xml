<Type Name="Stopwatch" FullName="System.Diagnostics.Stopwatch">
  <Metadata><Meta Name="ms.openlocfilehash" Value="00e280891640bc6bb4268a3fd34c180dd3d5046f" /><Meta Name="ms.sourcegitcommit" Value="33d00f2251119ae69bf205fb032815259baaf126" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/24/2020" /><Meta Name="ms.locfileid" Value="87168989" /></Metadata><TypeSignature Language="C#" Value="public class Stopwatch" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Stopwatch extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Stopwatch" />
  <TypeSignature Language="VB.NET" Value="Public Class Stopwatch" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stopwatch" />
  <TypeSignature Language="F#" Value="type Stopwatch = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Stopwatch extends System.Object" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System" FromVersion="4.0.0.0" To="System.Runtime.Extensions" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine Gruppe von Methoden und Eigenschaften bereit, mit denen die verstrichene Zeit exakt gemessen werden kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine- <xref:System.Diagnostics.Stopwatch> Instanz kann die verstrichene Zeit für ein Intervall oder die Summe der verstrichenen Zeit über mehrere Intervalle hinweg messen. In einem typischen <xref:System.Diagnostics.Stopwatch> Szenario wird die- <xref:System.Diagnostics.Stopwatch.Start%2A> Methode aufgerufen, schließlich wird die <xref:System.Diagnostics.Stopwatch.Stop%2A> -Methode aufgerufen, und anschließend wird die verstrichene Zeit mithilfe der- <xref:System.Diagnostics.Stopwatch.Elapsed%2A> Eigenschaft überprüft.  
  
 Eine- <xref:System.Diagnostics.Stopwatch> Instanz wird entweder ausgeführt oder beendet <xref:System.Diagnostics.Stopwatch.IsRunning%2A> . verwenden Sie, um den aktuellen Zustand eines zu bestimmen <xref:System.Diagnostics.Stopwatch> . Verwenden <xref:System.Diagnostics.Stopwatch.Start%2A> Sie, um mit der Messung der verstrichenen Zeit zu beginnen <xref:System.Diagnostics.Stopwatch.Stop%2A> Fragen Sie den verstrichenen Zeitwert über die Eigenschaften <xref:System.Diagnostics.Stopwatch.Elapsed%2A> , <xref:System.Diagnostics.Stopwatch.ElapsedMilliseconds%2A> oder ab <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A> . Sie können die verstrichenen Zeiteigenschaften Abfragen, während die Instanz ausgeführt wird oder beendet wird. Die verstrichenen Zeit werden ständig vergrößert <xref:System.Diagnostics.Stopwatch> , während der ausgeführt wird. Sie bleiben konstant, wenn die Instanz beendet wird.  
  
 Standardmäßig ist der verstrichene Zeitwert einer- <xref:System.Diagnostics.Stopwatch> Instanz mit der Summe aller gemessenen Zeitintervalle gleich. Jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Start%2A> beginnt mit dem zählen der kumulativen verstrichenen Zeit. jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Stop%2A> beendet die aktuelle Intervallmessung und friert den kumulativen Wert für die verstrichene Zeit. Verwenden Sie die- <xref:System.Diagnostics.Stopwatch.Reset%2A> Methode, um die kumulierte Zeitspanne in einer vorhandenen Instanz zu löschen <xref:System.Diagnostics.Stopwatch> .  
  
 Die <xref:System.Diagnostics.Stopwatch> verstrichene Zeit, indem Zeit Geber Ticks im zugrunde liegenden Zeit Geber Mechanismus gezählt werden. Wenn die installierte Hardware und das Betriebssystem einen Leistungs Bearbeiter mit hoher Auflösung unterstützen, <xref:System.Diagnostics.Stopwatch> verwendet die Klasse diesen Leistungs Bearbeiter, um die verstrichene Zeit zu messen. Andernfalls verwendet die- <xref:System.Diagnostics.Stopwatch> Klasse den systemtimer, um die verstrichene Zeit zu messen. Verwenden <xref:System.Diagnostics.Stopwatch.Frequency> Sie die <xref:System.Diagnostics.Stopwatch.IsHighResolution> Felder und, um die Genauigkeit und Auflösung der <xref:System.Diagnostics.Stopwatch> zeitlichen Steuerung zu bestimmen.  
  
 Die <xref:System.Diagnostics.Stopwatch> -Klasse unterstützt die Bearbeitung zeitbezogener Leistungsindikatoren in verwaltetem Code. Insbesondere können das- <xref:System.Diagnostics.Stopwatch.Frequency> Feld und die <xref:System.Diagnostics.Stopwatch.GetTimestamp%2A> -Methode anstelle der nicht verwalteten Windows-APIs und verwendet werden `QueryPerformanceFrequency` `QueryPerformanceCounter` .  
  
> [!NOTE]
>  Auf einem Multiprozessorcomputer ist es unerheblich, in welchem Prozessor der Thread ausgeführt wird. Aufgrund von Fehlern im BIOS oder der Hardware Abstraktionsschicht (HAL) können Sie jedoch unterschiedliche Zeit Steuerungs Ergebnisse für verschiedene Prozessoren erhalten. Um die Prozessor Affinität für einen Thread anzugeben, verwenden Sie die- <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die-Klasse verwendet wird <xref:System.Diagnostics.Stopwatch> , um die Ausführungszeit für eine Anwendung zu bestimmen.  
  
 [!code-csharp[System.Diagnostics.Stopwatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/CS/source.cs#1)]
 [!code-vb[System.Diagnostics.Stopwatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/VB/source.vb#1)]  
  
 Im folgenden Beispiel wird die Verwendung der- <xref:System.Diagnostics.Stopwatch> Klasse zum Berechnen von Leistungsdaten veranschaulicht.  
  
 [!code-cpp[StopWatchPerfSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/StopWatchPerfSample/CPP/source.cpp#1)]
 [!code-csharp[StopWatchPerfSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/StopWatchPerfSample/CS/source.cs#1)]
 [!code-vb[StopWatchPerfSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StopWatchPerfSample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.TimeSpan" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stopwatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stopwatch();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.Stopwatch" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebene <xref:System.Diagnostics.Stopwatch> -Instanz wird beendet, und die verstrichene Zeit Eigenschaft der-Instanz ist 0 (null).  
  
 Verwenden Sie die- <xref:System.Diagnostics.Stopwatch.Start%2A> Methode, um die verstrichene Zeit mit der neuen Instanz zu messen <xref:System.Diagnostics.Stopwatch> Verwenden <xref:System.Diagnostics.Stopwatch.StartNew%2A> Sie die-Methode, um eine neue Instanz zu initialisieren <xref:System.Diagnostics.Stopwatch> und sofort zu starten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine- <xref:System.Diagnostics.Stopwatch> Instanz mithilfe eines einfachen Klassenkonstruktors initialisiert.  
  
 [!code-csharp[System.Diagnostics.Stopwatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/CS/source.cs#1)]
 [!code-vb[System.Diagnostics.Stopwatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Stopwatch.StartNew" />
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public TimeSpan Elapsed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan Elapsed" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Stopwatch.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Elapsed As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan Elapsed { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.Elapsed : TimeSpan" Usage="System.Diagnostics.Stopwatch.Elapsed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamte verstrichene Zeit ab, die von der aktuellen Instanz gemessen wurde.</summary>
        <value>Eine schreibgeschützte <see cref="T:System.TimeSpan" />, die die gesamte, von der aktuellen Instanz gemessene verstrichene Zeit darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In einem typischen <xref:System.Diagnostics.Stopwatch> Szenario wird die- <xref:System.Diagnostics.Stopwatch.Start%2A> Methode aufgerufen, schließlich wird die <xref:System.Diagnostics.Stopwatch.Stop%2A> -Methode aufgerufen, und anschließend wird die verstrichene Zeit mithilfe der- <xref:System.Diagnostics.Stopwatch.Elapsed%2A> Eigenschaft überprüft.  
  
 Verwenden Sie die- <xref:System.Diagnostics.Stopwatch.Elapsed%2A> Eigenschaft, um den verstrichenen Zeitwert mithilfe von <xref:System.TimeSpan> Methoden und Eigenschaften abzurufen. Beispielsweise können Sie die zurückgegebene- <xref:System.TimeSpan> Instanz in eine Textdarstellung formatieren oder an eine andere Klasse übergeben, die einen- <xref:System.TimeSpan> Parameter erfordert.  
  
 Sie können die Eigenschaften <xref:System.Diagnostics.Stopwatch.Elapsed%2A> , und Abfragen, <xref:System.Diagnostics.Stopwatch.ElapsedMilliseconds%2A> <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A> während die <xref:System.Diagnostics.Stopwatch> Instanz ausgeführt wird oder beendet wird. Die verstrichenen Zeit werden ständig vergrößert <xref:System.Diagnostics.Stopwatch> , während der ausgeführt wird. Sie bleiben konstant, wenn die Instanz beendet wird.  
  
 Standardmäßig ist der verstrichene Zeitwert einer- <xref:System.Diagnostics.Stopwatch> Instanz mit der Summe aller gemessenen Zeitintervalle gleich. Jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Start%2A> beginnt mit dem zählen der kumulativen verstrichenen Zeit. jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Stop%2A> beendet die aktuelle Intervallmessung und friert den kumulativen Wert für die verstrichene Zeit. Verwenden Sie die- <xref:System.Diagnostics.Stopwatch.Reset%2A> Methode, um die kumulierte Zeitspanne in einer vorhandenen Instanz zu löschen <xref:System.Diagnostics.Stopwatch> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die-Eigenschaft verwendet wird <xref:System.Diagnostics.Stopwatch.Elapsed%2A> , um die Ausführungszeit für eine Anwendung zu bestimmen.  
  
 [!code-csharp[System.Diagnostics.Stopwatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/CS/source.cs#1)]
 [!code-vb[System.Diagnostics.Stopwatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="P:System.Diagnostics.Stopwatch.ElapsedMilliseconds" />
        <altmember cref="P:System.Diagnostics.Stopwatch.ElapsedTicks" />
      </Docs>
    </Member>
    <Member MemberName="ElapsedMilliseconds">
      <MemberSignature Language="C#" Value="public long ElapsedMilliseconds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ElapsedMilliseconds" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Stopwatch.ElapsedMilliseconds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ElapsedMilliseconds As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ElapsedMilliseconds { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ElapsedMilliseconds : int64" Usage="System.Diagnostics.Stopwatch.ElapsedMilliseconds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamte verstrichene Zeit in Millisekunden ab, die von der aktuellen Instanz gemessen wurde.</summary>
        <value>Eine schreibgeschützte Long-Integer-Zahl, die die Gesamtanzahl der von der aktuellen Instanz gemessenen Millisekunden angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft stellt die verstrichene Zeit dar, die auf den nächsten ganzzahligen Wert gerundet wurde. Verwenden Sie für Messungen mit höherer Genauigkeit die-Eigenschaft oder die-Eigenschaft <xref:System.Diagnostics.Stopwatch.Elapsed%2A> <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A> .  
  
 Sie können die Eigenschaften <xref:System.Diagnostics.Stopwatch.Elapsed%2A> , und Abfragen, <xref:System.Diagnostics.Stopwatch.ElapsedMilliseconds%2A> <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A> während die <xref:System.Diagnostics.Stopwatch> Instanz ausgeführt wird oder beendet wird. Die verstrichenen Zeit werden ständig vergrößert <xref:System.Diagnostics.Stopwatch> , während der ausgeführt wird. Sie bleiben konstant, wenn die Instanz beendet wird.  
  
 Standardmäßig ist der verstrichene Zeitwert einer- <xref:System.Diagnostics.Stopwatch> Instanz mit der Summe aller gemessenen Zeitintervalle gleich. Jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Start%2A> beginnt mit dem zählen der kumulativen verstrichenen Zeit. jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Stop%2A> beendet die aktuelle Intervallmessung und friert den kumulativen Wert für die verstrichene Zeit. Verwenden Sie die- <xref:System.Diagnostics.Stopwatch.Reset%2A> Methode, um die kumulierte Zeitspanne in einer vorhandenen Instanz zu löschen <xref:System.Diagnostics.Stopwatch> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird die- <xref:System.Diagnostics.Stopwatch> Klasse verwendet, um die Leistung von vier verschiedenen Implementierungen zum Durchsuchen einer Ganzzahl aus einer Zeichenfolge zu messen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Diagnostics.Stopwatch> .  
  
 [!code-cpp[StopWatchPerfSample#3](~/samples/snippets/cpp/VS_Snippets_CLR/StopWatchPerfSample/CPP/source.cpp#3)]
 [!code-csharp[StopWatchPerfSample#3](~/samples/snippets/csharp/VS_Snippets_CLR/StopWatchPerfSample/CS/source.cs#3)]
 [!code-vb[StopWatchPerfSample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/StopWatchPerfSample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Stopwatch.Elapsed" />
        <altmember cref="P:System.Diagnostics.Stopwatch.ElapsedTicks" />
      </Docs>
    </Member>
    <Member MemberName="ElapsedTicks">
      <MemberSignature Language="C#" Value="public long ElapsedTicks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ElapsedTicks" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Stopwatch.ElapsedTicks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ElapsedTicks As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ElapsedTicks { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ElapsedTicks : int64" Usage="System.Diagnostics.Stopwatch.ElapsedTicks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamte verstrichene Zeit, die von der aktuellen Instanz gemessen wurde, in Timerintervallen (Ticks) ab.</summary>
        <value>Eine schreibgeschützte Long-Integer-Zahl, die die Gesamtanzahl der von der aktuellen Instanz gemessenen Zeitgeberintervalle angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft stellt die Anzahl der im zugrunde liegenden Zeit Geber Mechanismus verstrichenen Ticks dar. Ein Tick ist die kleinste Zeiteinheit, die vom <xref:System.Diagnostics.Stopwatch> Timer gemessen werden kann. Verwenden Sie das- <xref:System.Diagnostics.Stopwatch.Frequency> Feld, um den <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A> Wert in eine Anzahl von Sekunden zu konvertieren.  
  
 Sie können die Eigenschaften <xref:System.Diagnostics.Stopwatch.Elapsed%2A> , und Abfragen, <xref:System.Diagnostics.Stopwatch.ElapsedMilliseconds%2A> <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A> während die <xref:System.Diagnostics.Stopwatch> Instanz ausgeführt wird oder beendet wird. Die verstrichenen Zeit werden ständig vergrößert <xref:System.Diagnostics.Stopwatch> , während der ausgeführt wird. Sie bleiben konstant, wenn die Instanz beendet wird.  
  
 Standardmäßig ist der verstrichene Zeitwert einer- <xref:System.Diagnostics.Stopwatch> Instanz mit der Summe aller gemessenen Zeitintervalle gleich. Jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Start%2A> beginnt mit dem zählen der kumulativen verstrichenen Zeit. jeder Aufruf von <xref:System.Diagnostics.Stopwatch.Stop%2A> beendet die aktuelle Intervallmessung und friert den kumulativen Wert für die verstrichene Zeit. Verwenden Sie die- <xref:System.Diagnostics.Stopwatch.Reset%2A> Methode, um die kumulierte Zeitspanne in einer vorhandenen Instanz zu löschen <xref:System.Diagnostics.Stopwatch> .  
  
> [!NOTE]
>  <xref:System.Diagnostics.Stopwatch> Ticks unterscheiden sich von <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> . Jeder Tick im <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> Wert stellt 1 100-Nanosekunden-Intervall dar. Jeder Tick im <xref:System.Diagnostics.Stopwatch.ElapsedTicks%2A> Wert stellt das Zeitintervall dar, das gleich 1 Sekunde ist, dividiert durch <xref:System.Diagnostics.Stopwatch.Frequency> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird die- <xref:System.Diagnostics.Stopwatch> Klasse verwendet, um die Leistung von vier verschiedenen Implementierungen zum Durchsuchen einer Ganzzahl aus einer Zeichenfolge zu messen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Diagnostics.Stopwatch> .  
  
 [!code-cpp[StopWatchPerfSample#4](~/samples/snippets/cpp/VS_Snippets_CLR/StopWatchPerfSample/CPP/source.cpp#4)]
 [!code-csharp[StopWatchPerfSample#4](~/samples/snippets/csharp/VS_Snippets_CLR/StopWatchPerfSample/CS/source.cs#4)]
 [!code-vb[StopWatchPerfSample#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/StopWatchPerfSample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.Stopwatch.Elapsed" />
        <altmember cref="P:System.Diagnostics.Stopwatch.ElapsedMilliseconds" />
        <altmember cref="F:System.Diagnostics.Stopwatch.Frequency" />
      </Docs>
    </Member>
    <Member MemberName="Frequency">
      <MemberSignature Language="C#" Value="public static readonly long Frequency;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 Frequency" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.Stopwatch.Frequency" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Frequency As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long Frequency;" />
      <MemberSignature Language="F#" Value=" staticval mutable Frequency : int64" Usage="System.Diagnostics.Stopwatch.Frequency" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Frequenz des Timers als Anzahl von Ticks pro Sekunde ab. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeit Geber Frequenz gibt die Zeit Geber Genauigkeit und-Auflösung an. Eine Zeit Geber Frequenz von 2 Millionen Ticks pro Sekunde ist beispielsweise eine Zeit Geber Auflösung von 500 Nanosekunden pro Tick. Das heißt, weil eine Sekunde gleich 1 Milliarde Nanosekunden ist, entspricht eine Zeit Geber Häufigkeit von 2 Millionen Ticks pro Sekunde 2 Millionen Ticks pro 1 Milliarde nanoseconds. Dies kann zu einer weiteren Vereinfachung auf 1 Tick pro 500 nanoseconds werden.  
  
 Der <xref:System.Diagnostics.Stopwatch.Frequency> Wert hängt von der Auflösung des zugrunde liegenden Zeit Steuerungsmechanismus ab. Wenn die installierte Hardware und das Betriebssystem einen Leistungs Bewert mit hoher Auflösung unterstützen, gibt der <xref:System.Diagnostics.Stopwatch.Frequency> Wert die Häufigkeit des Leistungs Zählers an. Andernfalls basiert der <xref:System.Diagnostics.Stopwatch.Frequency> Wert auf der Zeit Geber Frequenz des Systems.  
  
 Da die <xref:System.Diagnostics.Stopwatch> Häufigkeit von der installierten Hardware und dem Betriebssystem abhängt, <xref:System.Diagnostics.Stopwatch.Frequency> bleibt der Wert konstant, während das System ausgeführt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Häufigkeit und Auflösung eines <xref:System.Diagnostics.Stopwatch> Timers angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Diagnostics.Stopwatch> .  
  
 [!code-cpp[StopWatchPerfSample#2](~/samples/snippets/cpp/VS_Snippets_CLR/StopWatchPerfSample/CPP/source.cpp#2)]
 [!code-csharp[StopWatchPerfSample#2](~/samples/snippets/csharp/VS_Snippets_CLR/StopWatchPerfSample/CS/source.cs#2)]
 [!code-vb[StopWatchPerfSample#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/StopWatchPerfSample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Diagnostics.Stopwatch.IsHighResolution" />
      </Docs>
    </Member>
    <Member MemberName="GetTimestamp">
      <MemberSignature Language="C#" Value="public static long GetTimestamp ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTimestamp() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.GetTimestamp" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTimestamp () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTimestamp();" />
      <MemberSignature Language="F#" Value="static member GetTimestamp : unit -&gt; int64" Usage="System.Diagnostics.Stopwatch.GetTimestamp " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die aktuelle Anzahl der Ticks im Zeitgebermechanismus ab.</summary>
        <returns>Eine Long-Integer-Zahl, die den Tickzählerwert des zugrunde liegenden Timermechanismus angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Diagnostics.Stopwatch> Klasse einen Leistungs Bearbeiter mit hoher Auflösung verwendet, wird <xref:System.Diagnostics.Stopwatch.GetTimestamp%2A> der aktuelle Wert dieses Leistungs Zählers zurückgegeben. Wenn die <xref:System.Diagnostics.Stopwatch> Klasse den System-Timer verwendet, wird <xref:System.Diagnostics.Stopwatch.GetTimestamp%2A> die aktuelle <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> Eigenschaft der-Instanz zurückgegeben <xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType> .  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der- <xref:System.Diagnostics.Stopwatch.GetTimestamp%2A> Methode zum Aktualisieren eines Leistungs Zählers.  
  
 [!code-cpp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CPP/elapsedtime.cpp#2)]
 [!code-csharp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CS/elapsedtime.cs#2)]
 [!code-vb[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/VB/elapsedtime.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Diagnostics.Stopwatch.IsHighResolution" />
      </Docs>
    </Member>
    <Member MemberName="IsHighResolution">
      <MemberSignature Language="C#" Value="public static readonly bool IsHighResolution;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly bool IsHighResolution" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.Stopwatch.IsHighResolution" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsHighResolution As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly bool IsHighResolution;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsHighResolution : bool" Usage="System.Diagnostics.Stopwatch.IsHighResolution" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Timer auf einem hochauflösenden Leistungsindikator basiert. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von der-Klasse verwendete Timer <xref:System.Diagnostics.Stopwatch> hängt von der System Hardware und dem Betriebssystem ab. <xref:System.Diagnostics.Stopwatch.IsHighResolution> gibt `true` an, ob der <xref:System.Diagnostics.Stopwatch> Zeitgeber auf einem Leistungs Zähler mit hoher Auflösung basiert. Andernfalls ist der Wert <xref:System.Diagnostics.Stopwatch.IsHighResolution> `false` , der angibt, dass der <xref:System.Diagnostics.Stopwatch> Timer auf dem systemtimer basiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Häufigkeit und Auflösung eines <xref:System.Diagnostics.Stopwatch> Timers angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Diagnostics.Stopwatch> .  
  
 [!code-cpp[StopWatchPerfSample#2](~/samples/snippets/cpp/VS_Snippets_CLR/StopWatchPerfSample/CPP/source.cpp#2)]
 [!code-csharp[StopWatchPerfSample#2](~/samples/snippets/csharp/VS_Snippets_CLR/StopWatchPerfSample/CS/source.cs#2)]
 [!code-vb[StopWatchPerfSample#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/StopWatchPerfSample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Diagnostics.Stopwatch.Frequency" />
      </Docs>
    </Member>
    <Member MemberName="IsRunning">
      <MemberSignature Language="C#" Value="public bool IsRunning { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRunning" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Stopwatch.IsRunning" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRunning As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRunning { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRunning : bool" Usage="System.Diagnostics.Stopwatch.IsRunning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Diagnostics.Stopwatch" />-Timer ausgeführt wird.</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Diagnostics.Stopwatch" />-Instanz derzeit ausgeführt wird und die verstrichene Zeit für ein Intervall misst, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine- <xref:System.Diagnostics.Stopwatch> Instanz wird mit einem-oder-Rückruf gestartet <xref:System.Diagnostics.Stopwatch.Start%2A> <xref:System.Diagnostics.Stopwatch.StartNew%2A> . Die-Instanz wird nicht mehr ausgeführt, wenn oder aufgerufen wird <xref:System.Diagnostics.Stopwatch.Stop%2A> <xref:System.Diagnostics.Stopwatch.Reset%2A> .  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Stopwatch.StartNew" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Stop" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Start" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; unit" Usage="stopwatch.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Zeitintervallmessung und setzt die verstrichene Zeit auf 0 (null) zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Diagnostics.Stopwatch> -Instanz berechnet und bewahrt die kumulierte verstrichene Zeit über mehrere Zeiträume hinweg, bis die Instanz zurückgesetzt wird. Verwenden <xref:System.Diagnostics.Stopwatch.Stop%2A> Sie, um die aktuelle Intervallmessung anzuhalten und den kumulativen Wert für die verstrichene Zeit beizubehalten. Verwenden <xref:System.Diagnostics.Stopwatch.Reset%2A> Sie, um die laufende Intervallmessung zu beenden und den verstrichenen Zeitwert zu löschen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Stopwatch.StartNew" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Stop" />
        <altmember cref="P:System.Diagnostics.Stopwatch.IsRunning" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Start" />
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Restart();" />
      <MemberSignature Language="F#" Value="member this.Restart : unit -&gt; unit" Usage="stopwatch.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Zeitintervallmessung, setzt die verstrichene Zeit auf 0 (null) zurück, und startet die Messung der verstrichenen Zeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Diagnostics.Stopwatch> -Instanz berechnet und bewahrt die kumulierte verstrichene Zeit über mehrere Zeitintervalle hinweg, bis die Instanz zurückgesetzt oder neu gestartet wird. Verwenden <xref:System.Diagnostics.Stopwatch.Stop%2A> Sie, um die aktuelle Intervallmessung anzuhalten und den kumulativen Wert für die verstrichene Zeit beizubehalten. Verwenden <xref:System.Diagnostics.Stopwatch.Reset%2A> Sie, um die laufende Intervallmessung zu beenden und den verstrichenen Zeitwert zu löschen. Verwenden <xref:System.Diagnostics.Stopwatch.Restart%2A> Sie, um die aktuelle Intervallmessung anzuhalten und eine neue Intervallmessung zu starten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="stopwatch.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet den Messvorgang der verstrichenen Zeit für ein Intervall oder nimmt diesen wieder auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In einem typischen <xref:System.Diagnostics.Stopwatch> Szenario wird die- <xref:System.Diagnostics.Stopwatch.Start%2A> Methode aufgerufen, schließlich wird die <xref:System.Diagnostics.Stopwatch.Stop%2A> -Methode aufgerufen, und anschließend wird die verstrichene Zeit mithilfe der- <xref:System.Diagnostics.Stopwatch.Elapsed%2A> Eigenschaft überprüft.  
  
 Nach dem Start <xref:System.Diagnostics.Stopwatch> misst ein Timer das aktuelle Intervall (in den verstrichenen Zeiteinheiten Ticks), bis die Instanz beendet oder zurückgesetzt wird. Beim Starten von <xref:System.Diagnostics.Stopwatch> , der bereits ausgeführt wird, wird der Zeit Geber Zustand nicht geändert oder die verstrichenen Zeiteigenschaften werden zurückgesetzt.  
  
 Wenn eine- <xref:System.Diagnostics.Stopwatch> Instanz mehr als ein Intervall misst, wird die <xref:System.Diagnostics.Stopwatch.Start%2A> Mess Zeit des aktuell verstrichenen Zeitwerts von der Methode fortgesetzt. Eine <xref:System.Diagnostics.Stopwatch> -Instanz berechnet und bewahrt die kumulierte verstrichene Zeit über mehrere Zeiträume hinweg, bis die Instanz zurückgesetzt wird. Verwenden Sie die- <xref:System.Diagnostics.Stopwatch.Reset%2A> Methode <xref:System.Diagnostics.Stopwatch.Start%2A> , bevor Sie aufrufen, um die kumulierte Zeit in einer-Instanz zu löschen <xref:System.Diagnostics.Stopwatch> . Verwenden <xref:System.Diagnostics.Stopwatch.Restart%2A> Sie die <xref:System.Diagnostics.Stopwatch.Reset%2A> -Methode und <xref:System.Diagnostics.Stopwatch.Start%2A> die <xref:System.Diagnostics.Stopwatch> mit einem einzigen Befehl.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die-Methode verwendet wird <xref:System.Diagnostics.Stopwatch.Start%2A> , um einen Timer zu starten, der die Ausführungszeit einer Anwendung misst.  
  
 [!code-csharp[System.Diagnostics.Stopwatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/CS/source.cs#1)]
 [!code-vb[System.Diagnostics.Stopwatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Stopwatch.StartNew" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Stop" />
        <altmember cref="P:System.Diagnostics.Stopwatch.IsRunning" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Reset" />
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Stopwatch StartNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Stopwatch StartNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.StartNew" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StartNew () As Stopwatch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Stopwatch ^ StartNew();" />
      <MemberSignature Language="F#" Value="static member StartNew : unit -&gt; System.Diagnostics.Stopwatch" Usage="System.Diagnostics.Stopwatch.StartNew " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Stopwatch</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue <see cref="T:System.Diagnostics.Stopwatch" />-Instanz, legt die Eigenschaft der verstrichenen Zeit auf 0 (null) fest und beginnt mit dem Messen der verstrichenen Zeit.</summary>
        <returns>Eine <see cref="T:System.Diagnostics.Stopwatch" />, die gerade mit dem Messen der verstrichenen Zeit begonnen hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht dem Aufrufen des <xref:System.Diagnostics.Stopwatch> -Konstruktors und dem anschließenden <xref:System.Diagnostics.Stopwatch.Start%2A> Aufrufen von für die neue-Instanz.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die- <xref:System.Diagnostics.Stopwatch> Klasse verwendet, um die Leistung von vier verschiedenen Implementierungen zum Durchsuchen einer Ganzzahl aus einer Zeichenfolge zu messen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die-Klasse bereitgestellt wird <xref:System.Diagnostics.Stopwatch> .  
  
 [!code-cpp[StopWatchPerfSample#4](~/samples/snippets/cpp/VS_Snippets_CLR/StopWatchPerfSample/CPP/source.cpp#4)]
 [!code-csharp[StopWatchPerfSample#4](~/samples/snippets/csharp/VS_Snippets_CLR/StopWatchPerfSample/CS/source.cs#4)]
 [!code-vb[StopWatchPerfSample#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/StopWatchPerfSample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Stopwatch.Start" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Stop" />
        <altmember cref="P:System.Diagnostics.Stopwatch.IsRunning" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Stopwatch.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="stopwatch.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet das Messen der verstrichenen Zeit für ein Intervall.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In einem typischen <xref:System.Diagnostics.Stopwatch> Szenario wird die- <xref:System.Diagnostics.Stopwatch.Start%2A> Methode aufgerufen, schließlich wird die <xref:System.Diagnostics.Stopwatch.Stop%2A> -Methode aufgerufen, und anschließend wird die verstrichene Zeit mithilfe der- <xref:System.Diagnostics.Stopwatch.Elapsed%2A> Eigenschaft überprüft.  
  
 Die- <xref:System.Diagnostics.Stopwatch.Stop%2A> Methode beendet die aktuelle Zeitintervall Messung. Wenn Sie ein Beenden <xref:System.Diagnostics.Stopwatch> , das nicht ausgeführt wird, wird der Zeit Geber Zustand nicht geändert, oder die abgelaufenen Zeiteigenschaften werden zurückgesetzt.  
  
 Wenn eine- <xref:System.Diagnostics.Stopwatch> Instanz mehr als ein Intervall misst, <xref:System.Diagnostics.Stopwatch.Stop%2A> entspricht die Methode dem Anhalten der verstrichenen Zeitmessung. Bei einem nachfolgenden Aufruf <xref:System.Diagnostics.Stopwatch.Start%2A> von wird die Zeitmessung des aktuellen verstrichenen Zeitwerts fortgesetzt. Verwenden Sie die- <xref:System.Diagnostics.Stopwatch.Reset%2A> Methode, um die kumulierte Zeitspanne in einer-Instanz zu löschen <xref:System.Diagnostics.Stopwatch> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die-Methode verwendet wird <xref:System.Diagnostics.Stopwatch.Stop%2A> , um einen Timer zu beenden, der die Ausführungszeit einer Anwendung misst.  
  
 [!code-csharp[System.Diagnostics.Stopwatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/CS/source.cs#1)]
 [!code-vb[System.Diagnostics.Stopwatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Stopwatch/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.Stopwatch.StartNew" />
        <altmember cref="P:System.Diagnostics.Stopwatch.IsRunning" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Start" />
        <altmember cref="M:System.Diagnostics.Stopwatch.Reset" />
      </Docs>
    </Member>
  </Members>
</Type>
