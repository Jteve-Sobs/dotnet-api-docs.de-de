<Type Name="EventSchemaTraceListener" FullName="System.Diagnostics.EventSchemaTraceListener">
  <Metadata><Meta Name="ms.openlocfilehash" Value="881858fedf02b9247230e9939756902bfc548594" /><Meta Name="ms.sourcegitcommit" Value="08fc3691deb7adaf0dfd751b9d9d0b23a3d3a7b8" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/09/2019" /><Meta Name="ms.locfileid" Value="68906760" /></Metadata><TypeSignature Language="C#" Value="public class EventSchemaTraceListener : System.Diagnostics.TextWriterTraceListener" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventSchemaTraceListener extends System.Diagnostics.TextWriterTraceListener" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventSchemaTraceListener" />
  <TypeSignature Language="VB.NET" Value="Public Class EventSchemaTraceListener&#xA;Inherits TextWriterTraceListener" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventSchemaTraceListener : System::Diagnostics::TextWriterTraceListener" />
  <TypeSignature Language="F#" Value="type EventSchemaTraceListener = class&#xA;    inherit TextWriterTraceListener" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Diagnostics.TextWriterTraceListener</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Leitet die Ablaufverfolgungs- oder Debugausgabe von End-to-End-Ereignissen an eine XML-codierte, schemakompatible Protokolldatei weiter.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.EventSchemaTraceListener> -Klasse stellt die Ablauf Verfolgung von End-to-End-Schema kompatiblen Ereignissen bereit. Sie können die End-to-End-Ablauf Verfolgung für ein System mit heterogenen Komponenten verwenden, <xref:System.AppDomain>die Thread-, Prozess-und Computer Grenzen überschreiten. Ein standardisiertes Ereignis Schema (siehe [Ereignis Darstellung für](https://go.microsoft.com/fwlink/?LinkId=78955)Ereignisconsumer) wurde definiert, um die Ablauf Verfolgung über diese Grenzen hinweg zu ermöglichen. Das Schema ermöglicht das Hinzufügen von benutzerdefinierten, Schema kompatiblen Elementen. Sie können das [Service Trace Viewer-Tool (SvcTraceViewer. exe)](https://go.microsoft.com/fwlink/p/?LinkId=240129) verwenden, um die Ereignisdaten anzuzeigen.  
  
 <xref:System.Diagnostics.EventSchemaTraceListener>wird für die Protokollierung der Leistung mit impliziter Unterstützung für die Ablauf Verfolgung ohne Sperre optimiert  
  
 Die <xref:System.Diagnostics.EventSchemaTraceListener> -Klasse konvertiert Ablaufverfolgungs-und Debuginformationen in einen XML-codierten Textstream. Die Beschreibung der XML-Ausgabe wird in den Tabellen weiter unten in diesem Abschnitt angezeigt.  
  
 Sie können ein <xref:System.Diagnostics.EventSchemaTraceListener> Objekt über die Anwendungs Konfigurationsdatei aktivieren oder deaktivieren und dann das konfigurierte <xref:System.Diagnostics.EventSchemaTraceListener> Objekt in der Anwendung verwenden. Alternativ können Sie ein <xref:System.Diagnostics.EventSchemaTraceListener> Objekt im Code erstellen. Es wird empfohlen, Ablaufverfolgungslistener über die Anwendungs Konfigurationsdatei zu aktivieren Informationen zur Verwendung von Konfigurationsdateien für die Ablauf Verfolgung und das Debuggen finden Sie unter Schema für Ablauf Verfolgungs [-und Debugeinstellungen](~/docs/framework/configure-apps/file-schema/trace-debug/index.md).  
  
 Um ein <xref:System.Diagnostics.EventSchemaTraceListener> Objekt zu konfigurieren, ändern Sie die Konfigurationsdatei, die dem Namen der Anwendung entspricht. In dieser Datei können Sie die Eigenschaften für einen Listener hinzufügen, entfernen oder festlegen. Die Konfigurationsdatei sollte wie folgt formatiert werden:  
  
```xml  
<configuration>  
    <system.diagnostics>  
        <sources>  
            <source name="TestSource" >  
                <listeners>  
                    <!--Remove the default trace listener for better performance.-->  
                    <remove name="Default"/>  
                    <!--Note: Removing the default trace listener prevents the dialog box   
                    from being displayed for Debug.Fail or Debug.Assert commands that are   
                    executed in user mode.-->  
                    <add name="eventListener"   
                      type="System.Diagnostics.EventSchemaTraceListener,  system.core"  
                      initializeData="TraceOutput.xml"   
                      traceOutputOptions="ProcessId, DateTime, Timestamp"   
                      bufferSize="65536"  
                      maximumFileSize="20480000"  
                      logRetentionOption="LimitedCircularFiles"  
                      maximumNumberOfFiles="2"/>  
                </listeners>  
            </source>  
        </sources>  
    </system.diagnostics>  
```  
  
 Die <xref:System.Diagnostics.EventSchemaTraceListener> -Klasse erbt <xref:System.Diagnostics.TraceListener.Filter%2A> die-Eigenschaft von der <xref:System.Diagnostics.TraceListener>Basisklasse. Die <xref:System.Diagnostics.TraceListener.Filter%2A> -Eigenschaft ermöglicht eine zusätzliche Ebene der Ablauf Verfolgungs Ausgabe Filterung beim Listener. Wenn ein Filter vorhanden ist, wird `Trace` die- <xref:System.Diagnostics.TraceFilter.ShouldTrace%2A> Methode des-Ablaufverfolgungslistener aufgerufen, um zu bestimmen, ob die Ablauf Verfolgung ausgegeben werden soll.  
  
 Wenn versucht wird, in eine Datei zu schreiben, die verwendet wird oder nicht verfügbar ist, wird dem Dateinamen automatisch ein GUID-Suffix hinzugefügt.  
  
> [!NOTE]
>  Listenermethoden sollen von Methoden der <xref:System.Diagnostics.Debug>Klassen, <xref:System.Diagnostics.Trace>und <xref:System.Diagnostics.TraceSource> aufgerufen werden. Die Listenermethoden können nicht direkt aus dem Anwendungscode aufgerufen werden. Der <xref:System.Diagnostics.EventSchemaTraceListener> Listener ist hauptsächlich für die Verwendung durch <xref:System.Diagnostics.TraceSource> die-Klasse bestimmt.  
  
 In der folgenden Tabelle werden die Elemente und Attribute der XML-Ausgabe beschrieben.  
  
|Element|Attribute|Ausgabe|Hinweise|  
|-------------|----------------|------------|-----------|  
|`CallStack`|Keine|Hängt davon ab, ob das <xref:System.Diagnostics.TraceOptions.Callstack> -Flag in <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> der-Eigenschaft vorhanden ist.|Sonderzeichen, z. b. > oder <, werden durch Escapesequenzen ersetzt. Siehe die Zeichen Übersetzungstabelle mit Escapezeichen in der nächsten Tabelle.|  
|`Computer`|Keine|Immer vorhanden.|Dieses Element stellt den Wert <xref:System.Environment.MachineName%2A> der-Eigenschaft dar.|  
|`Correlation`|`ActivityID`|Immer vorhanden.|Wenn `ActivityID` nicht angegeben wird, ist der Standardwert eine leere Guid.|  
||`RelatedActivityID`|Hängt davon ab, ob der `relatedActivityId` -Parameter `Trace` im Methoden aufrufvorhanden ist.|Das `RelatedActivityID` -Attribut entspricht dem `relatedActivityId` -Parameter der <xref:System.Diagnostics.EventSchemaTraceListener.TraceTransfer%2A> -Methode.|  
|`Data`|Keine|Immer vorhanden.|Dieses Element stellt Parameter Eingabe (`data`) dar. Ein-Element wird für jedes Datenobjekt bereitgestellt. Im Fall von Ereignisprotokollen enthält das `Data` -Element geschützte XML-Daten. Im Fall von Datenprotokollen enthält das `Data` -Elementdaten ohne Escapezeichen. Die Ausgabe des Daten Protokolls verwendet `ToString` die-Methode der über gebenden Datenobjekte.|  
|`Event`|Keine|Immer vorhanden.|Dieses Element enthält ein Ablauf Verfolgungs Ereignis.|  
|`EventData`|Keine|Für Ereignisprotokolle vorhanden.|Dieses Element stellt Parameter Eingaben (`message`, `args`) dar. Sie enthält `Data` Elemente mit Escapezeichen, die durch den Aufruf der <xref:System.Diagnostics.EventSchemaTraceListener.TraceEvent%2A> -Methode erstellt werden.|  
|`EventID`|Keine|Immer vorhanden.|Dieses Element stellt Parameter Eingabe (`id`) dar.|  
|`Execution`|`ProcessID`|Hängt davon ab, ob das <xref:System.Diagnostics.TraceOptions.ProcessId> -Flag in <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> der-Eigenschaft vorhanden ist.|Das `ProcessID` -Attribut wird in der <xref:System.Diagnostics.TraceEventCache>angegeben. Wenn `ProcessID` die Betriebssysteme Microsoft Windows 98 und Windows Millennium Edition größer als 2.147.483.647 sind, handelt es sich um eine positive Darstellung einer negativen Zahl, die konvertiert werden muss, um die richtige Prozess-ID zu erhalten.|  
||`ThreadID`|Vorhanden, `ProcessID` wenn vorhanden ist.|Das `ThreadID` -Attribut wird in der <xref:System.Diagnostics.TraceEventCache>angegeben.|  
|`Level`|Keine|Immer vorhanden.|Dieses Element stellt Parameter Eingaben (den numerischen Wert von `eventType`) dar. Parameter Werte, die größer als 255 sind, werden als Ebene 8 ausgegeben, die <xref:System.Diagnostics.TraceEventType.Information?displayProperty=nameWithType>darstellt. Typen von Ablaufverfolgungsereignissen <xref:System.Diagnostics.TraceEventType.Critical>, <xref:System.Diagnostics.TraceEventType.Error>, <xref:System.Diagnostics.TraceEventType.Warning>, <xref:System.Diagnostics.TraceEventType.Information>, und <xref:System.Diagnostics.TraceEventType.Verbose> werden Sie als Ebenen 1, 2, 4, 8 und 10, ausgegeben bzw.|  
|`LogicalOperationStack`|Keine|Hängt davon ab, ob das <xref:System.Diagnostics.TraceOptions.LogicalOperationStack> -Flag in <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> der-Eigenschaft vorhanden ist.|Es kann nur ein logischer Vorgang vorhanden sein. Daher werden die Werte als `LogicalOperation` Knoten unter dem `LogicalOperationStack` -Element geschrieben.|  
|`OpCode`|Keine|Vorhanden, `Level` wenn größer als 255 ist.|Dieses Element stellt Ablauf Verfolgungs Ereignis Typen dar, die numerische Werte größer als 255 aufweisen. <xref:System.Diagnostics.TraceEventType.Start>, <xref:System.Diagnostics.TraceEventType.Stop>, <xref:System.Diagnostics.TraceEventType.Suspend>, <xref:System.Diagnostics.TraceEventType.Resume>, oder <xref:System.Diagnostics.TraceEventType.Transfer> werden Sie als Ebenen 1, 2, 4, 8 und 10, ausgegeben bzw.|  
|`Provider`|`GUID`|Immer vorhanden.|Immer leer.|  
|`RenderingInfo`|`Culture`|Immer vorhanden.|Dieses Attribut stellt eine Ressourcen Zeichenfolge für den Ereignistyp dar. Es ist immer "en-en\\".|  
|`System`|`Name`|Immer vorhanden.||  
|`TimeCreated`|`SystemTime`|Hängt davon ab, ob das <xref:System.Diagnostics.TraceOptions.DateTime> -Flag in <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> der-Eigenschaft vorhanden ist.|Die Zeit ist der Wert <xref:System.Diagnostics.TraceEventCache.DateTime%2A?displayProperty=nameWithType> der Eigenschaft. Diese Eigenschaft wird als koordinierte Weltzeit ausgedrückt.|  
|`TimeStamp`|Keine|Hängt davon ab, ob das <xref:System.Diagnostics.TraceOptions.Timestamp> -Flag in <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> der-Eigenschaft vorhanden ist.|Dieses Element wird in der <xref:System.Diagnostics.TraceEventCache>angegeben.|  
|`UserData`|Keine|Für Datenprotokolle vorhanden.|Dieses Element enthält `Data` Elemente mit nicht mit Escapezeichen versehenen, vom <xref:System.Diagnostics.EventSchemaTraceListener.TraceData%2A> Benutzer bereitgestellten Daten aus einer Methode.|  
  
 Die folgende Tabelle zeigt die Zeichen, die in der XML-Ausgabe mit Escapezeichen versehen werden. Escapezeichen treten in allen Elementen und Attributen außer dem `UserData` -Element auf, das vom Benutzer bereitgestellte Daten ohne Escapezeichen enthält. Das `UserData` -Element ist das Ergebnis von Aufrufen der <xref:System.Diagnostics.EventSchemaTraceListener.TraceData%2A> -Methode.  
  
|Escapezeichen|Wert|  
|-----------------------|-----------|  
|&|&amp;|  
|\<|&lt;|  
|>|&gt;|  
|"|&quot;|  
|\|&apos;|  
|0xD|&\#xD;|  
|0xA|&\#xA;|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Diagnostics.EventSchemaTraceListener> -Klasse veranschaulicht.  
  
 [!code-cpp[System.Diagnostics.EventSchemaTraceListener#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/CPP/eventschematracelistener.cpp#1)]
 [!code-csharp[System.Diagnostics.EventSchemaTraceListener#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/cs/program.cs#1)]
 [!code-vb[System.Diagnostics.EventSchemaTraceListener#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventSchemaTraceListener" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventSchemaTraceListener (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventSchemaTraceListener(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventSchemaTraceListener : string -&gt; System.Diagnostics.EventSchemaTraceListener" Usage="new System.Diagnostics.EventSchemaTraceListener fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Pfad der Protokolldatei.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventSchemaTraceListener" />-Klasse, wobei die angegebene Datei als Empfänger der Debug- oder Ablaufverfolgungsausgabe verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird eine Datei mit uneingeschränkter Größe protokolliert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Diagnostics.EventSchemaTraceListener.%23ctor%28System.String%29?displayProperty=nameWithType> -Konstruktors veranschaulicht.  
  
 [!code-csharp[System.Diagnostics.EventSchemaTraceListener.Ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener.Ctors/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.EventSchemaTraceListener.Ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener.Ctors/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventSchemaTraceListener (string fileName, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventSchemaTraceListener(System::String ^ fileName, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventSchemaTraceListener : string * string -&gt; System.Diagnostics.EventSchemaTraceListener" Usage="new System.Diagnostics.EventSchemaTraceListener (fileName, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Pfad der Protokolldatei.</param>
        <param name="name">Der Name des Listeners.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventSchemaTraceListener" />-Klasse mit dem angegebenen Namen und unter Verwendung der angegebenen Datei als Empfänger der Debug- oder Ablaufverfolgungsausgabe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Diagnostics.EventSchemaTraceListener.%23ctor%28System.String%2CSystem.String%2CSystem.Int32%29?displayProperty=nameWithType> -Konstruktors veranschaulicht.  
  
 [!code-csharp[System.Diagnostics.EventSchemaTraceListener.Ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener.Ctors/CS/program.cs#2)]
 [!code-vb[System.Diagnostics.EventSchemaTraceListener.Ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener.Ctors/VB/program.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventSchemaTraceListener (string fileName, string name, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string name, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.#ctor(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, name As String, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventSchemaTraceListener(System::String ^ fileName, System::String ^ name, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventSchemaTraceListener : string * string * int -&gt; System.Diagnostics.EventSchemaTraceListener" Usage="new System.Diagnostics.EventSchemaTraceListener (fileName, name, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Pfad der Protokolldatei.</param>
        <param name="name">Der Name des Listeners.</param>
        <param name="bufferSize">Die Größe des Ausgabepuffers in Bytes.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventSchemaTraceListener" />-Klasse mit dem angegebenen Namen und der angegebenen Puffergröße unter Verwendung der angegebenen Datei als Empfänger der Debug- oder Ablaufverfolgungsausgabe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überlegungen `bufferSize` zur Leistung sollte ein Vielfaches von 1024 Bytes sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Diagnostics.EventSchemaTraceListener.%23ctor%28System.String%2CSystem.String%2CSystem.Int32%29?displayProperty=nameWithType> -Konstruktors veranschaulicht.  
  
 [!code-csharp[System.Diagnostics.EventSchemaTraceListener.Ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener.Ctors/CS/program.cs#3)]
 [!code-vb[System.Diagnostics.EventSchemaTraceListener.Ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener.Ctors/VB/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventSchemaTraceListener (string fileName, string name, int bufferSize, System.Diagnostics.TraceLogRetentionOption logRetentionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string name, int32 bufferSize, valuetype System.Diagnostics.TraceLogRetentionOption logRetentionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.#ctor(System.String,System.String,System.Int32,System.Diagnostics.TraceLogRetentionOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, name As String, bufferSize As Integer, logRetentionOption As TraceLogRetentionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventSchemaTraceListener(System::String ^ fileName, System::String ^ name, int bufferSize, System::Diagnostics::TraceLogRetentionOption logRetentionOption);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventSchemaTraceListener : string * string * int * System.Diagnostics.TraceLogRetentionOption -&gt; System.Diagnostics.EventSchemaTraceListener" Usage="new System.Diagnostics.EventSchemaTraceListener (fileName, name, bufferSize, logRetentionOption)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="logRetentionOption" Type="System.Diagnostics.TraceLogRetentionOption" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Pfad der Protokolldatei.</param>
        <param name="name">Der Name des Listeners.</param>
        <param name="bufferSize">Die Größe des Ausgabepuffers in Bytes.</param>
        <param name="logRetentionOption">Einer der <see cref="T:System.Diagnostics.TraceLogRetentionOption" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventSchemaTraceListener" />-Klasse mit dem angegebenen Namen und der angegebenen Puffergröße unter Verwendung der angegebenen Datei mit der angegebenen Protokollbeibehaltungsrichtlinie als Empfänger der Debug- oder Ablaufverfolgungsausgabe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überlegungen `bufferSize` zur Leistung sollte ein Vielfaches von 1024 Bytes sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Diagnostics.EventSchemaTraceListener.%23ctor%28System.String%2CSystem.String%2CSystem.Int32%2CSystem.Diagnostics.TraceLogRetentionOption%29?displayProperty=nameWithType> -Konstruktors veranschaulicht.  
  
 [!code-csharp[System.Diagnostics.EventSchemaTraceListener.Ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener.Ctors/CS/program.cs#4)]
 [!code-vb[System.Diagnostics.EventSchemaTraceListener.Ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener.Ctors/VB/program.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventSchemaTraceListener (string fileName, string name, int bufferSize, System.Diagnostics.TraceLogRetentionOption logRetentionOption, long maximumFileSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string name, int32 bufferSize, valuetype System.Diagnostics.TraceLogRetentionOption logRetentionOption, int64 maximumFileSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.#ctor(System.String,System.String,System.Int32,System.Diagnostics.TraceLogRetentionOption,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, name As String, bufferSize As Integer, logRetentionOption As TraceLogRetentionOption, maximumFileSize As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventSchemaTraceListener(System::String ^ fileName, System::String ^ name, int bufferSize, System::Diagnostics::TraceLogRetentionOption logRetentionOption, long maximumFileSize);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventSchemaTraceListener : string * string * int * System.Diagnostics.TraceLogRetentionOption * int64 -&gt; System.Diagnostics.EventSchemaTraceListener" Usage="new System.Diagnostics.EventSchemaTraceListener (fileName, name, bufferSize, logRetentionOption, maximumFileSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="logRetentionOption" Type="System.Diagnostics.TraceLogRetentionOption" />
        <Parameter Name="maximumFileSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Pfad der Protokolldatei.</param>
        <param name="name">Der Name des Listeners.</param>
        <param name="bufferSize">Die Größe des Ausgabepuffers in Bytes.</param>
        <param name="logRetentionOption">Einer der <see cref="T:System.Diagnostics.TraceLogRetentionOption" />-Werte.</param>
        <param name="maximumFileSize">Die maximale Dateigröße in Bytes.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventSchemaTraceListener" />-Klasse mit dem angegebenen Namen und der angegebenen Puffergröße unter Verwendung der angegebenen Datei mit der angegebenen Protokollbeibehaltungsrichtlinie und der maximalen Größe als Empfänger der Debug- oder Ablaufverfolgungsausgabe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aus Leistungsgründen `bufferSize` sollten und `maximumFileSize` ein Vielfaches von 1024 Bytes sein. `maximumFileSize`bei handelt es sich nicht um einen absoluten Wert, sondern um einen Schwellenwert, der bis zur Größe der letzten Nachricht überschritten werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Diagnostics.EventSchemaTraceListener.%23ctor%28System.String%2CSystem.String%2CSystem.Int32%2CSystem.Diagnostics.TraceLogRetentionOption%2CSystem.Int64%29?displayProperty=nameWithType> -Konstruktors veranschaulicht.  
  
 [!code-csharp[System.Diagnostics.EventSchemaTraceListener.Ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener.Ctors/CS/program.cs#5)]
 [!code-vb[System.Diagnostics.EventSchemaTraceListener.Ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener.Ctors/VB/program.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumFileSize" /> ist eine negative Zahl oder kleiner als <paramref name="bufferSize" />.

- oder -

<paramref name="bufferSize" /> ist eine negative Zahl.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventSchemaTraceListener (string fileName, string name, int bufferSize, System.Diagnostics.TraceLogRetentionOption logRetentionOption, long maximumFileSize, int maximumNumberOfFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string name, int32 bufferSize, valuetype System.Diagnostics.TraceLogRetentionOption logRetentionOption, int64 maximumFileSize, int32 maximumNumberOfFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.#ctor(System.String,System.String,System.Int32,System.Diagnostics.TraceLogRetentionOption,System.Int64,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, name As String, bufferSize As Integer, logRetentionOption As TraceLogRetentionOption, maximumFileSize As Long, maximumNumberOfFiles As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventSchemaTraceListener(System::String ^ fileName, System::String ^ name, int bufferSize, System::Diagnostics::TraceLogRetentionOption logRetentionOption, long maximumFileSize, int maximumNumberOfFiles);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventSchemaTraceListener : string * string * int * System.Diagnostics.TraceLogRetentionOption * int64 * int -&gt; System.Diagnostics.EventSchemaTraceListener" Usage="new System.Diagnostics.EventSchemaTraceListener (fileName, name, bufferSize, logRetentionOption, maximumFileSize, maximumNumberOfFiles)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="logRetentionOption" Type="System.Diagnostics.TraceLogRetentionOption" />
        <Parameter Name="maximumFileSize" Type="System.Int64" />
        <Parameter Name="maximumNumberOfFiles" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Pfad der Protokolldatei.</param>
        <param name="name">Der Name des Listeners.</param>
        <param name="bufferSize">Die Größe des Ausgabepuffers in Bytes.</param>
        <param name="logRetentionOption">Einer der <see cref="T:System.Diagnostics.TraceLogRetentionOption" />-Werte.</param>
        <param name="maximumFileSize">Die maximale Dateigröße in Bytes.</param>
        <param name="maximumNumberOfFiles">Die maximale Anzahl von Ausgabeprotokolldateien.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.EventSchemaTraceListener" />-Klasse mit dem angegebenen Namen und der angegebenen Puffergröße unter Verwendung der angegebenen Datei mit der angegebenen Protokollbeibehaltungsrichtlinie, der maximalen Größe und der Dateianzahl als Empfänger der Debug- oder Ablaufverfolgungsausgabe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aus Leistungsgründen `bufferSize` sollten und `maximumFileSize` ein Vielfaches von 1024 Bytes sein. `maximumFileSize`ist kein absoluter Wert. Es handelt sich um einen Schwellenwert, der bis zur Größe der letzten Nachricht überschritten werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Diagnostics.EventSchemaTraceListener.%23ctor%2A> -Konstruktors veranschaulicht. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Diagnostics.EventSchemaTraceListener> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Diagnostics.EventSchemaTraceListener#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/cs/program.cs#2)]
 [!code-vb[System.Diagnostics.EventSchemaTraceListener#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumFileSize" /> ist eine negative Zahl oder kleiner als <paramref name="bufferSize" />.

- oder -

<paramref name="maximumNumberOfFiles" /> ist kleiner als 1, und <paramref name="logRetentionOption" /> ist <see cref="F:System.Diagnostics.TraceLogRetentionOption.LimitedSequentialFiles" />.

- oder -

<paramref name="maximumNumberOfFiles" /> ist kleiner als -2, und <paramref name="logRetentionOption" /> ist <see cref="F:System.Diagnostics.TraceLogRetentionOption.LimitedCircularFiles" />.

- oder -

<paramref name="bufferSize" /> ist eine negative Zahl.</exception>
      </Docs>
    </Member>
    <Member MemberName="BufferSize">
      <MemberSignature Language="C#" Value="public int BufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventSchemaTraceListener.BufferSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BufferSize : int" Usage="System.Diagnostics.EventSchemaTraceListener.BufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des Ausgabepuffers ab.</summary>
        <value>Die Größe des Ausgabepuffers in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der-Eigenschafts Wert wird durch `bufferSize` den-Parameter im-Konstruktor festgelegt. Aus Leistungsgründen sollte die Puffergröße auf ein Vielfaches von 1024 Bytes festgelegt werden. Für eine optimale Leistung wird entweder die Standardgröße von 32 * 1024\*Bytes oder 64 1024 Bytes empfohlen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie den Wert <xref:System.Diagnostics.EventSchemaTraceListener.BufferSize%2A> der-Eigenschaft anzeigen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Diagnostics.EventSchemaTraceListener> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Diagnostics.EventSchemaTraceListener#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/cs/program.cs#5)]
 [!code-vb[System.Diagnostics.EventSchemaTraceListener#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="eventSchemaTraceListener.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die Protokolldatei für diesen Listener, sodass dieser keine Ablaufverfolgungs- oder Debugausgaben mehr empfängt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fail">
      <MemberSignature Language="C#" Value="public override void Fail (string message, string detailMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Fail(string message, string detailMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.Fail(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Fail (message As String, detailMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Fail(System::String ^ message, System::String ^ detailMessage);" />
      <MemberSignature Language="F#" Value="override this.Fail : string * string -&gt; unit" Usage="eventSchemaTraceListener.Fail (message, detailMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="detailMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Die zu schreibende einfache Fehlermeldung.</param>
        <param name="detailMessage">Die ausführliche Fehlermeldung, die an die einfache Fehlermeldung angefügt werden soll.</param>
        <summary>Schreibt Fehlerinformationen in die Protokolldatei, einschließlich einer einfachen Fehlermeldung und einer ausführlichen Fehlermeldung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="eventSchemaTraceListener.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass gepufferte Daten in das Protokoll für diesen Listener geschrieben werden.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSupportedAttributes">
      <MemberSignature Language="C#" Value="protected override string[] GetSupportedAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance string[] GetSupportedAttributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.GetSupportedAttributes" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetSupportedAttributes () As String()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override cli::array &lt;System::String ^&gt; ^ GetSupportedAttributes();" />
      <MemberSignature Language="F#" Value="override this.GetSupportedAttributes : unit -&gt; string[]" Usage="eventSchemaTraceListener.GetSupportedAttributes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die vom Ablaufverfolgungslistener unterstützten benutzerdefinierten XML-Konfigurationsattribute ab.</summary>
        <returns>Ein <see cref="T:System.String" />-Array, das die von diesem Listener erkannten XML-Konfigurationsattribute enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die benutzerdefinierten Attribute, die von dieser Methode zurückgegeben werden, können in der XML-Konfigurationsdatei verwendet werden, um das Verhalten <xref:System.Diagnostics.EventSchemaTraceListener> einer Instanz der-Klasse zu steuern. Die Verwendung eines anderen Attributs verursacht eine Konfigurations Ausnahme. Die <xref:System.Diagnostics.EventSchemaTraceListener.GetSupportedAttributes%2A> -Methode <xref:System.Diagnostics.EventSchemaTraceListener> für gibt die folgenden Zeichen folgen Array Werte zurück: "bufferSize", "logRetentionOption", "maximumFileSize" und "maximumnumoffiles".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsThreadSafe">
      <MemberSignature Language="C#" Value="public override bool IsThreadSafe { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadSafe" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventSchemaTraceListener.IsThreadSafe" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsThreadSafe As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsThreadSafe { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadSafe : bool" Usage="System.Diagnostics.EventSchemaTraceListener.IsThreadSafe" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Ablaufverfolgungslistener threadsicher ist.</summary>
        <value>Gibt immer <see langword="true" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie den Wert <xref:System.Diagnostics.EventSchemaTraceListener.IsThreadSafe%2A> der-Eigenschaft anzeigen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Diagnostics.EventSchemaTraceListener> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Diagnostics.EventSchemaTraceListener#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/cs/program.cs#4)]
 [!code-vb[System.Diagnostics.EventSchemaTraceListener#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumFileSize">
      <MemberSignature Language="C#" Value="public long MaximumFileSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumFileSize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventSchemaTraceListener.MaximumFileSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumFileSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumFileSize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumFileSize : int64" Usage="System.Diagnostics.EventSchemaTraceListener.MaximumFileSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe der Protokolldatei ab.</summary>
        <value>Die maximale Dateigröße in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der-Eigenschafts Wert wird durch `maximumFileSize` den-Parameter im-Konstruktor `maximumFileSize` oder das-Attribut in der Konfigurationsdatei festgelegt. Aus Leistungsgründen sollten Sie die maximale Dateigröße auf ein Vielfaches von 1024 Byte festlegen. Der <xref:System.Diagnostics.EventSchemaTraceListener.MaximumFileSize%2A> Eigenschafts Wert ist kein absoluter Wert; es handelt sich um einen Schwellenwert, der bis zur Größe der letzten Nachricht überschritten werden kann.  
  
 In der folgenden Tabelle werden die möglichen und Standardwerte für die Dateigröße angezeigt, die den einzelnen Aufbewahrungs Optionen für das Ablauf Verfolgungs Protokoll zugeordnet sind. Die als N/v markierten Werte geben an, <xref:System.Diagnostics.EventSchemaTraceListener.MaximumFileSize%2A> dass die Eigenschaft für diesen <xref:System.Diagnostics.TraceLogRetentionOption> Wert nicht geprüft wird.  
  
|TraceLogRetentionOption|Maximale Dateigröße|Standarddatei Größe|  
|-----------------------------|-----------------------|-----------------------|  
|<xref:System.Diagnostics.TraceLogRetentionOption.LimitedCircularFiles>|Nicht zutreffend|-1|  
|<xref:System.Diagnostics.TraceLogRetentionOption.LimitedSequentialFiles>|>0|4 KB|  
|<xref:System.Diagnostics.TraceLogRetentionOption.SingleFileBoundedSize>|>0|4 KB|  
|<xref:System.Diagnostics.TraceLogRetentionOption.SingleFileUnboundedSize>|>0|4 KB|  
|<xref:System.Diagnostics.TraceLogRetentionOption.UnlimitedSequentialFiles>|>0|4 KB|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie den Wert <xref:System.Diagnostics.EventSchemaTraceListener.MaximumFileSize%2A> der-Eigenschaft anzeigen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Diagnostics.EventSchemaTraceListener> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Diagnostics.EventSchemaTraceListener#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/cs/program.cs#6)]
 [!code-vb[System.Diagnostics.EventSchemaTraceListener#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/vb/program.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumNumberOfFiles">
      <MemberSignature Language="C#" Value="public int MaximumNumberOfFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumNumberOfFiles" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventSchemaTraceListener.MaximumNumberOfFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumNumberOfFiles As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumNumberOfFiles { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumNumberOfFiles : int" Usage="System.Diagnostics.EventSchemaTraceListener.MaximumNumberOfFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Anzahl von Protokolldateien ab.</summary>
        <value>Die maximale Anzahl von Protokolldateien, bestimmt durch den Wert der <see cref="P:System.Diagnostics.EventSchemaTraceListener.TraceLogRetentionOption" />-Eigenschaft für die Datei.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der-Eigenschafts Wert wird durch `maximumNumberOfFiles` den-Parameter im-Konstruktor `maximumNumberOfFiles` oder das-Attribut in der Konfigurationsdatei festgelegt.  
  
 In der folgenden Tabelle werden die möglichen und Standardwerte für die Dateigröße und die Dateianzahl angezeigt, die den einzelnen Ablauf Verfolgungs Protokoll-Aufbewahrungs Optionen zugeordnet sind. Die als N/v markierten Werte geben an, <xref:System.Diagnostics.EventSchemaTraceListener.MaximumNumberOfFiles%2A> dass die Eigenschaft für diesen <xref:System.Diagnostics.TraceLogRetentionOption> Wert nicht geprüft wird.  
  
|TraceLogRetentionOption|Maximale Anzahl von Dateien|Standard Anzahl von Dateien|  
|-----------------------------|-----------------------------|-----------------------------|  
|<xref:System.Diagnostics.TraceLogRetentionOption.LimitedCircularFiles>|Nicht zutreffend|1|  
|<xref:System.Diagnostics.TraceLogRetentionOption.LimitedSequentialFiles>|Nicht zutreffend|1|  
|<xref:System.Diagnostics.TraceLogRetentionOption.SingleFileBoundedSize>|Nicht zutreffend|-1|  
|<xref:System.Diagnostics.TraceLogRetentionOption.SingleFileUnboundedSize>|>0|1|  
|<xref:System.Diagnostics.TraceLogRetentionOption.UnlimitedSequentialFiles>|>1|2|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie den Wert <xref:System.Diagnostics.EventSchemaTraceListener.MaximumNumberOfFiles%2A> der-Eigenschaft anzeigen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Diagnostics.EventSchemaTraceListener> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Diagnostics.EventSchemaTraceListener#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/cs/program.cs#7)]
 [!code-vb[System.Diagnostics.EventSchemaTraceListener#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TraceData">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Ablaufverfolgungsdaten in die Protokolldatei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TraceData">
      <MemberSignature Language="C#" Value="public override void TraceData (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceData(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub TraceData (eventCache As TraceEventCache, source As String, eventType As TraceEventType, id As Integer, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void TraceData(System::Diagnostics::TraceEventCache ^ eventCache, System::String ^ source, System::Diagnostics::TraceEventType eventType, int id, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="override this.TraceData : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * obj -&gt; unit" Usage="eventSchemaTraceListener.TraceData (eventCache, source, eventType, id, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="eventCache">Ein <see cref="T:System.Diagnostics.TraceEventCache" /> mit der aktuellen Prozess-ID, Thread-ID und den aktuellen Stapelüberwachungsinformationen.</param>
        <param name="source">Der Quellenname.</param>
        <param name="eventType">Einer der <see cref="T:System.Diagnostics.TraceEventType" />-Werte.</param>
        <param name="id">Ein numerischer Bezeichner für das Ereignis.</param>
        <param name="data">Ein auszugebendes Datenobjekt.</param>
        <summary>Schreibt Ablaufverfolgungsinformationen, ein einzelnes Datenobjekt sowie Ereignisinformationen in die Protokolldatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `eventCache`Parameter `source`, ,`eventType` und`id` werden in der Kopfzeile und Fußzeile der Ablauf Verfolgung verwendet. Der `id` -Parameter wird vor dem Schreiben in eine ganze Zahl ohne Vorzeichen konvertiert. Daher wird ein negativer `id` Wert als große positive Ganzzahl geschrieben. Der `data` -Parameter wird `Data` als Knoten im `UserData` -Element geschrieben. Die `ToString` -Methode des Datenobjekts wird verwendet, um das Objekt in eine Zeichenfolge zu konvertieren.  
  
> [!IMPORTANT]
>  Diese Methode ist nicht dafür vorgesehen, direkt durch den Anwendungscode aufgerufen zu werden. Sie wird von Methoden der <xref:System.Diagnostics.Debug>Klassen, <xref:System.Diagnostics.Trace>und <xref:System.Diagnostics.TraceSource> aufgerufen, um Ablauf Verfolgungs Daten zu schreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceData">
      <MemberSignature Language="C#" Value="public override void TraceData (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, params object[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceData(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, object[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub TraceData (eventCache As TraceEventCache, source As String, eventType As TraceEventType, id As Integer, ParamArray data As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void TraceData(System::Diagnostics::TraceEventCache ^ eventCache, System::String ^ source, System::Diagnostics::TraceEventType eventType, int id, ... cli::array &lt;System::Object ^&gt; ^ data);" />
      <MemberSignature Language="F#" Value="override this.TraceData : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * obj[] -&gt; unit" Usage="eventSchemaTraceListener.TraceData (eventCache, source, eventType, id, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="data" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventCache">Ein <see cref="T:System.Diagnostics.TraceEventCache" /> mit der aktuellen Prozess-ID, Thread-ID und den aktuellen Stapelüberwachungsinformationen.</param>
        <param name="source">Der Quellenname.</param>
        <param name="eventType">Einer der <see cref="T:System.Diagnostics.TraceEventType" />-Werte.</param>
        <param name="id">Ein numerischer Bezeichner für das Ereignis.</param>
        <param name="data">Ein Array von Datenobjekten, die ausgegeben werden sollen.</param>
        <summary>Schreibt Ablaufverfolgungsinformationen, mehrere Datenobjekte und Ereignisinformationen in die Protokolldatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `eventCache`Parameter `source`, ,`eventType` und`id` werden in der Kopfzeile und Fußzeile der Ablauf Verfolgung verwendet. Der `id` -Parameter wird vor dem Schreiben in eine ganze Zahl ohne Vorzeichen konvertiert. Daher wird ein negativer `id` Wert als große positive Ganzzahl geschrieben. Die Objekte im `data` Parameter Array werden als `Data` Knoten im `UserData` -Element geschrieben. Die `ToString` -Methode der einzelnen Datenobjekte wird verwendet, um das Objekt in eine Zeichenfolge zu konvertieren.  
  
> [!IMPORTANT]
>  Diese Methode ist nicht dafür vorgesehen, direkt durch den Anwendungscode aufgerufen zu werden. Sie wird von Methoden der <xref:System.Diagnostics.Debug>Klassen, <xref:System.Diagnostics.Trace>und <xref:System.Diagnostics.TraceSource> aufgerufen, um Ablauf Verfolgungs Daten zu schreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TraceEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Ablaufverfolgungsinformationen in die Protokolldatei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TraceEvent">
      <MemberSignature Language="C#" Value="public override void TraceEvent (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceEvent(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub TraceEvent (eventCache As TraceEventCache, source As String, eventType As TraceEventType, id As Integer, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void TraceEvent(System::Diagnostics::TraceEventCache ^ eventCache, System::String ^ source, System::Diagnostics::TraceEventType eventType, int id, System::String ^ message);" />
      <MemberSignature Language="F#" Value="override this.TraceEvent : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * string -&gt; unit" Usage="eventSchemaTraceListener.TraceEvent (eventCache, source, eventType, id, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventCache">Ein <see cref="T:System.Diagnostics.TraceEventCache" /> mit der aktuellen Prozess-ID, Thread-ID und den aktuellen Stapelüberwachungsinformationen.</param>
        <param name="source">Der Quellenname.</param>
        <param name="eventType">Einer der <see cref="T:System.Diagnostics.TraceEventType" />-Werte.</param>
        <param name="id">Ein numerischer Bezeichner für das Ereignis.</param>
        <param name="message">Die zu schreibende Meldung.</param>
        <summary>Schreibt Ablaufverfolgungsinformationen, eine Meldung und Ereignisinformationen in die Protokolldatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `eventCache`Parameter `source`, ,`eventType` und`id` werden in der Kopfzeile und Fußzeile der Ablauf Verfolgung verwendet. Der `id` -Parameter wird vor dem Schreiben in eine ganze Zahl ohne Vorzeichen konvertiert. Daher wird ein negativer `id` Wert als große positive Ganzzahl geschrieben. Der `message` -Parameter wird `Data` als Knoten im `EventData` -Element geschrieben.  
  
> [!IMPORTANT]
>  Diese Methode ist nicht dafür vorgesehen, direkt durch den Anwendungscode aufgerufen zu werden. Sie wird von Methoden der <xref:System.Diagnostics.Debug>Klassen, <xref:System.Diagnostics.Trace>und <xref:System.Diagnostics.TraceSource> aufgerufen, um Ablauf Verfolgungs Daten zu schreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceEvent">
      <MemberSignature Language="C#" Value="public override void TraceEvent (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceEvent(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub TraceEvent (eventCache As TraceEventCache, source As String, eventType As TraceEventType, id As Integer, format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void TraceEvent(System::Diagnostics::TraceEventCache ^ eventCache, System::String ^ source, System::Diagnostics::TraceEventType eventType, int id, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="override this.TraceEvent : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * string * obj[] -&gt; unit" Usage="eventSchemaTraceListener.TraceEvent (eventCache, source, eventType, id, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-3.5">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventCache">Ein <see cref="T:System.Diagnostics.TraceEventCache" /> mit der aktuellen Prozess-ID, Thread-ID und den aktuellen Stapelüberwachungsinformationen.</param>
        <param name="source">Der Quellenname.</param>
        <param name="eventType">Einer der <see cref="T:System.Diagnostics.TraceEventType" />-Werte.</param>
        <param name="id">Ein numerischer Bezeichner für das Ereignis.</param>
        <param name="format">Eine Formatzeichenfolge mit 0 oder mehr Formatelementen, die Objekten im <paramref name="args" />-Array entsprechen.</param>
        <param name="args">Ein Objektarray mit 0 (null) oder mehr zu formatierenden Objekten.</param>
        <summary>Schreibt Ablaufverfolgungsinformationen, eine formatierte Meldung und Ereignisinformationen in die Protokolldatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `eventCache`Parameter `source`, ,`eventType` und`id` werden in der Kopfzeile und Fußzeile der Ablauf Verfolgung verwendet. Der `id` -Parameter wird vor dem Schreiben in eine ganze Zahl ohne Vorzeichen konvertiert. Daher wird ein negativer `id` Wert als große positive Ganzzahl geschrieben. Die <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> -Methode wird aufgerufen, `format` und die `args` Zeichenfolge und das Array werden als Parameter angegeben. Mit dieser Methode wird `args` das Objekt Array formatiert und das formatierte `Data` Array als Knoten `EventData` im-Element geschrieben.  
  
> [!IMPORTANT]
>  Diese Methode ist nicht dafür vorgesehen, direkt durch den Anwendungscode aufgerufen zu werden. Sie wird von Methoden der <xref:System.Diagnostics.Debug>Klassen, <xref:System.Diagnostics.Trace>und <xref:System.Diagnostics.TraceSource> aufgerufen, um Ablauf Verfolgungs Daten zu schreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceLogRetentionOption">
      <MemberSignature Language="C#" Value="public System.Diagnostics.TraceLogRetentionOption TraceLogRetentionOption { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.TraceLogRetentionOption TraceLogRetentionOption" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventSchemaTraceListener.TraceLogRetentionOption" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TraceLogRetentionOption As TraceLogRetentionOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::TraceLogRetentionOption TraceLogRetentionOption { System::Diagnostics::TraceLogRetentionOption get(); };" />
      <MemberSignature Language="F#" Value="member this.TraceLogRetentionOption : System.Diagnostics.TraceLogRetentionOption" Usage="System.Diagnostics.EventSchemaTraceListener.TraceLogRetentionOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.TraceLogRetentionOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Beibehaltungsoption für das Ablaufverfolgungsprotokoll der Datei ab.</summary>
        <value>Einer der <see cref="T:System.Diagnostics.TraceLogRetentionOption" />-Werte. Die Standardeinstellung ist <see cref="F:System.Diagnostics.TraceLogRetentionOption.SingleFileUnboundedSize" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie den Wert <xref:System.Diagnostics.EventSchemaTraceListener.TraceLogRetentionOption%2A> der-Eigenschaft anzeigen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Diagnostics.EventSchemaTraceListener> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Diagnostics.EventSchemaTraceListener#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/cs/program.cs#9)]
 [!code-vb[System.Diagnostics.EventSchemaTraceListener#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.EventSchemaTraceListener/vb/program.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTransfer">
      <MemberSignature Language="C#" Value="public override void TraceTransfer (System.Diagnostics.TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceTransfer(class System.Diagnostics.TraceEventCache eventCache, string source, int32 id, string message, valuetype System.Guid relatedActivityId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.TraceTransfer(System.Diagnostics.TraceEventCache,System.String,System.Int32,System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub TraceTransfer (eventCache As TraceEventCache, source As String, id As Integer, message As String, relatedActivityId As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void TraceTransfer(System::Diagnostics::TraceEventCache ^ eventCache, System::String ^ source, int id, System::String ^ message, Guid relatedActivityId);" />
      <MemberSignature Language="F#" Value="override this.TraceTransfer : System.Diagnostics.TraceEventCache * string * int * string * Guid -&gt; unit" Usage="eventSchemaTraceListener.TraceTransfer (eventCache, source, id, message, relatedActivityId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="relatedActivityId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="eventCache">Ein <see cref="T:System.Diagnostics.TraceEventCache" /> mit der aktuellen Prozess-ID, Thread-ID und den aktuellen Stapelüberwachungsinformationen.</param>
        <param name="source">Der Quellenname.</param>
        <param name="id">Ein numerischer Bezeichner für das Ereignis.</param>
        <param name="message">Eine zu schreibende Ablaufverfolgungsmeldung.</param>
        <param name="relatedActivityId">Eine <see cref="T:System.Guid" />-Struktur, die eine verwandte Aktivität bezeichnet.</param>
        <summary>Schreibt Ablaufverfolgungsinformationen, darunter die Identität einer verwandten Aktivität, eine Meldung sowie Ereignisinformationen, in die Protokolldatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.EventSchemaTraceListener.TraceTransfer%2A> -Methode wird verwendet, um verwandte Ablauf Verfolgungen zu korrelieren. Die `eventCache`Parameter `source`, ,`id` und`relatedActivityId` werden in der Kopfzeile und Fußzeile der Ablauf Verfolgung verwendet. Der `id` -Parameter wird vor dem Schreiben in eine ganze Zahl ohne Vorzeichen konvertiert. Daher wird ein negativer `id` Wert als große positive Ganzzahl geschrieben. Der `message` -Parameter wird `Data` als-Element geschrieben. Die <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> -Methode wird aufgerufen, um `relatedActivityId` den Wert in eine formatierte Zeichenfolge "B" zu konvertieren, die im-Header angezeigt wird. Das `Opcode` -Element in der Fußzeile identifiziert den Ablaufverfolgungs- <xref:System.Diagnostics.TraceEventType.Transfer>Ereignistyp als.  
  
> [!IMPORTANT]
>  Die <xref:System.Diagnostics.EventSchemaTraceListener.TraceTransfer%2A> -Methode sollte nicht von Anwendungscode aufgerufen werden. Sie soll von einem <xref:System.Diagnostics.TraceSource> -Objekt verwendet werden, um die Ablauf Verfolgungs Informationen <xref:System.Diagnostics.TraceSource.TraceTransfer%2A> für die zugehörige-Methode auszugeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(System::String ^ message);" />
      <MemberSignature Language="F#" Value="override this.Write : string -&gt; unit" Usage="eventSchemaTraceListener.Write message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Die zu schreibende Meldung.</param>
        <summary>Schreibt eine Meldung ohne weitere Kontextinformationen in die Protokolldatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.EventSchemaTraceListener.TraceEvent%2A> -Methode wird aufgerufen, um die Meldung <xref:System.Diagnostics.TraceEventType.Information> als Ereignis zu protokollieren.  
  
> [!IMPORTANT]
>  Diese Methode ist nicht dafür vorgesehen, direkt durch den Anwendungscode aufgerufen zu werden. Sie wird von Methoden der <xref:System.Diagnostics.Debug>Klassen, <xref:System.Diagnostics.Trace>und <xref:System.Diagnostics.TraceSource> aufgerufen, um Ablauf Verfolgungs Daten zu schreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public override void WriteLine (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteLine(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventSchemaTraceListener.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteLine (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteLine(System::String ^ message);" />
      <MemberSignature Language="F#" Value="override this.WriteLine : string -&gt; unit" Usage="eventSchemaTraceListener.WriteLine message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Die zu schreibende Meldung.</param>
        <summary>Schreibt eine Meldung, gefolgt vom Abschlusszeichen der aktuellen Zeile und ohne weitere Kontextinformationen in die Protokolldatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.EventSchemaTraceListener.TraceEvent%2A> -Methode wird aufgerufen, um die Meldung <xref:System.Diagnostics.TraceEventType.Information> als Ereignis zu protokollieren.  
  
> [!IMPORTANT]
>  Diese Methode ist nicht dafür vorgesehen, direkt durch den Anwendungscode aufgerufen zu werden. Sie wird von Methoden der <xref:System.Diagnostics.Debug>Klassen, <xref:System.Diagnostics.Trace>und <xref:System.Diagnostics.TraceSource> aufgerufen, um Ablauf Verfolgungs Daten zu schreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Writer">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Writer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Writer" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventSchemaTraceListener.Writer" />
      <MemberSignature Language="VB.NET" Value="Public Property Writer As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Writer { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Writer : System.IO.TextWriter with get, set" Usage="System.Diagnostics.EventSchemaTraceListener.Writer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zugrunde liegenden TextWriter ab, der in die Protokolldatei schreibt, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.IO.TextWriter" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Versuch, den Set-Accessor für die <xref:System.Diagnostics.EventSchemaTraceListener.Writer%2A> -Eigenschaft zu <xref:System.NotSupportedException>verwenden, löst eine aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Es wurde versucht, der <see cref="P:System.Diagnostics.EventSchemaTraceListener.Writer" />-Eigenschaft einen Wert zuzuweisen.</exception>
      </Docs>
    </Member>
  </Members>
</Type>