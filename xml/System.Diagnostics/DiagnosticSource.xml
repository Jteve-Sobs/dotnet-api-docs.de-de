<Type Name="DiagnosticSource" FullName="System.Diagnostics.DiagnosticSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d79c7605daf68e0c4169c32fac48c2c1ac277dad" /><Meta Name="ms.sourcegitcommit" Value="cfc0e4215fd0d259582ada2141878befd7c3c8c6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/12/2019" /><Meta Name="ms.locfileid" Value="67854883" /></Metadata><TypeSignature Language="C#" Value="public abstract class DiagnosticSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DiagnosticSource extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.DiagnosticSource" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DiagnosticSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class DiagnosticSource abstract" />
  <TypeSignature Language="F#" Value="type DiagnosticSource = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.1</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Eine abstrakte Klasse, die das Instrumentieren von Code für die Protokollierung umfangreicher Datennutzlasten zur Produktionszeit für die Nutzung innerhalb des instrumentierten Prozesses ermöglicht.</summary>
    <remarks>Weitere Informationen finden Sie unter [DiagnosticSource-Benutzerhandbuch](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md).</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DiagnosticSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DiagnosticSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public abstract bool IsEnabled (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnabled(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.IsEnabled(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsEnabled (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsEnabled(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsEnabled : string -&gt; bool" Usage="diagnosticSource.IsEnabled name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des geschriebenen Ereignisses.</param>
        <summary>Überprüft, ob das Benachrichtigungsereignis aktiviert ist.</summary>
        <returns><see langword="true" /> wenn das Benachrichtigungsereignis aktiviert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

Ist es teuer Setup für die Benachrichtigung, können Sie die IsEnabled vor dem Ausführen dieses Setups aufrufen. Kunden sollten nicht davon ausgehen, dass sie nur Benachrichtigungen erhalten, für die IsEnabled "true" ist. Es ist jedoch optional für Hersteller, um diese API aufzurufen. Der Name muss identisch, die an <see cref="M:System.Diagnostics.DiagnosticSource.Write(System.String,System.Object)" />.

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public virtual bool IsEnabled (string name, object arg1, object arg2 = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnabled(string name, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.IsEnabled(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnabled (name As String, arg1 As Object, Optional arg2 As Object = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsEnabled : string * obj * obj -&gt; bool&#xA;override this.IsEnabled : string * obj * obj -&gt; bool" Usage="diagnosticSource.IsEnabled (name, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des geschriebenen Ereignisses.</param>
        <param name="arg1">Ein Objekt, das den zusätzlichen Kontext für „IsEnabled“ darstellt. Consumer sollten den Empfang von <see langword="null" /> erwarten, was darauf hinweisen kann, dass der Hersteller eine reine IsEnabled(string)-Zeichenfolge aufgerufen hat, um zu prüfen, ob der Consumer für derartige Ereignisse überhaupt Benachrichtigungen empfangen möchte. Auf dieser Grundlage ruft der Hersteller möglicherweise erneut IsEnabled(string, object, object) mit einem Kontext ungleich <see langword="null" /> auf.</param>
        <param name="arg2">Optional. Ein Objekt, das den zusätzlichen Kontext für „IsEnabled“ darstellt. <see langword="null" /> standardmäßig. Consumer sollten den Empfang von <see langword="null" /> erwarten, was darauf hinweisen kann, dass der Hersteller eine reine IsEnabled(string)-Zeichenfolge aufgerufen hat oder der Hersteller den gesamten erforderlichen Kontext in <paramref name="arg1" /> übergeben hat.</param>
        <summary>Überprüft, ob das Benachrichtigungsereignis aktiviert ist.</summary>
        <returns><see langword="true" /> wenn das Benachrichtigungsereignis aktiviert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
Ist es teuer Setup für die Benachrichtigung, können Sie diese Methode aufrufen und Kontext bereitzustellen, bevor Sie das Setup ausführen.
          
           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityExport">
      <MemberSignature Language="C#" Value="public virtual void OnActivityExport (System.Diagnostics.Activity activity, object payload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnActivityExport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.OnActivityExport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnActivityExport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="abstract member OnActivityExport : System.Diagnostics.Activity * obj -&gt; unit&#xA;override this.OnActivityExport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.OnActivityExport (activity, payload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity">To be added.</param>
        <param name="payload">To be added.</param>
        <summary>Überträgt den Status von einer Aktivität auf außerhalb des Prozesses stattfindende Ereignisse oder Vorgänge, wie z.B. eine ausgehende HTTP-Anfrage.</summary>
        <remarks>  
          <format type="text/markdown"><![CDATA[  

Ist eine Website Instumentation an einem Speicherort, in denen Aktivitäten des Prozesses (z. B. ausgehenden HTTP-Anforderungen) lassen, wird dieses Standorts Status aus der Aktivität zu einer ausgehenden Anforderung übertragen möchten.

Soweit möglich, dies sollte erfolgen von der Website Instrumenation, da es ein Vertrag zwischen ist einer <xref:System.Diagnostics.Activity> und die Ougoing Anforderung Logik des Standorts der Instrumentation.   Allerdings kann die Website Instrumenation nicht verarbeiten Richtlinie (z. B., ob Aktivitätsinformationen sollten werden deaktiviert oder in einem älteren Format aus Kompatibilitätsgründen geschrieben).
Hierzu muss der Standort für die Instrumentation einen Rückruf an an das Protokollierungssystem, und bitten ihn zum Auflösen von Richtlinien. Dies ist der Zweck der `OnActivityExport` Methode.

Die `OnActivityExport` Methode erhält den <xref:System.Diagnostics.Activity> sowie eine nutzlastobjekt, das die ausgehende Anforderung darstellt. Ein <xref:System.Diagnostics.DiagnosticSource> Abonnent hat dann die Möglichkeit, die ausgehende Anforderung zu aktualisieren, bevor sie gesendet wird.
 
Beachten Sie, dass diese Methode wird nur selten verwendet, bei der Instrumentation-Websites (nur diese Websites, die auf eine ausgehende Grenze des Prozesses befinden).   Darüber hinaus ist in der Regel die Standardrichtlinie, dass die Instrumenation-Website (z. B., um alle Aktivitäten in einer bestimmten ausgehenden Konvention statusübertragung) führt wahrscheinlich zu funktionieren. Diese Methode ist nur für Fälle, d. h. ein Problem aufgetreten. Daher diese Methode sollte nur sehr selten verwendet werden und ist größtenteils hier Symetry mit `OnActivityImport` und die zukunftsfähigkeit.

Beachten Sie, dass `payload` typisiert ist, als ein <xref:System.Object> hier allerdings eine bestimmte Instrumentation-Standort und dem Abonnenten müssen den Typ der Nutzlast kennen und daher umgewandelt und Decodieren bei Bedarf.

         ]]></format>
         </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityImport">
      <MemberSignature Language="C#" Value="public virtual void OnActivityImport (System.Diagnostics.Activity activity, object payload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnActivityImport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.OnActivityImport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnActivityImport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="abstract member OnActivityImport : System.Diagnostics.Activity * obj -&gt; unit&#xA;override this.OnActivityImport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.OnActivityImport (activity, payload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity">Die Aktivität, die von einem externen Ereignis betroffen ist.</param>
        <param name="payload">Eine Nutzlast, die die eingehende Anforderung darstellt.</param>
        <summary>Überträgt den Status von außerhalb des Prozesses stattfindenden Ereignissen oder Vorgängen, wie z.B. einer eingehenden Anfrage, auf eine Aktivität.</summary>
        <remarks>  
          <format type="text/markdown"><![CDATA[  

Wenn eine Instumentation-Website eine neue Aktivität als Reaktion auf ein Ereignis außerhalb des Prozesses erstellt werden, z. B. einer eingehenden HTTP Anforderung), die `OnActivityImport` -Methode ermöglicht es, diesen Standort wird erstellen möchten, einen neuen Status der Aktivität und die Übertragung in die eingehende Anforderung an die Aktivität. 

Soweit möglich, dies sollte erfolgen von der Instrumentation-Website, weil es ein Vertrag zwischen ist dem <xref:System.Diagnostics.Activity> und der eingehenden Anforderung Logik des Standorts der Instrumentation.   Allerdings kann die Website für die Instrumentation Richtlinie nicht verarbeiten. (Z. B. wenn Sampling erfolgt, sollte genau die Anforderungen Stichproben erstellt werden?) In diesen Fällen muss der Standort für die Instrumentation einen Rückruf an an das Protokollierungssystem, und bitten, um die Richtlinie (z. B. entscheiden, ob der Aktivität "Sampling" Bit festgelegt werden soll) zu beheben. Dies ist der Zweck der `OnActivityImport` Methode. Es wird zugewiesen, die Aktivität als auch auf ein nutzlastobjekt, die der eingehenden Anforderung darstellt. Abonnenten der <xref:System.Diagnostics.DiagnosticSource> dann haben die Möglichkeit, diese Aktivität nach Bedarf aktualisiert. 

Diese Methode wird nur selten verwendet, bei der Instrumentation-Websites (nur diese Websites, die auf die Begrenzung des Prozesses befinden) und der Standort für die Verwaltungsinstrumentation implementiert einige Standardrichtlinie (wird die Aktivität *einige* Möglichkeit), und daher es nicht notwendig ist, Diese Standardrichtlinie wird, wird überschreiben Sie diese Methode. Das heißt, sollten diese Methode in sehr selten (aber oft wichtige) Fällen überschrieben werden.

Beachten Sie, dass `payload` typisiert ist, als <xref:System.Object> hier allerdings eine bestimmte Instrumentation-Standort und dem Abonnenten werden den Typ der Nutzlast kennen und daher umgewandelt und Decodieren bei Bedarf.

         ]]></format>
         </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartActivity">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Activity StartActivity (System.Diagnostics.Activity activity, object args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Activity StartActivity(class System.Diagnostics.Activity activity, object args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.StartActivity(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::Activity ^ StartActivity(System::Diagnostics::Activity ^ activity, System::Object ^ args);" />
      <MemberSignature Language="F#" Value="member this.StartActivity : System.Diagnostics.Activity * obj -&gt; System.Diagnostics.Activity" Usage="diagnosticSource.StartActivity (activity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="args" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity">Die <see cref="T:System.Diagnostics.Activity" />, die gestartet werden soll.</param>
        <param name="args">Ein Objekt, das den Wert darstellt, der als Nutzlast für das Ereignis übergeben wird.</param>
        <summary>Startet eine <see cref="T:System.Diagnostics.Activity" /> und schreibt ein Startereignis.</summary>
        <returns>Die gestartete Aktivität zur komfortablen Verkettung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
           
Die <xref:System.Diagnostics.Activity> beschreibt die logische Operation, seinen Kontext sowie die übergeordnete Beziehung der aktuellen <xref:System.Diagnostics.Activity> durchläuft die vorgangsverarbeitung.

Diese Methode startet die angegebene <xref:System.Diagnostics.Activity>, verwaltet eine globale <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> und <xref:System.Diagnostics.Activity.Parent?displayProperty=nameWithType> Aktivität für die angegebenen <xref:System.Diagnostics.Activity>, und benachrichtigt Consumer, ein neues <xref:System.Diagnostics.Activity> gestartet wurde. Consumer können auf zugreifen <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> Kontext hinzufügen bzw. Erweitern der Telemetriedaten.

Hersteller können zusätzliche Details an den Consumer in der Nutzlast übergeben.

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopActivity">
      <MemberSignature Language="C#" Value="public void StopActivity (System.Diagnostics.Activity activity, object args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopActivity(class System.Diagnostics.Activity activity, object args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.StopActivity(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopActivity(System::Diagnostics::Activity ^ activity, System::Object ^ args);" />
      <MemberSignature Language="F#" Value="member this.StopActivity : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.StopActivity (activity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="args" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activity">Die zu beendende Aktivität.</param>
        <param name="args">Ein Objekt, das den Wert darstellt, der als Nutzlast für das Ereignis übergeben wird.</param>
        <summary>Beendet die angegebene <see cref="T:System.Diagnostics.Activity" />, behält die globale <see cref="P:System.Diagnostics.Activity.Current" />-Aktivität bei und benachrichtigt Consumer, dass die <see cref="T:System.Diagnostics.Activity" /> beendet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Hersteller können zusätzliche Details an den Consumer in der Nutzlast übergeben.

Consumer können auf zugreifen <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> Kontext hinzufügen bzw. Erweitern der Telemetriedaten.


         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Write : string * obj -&gt; unit" Usage="diagnosticSource.Write (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des geschriebenen Ereignisses.</param>
        <param name="value">Ein Objekt, das den Wert darstellt, der als Nutzlast für das Ereignis übergeben wird. Dies ist häufig ein anonymer Typ, der mehrere untergeordnete Werte enthält.</param>
        <summary>Stellt eine generische Möglichkeit zum Protokollieren komplexer Nutzlasten zur Verfügung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Jede Benachrichtigung ist ein Name zugewiesen, der angibt, sowie ein Objekt (i. d. r. ein anonymer Typ), die willkürlichen Informationen an der Benachrichtigung übergeben bereitstellt.  

`name` sollte kurz sein. Verwenden Sie einen vollqualifizierten Namen nicht, es sei denn, Sie zu haben, um Mehrdeutigkeit zu vermeiden, da `name` muss global eindeutig sein. In der Regel *componentName.eventName*, wobei *ComponentName* und *EventName* sind Zeichenfolgen mit höchstens 10 Zeichen sind ein guter Kompromiss.

Benachrichtigungs-Namen dürfen keine `.` darin da Komponentennamen Punkte aufweisen und für diese beiden Punkte haben führt zu Mehrdeutigkeiten. Wir empfehlen die Verwendung von `_` stattdessen.

Wird davon ausgegangen Sie, dass Listener verwendet Zeichenfolge voranstellen, um Gruppen zu filtern. Aus diesem Grund ist eine Hierarchie von Komponentennamen bewährt.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
