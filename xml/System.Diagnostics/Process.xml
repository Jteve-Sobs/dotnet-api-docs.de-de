<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="127c9e20e4e1095a2c84ebc6fa5a1939173a5fe3" /><Meta Name="ms.sourcegitcommit" Value="f6fc130f7b9399b2b130a137d6b0b2b73c1d17b3" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/18/2019" /><Meta Name="ms.locfileid" Value="74154395" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht den Zugriff auf lokale Prozesse und Remoteprozesse und das Starten und Anhalten lokaler Systemprozesse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Diagnostics.Process> Komponente ermöglicht den Zugriff auf einen Prozess, der auf einem Computer ausgeführt wird. Ein Prozess ist in den einfachsten Begriffen eine laufende app. Ein Thread ist die Basiseinheit, der die Prozessorzeit vom Betriebssystem zugewiesen wird. Ein Thread kann einen beliebigen Teil des Code des Prozesses ausführen, einschließlich der Teile, die gerade von einem anderen Thread ausgeführt werden.  
  
 Die <xref:System.Diagnostics.Process> Komponente ist ein nützliches Tool zum Starten, beenden, Steuern und Überwachen von apps. Sie können die <xref:System.Diagnostics.Process> Komponente zum Abrufen einer Liste der Prozesse verwenden, die ausgeführt werden, oder Sie können einen neuen Prozess starten. Für den Zugriff auf System Prozesse wird eine <xref:System.Diagnostics.Process> Komponente verwendet. Nachdem eine <xref:System.Diagnostics.Process> Komponente initialisiert wurde, kann Sie zum Abrufen von Informationen über den laufenden Prozess verwendet werden. Zu diesen Informationen gehören der Satz von Threads, die geladenen Module (dll-und exe-Dateien) und Leistungsinformationen, wie z. b. die Menge an Arbeitsspeicher, die vom Prozess verwendet wird.  
  
 Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle. Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`finally`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
  
> [!NOTE]
>  32-Bit-Prozesse können nicht auf die Module eines 64-Bit-Prozesses zugreifen. Wenn Sie versuchen, Informationen zu einem 64-Bit-Prozess von einem 32-Bit-Prozess zu erhalten, erhalten Sie eine <xref:System.ComponentModel.Win32Exception> Ausnahme. Ein 64-Bit-Prozess hingegen kann auf die Module eines 32-Bit-Prozesses zugreifen.  
  
 Die Prozess Komponente ruft alle Informationen über eine Gruppe von Eigenschaften gleichzeitig ab. Nachdem die <xref:System.Diagnostics.Process> Komponente Informationen zu einem Mitglied einer beliebigen Gruppe abgerufen hat, werden die Werte für die anderen Eigenschaften in dieser Gruppe zwischengespeichert, und es werden keine neuen Informationen zu den anderen Mitgliedern der Gruppe abgerufen, bis Sie die <xref:System.Diagnostics.Process.Refresh%2A>-Methode aufrufen. Daher ist ein Eigenschafts Wert nicht unbedingt neuer als der letzte aufzurufende <xref:System.Diagnostics.Process.Refresh%2A> Methode. Die Gruppen Ausfälle sind Betriebssystem abhängig.  
  
 Wenn Sie über eine in Ihrem System deklarierte Pfad Variable mit Anführungszeichen verfügen, müssen Sie diesen Pfad vollständig qualifizieren, wenn Sie einen Prozess starten, der an diesem Speicherort gefunden wird. Andernfalls findet das System den Pfad nicht. Wenn `c:\mypath` z. b. nicht in Ihrem Pfad vorhanden ist und Sie ihn mit Anführungszeichen hinzufügen: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess in `c:\mypath` vollständig qualifizieren, wenn Sie ihn starten.  
  
 Ein System Prozess wird durch seine Prozess-ID auf dem System eindeutig identifiziert. Wie viele Windows-Ressourcen wird auch ein Prozess durch sein Handle identifiziert, der auf dem Computer möglicherweise nicht eindeutig ist. Ein Handle ist der generische Begriff für einen Bezeichner einer Ressource. Das Betriebssystem speichert das Prozess handle, auf das über die <xref:System.Diagnostics.Process.Handle%2A>-Eigenschaft der <xref:System.Diagnostics.Process> Komponente zugegriffen wird, auch wenn der Prozess beendet wurde. Daher können Sie die Verwaltungsinformationen des Prozesses, z. b. die <xref:System.Diagnostics.Process.ExitCode%2A> (in der Regel entweder NULL für Erfolg oder einen Fehlercode ungleich 0) und die <xref:System.Diagnostics.Process.ExitTime%2A>erhalten. Handles sind eine äußerst wertvolle Ressource, sodass das Verlust von Handles eher stärker als das Verlust von Speicher ist.  
  
> [!NOTE]
>  Diese Klasse enthält einen Link Aufruf und eine Vererbungs Anforderung auf Klassenebene, die für alle Member gilt. Eine <xref:System.Security.SecurityException> wird ausgelöst, wenn der unmittelbare Aufrufer oder die abgeleitete Klasse nicht über die Berechtigung für volle Vertrauenswürdigkeit verfügt. Ausführliche Informationen zu Sicherheitsanforderungen finden Sie unter [Link](~/docs/framework/misc/link-demands.md)Aufrufe.  
  
<a name="Core"></a>   
## <a name="includenet_coreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Anmerkungen zu dieser Version  
 In der .NET Framework verwendet die <xref:System.Diagnostics.Process>-Klasse standardmäßig <xref:System.Console> Codierungen, bei denen es sich in der Regel um Code Page Codierungen handelt, für die Eingabe-, Ausgabe-und Fehler Datenströme. Beispielsweise wird auf Systemen, deren Kultur Englisch (USA) ist, die Codepage 437 die Standard Codierung für die <xref:System.Console>-Klasse. [!INCLUDE[net_core](~/includes/net-core-md.md)] können jedoch nur eine begrenzte Teilmenge dieser Codierungen verfügbar machen. Wenn dies der Fall ist, wird <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> als Standard Codierung verwendet.  
  
 Wenn ein <xref:System.Diagnostics.Process> Objekt von bestimmten Code Page Codierungen abhängt, können Sie diese wie folgt verfügbar machen, *bevor* Sie <xref:System.Diagnostics.Process> Methoden aufzurufen:  
  
1.  Fügen Sie dem Projekt einen Verweis auf die System. Text. Encoding. Codepages. dll-Assembly hinzu.  
  
2.  Rufen Sie das <xref:System.Text.EncodingProvider>-Objekt aus der <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType>-Eigenschaft ab.  
  
3.  Übergeben Sie das <xref:System.Text.EncodingProvider>-Objekt an die <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType>-Methode, um die zusätzlichen Codierungen bereitzustellen, die vom Codierungs Anbieter unterstützt werden.  
  
 Die <xref:System.Diagnostics.Process>-Klasse verwendet dann automatisch die Standardsystem Codierung anstelle von UTF8, vorausgesetzt, dass Sie den Codierungs Anbieter registriert haben, bevor Sie <xref:System.Diagnostics.Process> Methoden aufrufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz der <xref:System.Diagnostics.Process>-Klasse verwendet, um einen Prozess zu starten.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 Im folgenden Beispiel werden die <xref:System.Diagnostics.Process>-Klasse und eine statische <xref:System.Diagnostics.Process.Start%2A>-Methode verwendet, um einen Prozess zu starten.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 Im folgenden F# Beispiel wird eine `runProc` Funktion definiert, die einen Prozess startet, alle Ausgabe-und Fehlerinformationen erfasst und die Anzahl der Millisekunden aufzeichnet, die der Prozess ausgeführt hat.  Die `runProc`-Funktion verfügt über drei Parameter: den Namen der zu startenden Anwendung, die Argumente, die für die Anwendung bereitgestellt werden sollen, und das Start Verzeichnis.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Der Code für die `runProc`-Funktion wurde von [imaginarydevelopment](http://fssnip.net/authors/ImaginaryDevelopment) geschrieben und ist unter der [öffentlichen Microsoft-Lizenz](https://opensource.org/licenses/ms-pl)verfügbar.  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Diese Klasse kann von teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für vollständige Vertrauenswürdigkeit für Vererber. Diese Klasse kann von teilweise vertrauenswürdigem Code nicht geerbt werden.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">Verwenden der .NET-Prozess Klasse</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.Process" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Diagnostics.Process.MachineName%2A>-Eigenschaft nicht angeben, ist der Standardwert der lokale Computer (".").  
  
 Sie haben zwei Möglichkeiten, eine neue <xref:System.Diagnostics.Process> Komponente einem Prozess auf dem Computer zuzuordnen. Die erste Option besteht darin, den-Konstruktor zum Erstellen der <xref:System.Diagnostics.Process> Komponente zu verwenden, die entsprechenden Member der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft festzulegen und <xref:System.Diagnostics.Process.Start%2A> aufzurufen, um die <xref:System.Diagnostics.Process> einem neuen System Prozess zuzuordnen. Die zweite Option besteht darin, die <xref:System.Diagnostics.Process> einem laufenden System Prozess zuzuordnen, indem Sie <xref:System.Diagnostics.Process.GetProcessById%2A> oder einen der <xref:System.Diagnostics.Process.GetProcesses%2A> Rückgabewerte verwenden.  
  
 Wenn Sie eine `static` Überladung der <xref:System.Diagnostics.Process.Start%2A>-Methode verwenden, um einen neuen System Prozess zu starten, erstellt die-Methode eine neue <xref:System.Diagnostics.Process>-Komponente und ordnet diese dem-Prozess zu.  
  
 Wenn die <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>-Eigenschaft auf ihren Standardwert festgelegt ist `true`, können Sie Anwendungen und Dokumente auf eine Weise starten, die der Verwendung des Dialog Felds `Run` im Menü Windows `Start` ähnelt. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> `false`, können Sie nur ausführbare Dateien starten.  
  
 Jede ausführbare Datei, die Sie über die Befehlszeile aufrufen können, kann auf zwei Arten gestartet werden: durch Festlegen der entsprechenden Member der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft und Aufrufen der <xref:System.Diagnostics.Process.Start%2A>-Methode ohne Parameter oder durch Übergeben des entsprechenden Parameters an die `static`@no_ _t_3_-Member.<xref:System.Diagnostics.Process.Start%2A>  
  
 Sie können eine <xref:System.Diagnostics.Process> Komponente erstellen, indem Sie den-Konstruktor, eine der statischen <xref:System.Diagnostics.Process.Start%2A> Überladungen oder eine der Methoden <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>oder <xref:System.Diagnostics.Process.GetProcessesByName%2A> verwenden. Nachdem Sie dies abgeschlossen haben, haben Sie einen Einblick in den zugeordneten Prozess. Dabei handelt es sich nicht um eine dynamische Ansicht, die automatisch aktualisiert wird, wenn sich die Prozess Eigenschaften im Arbeitsspeicher geändert haben. Stattdessen müssen Sie <xref:System.Diagnostics.Process.Refresh%2A> für die Komponente aufzurufen, um die <xref:System.Diagnostics.Process> Eigenschaften Informationen in der Anwendung zu aktualisieren.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Basispriorität des zugeordneten Prozesses ab.</summary>
        <value>Die Basispriorität, die anhand der <see cref="P:System.Diagnostics.Process.PriorityClass" /> des zugeordneten Prozesses berechnet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.BasePriority%2A> des Prozesses ist die Anfangs Priorität für Threads, die innerhalb des zugeordneten Prozesses erstellt werden. Sie können Informationen über die Basis Priorität mithilfe des Prioritäts Basis Zählers des System Monitors anzeigen.  
  
 Basierend auf der verstrichenen Zeit oder anderen Steigerungen kann das Betriebssystem die Basis Priorität ändern, wenn ein Prozess vor anderen versetzt werden soll.  
  
 Mit der <xref:System.Diagnostics.Process.BasePriority%2A>-Eigenschaft können Sie die dem Prozess zugewiesene anfangs Priorität anzeigen. Da Sie jedoch schreibgeschützt ist, können Sie die <xref:System.Diagnostics.Process.BasePriority%2A> nicht verwenden, um die Priorität des Prozesses festzulegen. Verwenden Sie die <xref:System.Diagnostics.Process.PriorityClass%2A>-Eigenschaft, um die Priorität zu ändern. Der <xref:System.Diagnostics.Process.BasePriority%2A> kann mit dem System Monitor angezeigt werden, während der <xref:System.Diagnostics.Process.PriorityClass%2A> nicht ist. Sowohl die <xref:System.Diagnostics.Process.BasePriority%2A> als auch die <xref:System.Diagnostics.Process.PriorityClass%2A> können Programm gesteuert angezeigt werden. Die folgende Tabelle zeigt die Beziehung zwischen <xref:System.Diagnostics.Process.BasePriority%2A> Werten und <xref:System.Diagnostics.Process.PriorityClass%2A> Werten.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode des Prozesses an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde beendet.  
  
 - oder -  
  
 Der Prozess wurde nicht gestartet, daher gibt es keine Prozess-ID.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet asynchrone Lesevorgänge im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardError" />-Stream der Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Diagnostics.Process.StandardError%2A> Datenstrom kann synchron oder asynchron gelesen werden. Methoden wie <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>und <xref:System.IO.StreamReader.ReadToEnd%2A> führen synchrone Lesevorgänge im Fehlerausgabestream des Prozesses aus. Diese synchronen Lesevorgänge werden erst abgeschlossen, wenn die zugeordnete <xref:System.Diagnostics.Process> in den <xref:System.Diagnostics.Process.StandardError%2A> Stream schreibt oder den Stream schließt.  
  
 Im Gegensatz dazu startet <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> asynchrone Lesevorgänge für den <xref:System.Diagnostics.Process.StandardError%2A> Datenstrom. Diese Methode aktiviert den festgelegten Ereignishandler für die Datenstrom Ausgabe und kehrt sofort an den Aufrufer zurück, der andere Aufgaben ausführen kann, während die Datenstrom Ausgabe an den Ereignishandler weitergeleitet wird.  
  
 Führen Sie die folgenden Schritte aus, um asynchrone Lesevorgänge für <xref:System.Diagnostics.Process.StandardError%2A> für eine <xref:System.Diagnostics.Process> auszuführen:  
  
1.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> auf `false`fest.  
  
2.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> auf `true`fest.  
  
3.  Fügen Sie dem <xref:System.Diagnostics.Process.ErrorDataReceived>-Ereignis den Ereignishandler hinzu. Der Ereignishandler muss mit der <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> Delegatsignatur identisch sein.  
  
4.  Starten Sie die <xref:System.Diagnostics.Process>.  
  
5.  Ruft <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> für die <xref:System.Diagnostics.Process>auf. Dieser Befehl startet asynchrone Lesevorgänge auf <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Wenn asynchrone Lesevorgänge gestartet werden, wird der Ereignishandler jedes Mal aufgerufen, wenn die zugeordnete <xref:System.Diagnostics.Process> eine Textzeile in den <xref:System.Diagnostics.Process.StandardError%2A>-Stream schreibt.  
  
 Sie können einen asynchronen Lesevorgang abbrechen, indem Sie <xref:System.Diagnostics.Process.CancelErrorRead%2A>aufrufen. Der Lesevorgang kann vom Aufrufer oder vom Ereignishandler abgebrochen werden. Nach dem abbrechen können Sie <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> erneut aufzurufen, um asynchrone Lesevorgänge fortzusetzen.  
  
> [!NOTE]
>  Asynchrone und synchrone Lesevorgänge können nicht in einem umgeleiteten Stream gemischt werden. Sobald der umgeleitete Stream einer <xref:System.Diagnostics.Process> entweder im asynchronen oder im synchronen Modus geöffnet ist, müssen sich alle weiteren Lesevorgänge in diesem Stream im gleichen Modus befinden. Befolgen Sie z. b. <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> nicht, wenn Sie <xref:System.IO.StreamReader.ReadLine%2A> im <xref:System.Diagnostics.Process.StandardError%2A> Stream aufrufen oder umgekehrt. Sie können jedoch zwei verschiedene Streams in verschiedenen Modi lesen. Beispielsweise können Sie <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> aufzurufen und dann <xref:System.IO.StreamReader.ReadLine%2A> für den <xref:System.Diagnostics.Process.StandardOutput%2A> Stream aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der `net view` Befehl verwendet, um die verfügbaren Netzwerkressourcen auf einem Remote Computer aufzulisten. Der Benutzer gibt den Namen des Ziel Computers als Befehlszeilenargument an. Der Benutzer kann auch einen Dateinamen für die Fehlerausgabe angeben. Im Beispiel wird die Ausgabe des NET-Befehls erfasst, auf den Abschluss des Prozesses gewartet und dann die Ausgabe Ergebnisse in die Konsole geschrieben. Wenn der Benutzer die optionale Fehler Datei angibt, schreibt das Beispiel Fehler in die Datei.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />-Eigenschaft ist <see langword="false" />.  
  
- oder - 
Für den <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wird bereits ein asynchroner Lesevorgang ausgeführt.  
  
- oder - 
Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wurde von einem synchronen Lesevorgang verwendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet asynchrone Lesevorgänge im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream der Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Diagnostics.Process.StandardOutput%2A> Datenstrom kann synchron oder asynchron gelesen werden. Methoden wie <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>und <xref:System.IO.StreamReader.ReadToEnd%2A> führen synchrone Lesevorgänge für den Ausgabestream des Prozesses aus. Diese synchronen Lesevorgänge werden erst abgeschlossen, wenn die zugeordnete <xref:System.Diagnostics.Process> in den <xref:System.Diagnostics.Process.StandardOutput%2A> Stream schreibt oder den Stream schließt.  
  
 Im Gegensatz dazu startet <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> asynchrone Lesevorgänge für den <xref:System.Diagnostics.Process.StandardOutput%2A> Datenstrom. Diese Methode aktiviert einen festgelegten Ereignishandler für die Datenstrom Ausgabe und kehrt sofort an den Aufrufer zurück, der andere Aufgaben ausführen kann, während die Datenstrom Ausgabe an den Ereignishandler weitergeleitet wird.  
  
 Führen Sie die folgenden Schritte aus, um asynchrone Lesevorgänge für <xref:System.Diagnostics.Process.StandardOutput%2A> für eine <xref:System.Diagnostics.Process> auszuführen:  
  
1.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> auf `false`fest.  
  
2.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> auf `true`fest.  
  
3.  Fügen Sie dem <xref:System.Diagnostics.Process.OutputDataReceived>-Ereignis den Ereignishandler hinzu. Der Ereignishandler muss mit der <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> Delegatsignatur identisch sein.  
  
4.  Starten Sie die <xref:System.Diagnostics.Process>.  
  
5.  Ruft <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> für die <xref:System.Diagnostics.Process>auf. Dieser Befehl startet asynchrone Lesevorgänge auf <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Wenn asynchrone Lesevorgänge gestartet werden, wird der Ereignishandler jedes Mal aufgerufen, wenn die zugeordnete <xref:System.Diagnostics.Process> eine Textzeile in den <xref:System.Diagnostics.Process.StandardOutput%2A>-Stream schreibt.  
  
 Sie können einen asynchronen Lesevorgang abbrechen, indem Sie <xref:System.Diagnostics.Process.CancelOutputRead%2A>aufrufen. Der Lesevorgang kann vom Aufrufer oder vom Ereignishandler abgebrochen werden. Nach dem abbrechen können Sie <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> erneut aufzurufen, um asynchrone Lesevorgänge fortzusetzen.  
  
> [!NOTE]
>  Asynchrone und synchrone Lesevorgänge können nicht in einem umgeleiteten Stream gemischt werden. Sobald der umgeleitete Stream einer <xref:System.Diagnostics.Process> entweder im asynchronen oder im synchronen Modus geöffnet ist, müssen sich alle weiteren Lesevorgänge in diesem Stream im gleichen Modus befinden. Befolgen Sie z. b. <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> nicht, wenn Sie <xref:System.IO.StreamReader.ReadLine%2A> im <xref:System.Diagnostics.Process.StandardOutput%2A> Stream aufrufen oder umgekehrt. Sie können jedoch zwei verschiedene Streams in verschiedenen Modi lesen. Beispielsweise können Sie <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> aufzurufen und dann <xref:System.IO.StreamReader.ReadLine%2A> für den <xref:System.Diagnostics.Process.StandardError%2A> Stream aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie asynchrone Lesevorgänge für den umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream des `sort`-Befehls durchgeführt werden. Der `sort`-Befehl ist eine Konsolenanwendung, die Texteingaben liest und sortiert.  
  
 Im Beispiel wird ein Ereignis Delegat für den `SortOutputHandler` Ereignishandler erstellt und dem <xref:System.Diagnostics.Process.OutputDataReceived>-Ereignis zugeordnet. Der Ereignishandler empfängt Textzeilen aus dem umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, formatiert den Text und schreibt den Text auf den Bildschirm.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />-Eigenschaft ist <see langword="false" />.  
  
- oder - 
Für den <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wird bereits ein asynchroner Lesevorgang ausgeführt.  
  
- oder - 
Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wurde von einem synchronen Lesevorgang verwendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht den asynchronen Lesevorgang im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardError" />-Stream einer Anwendung ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> startet einen asynchronen Lesevorgang für den <xref:System.Diagnostics.Process.StandardError%2A> Datenstrom. <xref:System.Diagnostics.Process.CancelErrorRead%2A> beendet den asynchronen Lesevorgang.  
  
 Nach dem abbrechen können Sie den asynchronen Lesevorgang fortsetzen, indem Sie <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> erneut aufrufen.  
  
 Wenn Sie <xref:System.Diagnostics.Process.CancelErrorRead%2A>aufzurufen, werden alle laufenden Lesevorgänge für <xref:System.Diagnostics.Process.StandardError%2A> abgeschlossen, und der Ereignishandler ist deaktiviert. Alle weitergeleiteten Ausgaben an <xref:System.Diagnostics.Process.StandardError%2A> gehen verloren. Wenn Sie den Ereignishandler mit einem-<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>reaktivieren, werden asynchrone Lesevorgänge wieder aufgenommen. Wenn Sie den Ereignishandler vor dem Fortsetzen von asynchronen Lesevorgängen ändern möchten, müssen Sie den vorhandenen Ereignishandler entfernen, bevor Sie den neuen Ereignishandler hinzufügen:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Asynchrone und synchrone Lesevorgänge können nicht für den umgeleiteten <xref:System.Diagnostics.Process.StandardError%2A> Stream gemischt werden. Sobald der umgeleitete Stream einer <xref:System.Diagnostics.Process> entweder im asynchronen oder im synchronen Modus geöffnet ist, müssen sich alle weiteren Lesevorgänge in diesem Stream im gleichen Modus befinden. Wenn Sie einen asynchronen Lesevorgang auf <xref:System.Diagnostics.Process.StandardError%2A> abbrechen und dann erneut aus dem Datenstrom lesen müssen, müssen Sie <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> verwenden, um asynchrone Lesevorgänge fortzusetzen. Befolgen Sie <xref:System.Diagnostics.Process.CancelErrorRead%2A> nicht mit einem aufzurufenden synchronen Lesemethoden <xref:System.Diagnostics.Process.StandardError%2A> wie <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>oder <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der `nmake`-Befehl mit vom Benutzer bereitgestellten Argumenten gestartet. Die Fehler-und Ausgabestreams werden asynchron gelesen. die gesammelten Textzeilen werden in der Konsole angezeigt und in eine Protokolldatei geschrieben. Wenn die Befehlsausgabe eine angegebene Anzahl von Zeilen überschreitet, werden die asynchronen Lesevorgänge abgebrochen.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream ist nicht für asynchrone Lesevorgänge aktiviert.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht den asynchronen Lesevorgang im umgeleiteten <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream einer Anwendung ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> startet einen asynchronen Lesevorgang für den <xref:System.Diagnostics.Process.StandardOutput%2A> Datenstrom. <xref:System.Diagnostics.Process.CancelOutputRead%2A> beendet den asynchronen Lesevorgang.  
  
 Nach dem abbrechen können Sie asynchrone Lesevorgänge fortsetzen, indem Sie <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> erneut aufrufen.  
  
 Wenn Sie <xref:System.Diagnostics.Process.CancelOutputRead%2A>aufzurufen, werden alle laufenden Lesevorgänge für <xref:System.Diagnostics.Process.StandardOutput%2A> abgeschlossen, und der Ereignishandler ist deaktiviert. Alle weitergeleiteten Ausgaben an <xref:System.Diagnostics.Process.StandardOutput%2A> werden in einem Puffer gespeichert. Wenn Sie den Ereignishandler mit einem-<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>reaktivieren, wird die gespeicherte Ausgabe an den Ereignishandler gesendet, und asynchrone Lesevorgänge werden fortgesetzt. Wenn Sie den Ereignishandler vor dem Fortsetzen von asynchronen Lesevorgängen ändern möchten, müssen Sie den vorhandenen Ereignishandler entfernen, bevor Sie den neuen Ereignishandler hinzufügen:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Asynchrone und synchrone Lesevorgänge können nicht für den umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream gemischt werden. Sobald der umgeleitete Stream einer <xref:System.Diagnostics.Process> entweder im asynchronen oder im synchronen Modus geöffnet ist, müssen sich alle weiteren Lesevorgänge in diesem Stream im gleichen Modus befinden. Wenn Sie einen asynchronen Lesevorgang auf <xref:System.Diagnostics.Process.StandardOutput%2A> abbrechen und dann erneut aus dem Datenstrom lesen müssen, müssen Sie <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> verwenden, um asynchrone Lesevorgänge fortzusetzen. Befolgen Sie <xref:System.Diagnostics.Process.CancelOutputRead%2A> nicht mit einem aufzurufenden synchronen Lesemethoden <xref:System.Diagnostics.Process.StandardOutput%2A> wie <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>oder <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der `nmake`-Befehl mit vom Benutzer bereitgestellten Argumenten gestartet. Die Fehler-und Ausgabestreams werden asynchron gelesen. die gesammelten Textzeilen werden in der Konsole angezeigt und in eine Protokolldatei geschrieben. Wenn die Befehlsausgabe eine angegebene Anzahl von Zeilen überschreitet, werden die asynchronen Lesevorgänge abgebrochen.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream ist nicht für asynchrone Lesevorgänge aktiviert.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle dieser Komponente zugeordneten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.Close%2A>-Methode bewirkt, dass der Prozess beendet wird, wenn er wartet, das Prozess handle schließt und prozessspezifische Eigenschaften löscht. <xref:System.Diagnostics.Process.Close%2A> schließt die Standardausgabe, Eingabe und Fehler Leser und Writer für den Fall, dass Sie extern referenziert werden.  
  
> [!NOTE]
>  Die <xref:System.Diagnostics.Process.Dispose%2A>-Methode ruft <xref:System.Diagnostics.Process.Close%2A> auf. Durch das Platzieren des <xref:System.Diagnostics.Process> Objekts in einem `using` Block werden Ressourcen frei, ohne dass <xref:System.Diagnostics.Process.Close%2A>aufgerufen werden muss.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet. Anschließend wird die physische Speicherauslastung des zugeordneten Prozesses in Intervallen von 2 Sekunden für maximal 10 Sekunden abgerufen. Im Beispiel wird erkannt, ob der Prozess beendet wird, bevor 10 Sekunden abgelaufen sind. Im Beispiel wird der Prozess geschlossen, wenn er nach 10 Sekunden noch ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt einen Prozess mit einer Benutzeroberfläche, indem eine Meldung zum Schließen an das Hauptfenster gesendet wird.</summary>
        <returns><see langword="true" />, wenn die Meldung zum Schließen erfolgreich gesendet wurde. <see langword="false" />, wenn der zugeordnete Prozess nicht über ein Hauptfenster verfügt oder wenn das Hauptfenster deaktiviert ist (z. B., wenn ein modales Dialogfeld angezeigt wird).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Prozess ausgeführt wird, befindet sich seine Nachrichten Schleife in einem Wartezustand. Die Nachrichten Schleife wird jedes Mal ausgeführt, wenn vom Betriebssystem eine Windows-Meldung an den Prozess gesendet wird. Durch Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> wird eine Anforderung zum Schließen des Hauptfensters gesendet, das in einer wohlgeformten Anwendung untergeordnete Fenster schließt und alle laufenden Nachrichten Schleifen für die Anwendung widerruft. Die Anforderung zum Beenden des Prozesses durch Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> zwingt nicht, dass die Anwendung beendet wird. Die Anwendung kann die Benutzer Überprüfung vor dem Beenden anfordern, oder Sie kann das Beenden ablehnen. Verwenden Sie die <xref:System.Diagnostics.Process.Kill%2A>-Methode, um das Beenden der Anwendung zu erzwingen. Das Verhalten von <xref:System.Diagnostics.Process.CloseMainWindow%2A> ist identisch mit dem eines Benutzers, der das Hauptfenster einer Anwendung mithilfe des Systemmenüs schließt. Daher zwingt die Anforderung zum Beenden des Prozesses durch Schließen des Hauptfensters nicht, dass die Anwendung sofort beendet wird.  
  
 Die von dem Prozess bearbeiteten Daten oder Ressourcen, die dem Prozess zugeordnet sind, können verloren gehen, wenn Sie <xref:System.Diagnostics.Process.Kill%2A>abrufen. <xref:System.Diagnostics.Process.Kill%2A> verursacht eine ungewöhnliche Prozess Beendigung und sollte nur bei Bedarf verwendet werden. <xref:System.Diagnostics.Process.CloseMainWindow%2A> ermöglicht eine ordnungsgemäße Beendigung des Prozesses und schließt alle Fenster, sodass Anwendungen mit einer Schnittstelle bevorzugt werden. Wenn <xref:System.Diagnostics.Process.CloseMainWindow%2A> fehlschlägt, können Sie <xref:System.Diagnostics.Process.Kill%2A> verwenden, um den Prozess zu beenden. <xref:System.Diagnostics.Process.Kill%2A> ist die einzige Möglichkeit, Prozesse zu beenden, die keine grafischen Schnittstellen aufweisen.  
  
 Rufen Sie <xref:System.Diagnostics.Process.Kill%2A> und <xref:System.Diagnostics.Process.CloseMainWindow%2A> nur für Prozesse, die auf dem lokalen Computer ausgeführt werden. Es ist nicht möglich, Prozesse auf Remote Computern zu beenden. Sie können nur Informationen für Prozesse anzeigen, die auf Remote Computern ausgeführt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet. Anschließend wird die physische Speicherauslastung des zugeordneten Prozesses in Intervallen von 2 Sekunden für maximal 10 Sekunden abgerufen. Im Beispiel wird erkannt, ob der Prozess beendet wird, bevor 10 Sekunden abgelaufen sind. Im Beispiel wird der Prozess geschlossen, wenn er nach 10 Sekunden noch ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde bereits beendet.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt alle von diesem Prozess verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob beim Beenden des Prozesses das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis ausgelöst werden soll.</summary>
        <value><see langword="true" />, wenn das <see cref="E:System.Diagnostics.Process.Exited" /> Ereignis ausgelöst werden soll, wenn der zugeordnete Prozess beendet wird (entweder durch beenden oder einen-Befehl <see cref="M:System.Diagnostics.Process.Kill" />). Andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />. Beachten Sie, dass das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis auch dann ausgelöst wird, wenn der Wert von <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> <see langword="false" /> wird, wenn der Prozess während oder vor der Durchführung einer <see cref="P:System.Diagnostics.Process.HasExited" /> Überprüfung durch den Benutzer beendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>-Eigenschaft gibt an, ob die Komponente benachrichtigt werden soll, wenn das Betriebssystem einen Prozess heruntergefahren hat. Die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>-Eigenschaft wird bei der asynchronen Verarbeitung verwendet, um die Anwendung darüber zu benachrichtigen, dass ein Prozess beendet wurde. Verwenden Sie die <xref:System.Diagnostics.Process.WaitForExit%2A>-Methode, um die synchrone Wartezeit der Anwendung auf ein Exit-Ereignis zu erzwingen (wodurch die Verarbeitung der Anwendung unterbrochen wird, bis das Exit-Ereignis aufgetreten ist).

> [!NOTE]
> Wenn Sie Visual Studio verwenden und im Projekt auf eine <xref:System.Diagnostics.Process> Komponente doppelklicken, werden automatisch ein <xref:System.Diagnostics.Process.Exited> Ereignis Delegat und ein Ereignishandler generiert. Zusätzlicher Code legt die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>-Eigenschaft auf `false`fest. Sie müssen diese Eigenschaft in `true` ändern, damit der Ereignishandler ausgeführt wird, wenn der zugeordnete Prozess beendet wird.

Wenn der <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Wert der Komponente `true`ist oder wenn <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> `false` und eine <xref:System.Diagnostics.Process.HasExited%2A> Prüfung von der Komponente aufgerufen wird, kann die Komponente auf die administrativen Informationen für den zugeordneten Prozess zugreifen, der weiterhin vom Betriebssystem gespeichert wird. Zu diesen Informationen gehören die <xref:System.Diagnostics.Process.ExitTime%2A> und die <xref:System.Diagnostics.Process.ExitCode%2A>.

Nachdem der zugehörige Prozess beendet wurde, zeigt der <xref:System.Diagnostics.Process.Handle%2A> der Komponente nicht mehr auf eine vorhandene Prozess Ressource. Stattdessen kann Sie nur für den Zugriff auf die Informationen des Betriebssystems über die Prozess Ressource verwendet werden. Das Betriebssystem ist sich bewusst, dass Handles vorhanden sind, die nicht von <xref:System.Diagnostics.Process> Komponenten freigegeben wurden, sodass die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.Handle%2A> Informationen im Arbeitsspeicher aufbewahrt werden.

Es fallen Kosten für die Überwachung eines Prozesses an. Wenn <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> `true`ist, wird das <xref:System.Diagnostics.Process.Exited> Ereignis ausgelöst, wenn der zugeordnete Prozess beendet wird. Die Prozeduren für das <xref:System.Diagnostics.Process.Exited> Ereignis werden zu diesem Zeitpunkt ausgeführt.

Manchmal startet die Anwendung einen Prozess, erfordert aber keine Benachrichtigung über den Abschluss. Beispielsweise kann Ihre Anwendung den Editor starten, um dem Benutzer die Durchführung von Textbearbeitung zu ermöglichen, aber keine weitere Verwendung der Notepad-Anwendung. Sie können eine Benachrichtigung vermeiden, wenn der Prozess beendet wird, da Sie für den fortgesetzten Betrieb der Anwendung nicht relevant ist. Durch Festlegen von <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> auf `false` können Systemressourcen eingespart werden.

## Examples  
Im folgenden Codebeispiel wird ein Prozess erstellt, der eine Datei ausgibt. Dadurch wird die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>-Eigenschaft festgelegt, damit der Prozess das <xref:System.Diagnostics.Process.Exited>-Ereignis auslöst, wenn es beendet wird. Der <xref:System.Diagnostics.Process.Exited>-Ereignishandler zeigt Prozessinformationen an.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Versetzt durch Aktivieren der systemeigenen <see cref="T:System.Diagnostics.Process" />-Eigenschaft für den aktuellen Thread eine <see langword="SeDebugPrivilege" />-Komponente in einen Zustand, in dem sie mit Betriebssystemprozessen interagieren kann, die in einem speziellen Modus ausgeführt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Betriebssystem Prozesse werden in einem speziellen Modus ausgeführt. Es ist nicht möglich, die Eigenschaften von zu lesen oder an diese Prozesse anzufügen, es sei denn, Sie haben <xref:System.Diagnostics.Process.EnterDebugMode%2A> für die Komponente aufgerufen. Aufrufen von <xref:System.Diagnostics.Process.LeaveDebugMode%2A>, wenn Sie keinen Zugriff mehr auf diese Prozesse benötigen, die im speziellen Modus ausgeführt werden.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event ErrorDataReceived As DataReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Anwendung in ihren umgeleiteten <see cref="P:System.Diagnostics.Process.StandardError" />-Stream schreibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ereignis <xref:System.Diagnostics.Process.ErrorDataReceived> gibt an, dass der zugeordnete Prozess in seinen umgeleiteten <xref:System.Diagnostics.Process.StandardError%2A> Stream geschrieben hat.  
  
 Das Ereignis tritt nur bei asynchronen Lesevorgängen auf <xref:System.Diagnostics.Process.StandardError%2A>auf. Um asynchrone Lesevorgänge zu starten, müssen Sie den <xref:System.Diagnostics.Process.StandardError%2A> Stream eines <xref:System.Diagnostics.Process>umleiten, den Ereignishandler dem <xref:System.Diagnostics.Process.ErrorDataReceived>-Ereignis hinzufügen und <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>aufzurufen. Danach signalisiert das Ereignis <xref:System.Diagnostics.Process.ErrorDataReceived> jedes Mal, wenn der Prozess eine Zeile in den umgeleiteten <xref:System.Diagnostics.Process.StandardError%2A> Datenstrom schreibt, bis der Prozess beendet wird oder <xref:System.Diagnostics.Process.CancelErrorRead%2A>aufruft.  
  
> [!NOTE]
>  Die Anwendung, die die asynchrone Ausgabe verarbeitet, sollte die <xref:System.Diagnostics.Process.WaitForExit>-Methode aufzurufen, um sicherzustellen, dass der Ausgabepuffer geleert wurde. Beachten Sie, dass durch das Angeben eines Timeouts mithilfe der <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> Überladung *nicht* sichergestellt wird, dass der Ausgabepuffer geleert wurde.
  
   
  
## Examples  
 Im folgenden Beispiel wird der `net view` Befehl verwendet, um die verfügbaren Netzwerkressourcen auf einem Remote Computer aufzulisten. Der Benutzer gibt den Namen des Ziel Computers als Befehlszeilenargument an. Der Benutzer kann auch einen Dateinamen für die Fehlerausgabe angeben. Im Beispiel wird die Ausgabe des NET-Befehls erfasst, auf den Abschluss des Prozesses gewartet und dann die Ausgabe Ergebnisse in die Konsole geschrieben. Wenn der Benutzer die optionale Fehler Datei angibt, schreibt das Beispiel Fehler in die Datei.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der vom zugeordneten Prozess beim Beenden angegeben wurde.</summary>
        <value>Der Code, der vom zugeordneten Prozess beim Beenden angegeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Diagnostics.Process.ExitCode%2A>, um den Status zu erhalten, den der System Prozess beim verlassen zurückgegeben hat. Sie können den Exitcode ähnlich wie ein ganzzahliger Rückgabewert aus einer `main()` Prozedur verwenden.  
  
 Der <xref:System.Diagnostics.Process.ExitCode%2A> Wert für einen Prozess gibt die bestimmte Konvention wieder, die vom Anwendungsentwickler für diesen Prozess implementiert wird. Wenn Sie den Exitcodewert verwenden, um Entscheidungen im Code zu treffen, stellen Sie sicher, dass Sie die vom Anwendungsprozess verwendete exitcodekonvention kennen.  
  
 Entwickler geben in der Regel einen erfolgreichen Ausgang durch einen <xref:System.Diagnostics.Process.ExitCode%2A> Wert von NULL an und legen Fehler durch Werte ungleich NULL fest, die von der aufrufenden Methode verwendet werden können, um die Ursache für eine ungewöhnliche Prozess Beendigung zu identifizieren. Es ist nicht erforderlich, diese Richtlinien einzuhalten, aber Sie sind die Konvention.  
  
 Wenn Sie versuchen, die <xref:System.Diagnostics.Process.ExitCode%2A> zu erhalten, bevor der Prozess beendet wurde, wird durch den Versuch eine Ausnahme ausgelöst. Überprüfen Sie zuerst die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft, um zu überprüfen, ob der zugeordnete Prozess beendet wurde  
  
> [!NOTE]
>  Wenn die Standardausgabe zu asynchronen Ereignis Handlern umgeleitet wurde, ist es möglich, dass die Ausgabe Verarbeitung nicht abgeschlossen ist, wenn <xref:System.Diagnostics.Process.HasExited%2A> `true`zurückgibt. Um sicherzustellen, dass die asynchrone Ereignisverarbeitung abgeschlossen ist, müssen Sie die <xref:System.Diagnostics.Process.WaitForExit>-Überladung aufrufen, die keinen Parameter annimmt, bevor Sie <xref:System.Diagnostics.Process.HasExited%2A>prüfen.  
  
 Sie können die-<xref:System.Diagnostics.Process.CloseMainWindow%2A> oder die <xref:System.Diagnostics.Process.Kill%2A>-Methode verwenden, um einen zugeordneten Prozess zu beenden.  
  
 Es gibt zwei Möglichkeiten, benachrichtigt zu werden, wenn der zugehörige Prozess beendet wird: synchron und asynchron. Die synchrone Benachrichtigung basiert darauf, dass die <xref:System.Diagnostics.Process.WaitForExit%2A>-Methode aufgerufen wird, um die Verarbeitung der Anwendung anzuhalten, bis die zugehörige Komponente beendet wird Die asynchrone Benachrichtigung basiert auf dem <xref:System.Diagnostics.Process.Exited> Ereignis. Wenn Sie asynchrone Benachrichtigungen verwenden, müssen <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> auf `true` festgelegt werden, damit die <xref:System.Diagnostics.Process> Komponente benachrichtigt, dass der Prozess beendet wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode des Prozesses an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht beendet.  
  
- oder - 
Der Prozess <see cref="P:System.Diagnostics.Process.Handle" /> ist ungültig.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.ExitCode" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Beenden eines Prozesses ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ereignis <xref:System.Diagnostics.Process.Exited> gibt an, dass der zugeordnete Prozess beendet wurde. Dieses Vorkommen bedeutet, dass der Prozess beendet (abgebrochen) oder erfolgreich geschlossen wurde. Dieses Ereignis kann nur auftreten, wenn der Wert der <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>-Eigenschaft `true`ist.  
  
 Es gibt zwei Möglichkeiten, benachrichtigt zu werden, wenn der zugehörige Prozess beendet wird: synchron und asynchron. Synchrone Benachrichtigung bedeutet, dass die <xref:System.Diagnostics.Process.WaitForExit%2A>-Methode aufgerufen wird, um den aktuellen Thread zu blockieren, bis der Prozess beendet Die asynchrone Benachrichtigung verwendet das <xref:System.Diagnostics.Process.Exited>-Ereignis, mit dem der aufrufende Thread die Ausführung in der Zwischenzeit fortsetzen kann. Im letzteren Fall muss <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> auf `true` festgelegt werden, damit die aufrufende Anwendung das Ereignis "beendet" empfangen kann.  
  
 Wenn das Betriebssystem einen Prozess herunterfährt, werden alle anderen Prozesse benachrichtigt, die über registrierte Handler für das Ereignis "beendet" verfügen. Zu diesem Zeitpunkt kann das Handle des soeben abzurufenden Prozesses für den Zugriff auf einige Eigenschaften wie <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.HasExited%2A> verwendet werden, die das Betriebssystem verwaltet, bis es das Handle vollständig freigibt.  
  
> [!NOTE]
>  Auch wenn Sie über ein Handle für einen vorhandenen Prozess verfügen, können Sie <xref:System.Diagnostics.Process.Start%2A> nicht erneut aufzurufen, um erneut eine Verbindung mit dem gleichen Prozess herzustellen. Durch Aufrufen von <xref:System.Diagnostics.Process.Start%2A> wird der zugeordnete Prozess automatisch freigegeben, und es wird eine Verbindung <xref:System.Diagnostics.Process.Handle%2A>mit einem Prozess hergestellt  
  
 Weitere Informationen zur Verwendung des <xref:System.Diagnostics.Process.Exited> Ereignisses in Windows Forms Anwendungen finden Sie unter der <xref:System.Diagnostics.Process.SynchronizingObject%2A>-Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Prozess erstellt, der eine Datei ausgibt. Das <xref:System.Diagnostics.Process.Exited>-Ereignis wird ausgelöst, wenn der Prozess beendet wird, da die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>-Eigenschaft beim Erstellen des Prozesses festgelegt wurde. Der <xref:System.Diagnostics.Process.Exited>-Ereignishandler zeigt Prozessinformationen an.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zeitpunkt ab, zu dem der zugeordnete Prozess beendet wurde.</summary>
        <value>Eine <see cref="T:System.DateTime" />, die angibt, wann der zugeordnete Prozess beendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Prozess nicht beendet wurde, wird beim Versuch, die <xref:System.Diagnostics.Process.ExitTime%2A>-Eigenschaft abzurufen, eine Ausnahme ausgelöst. Verwenden Sie <xref:System.Diagnostics.Process.HasExited%2A>, bevor Sie die <xref:System.Diagnostics.Process.ExitTime%2A>-Eigenschaft zum Ermitteln verwenden, ob der zugeordnete Prozess beendet wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Prozess erstellt, der eine Datei ausgibt. Der Prozess löst das <xref:System.Diagnostics.Process.Exited>-Ereignis aus, wenn es beendet wird, und der Ereignishandler zeigt die <xref:System.Diagnostics.Process.ExitTime%2A>-Eigenschaft und andere Prozessinformationen an.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.ExitTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine neue <see cref="T:System.Diagnostics.Process" />-Komponente ab und ordnet diese dem gegenwärtig aktiven Prozess zu.</summary>
        <returns>Eine neue <see cref="T:System.Diagnostics.Process" />-Komponente, die der Prozessressource zugeordnet ist, die die aufrufende Anwendung ausführt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine neue <xref:System.Diagnostics.Process>-Instanz zu erstellen und Sie der Prozess Ressource auf dem lokalen Computer zuzuordnen.  
  
 Wie bei den ähnlichen Methoden <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>und <xref:System.Diagnostics.Process.GetProcesses%2A> ordnet <xref:System.Diagnostics.Process.GetCurrentProcess%2A> einer neuen <xref:System.Diagnostics.Process> Komponente eine vorhandene Ressource zu.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Informationen zum aktuellen Prozess, Prozesse, die auf dem lokalen Computer ausgeführt werden, alle Instanzen von Notepad, die auf dem lokalen Computer ausgeführt werden, und ein bestimmter Prozess auf dem lokalen Computer abgerufen. Er ruft dann Informationen für die gleichen Prozesse auf einem Remote Computer ab.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente und ordnet diese der angegebenen vorhandenen Prozessressource zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">Der systemweit eindeutige Bezeichner einer Prozessressource.</param>
        <summary>Gibt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente zurück, wenn der Bezeichner eines Prozesses auf dem lokalen Computer angegeben ist.</summary>
        <returns>Eine <see cref="T:System.Diagnostics.Process" />-Komponente, die der durch den <paramref name="processId" />-Parameter bezeichneten lokalen Prozessressource zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine neue <xref:System.Diagnostics.Process> Komponente zu erstellen und Sie einer Prozess Ressource auf dem lokalen Computer zuzuordnen. Die Prozess Ressource muss bereits auf dem Computer vorhanden sein, da <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> keine System Ressource erstellt, sondern eine Ressource mit einer von der Anwendung generierten <xref:System.Diagnostics.Process> Komponente verknüpft. Ein Prozess <xref:System.Diagnostics.Process.Id%2A> kann nur für einen Prozess abgerufen werden, der zurzeit auf dem Computer ausgeführt wird. Nachdem der Prozess beendet wurde, löst <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> eine Ausnahme aus, wenn Sie einen abgelaufenen Bezeichner übergeben.  
  
 Auf einem bestimmten Computer ist der Bezeichner eines Prozesses eindeutig. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> gibt höchstens einen Prozess zurück. Wenn Sie alle Prozesse, die eine bestimmte Anwendung ausführen, erhalten möchten, verwenden Sie <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Wenn auf dem Computer, auf dem die angegebene Anwendung ausgeführt wird, mehrere Prozesse vorhanden sind, gibt <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> ein Array mit allen zugeordneten Prozessen zurück. Sie können jeden dieser Prozesse wiederum für den Bezeichner Abfragen. Der Prozess Bezeichner kann im `Processes` Panel des Windows Task-Managers angezeigt werden. In der Spalte `PID` wird die Prozess-ID angezeigt, die einem Prozess zugewiesen ist.  
  
 Der `processId`-Parameter ist eine <xref:System.Int32> (eine 32-Bit-Ganzzahl mit Vorzeichen), obwohl die zugrunde liegende Windows-API eine `DWORD` (eine ganze Zahl 32 ohne Vorzeichen) für ähnliche APIs verwendet. Dies ist aus historischen Gründen der Grund.
  
## Examples  
 Im folgenden Beispiel werden Informationen zum aktuellen Prozess, Prozesse, die auf dem lokalen Computer ausgeführt werden, alle Instanzen von Notepad, die auf dem lokalen Computer ausgeführt werden, und ein bestimmter Prozess auf dem lokalen Computer abgerufen. Er ruft dann Informationen für die gleichen Prozesse auf einem Remote Computer ab.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der durch den <paramref name="processId" />-Parameter angegebene Prozess wird nicht ausgeführt. Möglicherweise ist der Bezeichner abgelaufen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht von diesem Objekt gestartet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">Der systemweit eindeutige Bezeichner einer Prozessressource.</param>
        <param name="machineName">Der Name eines Computers im Netzwerk.</param>
        <summary>Gibt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente zurück, wenn die Prozess-ID und der Name des Computers im Netzwerk angegeben sind.</summary>
        <returns>Eine <see cref="T:System.Diagnostics.Process" />-Komponente, die der durch den <paramref name="processId" />-Parameter bezeichneten Remoteprozessressource zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um eine neue <xref:System.Diagnostics.Process> Komponente zu erstellen und Sie einer Prozess Ressource auf einem Remote Computer im Netzwerk zuzuordnen. Die Prozess Ressource muss bereits auf dem angegebenen Computer vorhanden sein, da <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> keine System Ressource erstellt, sondern eine Ressource mit einer von der Anwendung generierten <xref:System.Diagnostics.Process> Komponente verknüpft. Ein Prozess <xref:System.Diagnostics.Process.Id%2A> kann nur für einen Prozess abgerufen werden, der zurzeit auf dem Computer ausgeführt wird. Nachdem der Prozess beendet wurde, löst <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> eine Ausnahme aus, wenn Sie einen abgelaufenen Bezeichner übergeben.  
  
 Auf einem bestimmten Computer ist der Bezeichner eines Prozesses eindeutig. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> gibt höchstens einen Prozess zurück. Wenn Sie alle Prozesse, die eine bestimmte Anwendung ausführen, erhalten möchten, verwenden Sie <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Wenn auf dem Computer, auf dem die angegebene Anwendung ausgeführt wird, mehrere Prozesse vorhanden sind, gibt <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> ein Array mit allen zugeordneten Prozessen zurück. Sie können jeden dieser Prozesse wiederum für den Bezeichner Abfragen. Der Prozess Bezeichner kann im `Processes` Panel des Windows Task-Managers angezeigt werden. In der Spalte `PID` wird die Prozess-ID angezeigt, die einem Prozess zugewiesen ist.  
  
 Wenn Sie keine `machineName`angeben, wird der lokale Computer verwendet. Alternativ können Sie den lokalen Computer angeben, indem Sie `machineName` auf den Wert "." oder eine leere Zeichenfolge ("") festlegen.  
  
 Der `processId`-Parameter ist eine <xref:System.Int32> (eine 32-Bit-Ganzzahl mit Vorzeichen), obwohl die zugrunde liegende Windows-API eine `DWORD` (eine ganze Zahl 32 ohne Vorzeichen) für ähnliche APIs verwendet. Dies ist aus historischen Gründen der Grund.   
  
## Examples  
 Im folgenden Beispiel werden Informationen zum aktuellen Prozess, Prozesse, die auf dem lokalen Computer ausgeführt werden, alle Instanzen von Notepad, die auf dem lokalen Computer ausgeführt werden, und ein bestimmter Prozess auf dem lokalen Computer abgerufen. Er ruft dann Informationen für die gleichen Prozesse auf einem Remote Computer ab.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der durch den <paramref name="processId" />-Parameter angegebene Prozess wird nicht ausgeführt. Möglicherweise ist der Bezeichner abgelaufen.  
  
- oder - 
Die Syntax des <paramref name="machineName" />-Parameters ist ungültig. Der Name kann die Länge 0 (null) haben.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="machineName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht von diesem Objekt gestartet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Array neuer <see cref="T:System.Diagnostics.Process" />-Komponenten und ordnet diese den vorhandenen Prozessressourcen zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente für jede Prozessressource auf dem lokalen Computer.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das alle auf dem lokalen Computer ausgeführten Prozessressourcen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um ein Array mit neuen <xref:System.Diagnostics.Process> Komponenten zu erstellen und diese allen Prozess Ressourcen auf dem lokalen Computer zuzuordnen. Die Prozess Ressourcen müssen bereits auf dem lokalen Computer vorhanden sein, da <xref:System.Diagnostics.Process.GetProcesses%2A> keine Systemressourcen erstellt, sondern Ressourcen mit von der Anwendung generierten <xref:System.Diagnostics.Process> Komponenten verknüpft. Da das Betriebssystem selbst Hintergrundprozesse ausführen, ist dieses Array nie leer.  
  
 Wenn Sie nicht alle Prozesse abrufen möchten, die auf dem Computer ausgeführt werden, können Sie die Anzahl mithilfe der <xref:System.Diagnostics.Process.GetProcessById%2A>-oder <xref:System.Diagnostics.Process.GetProcessesByName%2A> Methode einschränken. <xref:System.Diagnostics.Process.GetProcessById%2A> erstellt eine <xref:System.Diagnostics.Process> Komponente, die dem Prozess zugeordnet ist, der von der Prozess-ID, die Sie an die-Methode übergeben, auf dem System identifiziert wird. <xref:System.Diagnostics.Process.GetProcessesByName%2A> erstellt ein Array von <xref:System.Diagnostics.Process> Komponenten, deren zugeordnete Prozess Ressourcen die ausführbare Datei gemeinsam verwenden, die Sie an die-Methode übergeben.  
  
> [!NOTE]
>  Mehrere Windows-Dienste können innerhalb derselben Instanz des Dienst Host Prozesses (svchost. exe) geladen werden. GetProcesses identifiziert diese einzelnen Dienste nicht. Informationen hierzu finden Sie unter <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Informationen zum aktuellen Prozess, Prozesse, die auf dem lokalen Computer ausgeführt werden, alle Instanzen von Notepad, die auf dem lokalen Computer ausgeführt werden, und ein bestimmter Prozess auf dem lokalen Computer abgerufen. Er ruft dann Informationen für die gleichen Prozesse auf einem Remote Computer ab.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Der Computer, von dem die Liste der Prozesse gelesen werden soll.</param>
        <summary>Erstellt eine neue <see cref="T:System.Diagnostics.Process" />-Komponente für jede Prozessressource auf dem lokalen Computer.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das alle auf dem angegebenen Computer ausgeführten Prozessressourcen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um ein Array mit neuen <xref:System.Diagnostics.Process> Komponenten zu erstellen und diese allen Prozess Ressourcen auf dem angegebenen (normalerweise Remote) Computer zuzuordnen. Die Prozess Ressourcen müssen bereits auf dem lokalen Computer vorhanden sein, da <xref:System.Diagnostics.Process.GetProcesses%2A> keine Systemressourcen erstellt, sondern Ressourcen mit von der Anwendung generierten <xref:System.Diagnostics.Process> Komponenten verknüpft. Da das Betriebssystem selbst Hintergrundprozesse ausführen, ist dieses Array nie leer.  
  
 Wenn Sie nicht alle Prozesse abrufen möchten, die auf dem Computer ausgeführt werden, können Sie die Anzahl mithilfe der <xref:System.Diagnostics.Process.GetProcessById%2A>-oder <xref:System.Diagnostics.Process.GetProcessesByName%2A> Methode einschränken. <xref:System.Diagnostics.Process.GetProcessById%2A> erstellt eine <xref:System.Diagnostics.Process> Komponente, die dem Prozess zugeordnet ist, der von der Prozess-ID, die Sie an die-Methode übergeben, auf dem System identifiziert wird. <xref:System.Diagnostics.Process.GetProcessesByName%2A> erstellt ein Array von <xref:System.Diagnostics.Process> Komponenten, deren zugeordnete Prozess Ressourcen die ausführbare Datei gemeinsam verwenden, die Sie an die-Methode übergeben.  
  
 Diese Überladung der <xref:System.Diagnostics.Process.GetProcesses%2A>-Methode wird in der Regel verwendet, um die Liste der Prozess Ressourcen abzurufen, die auf einem Remote Computer im Netzwerk ausgeführt werden, aber Sie können den lokalen Computer durch Übergeben von "." angeben.  
  
> [!NOTE]
>  Mehrere Windows-Dienste können innerhalb derselben Instanz des Dienst Host Prozesses (svchost. exe) geladen werden. GetProcesses identifiziert diese einzelnen Dienste nicht. Informationen hierzu finden Sie unter <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Informationen zum aktuellen Prozess, Prozesse, die auf dem lokalen Computer ausgeführt werden, alle Instanzen von Notepad, die auf dem lokalen Computer ausgeführt werden, und ein bestimmter Prozess auf dem lokalen Computer abgerufen. Er ruft dann Informationen für die gleichen Prozesse auf einem Remote Computer ab.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="machineName" />-Parameters ist ungültig. Sie kann die Länge 0 (null) haben.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="machineName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Betriebssystemplattform unterstützt diesen Vorgang nicht auf Remotecomputern.</exception>
        <exception cref="T:System.InvalidOperationException">Es gibt Probleme beim Zugriff auf die Leistungsindikator-APIs zum Abrufen von Prozessinformationen. Diese Ausnahme tritt nur unter Windows NT, Windows 2000 und Windows XP auf.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugriff auf eine zugrunde liegende System-API ist ein Problem aufgetreten.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Array neuer <see cref="T:System.Diagnostics.Process" />-Komponenten und ordnet diese den vorhandenen Prozessressourcen zu, die den angegebenen Prozessnamen gemeinsam verwenden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Der angezeigte Name des Prozesses.</param>
        <summary>Erstellt ein Array neuer <see cref="T:System.Diagnostics.Process" />-Komponenten und ordnet diese allen Prozessressourcen auf dem lokalen Computer zu, die den angegebenen Prozessnamen gemeinsam verwenden.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das die Prozessressourcen darstellt, die die angegebene Anwendung oder Datei ausführen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um ein Array mit neuen <xref:System.Diagnostics.Process> Komponenten zu erstellen und diese allen Prozess Ressourcen zuzuordnen, die dieselbe ausführbare Datei auf dem lokalen Computer ausführen. Die Prozess Ressourcen müssen bereits auf dem Computer vorhanden sein, da <xref:System.Diagnostics.Process.GetProcessesByName%2A> keine Systemressourcen erstellt, sondern Sie mit Anwendungs generierten <xref:System.Diagnostics.Process> Komponenten verknüpft. Eine `processName` kann für eine ausführbare Datei angegeben werden, die derzeit nicht auf dem lokalen Computer ausgeführt wird, sodass das von der Methode zurückgegebene Array leer sein kann.  
  
 Der Prozess Name ist ein Anzeige Name für den Prozess, z. b. Outlook, der weder die exe-Erweiterung noch den Pfad enthält. <xref:System.Diagnostics.Process.GetProcessesByName%2A> ist hilfreich, um alle Prozesse, die mit derselben ausführbaren Datei verknüpft sind, zu erhalten und zu bearbeiten. Beispielsweise können Sie den Namen einer ausführbaren Datei als `processName`-Parameter übergeben, um alle laufenden Instanzen dieser ausführbaren Datei zu beenden.  
  
 Obwohl ein Prozess <xref:System.Diagnostics.Process.Id%2A> für eine einzelne Prozess Ressource im System eindeutig ist, können mehrere Prozesse auf dem lokalen Computer die durch den Parameter `processName` angegebene Anwendung ausführen. Daher gibt <xref:System.Diagnostics.Process.GetProcessById%2A> höchstens einen Prozess zurück, aber <xref:System.Diagnostics.Process.GetProcessesByName%2A> gibt ein Array zurück, das alle zugeordneten Prozesse enthält. Wenn Sie den Prozess mithilfe von Standard-API-aufrufen bearbeiten müssen, können Sie jeden dieser Prozesse ihrerseits für den Bezeichner Abfragen. Sie können nicht allein auf Prozess Ressourcen zugreifen, aber nachdem Sie ein Array von <xref:System.Diagnostics.Process>-Komponenten abgerufen haben, die den Prozess Ressourcen zugeordnet sind, können Sie die Systemressourcen starten, beenden und anderweitig bearbeiten.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Informationen zum aktuellen Prozess, Prozesse, die auf dem lokalen Computer ausgeführt werden, alle Instanzen von Notepad, die auf dem lokalen Computer ausgeführt werden, und ein bestimmter Prozess auf dem lokalen Computer abgerufen. Er ruft dann Informationen für die gleichen Prozesse auf einem Remote Computer ab.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es gibt Probleme beim Zugriff auf die Leistungsindikator-APIs zum Abrufen von Prozessinformationen. Diese Ausnahme tritt nur unter Windows NT, Windows 2000 und Windows XP auf.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Der angezeigte Name des Prozesses.</param>
        <param name="machineName">Der Name eines Computers im Netzwerk.</param>
        <summary>Erstellt ein Array neuer <see cref="T:System.Diagnostics.Process" />-Komponenten und ordnet diese allen Prozessressourcen auf einem Remotecomputer zu, die den angegebenen Prozessnamen gemeinsam verwenden.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Diagnostics.Process" />, das die Prozessressourcen darstellt, die die angegebene Anwendung oder Datei ausführen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um ein Array mit neuen <xref:System.Diagnostics.Process> Komponenten zu erstellen und diese allen Prozess Ressourcen zuzuordnen, die dieselbe ausführbare Datei auf dem angegebenen Computer ausführen. Die Prozess Ressourcen müssen bereits auf dem Computer vorhanden sein, da <xref:System.Diagnostics.Process.GetProcessesByName%2A> keine Systemressourcen erstellt, sondern Sie mit Anwendungs generierten <xref:System.Diagnostics.Process> Komponenten verknüpft. Eine `processName` kann für eine ausführbare Datei angegeben werden, die derzeit nicht auf dem lokalen Computer ausgeführt wird, sodass das von der Methode zurückgegebene Array leer sein kann.  
  
 Der Prozess Name ist ein Anzeige Name für den Prozess, z. b. Outlook, der weder die exe-Erweiterung noch den Pfad enthält. <xref:System.Diagnostics.Process.GetProcessesByName%2A> ist hilfreich, um alle Prozesse, die mit derselben ausführbaren Datei verknüpft sind, zu erhalten und zu bearbeiten. Beispielsweise können Sie den Namen einer ausführbaren Datei als `processName`-Parameter übergeben, um alle laufenden Instanzen dieser ausführbaren Datei zu beenden.  
  
 Obwohl ein Prozess <xref:System.Diagnostics.Process.Id%2A> für eine einzelne Prozess Ressource im System eindeutig ist, können mehrere Prozesse auf dem lokalen Computer die durch den Parameter `processName` angegebene Anwendung ausführen. Daher gibt <xref:System.Diagnostics.Process.GetProcessById%2A> höchstens einen Prozess zurück, aber <xref:System.Diagnostics.Process.GetProcessesByName%2A> gibt ein Array zurück, das alle zugeordneten Prozesse enthält. Wenn Sie den Prozess mithilfe von Standard-API-aufrufen bearbeiten müssen, können Sie jeden dieser Prozesse ihrerseits für den Bezeichner Abfragen. Sie können nicht allein auf Prozess Ressourcen zugreifen, aber nachdem Sie ein Array von <xref:System.Diagnostics.Process>-Komponenten abgerufen haben, die den Prozess Ressourcen zugeordnet sind, können Sie die Systemressourcen starten, beenden und anderweitig bearbeiten.  
  
 Sie können diese Überladung verwenden, um Prozesse auf dem lokalen Computer und auf einem Remote Computer zu erhalten. Verwenden Sie ".", um den lokalen Computer anzugeben. Es gibt eine andere Überladung, die standardmäßig den lokalen Computer verwendet.  
  
 Sie können auf Prozesse auf Remote Computern nur zugreifen, um Informationen zu den Prozessen anzuzeigen (z. b. Statistiken). Sie können keine Prozesse auf Remote Computern schließen, beenden (verwenden <xref:System.Diagnostics.Process.Kill%2A>) oder starten.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Informationen zum aktuellen Prozess, Prozesse, die auf dem lokalen Computer ausgeführt werden, alle Instanzen von Notepad, die auf dem lokalen Computer ausgeführt werden, und ein bestimmter Prozess auf dem lokalen Computer abgerufen. Er ruft dann Informationen für die gleichen Prozesse auf einem Remote Computer ab.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Syntax des <paramref name="machineName" />-Parameters ist ungültig. Sie kann die Länge 0 (null) haben.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="machineName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Betriebssystemplattform unterstützt diesen Vorgang nicht auf Remotecomputern.</exception>
        <exception cref="T:System.InvalidOperationException">Der Versuch, eine Verbindung zu <paramref name="machineName" /> aufzubauen, ist fehlgeschlagen.

- oder - 
Es gibt Probleme beim Zugriff auf die Leistungsindikator-APIs zum Abrufen von Prozessinformationen. Diese Ausnahme tritt nur unter Windows NT, Windows 2000 und Windows XP auf.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Zugriff auf eine zugrunde liegende System-API ist ein Problem aufgetreten.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">, wenn nicht verwalteter Code aufgerufen werden soll. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Handle des zugeordneten Prozesses ab.</summary>
        <value>Das Handle, das das Betriebssystem dem zugeordneten Prozess beim Starten des Prozesses zugewiesen hat. Das System verwendet dieses Handle zum Verfolgen der Prozessattribute.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung kann ein Handle für einen Prozess abrufen, der als Parameter für viele Prozessinformationen und Steuerungsfunktionen verwendet werden kann. Sie können dieses Handle verwenden, um eine <xref:System.Threading.WaitHandle> zu initialisieren oder um Native Methoden mit Platt Form Aufruf aufzurufen.  
  
 Dieses Prozess handle ist für eine Anwendung privat, d. h., Prozess Handles können nicht freigegeben werden. Ein Prozess verfügt auch über einen Prozess <xref:System.Diagnostics.Process.Id%2A> der im Gegensatz zum <xref:System.Diagnostics.Process.Handle%2A>eindeutig und daher im gesamten System gültig ist.  
  
 Nur Prozesse, die durch einen-<xref:System.Diagnostics.Process.Start%2A> gestartet werden, legen die <xref:System.Diagnostics.Process.Handle%2A>-Eigenschaft der entsprechenden <xref:System.Diagnostics.Process>-Instanzen fest.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde nicht gestartet oder wurde beendet. Die <see cref="P:System.Diagnostics.Process.Handle" />-Eigenschaft kann nicht gelesen werden, weil dieser <see cref="T:System.Diagnostics.Process" />-Instanz kein Prozess zugeordnet ist.  
  
- oder - 
Die <see cref="T:System.Diagnostics.Process" />-Instanz wurde einem aktiven Prozess zugeordnet, Sie haben aber nicht die erforderlichen Berechtigungen, um ein Handle mit vollen Zugriffsrechten abzurufen.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Handle" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der vom Prozess geöffneten Handles ab.</summary>
        <value>Die Anzahl der vom Prozess geöffneten Betriebssystemhandles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Handles bieten eine Möglichkeit für einen Prozess, auf Objekte zu verweisen. Ein Prozess kann Handles für Dateien, Ressourcen, Nachrichten Warteschlangen und viele andere Betriebssystem Objekte abrufen. Das Betriebssystem gibt den dem Prozess zugeordneten Arbeitsspeicher nur dann frei, wenn die Handle-Anzahl 0 (null) ist.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der zugehörige Prozess beendet wurde.</summary>
        <value><see langword="true" />, wenn der Betriebssystemprozess, auf den die <see cref="T:System.Diagnostics.Process" />-Komponente verweist, beendet wurde; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert `true` für <xref:System.Diagnostics.Process.HasExited%2A> gibt an, dass der zugeordnete Prozess entweder normal oder nicht ordnungsgemäß beendet wurde. Sie können den zugeordneten Prozess anfordern oder erzwingen, indem Sie <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>aufrufen. Wenn ein Handle für den Prozess geöffnet ist, gibt das Betriebssystem den Prozess Speicher frei, wenn der Prozess beendet wurde, behält jedoch administrative Informationen zum Prozess bei, wie z. b. das Handle, den Exitcode und die Beendigungs Zeit. Um diese Informationen zu erhalten, können Sie die Eigenschaften <xref:System.Diagnostics.Process.ExitCode%2A> und <xref:System.Diagnostics.Process.ExitTime%2A> verwenden. Diese Eigenschaften werden automatisch für Prozesse aufgefüllt, die von dieser Komponente gestartet wurden. Die administrativen Informationen werden freigegeben, wenn alle <xref:System.Diagnostics.Process> Komponenten, die dem System Prozess zugeordnet sind, zerstört werden und keine weiteren Handles für den verlassen-Prozess enthalten.  
  
 Ein Prozess kann unabhängig von Ihrem Code beendet werden. Wenn Sie den Prozess mit dieser Komponente gestartet haben, aktualisiert das System den Wert von <xref:System.Diagnostics.Process.HasExited%2A> automatisch, auch wenn der zugehörige Prozess unabhängig beendet wird.  
  
> [!NOTE]
>  Wenn die Standardausgabe zu asynchronen Ereignis Handlern umgeleitet wurde, ist es möglich, dass die Ausgabe Verarbeitung nicht abgeschlossen ist, wenn diese Eigenschaft `true`zurückgibt. Um sicherzustellen, dass die asynchrone Ereignisverarbeitung abgeschlossen ist, müssen Sie die <xref:System.Diagnostics.Process.WaitForExit>-Überladung aufrufen, die keinen Parameter annimmt, bevor Sie <xref:System.Diagnostics.Process.HasExited%2A>prüfen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet. Anschließend wird die physische Speicherauslastung des zugeordneten Prozesses in Intervallen von 2 Sekunden für maximal 10 Sekunden abgerufen. Im Beispiel wird erkannt, ob der Prozess beendet wird, bevor 10 Sekunden abgelaufen sind. Im Beispiel wird der Prozess geschlossen, wenn er nach 10 Sekunden noch ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diesem Objekt ist kein Prozess zugeordnet.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Der Exitcode für den Prozess konnte nicht abgerufen werden.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.HasExited" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den eindeutigen Bezeichner für den zugeordneten Prozess ab.</summary>
        <value>Der vom System generierte eindeutige Bezeichner des Prozesses, auf den von dieser <see cref="T:System.Diagnostics.Process" />-Instanz verwiesen wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Prozess <xref:System.Diagnostics.Process.Id%2A> ist ungültig, wenn der zugehörige Prozess nicht ausgeführt wird. Daher sollten Sie sicherstellen, dass der Prozess ausgeführt wird, bevor Sie versuchen, die <xref:System.Diagnostics.Process.Id%2A>-Eigenschaft abzurufen. Bis der Prozess beendet wird, identifiziert die Prozess-ID den Prozess im gesamten System eindeutig.  
  
 Sie können einen Prozess, der auf einem lokalen Computer oder einem Remote Computer ausgeführt wird, mit einer neuen <xref:System.Diagnostics.Process> Instanz verbinden, indem Sie die Prozess-ID an die <xref:System.Diagnostics.Process.GetProcessById%2A>-Methode übergeben. <xref:System.Diagnostics.Process.GetProcessById%2A> ist eine `static` Methode, mit der eine neue Komponente erstellt und die <xref:System.Diagnostics.Process.Id%2A>-Eigenschaft für die neue <xref:System.Diagnostics.Process> Instanz automatisch festgelegt wird.  
  
 Prozess Bezeichner können vom System wieder verwendet werden. Der <xref:System.Diagnostics.Process.Id%2A>-Eigenschafts Wert ist nur dann eindeutig, wenn der zugeordnete Prozess ausgeführt wird. Nachdem der Prozess beendet wurde, kann das System den <xref:System.Diagnostics.Process.Id%2A>-Eigenschafts Wert für einen nicht verknüpften Prozess wieder verwenden.  
  
 Da der Bezeichner im System eindeutig ist, kann er als Alternative zum Übergeben einer <xref:System.Diagnostics.Process> Instanz an andere Threads übergeben werden. Durch diese Aktion können Systemressourcen eingespart werden, und es wird sichergestellt, dass der Prozess korrekt identifiziert wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Diagnostics.Process.Id%2A> für alle laufenden Instanzen einer Anwendung abgerufen werden. Der Code erstellt eine neue Instanz von Notepad, listet alle Instanzen von Editor auf und ermöglicht es dem Benutzer, die <xref:System.Diagnostics.Process.Id%2A> Nummer einzugeben, um eine bestimmte Instanz zu entfernen.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.Process.Id" />-Eigenschaft des Prozesses wurde nicht festgelegt.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Kill">
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Die `Kill`-Methode erzwingt eine Beendigung des Prozesses, während <xref:System.Diagnostics.Process.CloseMainWindow%2A> nur eine Beendigung anfordert. Wenn ein Prozess mit grafischer Benutzeroberfläche ausgeführt wird, befindet sich die Nachrichten Schleife in einem Wartezustand. Die Nachrichten Schleife wird jedes Mal ausgeführt, wenn vom Betriebssystem eine Windows-Meldung an den Prozess gesendet wird. Durch Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> wird eine Anforderung zum Schließen des Hauptfensters gesendet, das in einer wohlgeformten Anwendung untergeordnete Fenster schließt und alle laufenden Nachrichten Schleifen für die Anwendung widerruft. Die Anforderung zum Beenden des Prozesses durch Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> zwingt nicht, dass die Anwendung beendet wird.
Die Anwendung kann die Benutzer Überprüfung vor dem Beenden anfordern, oder Sie kann das Beenden ablehnen. Verwenden Sie die `Kill`-Methode, um das Beenden der Anwendung zu erzwingen.

Das Verhalten von <xref:System.Diagnostics.Process.CloseMainWindow%2A> ist identisch mit dem eines Benutzers, der das Hauptfenster einer Anwendung mithilfe des Systemmenüs schließt.
Daher zwingt die Anforderung zum Beenden des Prozesses durch Schließen des Hauptfensters nicht, dass die Anwendung sofort beendet wird.
  
> [!NOTE]
> Wenn die <xref:System.Diagnostics.Process.Kill%2A> Methode asynchron ausgeführt wird. Rufen Sie nach dem Aufrufen der `Kill` Methode die <xref:System.Diagnostics.Process.WaitForExit%2A>-Methode auf, um zu warten, bis der Prozess beendet wird, oder überprüfen Sie die <xref:System.Diagnostics.Process.HasExited%2A>-Eigenschaft, um zu ermitteln, ob der Prozess beendet wurde.

> [!NOTE]
> Die <xref:System.Diagnostics.Process.WaitForExit%2A>-Methode und die <xref:System.Diagnostics.Process.HasExited%2A>-Eigenschaft reflektieren nicht den Status von Nachfolger Prozessen.
> Wenn `Kill(entireProcessTree: true)` verwendet wird, geben <xref:System.Diagnostics.Process.WaitForExit%2A> und <xref:System.Diagnostics.Process.HasExited%2A> an, dass das Beenden abgeschlossen ist, nachdem der angegebene Prozess beendet wurde, auch wenn alle Nachfolger noch nicht beendet wurden.
  
Die von dem Prozess bearbeiteten Daten oder Ressourcen, die dem Prozess zugeordnet sind, können verloren gehen, wenn Sie `Kill`abrufen. 
`Kill` verursacht eine ungewöhnliche Prozess Beendigung und sollte nur bei Bedarf verwendet werden.
<xref:System.Diagnostics.Process.CloseMainWindow%2A> ermöglicht eine ordnungsgemäße Beendigung des Prozesses und schließt alle Fenster, sodass Anwendungen mit einer Schnittstelle bevorzugt werden. Wenn <xref:System.Diagnostics.Process.CloseMainWindow%2A> fehlschlägt, können Sie `Kill` verwenden, um den Prozess zu beenden.
`Kill` ist die einzige Möglichkeit, Prozesse zu beenden, die keine grafischen Schnittstellen aufweisen.
  
Rufen Sie `Kill` und <xref:System.Diagnostics.Process.CloseMainWindow%2A> nur für Prozesse, die auf dem lokalen Computer ausgeführt werden.
Es ist nicht möglich, Prozesse auf Remote Computern zu beenden. Sie können nur Informationen für Prozesse anzeigen, die auf Remote Computern ausgeführt werden.
  
> [!NOTE]
> Wenn der `Kill`-Methode aufgerufen wird, während der Prozess gerade beendet wird, wird für den Zugriff verweigert ein <xref:System.ComponentModel.Win32Exception> ausgelöst.
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hält den zugeordneten Prozess sofort an.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Der zugeordnete Prozess konnte nicht beendet werden.  
  
 - oder -  
  
 Der Prozess wird beendet.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, <see cref="M:System.Diagnostics.Process.Kill" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Die Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde bereits beendet.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill (bool entireProcessTree);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill(bool entireProcessTree) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (entireProcessTree As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill(bool entireProcessTree);" />
      <MemberSignature Language="F#" Value="member this.Kill : bool -&gt; unit" Usage="process.Kill entireProcessTree" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entireProcessTree" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="entireProcessTree"><see langword="true" />, um den zugeordneten Prozess und seine Nachfolger zu beenden; <see langword="false" />, um nur den zugeordneten Prozess zu beenden.</param>
        <summary>Beendet sofort den zugeordneten Prozess und optional seine untergeordneten Prozesse/Nachfolgerprozesse.</summary>
        <remarks>Wenn <paramref name="entireProcessTree" /> auf <see langword="true" />festgelegt ist, werden Prozesse, bei denen dem Aufruf keine Berechtigungen zum Anzeigen von Details fehlen, vom Nachfolger Beendigungs Prozess automatisch übersprungen, da der Beendigungs Prozess nicht ermitteln kann, ob es sich bei diesen Prozessen um Nachfolger handelt.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Der zugeordnete Prozess konnte nicht beendet werden.  
  
 - oder -  
  
 Der Prozess wird beendet.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, <see cref="M:System.Diagnostics.Process.Kill" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Die Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde bereits beendet.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.

- oder -

Der aufrufende Prozess ist ein Element der Nachfolgerstruktur des zugeordneten Prozesses.</exception>
        <exception cref="T:System.AggregateException">Nicht alle Prozesse in der Nachfolgerstruktur des zugeordneten Prozesses konnten beendet werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet den Zustand einer <see cref="T:System.Diagnostics.Process" />-Komponente, in dem sie mit Betriebssystemprozessen interagieren kann, die in einem speziellen Modus ausgeführt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Betriebssystem Prozesse werden in einem speziellen Modus ausgeführt. Es ist nicht möglich, die Eigenschaften von zu lesen oder an diese Prozesse anzufügen, es sei denn, Sie haben <xref:System.Diagnostics.Process.EnterDebugMode%2A> für die Komponente aufgerufen. Aufrufen von <xref:System.Diagnostics.Process.LeaveDebugMode%2A>, wenn Sie keinen Zugriff mehr auf diese Prozesse benötigen, die im speziellen Modus ausgeführt werden.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Computers ab, auf dem der zugeordnete Prozess ausgeführt wird.</summary>
        <value>Der Name des Computers, auf dem der zugeordnete Prozess ausgeführt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können statistische Daten und Prozessinformationen für Prozesse anzeigen, die auf Remote Computern ausgeführt werden, aber Sie können keine <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>oder <xref:System.Diagnostics.Process.Kill%2A> auf Remote Computern abrufen.  
  
> [!NOTE]
>  Wenn der zugeordnete Prozess auf dem lokalen Computer ausgeführt wird, gibt diese Eigenschaft einen Zeitraum (".") für den Computernamen zurück. Verwenden Sie die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType>-Eigenschaft, um den richtigen Computernamen zu erhalten.  
  
   
  
## Examples  
 Wenn Sie das folgende Beispiel verwenden möchten, müssen Sie zunächst mindestens eine Instanz von Notepad auf einem Remote Computer starten. Im Beispiel wird der Name des Remote Computers angefordert, auf dem der Editor ausgeführt wird, und anschließend werden die entsprechenden Eigenschaften <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>und <xref:System.Diagnostics.Process.MachineName%2A> für jede Instanz angezeigt.  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Hauptmodul für den zugeordneten Prozess ab.</summary>
        <value>Das zum Starten des Prozesses verwendete <see cref="T:System.Diagnostics.ProcessModule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Prozess Modul stellt eine DLL-oder exe-Datei dar, die in einen bestimmten Prozess geladen wird. Mit der <xref:System.Diagnostics.Process.MainModule%2A>-Eigenschaft können Sie Informationen zu der ausführbaren Datei anzeigen, die zum Starten des Prozesses verwendet wurde, einschließlich Modulname, Dateiname und Modul Speicher Details.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MainModule" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ein 32-Bit-Prozess versucht, auf die Module eines 64-Bit-Prozesses zuzugreifen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.  
  
- oder - 
Der Prozess wurde beendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Fensterhandle des Hauptfensters des zugeordneten Prozesses ab.</summary>
        <value>Das vom System generierte Fensterhandle des Hauptfensters des zugeordneten Prozesses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Hauptfenster ist das Fenster, das von dem Prozess geöffnet wird, der derzeit den Fokus hat (das <xref:System.Windows.Forms.Form.TopLevel%2A> Formular). Sie müssen die <xref:System.Diagnostics.Process.Refresh%2A>-Methode verwenden, um das <xref:System.Diagnostics.Process> Objekt zu aktualisieren, um das aktuelle Hauptfenster Handle zu erhalten, wenn es geändert wurde. Da das Fenster Handle zwischengespeichert wird, verwenden Sie im allgemeinen <xref:System.Diagnostics.Process.Refresh%2A>, um sicherzustellen, dass Sie das aktuelle handle abrufen.  
  
 Sie erhalten die <xref:System.Diagnostics.Process.MainWindowHandle%2A> Eigenschaft nur für Prozesse, die auf dem lokalen Computer ausgeführt werden. Die <xref:System.Diagnostics.Process.MainWindowHandle%2A>-Eigenschaft ist ein Wert, der das Fenster eindeutig identifiziert, das dem Prozess zugeordnet ist.  
  
 Einem Prozess ist nur dann ein Hauptfenster zugeordnet, wenn der Prozess über eine grafische Benutzeroberfläche verfügt. Wenn der zugeordnete Prozess nicht über ein Hauptfenster verfügt, ist der <xref:System.Diagnostics.Process.MainWindowHandle%2A> Wert 0 (null). Der Wert ist auch 0 (null) für Prozesse, die ausgeblendet wurden, d. h. Prozesse, die auf der Taskleiste nicht sichtbar sind. Dies kann bei Prozessen der Fall sein, die im Benachrichtigungsbereich ganz rechts auf der Taskleiste als Symbole angezeigt werden.  
  
 Wenn Sie gerade einen Prozess gestartet haben und dessen Hauptfenster Handle verwenden möchten, sollten Sie die <xref:System.Diagnostics.Process.WaitForInputIdle%2A>-Methode verwenden, um den Abschluss des Prozesses zu ermöglichen und sicherzustellen, dass das Hauptfenster Handle erstellt wurde. Andernfalls wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.MainWindowHandle" /> ist nicht definiert, da der Prozess beendet wurde.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MainWindowHandle" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Beschriftung des Hauptfensters des Prozesses ab.</summary>
        <value>Der Titel des Hauptfensters des Prozesses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einem Prozess ist nur dann ein Hauptfenster zugeordnet, wenn der Prozess über eine grafische Benutzeroberfläche verfügt. Wenn der zugeordnete Prozess nicht über ein Hauptfenster verfügt (sodass <xref:System.Diagnostics.Process.MainWindowHandle%2A> NULL ist), ist <xref:System.Diagnostics.Process.MainWindowTitle%2A> eine leere Zeichenfolge (""). Wenn Sie gerade einen Prozess gestartet haben und dessen Hauptfenster Titel verwenden möchten, sollten Sie die <xref:System.Diagnostics.Process.WaitForInputIdle%2A>-Methode verwenden, um den Abschluss des Prozesses zu ermöglichen, um sicherzustellen, dass das Hauptfenster Handle erstellt wurde. Andernfalls löst das System eine Ausnahme aus.  
  
> [!NOTE]
>  Das Hauptfenster ist das Fenster, das derzeit den Fokus besitzt. Beachten Sie, dass dies möglicherweise nicht das primäre Fenster für den Prozess ist. Sie müssen die <xref:System.Diagnostics.Process.Refresh%2A>-Methode verwenden, um das <xref:System.Diagnostics.Process> Objekt zu aktualisieren, um das aktuelle Hauptfenster Handle zu erhalten, wenn es geändert wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet und die Beschriftung des Hauptfensters des Prozesses abgerufen.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Diagnostics.Process.MainWindowTitle" />-Eigenschaft ist nicht definiert, da der Prozess beendet wurde.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MainWindowTitle" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft, in Bytes, die maximal zulässige Workingsetgröße für den zugeordneten Prozess ab oder legt diese fest.</summary>
        <value>Die im Speicher maximal zulässige Workingsetgröße für den Prozess in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Workingset eines Prozesses ist der Satz von Speicherseiten, die derzeit für den Prozess im physischen RAM-Arbeitsspeicher sichtbar sind. Diese Seiten sind residente und können für eine Anwendung verwendet werden, ohne dass ein Seiten Fehler ausgelöst wird.  
  
 Das Workingset enthält sowohl freigegebene als auch private Daten. Die freigegebenen Daten enthalten die Seiten, die alle von der Anwendung ausgeführten Anweisungen enthalten, einschließlich der Seiten in den DLL-Dateien und der System. dll-Dateien. Wenn die Workingsetgröße zunimmt, steigt der Arbeitsspeicher Bedarf.  
  
 Ein Prozess verfügt über minimale und maximale workingsetgrößen. Jedes Mal, wenn eine Prozess Ressource erstellt wird, reserviert das System eine Menge an Arbeitsspeicher, die der minimalen Workingsetgröße für den Prozess entspricht. Der virtuelle Speicher-Manager versucht, zumindest den minimalen Arbeitsspeicher zu behalten, wenn der Prozess aktiv ist, aber er behält nie die maximale Größe bei.  
  
 Das System legt die standardmäßigen workingsetgrößen fest. Sie können diese Größen mit den <xref:System.Diagnostics.Process.MaxWorkingSet%2A>-und <xref:System.Diagnostics.Process.MinWorkingSet%2A> Membern ändern. Wenn diese Werte festgelegt werden, ist jedoch nicht sichergestellt, dass der Arbeitsspeicher reserviert oder Residenten ist.  
  
> [!NOTE]
>  Wenn Sie die Workingsetgröße eines Prozesses erhöhen, nehmen Sie den physischen Speicher vom Rest des Systems Weg. Stellen Sie sicher, dass keine minimale oder maximale Workingsetgröße angefordert wird, die zu groß ist, da dadurch die Systemleistung beeinträchtigt werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die maximale Workingsetgröße ist ungültig. Sie muss größer gleich der Workingsetmindestgröße sein.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Workingsetinformationen können nicht aus der zugeordneten Prozessressource abgerufen werden  
  
 - oder -  
  
 Die Prozess-ID oder das Prozesshandle ist 0 (null), weil der Prozess nicht gestartet wurde.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MaxWorkingSet" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.  
  
- oder - 
Der Prozess wurde beendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft, in Bytes, die Workingsetmindestgröße für den zugeordneten Prozess ab oder legt diese fest.</summary>
        <value>Die im Speicher mindestens erforderliche Workingsetgröße für den Prozess in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Workingset eines Prozesses ist der Satz von Speicherseiten, die derzeit für den Prozess im physischen RAM-Arbeitsspeicher sichtbar sind. Diese Seiten sind residente und können für eine Anwendung verwendet werden, ohne dass ein Seiten Fehler ausgelöst wird.  
  
 Das Workingset enthält sowohl freigegebene als auch private Daten. Die freigegebenen Daten enthalten die Seiten, die alle von der Anwendung ausgeführten Anweisungen enthalten, einschließlich der Seiten in den DLL-Dateien und der System. dll-Dateien. Wenn die Workingsetgröße zunimmt, steigt der Arbeitsspeicher Bedarf.  
  
 Ein Prozess verfügt über minimale und maximale workingsetgrößen. Jedes Mal, wenn eine Prozess Ressource erstellt wird, reserviert das System eine Menge an Arbeitsspeicher, die der minimalen Workingsetgröße für den Prozess entspricht. Der virtuelle Speicher-Manager versucht, zumindest den minimalen Arbeitsspeicher zu behalten, wenn der Prozess aktiv ist, aber er behält nie die maximale Größe bei.  
  
 Das System legt die standardmäßigen workingsetgrößen fest. Sie können diese Größen mit den <xref:System.Diagnostics.Process.MaxWorkingSet%2A>-und <xref:System.Diagnostics.Process.MinWorkingSet%2A> Membern ändern. Wenn diese Werte festgelegt werden, ist jedoch nicht sichergestellt, dass der Arbeitsspeicher reserviert oder Residenten ist.  
  
> [!NOTE]
>  Wenn Sie die Workingsetgröße eines Prozesses erhöhen, nehmen Sie den physischen Speicher vom Rest des Systems Weg. Stellen Sie sicher, dass keine minimale oder maximale Workingsetgröße angefordert wird, die zu groß ist, da dadurch die Systemleistung beeinträchtigt werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Workingsetmindestgröße ist ungültig. Sie muss kleiner gleich der maximalen Workingsetgröße sein.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Workingsetinformationen können nicht aus der zugeordneten Prozessressource abgerufen werden  
  
 - oder -  
  
 Die Prozess-ID oder das Prozesshandle ist 0 (null), weil der Prozess nicht gestartet wurde.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.MinWorkingSet" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.  
  
- oder - 
Der Prozess wurde beendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Module ab, die vom zugeordneten Prozess geladen wurden.</summary>
        <value>Ein Array vom Typ <see cref="T:System.Diagnostics.ProcessModule" />, das die vom zugeordneten Prozess geladenen Module darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Prozess Modul stellt eine DLL-oder exe-Datei dar, die in einen bestimmten Prozess geladen wird. Mit einer <xref:System.Diagnostics.ProcessModule>-Instanz können Sie Informationen zu einem Modul anzeigen, einschließlich Modulname, Dateiname und Modul Speicher Details.  
  
 Ein Prozess kann mehrere Module in den Arbeitsspeicher laden. Beispielsweise verfügen exe-Dateien, die zusätzliche DLL-Dateien laden, über mehrere Module.  
  
 Nach dem Starten des Prozesses ist diese Auflistung leer, bis das System den Prozess geladen hat. Wenn der Prozess über ein Hauptfenster verfügt, können Sie <xref:System.Diagnostics.Process.WaitForInputIdle%2A> aufrufen, bevor Sie diese Eigenschaft abrufen, um sicherzustellen, dass die Auflistung beim Abrufen der Liste nicht leer ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Modules" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Modules" />-Eigenschaft für den Systemprozess oder den Leerlaufprozess zuzugreifen. Diese Prozesse verfügen über keine Module.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des für den zugeordneten Prozess belegten nicht ausgelagerten Systemspeichers in Bytes ab.</summary>
        <value>Der Arbeitsspeicher in Bytes, den das System für den zugehörigen Prozess belegt hat und der nicht in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des für den zugeordneten Prozess belegten nicht ausgelagerten Systemspeichers in Bytes ab.</summary>
        <value>Der Anteil am Systemspeicher in Bytes, der für den zugeordneten Prozess reserviert ist und der nicht in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des vom Prozess verwendeten nicht auslagerenden System Speichers in Bytes dar. Der System Arbeitsspeicher ist der physische Arbeitsspeicher, der vom Betriebssystem verwendet wird, und ist in auslagerbare und nicht auslagerbare Pools unterteilt. Nicht Auslagerungs Speicher Belegungen verbleiben im Systemspeicher und werden nicht in die Auslagerungs Datei des virtuellen Speichers ausgelagert.  
  
 Diese Eigenschaft kann verwendet werden, um die Speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren zu überwachen. Der-Eigenschafts Wert entspricht dem Leistungs Bespiel ' nicht-Auslagerungs **Bytes** ' für den-Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz der Notepad-Anwendung gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode und die maximale Speicher Statistik an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> die API-Methode, die auslöst wird die <xref:System.Diagnostics.Process.Exited> Ereignis. Das Aufrufen von <xref:System.Diagnostics.Process.OnExited%2A> bewirkt, dass das <xref:System.Diagnostics.Process.Exited>-Ereignis stattfindet, und stellt die einzige Möglichkeit dar, das Ereignis mithilfe der <xref:System.Diagnostics.Process> Komponente zu erhöhen. <xref:System.Diagnostics.Process.OnExited%2A> wird hauptsächlich verwendet, wenn Klassen von der Komponente abgeleitet werden.  
  
 Als Alternative zu <xref:System.Diagnostics.Process.OnExited%2A>können Sie einen eigenen Ereignishandler schreiben. Sie erstellen einen eigenen Ereignishandlerdelegaten und ihre eigene Methode zur Ereignis Behandlung.  
  
> [!NOTE]
>  Wenn Sie die Visual Studio-Umgebung verwenden, werden ein Ereignishandlerdelegat (AddOnExited) und eine Ereignis Behandlungsmethode (Process1_Exited) für Sie erstellt, wenn Sie eine <xref:System.Diagnostics.Process> Komponente auf ein Formular ziehen und auf das Symbol doppelklicken. Der Code, den Sie erstellen, wenn das <xref:System.Diagnostics.Process.Exited> Ereignis auftritt, wird in die Process1_Exited Prozedur eingegeben. Sie müssen das <xref:System.Diagnostics.Process.OnExited%2A>-Element nicht erstellen, da es für Sie implementiert ist.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auswerfen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Diagnostics.Process.OnExited%2A> -Methode in einer abgeleiteten Klasse.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event OutputDataReceived As DataReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt jedes Mal auf, wenn eine Anwendung eine Zeile in ihren umgeleiteten <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream schreibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ereignis <xref:System.Diagnostics.Process.OutputDataReceived> gibt an, dass die zugeordnete <xref:System.Diagnostics.Process> eine Zeile geschrieben hat, die mit einem Zeilen Umleitungs Zeichen endet, in den umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  
  
 Das Ereignis wird bei asynchronen Lesevorgängen auf <xref:System.Diagnostics.Process.StandardOutput%2A>aktiviert. Um asynchrone Lesevorgänge zu starten, müssen Sie den <xref:System.Diagnostics.Process.StandardOutput%2A> Stream eines <xref:System.Diagnostics.Process>umleiten, den Ereignishandler dem <xref:System.Diagnostics.Process.OutputDataReceived>-Ereignis hinzufügen und <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>aufzurufen. Danach signalisiert das Ereignis <xref:System.Diagnostics.Process.OutputDataReceived> jedes Mal, wenn der Prozess eine Zeile in den umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Datenstrom schreibt, bis der Prozess beendet wird oder <xref:System.Diagnostics.Process.CancelOutputRead%2A>aufruft.  
  
> [!NOTE]
>  Die Anwendung, die die asynchrone Ausgabe verarbeitet, sollte die <xref:System.Diagnostics.Process.WaitForExit%2A>-Methode aufzurufen, um sicherzustellen, dass der Ausgabepuffer geleert wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie asynchrone Lesevorgänge für den umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream des `ipconfig`-Befehls durchgeführt werden.  
  
 Im Beispiel wird ein Ereignis Delegat für den `OutputHandler` Ereignishandler erstellt und dem <xref:System.Diagnostics.Process.OutputDataReceived>-Ereignis zugeordnet. Der Ereignishandler empfängt Textzeilen aus dem umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, formatiert den Text und speichert ihn in einer Ausgabe Zeichenfolge, die später im Konsolenfenster des Beispiels angezeigt wird.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des Auslagerungsspeichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Der Arbeitsspeicher in Bytes, den der zugehörige Prozess belegt und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des Auslagerungsspeichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Die Größe des Arbeitsspeichers in Bytes, der für den zugeordneten Prozess in der Auslagerungsdatei des virtuellen Arbeitsspeichers belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des Arbeitsspeichers in der Auslagerungs Datei des virtuellen Speichers dar, die vom Prozess verwendet wird (in Bytes). Das Betriebssystem verwendet die Auslagerungs Datei des virtuellen Speichers in Verbindung mit physischem Speicher, um den virtuellen Adressraum für jeden Prozess zu verwalten. Wenn der auslagerbare Speicher nicht verwendet wird, kann er in die Auslagerungs Datei des virtuellen Speichers auf dem Datenträger übertragen werden. Verwenden Sie die <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>-Eigenschaft, um die Größe des vom Betriebssystem für den Prozess genutzten Speichers zu erhalten.  
  
 Diese Eigenschaft kann verwendet werden, um die Speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren zu überwachen. Der-Eigenschafts Wert entspricht dem Leistungs Leistungs-Leistungs Bewert "Auslagerungs **Datei Bytes** " für den Prozess  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz der Notepad-Anwendung gestartet, und anschließend werden verschiedene Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode und die maximale Speicher Statistik an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des für den zugeordneten Prozess belegten auslagerbaren Systemspeichers in Bytes ab.</summary>
        <value>Der Arbeitsspeicher in Bytes, den das System für den zugehörigen Prozess belegt hat und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Menge des für den zugeordneten Prozess belegten auslagerbaren Systemspeichers in Bytes ab.</summary>
        <value>Der Anteil am Systemspeicher in Bytes, der für den zugeordneten Prozess belegt wird und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert, der von diesem Eigenschafts Wert zurückgegeben wird, stellt die aktuelle Größe des vom Prozess genutzten Speicher abrechenbaren System Speichers in Bytes dar. Der System Arbeitsspeicher ist der physische Arbeitsspeicher, der vom Betriebssystem verwendet wird, und ist in auslagerbare und nicht auslagerbare Pools unterteilt. Wenn der auslagerbare Speicher nicht verwendet wird, kann er in die Auslagerungs Datei des virtuellen Speichers auf dem Datenträger übertragen werden. Verwenden Sie die <xref:System.Diagnostics.Process.PagedMemorySize64%2A>-Eigenschaft, um die Größe des vom Prozess verwendeten Anwendungs Arbeitsspeichers zu erhalten.  
  
 Diese Eigenschaft kann verwendet werden, um die Speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren zu überwachen. Der-Eigenschafts Wert entspricht dem Leistungs Bespiel "Auslagerungs **Pool (Bytes** )" für den-Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz der Notepad-Anwendung gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode und die maximale Speicher Statistik an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vom zugeordneten Prozess verwendeten maximalen Arbeitsspeicher in der Auslagerungsdatei des virtuellen Arbeitsspeichers in Bytes ab.</summary>
        <value>Der maximale Arbeitsspeicher in Bytes, den der zugehörige Prozess belegt und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vom zugeordneten Prozess verwendeten maximalen Arbeitsspeicher in der Auslagerungsdatei des virtuellen Arbeitsspeichers in Bytes ab.</summary>
        <value>Die maximale Größe des Arbeitsspeichers in Bytes, der seit dem Starten für den zugeordneten Prozess in der Auslagerungsdatei des virtuellen Arbeitsspeichers belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von diesem Eigenschafts Wert zurückgegebene Wert stellt die maximale Größe des Arbeitsspeichers in der Auslagerungs Datei des virtuellen Speichers dar, die vom Prozess seit dem Start verwendet wurde (in Bytes). Das Betriebssystem verwendet die Auslagerungs Datei des virtuellen Speichers in Verbindung mit physischem Speicher, um den virtuellen Adressraum für jeden Prozess zu verwalten. Wenn der auslagerbare Speicher nicht verwendet wird, kann er in die Auslagerungs Datei des virtuellen Speichers auf dem Datenträger übertragen werden.  
  
 Diese Eigenschaft kann verwendet werden, um die Speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren zu überwachen. Der-Eigenschafts Wert entspricht dem Leistungs Leistungs Bewert " **Byte-Spitzenwert** " für den-Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz der Notepad-Anwendung gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode und die maximale Speicher Statistik an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe des virtuellen Speichers (in Bytes) ab, der vom zugeordneten Prozess verwendet wird.</summary>
        <value>Die maximale virtuelle Speicher in Bytes, der vom zugehörigen Prozess angefordert wurde.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe des virtuellen Speichers (in Bytes) ab, der vom zugeordneten Prozess verwendet wird.</summary>
        <value>Die maximale Größe des virtuellen Arbeitsspeichers in Bytes, der für den zugeordneten Prozess seit dem Starten belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die maximale Größe des virtuellen Speichers dar, der seit dem Start des Prozesses in Bytes verwendet wurde. Das Betriebssystem ordnet den virtuellen Adressraum für jeden Prozess entweder den Seiten, die in den physischen Speicher geladen werden, oder den in der Auslagerungs Datei des virtuellen Arbeitsspeichers gespeicherten Seiten zu.  
  
 Diese Eigenschaft kann verwendet werden, um die Speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren zu überwachen. Der-Eigenschafts Wert entspricht dem Leistungs Leistungswert für **Virtuelle Bytes** für den-Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz der Notepad-Anwendung gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode und die maximale Speicher Statistik an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe des Workingsets für den zugeordneten Prozess in Bytes ab.</summary>
        <value>Die maximale Größe des physischen Speichers in Bytes, den der zugeordnete Prozess gleichzeitig angefordert hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Workingset eines Prozesses ist der Satz von Speicherseiten, die derzeit für den Prozess im physischen RAM-Arbeitsspeicher sichtbar sind. Diese Seiten sind residente und können für eine Anwendung verwendet werden, ohne dass ein Seiten Fehler ausgelöst wird.  
  
 Das Workingset enthält sowohl freigegebene als auch private Daten. Die freigegebenen Daten enthalten die Seiten, die alle vom Prozess ausgeführten Anweisungen enthalten, einschließlich der Prozessmodule und der Systembibliotheken.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Größe des physischen Speichers (in Bytes) ab, der vom zugeordneten Prozess verwendet wird.</summary>
        <value>Die maximale Größe des physischen Speichers in Bytes, der für den zugeordneten Prozess seit dem Starten belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die maximale Größe des Arbeits Satz Arbeitsspeichers dar, der seit dem Start des Prozesses in Bytes verwendet wurde. Das Workingset eines Prozesses ist der Satz von Speicherseiten, die derzeit für den Prozess im physischen RAM-Arbeitsspeicher sichtbar sind. Diese Seiten sind residente und können für eine Anwendung verwendet werden, ohne dass ein Seiten Fehler ausgelöst wird.  
  
 Das Workingset enthält sowohl freigegebene als auch private Daten. Die freigegebenen Daten enthalten die Seiten, die alle vom Prozess ausgeführten Anweisungen enthalten, einschließlich Anweisungen der Prozessmodule und der Systembibliotheken.  
  
 Diese Eigenschaft kann verwendet werden, um die Speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren zu überwachen. Der-Eigenschafts Wert entspricht dem **Spitzen** Wert des Workingsets für den-Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz der Notepad-Anwendung gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode und die maximale Speicher Statistik an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die zugeordnete Prozesspriorität durch das Betriebssystem vorübergehend erhöht werden soll, wenn das Hauptfenster den Fokus besitzt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Prozesspriorität eines Prozesses dynamisch erhöht werden soll, wenn dieser den Wartezustand verlässt; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Thread in einem Prozess ausgeführt wird, für den die Prioritäts Klasse einen der dynamischen Prioritäts Enumerationswerte hat (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>oder <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), erhöht das System vorübergehend die Priorität des Threads, wenn er aus dem Wartezustand entfernt wird. Durch diese Aktion wird verhindert, dass andere Prozesse die Verarbeitung des aktuellen Threads unterbrechen. Die <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Einstellung wirkt sich auf alle vorhandenen Threads und alle Threads aus, die anschließend vom Prozess erstellt werden. Um das normale Verhalten wiederherzustellen, legen Sie die <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>-Eigenschaft auf `false`fest.  
  
> [!NOTE]
>  Wenn die Priorität zu hoch erhöht wird, können Ressourcen von wichtigen Betriebssystem-und Netzwerkfunktionen ausgeglichen werden, was zu Problemen mit anderen Betriebssystem Tasks führt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Es konnten keine Prozesserhöhungsinformationen von der zugeordneten Prozessressource abgerufen werden.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die Prozess-ID oder das Prozesshandle ist 0 (null). (Der Prozess wurde nicht gestartet.)</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die allgemeine Prioritätskategorie für den zugeordneten Prozess ab oder legt diese fest.</summary>
        <value>Die Prioritätskategorie für den zugeordneten Prozess, aus der die <see cref="P:System.Diagnostics.Process.BasePriority" /> des Prozesses berechnet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Prozess Prioritäts Klasse umfasst eine Reihe von Thread Prioritäts Ebenen. Threads mit unterschiedlichen Prioritäten, die im Prozess ausgeführt werden, werden relativ zur Prioritäts Klasse des Prozesses ausgeführt. Win32 verwendet vier Prioritäts Klassen mit sieben Basis Prioritätsstufen pro Klasse. Diese Prozess Prioritäts Klassen werden in der <xref:System.Diagnostics.ProcessPriorityClass>-Enumeration aufgezeichnet, mit der Sie die Prozesspriorität auf <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>oder <xref:System.Diagnostics.ProcessPriorityClass.RealTime>festlegen können. Basierend auf der verstrichenen Zeit oder anderen Steigerungen kann die Basis Prioritätsstufe vom Betriebssystem geändert werden, wenn ein Prozess für den Zugriff auf den Prozessor vor anderen versetzt werden muss. Außerdem können Sie die <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> festlegen, um die Prioritäts Ebene der Threads, die aus dem Wartezustand entfernt wurden, vorübergehend zu erhöhen. Die Priorität wird zurückgesetzt, wenn der Prozess in den Wartezustand zurückkehrt.  
  
 Mit der <xref:System.Diagnostics.Process.BasePriority%2A>-Eigenschaft können Sie die Anfangs Priorität anzeigen, die einem Prozess zugewiesen ist. Da Sie jedoch schreibgeschützt ist, können Sie die <xref:System.Diagnostics.Process.BasePriority%2A>-Eigenschaft nicht verwenden, um die Priorität eines Prozesses festzulegen. Um die Priorität zu ändern, verwenden Sie die <xref:System.Diagnostics.Process.PriorityClass%2A>-Eigenschaft, mit der die Kategorie Gesamt Priorität für den Prozess abgerufen oder festgelegt wird.  
  
 Die Prioritäts Klasse kann nicht mit dem System Monitor angezeigt werden. In der folgenden Tabelle wird die Beziehung zwischen den Werten <xref:System.Diagnostics.Process.BasePriority%2A> und <xref:System.Diagnostics.Process.PriorityClass%2A> gezeigt.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode des Prozesses an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Es konnten keine Prozessprioritätsinformationen festgelegt oder von der zugeordneten Prozessressource abgerufen werden.  
  
 - oder -  
  
 Die Prozess-ID oder das Prozesshandle ist 0 (null). (Der Prozess wurde nicht gestartet.)</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.PriorityClass" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> ist nicht verfügbar.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Die Prioritätsklasse kann nicht festgelegt werden, weil sie keinen gültigen Wert gemäß der Definition in der <see cref="T:System.Diagnostics.ProcessPriorityClass" />-Enumeration verwendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des privaten Speichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Die Anzahl der vom zugeordneten Prozess reservierten Bytes, die nicht mit anderen Prozessen gemeinsam genutzt werden können.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des privaten Speichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Die Größe des Speichers in Bytes, der für den zugeordneten Prozess belegt wird und nicht mit anderen Prozessen gemeinsam genutzt werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des vom Prozess verwendeten Arbeitsspeichers in Bytes dar, der nicht gemeinsam mit anderen Prozessen verwendet werden kann.  
  
 Diese Eigenschaft kann verwendet werden, um die Speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren zu überwachen. Der-Eigenschafts Wert entspricht dem Leistungswert für **Private Bytes** für den-Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz der Notepad-Anwendung gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode und die maximale Speicher Statistik an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die privilegierte Prozessorzeit für diesen Prozess ab.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die angibt, wie lange der Prozess im Betriebssystemkern Code ausgeführt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode des Prozesses an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Prozesses ab.</summary>
        <value>Der Name, mit dem das System den Prozess für den Benutzer kennzeichnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.ProcessName%2A>-Eigenschaft enthält einen Namen einer ausführbaren Datei, z. b. Outlook, der nicht die Erweiterung. exe oder den Pfad enthält. Es ist hilfreich, alle Prozesse, die derselben ausführbaren Datei zugeordnet sind, zu erhalten und zu bearbeiten.  
  
> [!NOTE]
>  Unter [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] Betriebssystemen wird die <xref:System.Diagnostics.Process.ProcessName%2A>-Eigenschaft möglicherweise auf 15 Zeichen gekürzt, wenn die Prozess Modul Informationen nicht abgerufen werden können.  
  
 Sie können <xref:System.Diagnostics.Process.GetProcessesByName%2A>aufrufen und ihm einen ausführbaren Dateinamen übergeben, um ein Array abzurufen, das jede laufende Instanz auf dem angegebenen Computer enthält. Sie können dieses Array z. b. verwenden, um alle laufenden Instanzen der ausführbaren Datei zu beenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Für den Prozess ist kein Bezeichner vorhanden, oder dem <see cref="T:System.Diagnostics.Process" /> ist kein Prozess zugeordnet.  
  
- oder - 
Der zugeordnete Prozess wurde beendet.</exception>
        <exception cref="T:System.NotSupportedException">Der Prozess ist auf diesem Computer nicht vorhanden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Prozessoren ab, auf denen die Ausführung der Threads in diesem Prozess geplant werden kann, oder legt diese fest.</summary>
        <value>Eine Bitmaske, die angibt, auf welchen Prozessoren die Threads im zugeordneten Prozess ausgeführt werden können. Der Standardwert hängt von der Anzahl der Prozessoren des Computers ab. Der Standardwert ist 2 <sup>n</sup> -1, wobei n die Anzahl der Prozessoren ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Windows 2000 und höher kann ein Thread in einem Prozess von Prozessor zu Prozessor migrieren, wobei jede Migration den Prozessor Cache erneut lädt. Bei hoher System Auslastung kann die Leistung durch Angeben des Prozessors, der einen bestimmten Thread ausführen soll, verbessert werden, indem die Anzahl der erneuten Ladevorgänge des Prozessor Caches verringert wird. Die Zuordnung zwischen einem Prozessor und einem Thread wird als Prozessor Affinität bezeichnet.  
  
 Jeder Prozessor wird als Bit dargestellt. Bit 0 stellt einen Prozessor, Bit 1 ist Prozessor 2 usw. Wenn Sie ein Bit auf den Wert 1 festlegen, wird der entsprechende Prozessor für die Thread Zuweisung ausgewählt. Wenn Sie den <xref:System.Diagnostics.Process.ProcessorAffinity%2A> Wert auf NULL festlegen, legen die Planungs Algorithmen des Betriebssystems die Thread Affinität fest. Wenn der <xref:System.Diagnostics.Process.ProcessorAffinity%2A> Wert auf einen Wert ungleich 0 (null) festgelegt ist, wird der Wert als Bitmaske interpretiert, die die für die Auswahl berechtigten Prozessoren angibt.  
  
 In der folgenden Tabelle wird eine Auswahl <xref:System.Diagnostics.Process.ProcessorAffinity%2A> Werte für ein System mit acht Prozessoren angezeigt.  
  
|Bitmaske|Binärwert|Berechtigte Prozessoren|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 und 2|  
|0x0007|00000000 00000111|1, 2 und 3|  
|0x0009|00000000 00001001|1 und 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 und 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Es konnten keine <see cref="P:System.Diagnostics.Process.ProcessorAffinity" />-Informationen festgelegt oder von der zugeordneten Prozessressource abgerufen werden.  
  
- oder - 
Die Prozess-ID oder das Prozesshandle ist 0 (null). (Der Prozess wurde nicht gestartet.)</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.ProcessorAffinity" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess <see cref="P:System.Diagnostics.Process.Id" /> war nicht verfügbar.  
  
- oder - 
Der Prozess wurde beendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verwirft alle Informationen über den zugeordneten Prozess, die in der Prozesskomponente zwischengespeichert waren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem <xref:System.Diagnostics.Process.Refresh%2A> aufgerufen wurde, bewirkt die erste Anforderung von Informationen zu jeder Eigenschaft, dass die Prozess Komponente einen neuen Wert aus dem zugeordneten Prozess erhält.  
  
 Wenn eine <xref:System.Diagnostics.Process> Komponente einer Prozess Ressource zugeordnet ist, werden die Eigenschaftswerte der <xref:System.Diagnostics.Process> sofort gemäß dem Status des zugeordneten Prozesses aufgefüllt. Wenn sich die Informationen zum zugeordneten Prozess nachfolgend ändern, werden diese Änderungen nicht in den zwischengespeicherten Werten der <xref:System.Diagnostics.Process> Komponente widergespiegelt. Bei der <xref:System.Diagnostics.Process> Komponente handelt es sich um eine Momentaufnahme der Prozess Ressource zu dem Zeitpunkt, zu dem Sie zugeordnet sind. Um die aktuellen Werte für den zugeordneten Prozess anzuzeigen, müssen Sie die <xref:System.Diagnostics.Process.Refresh%2A>-Methode abrufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet. Anschließend wird die physische Speicherauslastung des zugeordneten Prozesses in Intervallen von 2 Sekunden für maximal 10 Sekunden abgerufen. Im Beispiel wird erkannt, ob der Prozess beendet wird, bevor 10 Sekunden abgelaufen sind. Im Beispiel wird der Prozess geschlossen, wenn er nach 10 Sekunden noch ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Benutzeroberfläche des Prozesses reagiert.</summary>
        <value><see langword="true" />, wenn die Benutzeroberfläche des zugeordneten Prozesses auf das System reagiert; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Prozess über eine Benutzeroberfläche verfügt, kontaktiert die <xref:System.Diagnostics.Process.Responding%2A>-Eigenschaft die Benutzeroberfläche, um zu bestimmen, ob der Prozess auf Benutzereingaben antwortet. Wenn die Schnittstelle nicht sofort antwortet, gibt die <xref:System.Diagnostics.Process.Responding%2A>-Eigenschaft `false`zurück. Verwenden Sie diese Eigenschaft, um zu bestimmen, ob die Schnittstelle des zugeordneten Prozesses nicht mehr reagiert.  
  
 Wenn der Prozess keine <xref:System.Diagnostics.Process.MainWindowHandle%2A>hat, gibt diese Eigenschaft `true`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode des Prozesses an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.Responding" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das systemeigene Handle dieses Prozesses ab.</summary>
        <value>Das systemeigene Handle dieses Prozesses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Handle ist nur verfügbar, wenn der Prozess von der aufrufenden Komponente gestartet wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Terminaldienste-Sitzungs-ID für den zugeordneten Prozess ab.</summary>
        <value>Die Terminaldienste-Sitzungs-ID für den zugeordneten Prozess.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.SessionId%2A>-Eigenschaft identifiziert die Sitzung, in der die Anwendung derzeit ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Diesem Prozess ist keine Sitzung zugeordnet.</exception>
        <exception cref="T:System.InvalidOperationException">Dieser Sitzungs-ID ist kein Prozess zugeordnet.  
  
 - oder -  
  
 Der zugeordnete Prozess befindet sich nicht auf diesem Computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Stream ab, mit dem die Fehlerausgabe der Anwendung gelesen wird.</summary>
        <value>Ein <see cref="T:System.IO.StreamReader" /> zum Lesen des Standardfehlerstreams der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein <xref:System.Diagnostics.Process> Text in seinen Standardfehlerstream schreibt, wird dieser Text normalerweise in der Konsole angezeigt. Wenn Sie den <xref:System.Diagnostics.Process.StandardError%2A> Datenstrom umleiten, können Sie die Fehlerausgabe eines Prozesses ändern oder unterdrücken. Beispielsweise können Sie den Text filtern, ihn anders formatieren oder die Ausgabe in die Konsole und eine bestimmte Protokolldatei schreiben.  
  
> [!NOTE]
>  Wenn Sie <xref:System.Diagnostics.Process.StandardError%2A>verwenden möchten, müssen Sie <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> auf `false`festlegen, und Sie müssen <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> auf `true`festlegen. Andernfalls löst das Lesen aus dem <xref:System.Diagnostics.Process.StandardError%2A> Stream eine Ausnahme aus.  
  
 Der umgeleitete <xref:System.Diagnostics.Process.StandardError%2A> Stream kann synchron oder asynchron gelesen werden. Methoden wie <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>und <xref:System.IO.StreamReader.ReadToEnd%2A> führen synchrone Lesevorgänge im Fehlerausgabestream des Prozesses aus. Diese synchronen Lesevorgänge werden erst abgeschlossen, wenn die zugeordnete <xref:System.Diagnostics.Process> in den <xref:System.Diagnostics.Process.StandardError%2A> Stream schreibt oder den Stream schließt.  
  
 Im Gegensatz dazu startet <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> asynchrone Lesevorgänge für den <xref:System.Diagnostics.Process.StandardError%2A> Datenstrom. Diese Methode aktiviert einen festgelegten Ereignishandler für die Datenstrom Ausgabe und kehrt sofort an den Aufrufer zurück, der andere Aufgaben ausführen kann, während die Datenstrom Ausgabe an den Ereignishandler weitergeleitet wird.  
  
 Synchrone Lesevorgänge führen zu einer Abhängigkeit zwischen dem Aufrufer, der aus dem <xref:System.Diagnostics.Process.StandardError%2A> Stream liest, und dem untergeordneten Prozess, der in diesen Stream schreibt Diese Abhängigkeiten können zu Deadlock-Bedingungen führen. Wenn der Aufrufer aus dem umgeleiteten Stream eines untergeordneten Prozesses liest, ist er vom untergeordneten Element abhängig. Der Aufrufer wartet auf den Lesevorgang, bis das untergeordnete Objekt in den Stream schreibt oder den Stream schließt. Wenn der untergeordnete Prozess genügend Daten schreibt, um den umgeleiteten Stream auszufüllen, ist er vom übergeordneten Prozess abhängig. Der untergeordnete Prozess wartet auf den nächsten Schreibvorgang, bis das übergeordnete Element aus dem vollständigen Stream liest oder den Stream schließt. Die Deadlockbedingung ergibt sich, wenn der Aufrufer und der untergeordnete Prozess aufeinander warten, um einen Vorgang abzuschließen. Sie können Deadlocks vermeiden, indem Sie Abhängigkeiten zwischen dem Aufrufer und dem untergeordneten Prozess auswerten.  

In den letzten beiden Beispielen in diesem Abschnitt wird die <xref:System.Diagnostics.Process.Start%2A>-Methode verwendet, um eine ausführbare Datei namens *Write500Lines. exe*zu starten. Das folgende Beispiel enthält den Quellcode.

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

Im folgenden Beispiel wird gezeigt, wie Sie aus einem umgeleiteten Fehler Datenstrom lesen und warten, bis der untergeordnete Prozess beendet wird. Eine Deadlockbedingung wird vermieden, indem `p.StandardError.ReadToEnd` vor `p.WaitForExit`aufgerufen wird. Ein Deadlockzustand kann auftreten, wenn der übergeordnete Prozess `p.WaitForExit` vor `p.StandardError.ReadToEnd` aufruft und der untergeordnete Prozess genug Text schreibt, um den umgeleiteten Stream auszufüllen. Der übergeordnete Prozess wartet unbegrenzt, bis der untergeordnete Prozess beendet wird. Der untergeordnete Prozess wartet unbegrenzt, bis das übergeordnete Element aus dem vollständigen <xref:System.Diagnostics.Process.StandardError%2A> Stream gelesen wird.   

[!code-csharp[Reading from the error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standarderror/stderror-sync.cs)]
[!code-vb[Reading from the error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standarderror/stderror-sync.vb)]  

Es gibt ein ähnliches Problem, wenn Sie den gesamten Text sowohl aus der Standardausgabe als auch aus den Standardfehlerstreams lesen. Im folgenden Beispiel wird ein Lesevorgang für beide Streams durchführt. Die Deadlockbedingung wird vermieden, indem asynchrone Lesevorgänge für den <xref:System.Diagnostics.Process.StandardError%2A> Stream durchgeführt werden. Eine Deadlockbedingung ergibt sich, wenn der übergeordnete Prozess `p.StandardOutput.ReadToEnd` gefolgt von `p.StandardError.ReadToEnd` aufruft und der untergeordnete Prozess genug Text schreibt, um den Fehler Datenstrom auszufüllen. Der übergeordnete Prozess wartet unbegrenzt, bis der untergeordnete Prozess seinen <xref:System.Diagnostics.Process.StandardOutput%2A> Stream schließt. Der untergeordnete Prozess wartet unbegrenzt, bis das übergeordnete Element aus dem vollständigen <xref:System.Diagnostics.Process.StandardError%2A> Stream gelesen wird.  
[!code-csharp[Reading from both streams](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]
[!code-vb[Reading from both streams](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]  

Sie können asynchrone Lesevorgänge verwenden, um diese Abhängigkeiten und ihr Deadlockpotenzial zu vermeiden. Alternativ können Sie die Deadlockbedingung vermeiden, indem Sie zwei Threads erstellen und die Ausgabe der einzelnen Datenströme in einem separaten Thread lesen.  
  
> [!NOTE]
>  Asynchrone und synchrone Lesevorgänge können nicht in einem umgeleiteten Stream gemischt werden. Sobald der umgeleitete Stream einer <xref:System.Diagnostics.Process> entweder im asynchronen oder im synchronen Modus geöffnet ist, müssen sich alle weiteren Lesevorgänge in diesem Stream im gleichen Modus befinden. Befolgen Sie z. b. <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> nicht, wenn Sie <xref:System.IO.StreamReader.ReadLine%2A> im <xref:System.Diagnostics.Process.StandardError%2A> Stream aufrufen oder umgekehrt. Sie können jedoch zwei verschiedene Streams in verschiedenen Modi lesen. Beispielsweise können Sie <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> aufzurufen und dann <xref:System.IO.StreamReader.ReadLine%2A> für den <xref:System.Diagnostics.Process.StandardError%2A> Stream aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der `net use`-Befehl in Verbindung mit einem vom Benutzer bereitgestellten Argument verwendet, um eine Netzwerkressource zuzuordnen. Anschließend wird der Standardfehlerstream des NET-Befehls gelesen und in die Konsole geschrieben.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wurde nicht für die Umleitung definiert. Stellen Sie sicher, dass <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> auf <see langword="true" /> und <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> festgelegt ist.  
  
- oder - 
Der <see cref="P:System.Diagnostics.Process.StandardError" />-Stream wurde für asynchrone Lesevorgänge mit <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> geöffnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Stream ab, in den die Eingaben der Anwendung geschrieben werden.</summary>
        <value>Ein <see cref="T:System.IO.StreamWriter" /> zum Schreiben des Standardeingabestreams der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Diagnostics.Process> kann den Eingabetext aus dem Standardeingabestream lesen, in der Regel die Tastatur. Wenn Sie den <xref:System.Diagnostics.Process.StandardInput%2A> Stream umleiten, können Sie die Eingabe Programm gesteuert angeben. Anstatt Tastatureingaben zu verwenden, können Sie z. b. Text aus dem Inhalt einer angegebenen Datei oder Ausgabe einer anderen Anwendung bereitstellen.  
  
> [!NOTE]
>  Wenn Sie <xref:System.Diagnostics.Process.StandardInput%2A>verwenden möchten, müssen Sie <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> auf `false`festlegen, und Sie müssen <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> auf `true`festlegen. Andernfalls löst das Schreiben in den <xref:System.Diagnostics.Process.StandardInput%2A> Stream eine Ausnahme aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie den <xref:System.Diagnostics.Process.StandardInput%2A> Datenstrom eines Prozesses umleiten. Im Beispiel wird der `sort`-Befehl mit umgeleiteter Eingabe gestartet. Anschließend wird der Benutzer zur Eingabe von Text aufgefordert und mithilfe des umgeleiteten <xref:System.Diagnostics.Process.StandardInput%2A> Streams an den `sort` Prozess weitergeleitet. Die `sort` Ergebnisse werden dem Benutzer in der-Konsole angezeigt.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardInput" />-Stream wurde nicht definiert, da <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> auf <see langword="false" /> festgelegt ist.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Stream ab, der dazu verwendet wird, die Textausgabe der Anwendung zu lesen.</summary>
        <value>Ein <see cref="T:System.IO.StreamReader" /> zum Lesen des Standardausgabestreams der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein <xref:System.Diagnostics.Process> Text in seinen Standardstream schreibt, wird dieser Text normalerweise in der Konsole angezeigt. Wenn Sie den <xref:System.Diagnostics.Process.StandardOutput%2A> Datenstrom umleiten, können Sie die Ausgabe eines Prozesses ändern oder unterdrücken. Beispielsweise können Sie den Text filtern, ihn anders formatieren oder die Ausgabe in die Konsole und eine bestimmte Protokolldatei schreiben.  
  
> [!NOTE]
>  Wenn Sie <xref:System.Diagnostics.Process.StandardOutput%2A>verwenden möchten, müssen Sie <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> auf `false`festlegen, und Sie müssen <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> auf `true`festlegen. Andernfalls löst das Lesen aus dem <xref:System.Diagnostics.Process.StandardOutput%2A> Stream eine Ausnahme aus.  
  
 Der umgeleitete <xref:System.Diagnostics.Process.StandardOutput%2A> Stream kann synchron oder asynchron gelesen werden. Methoden wie <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>und <xref:System.IO.StreamReader.ReadToEnd%2A> führen synchrone Lesevorgänge für den Ausgabestream des Prozesses aus. Diese synchronen Lesevorgänge werden erst abgeschlossen, wenn die zugeordnete <xref:System.Diagnostics.Process> in den <xref:System.Diagnostics.Process.StandardOutput%2A> Stream schreibt oder den Stream schließt.  
  
 Im Gegensatz dazu startet <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> asynchrone Lesevorgänge für den <xref:System.Diagnostics.Process.StandardOutput%2A> Datenstrom. Diese Methode aktiviert einen festgelegten Ereignishandler für die Datenstrom Ausgabe und kehrt sofort an den Aufrufer zurück, der andere Aufgaben ausführen kann, während die Datenstrom Ausgabe an den Ereignishandler weitergeleitet wird.  
  
 Synchrone Lesevorgänge führen zu einer Abhängigkeit zwischen dem Aufrufer, der aus dem <xref:System.Diagnostics.Process.StandardOutput%2A> Stream liest, und dem untergeordneten Prozess, der in diesen Stream schreibt Diese Abhängigkeiten können zu Deadlock-Bedingungen führen. Wenn der Aufrufer aus dem umgeleiteten Stream eines untergeordneten Prozesses liest, ist er vom untergeordneten Element abhängig. Der Aufrufer wartet auf den Lesevorgang, bis das untergeordnete Objekt in den Stream schreibt oder den Stream schließt. Wenn der untergeordnete Prozess genügend Daten schreibt, um den umgeleiteten Stream auszufüllen, ist er vom übergeordneten Prozess abhängig. Der untergeordnete Prozess wartet auf den nächsten Schreibvorgang, bis das übergeordnete Element aus dem vollständigen Stream liest oder den Stream schließt. Die Deadlockbedingung ergibt sich, wenn der Aufrufer und der untergeordnete Prozess aufeinander warten, um einen Vorgang abzuschließen. Sie können Deadlocks vermeiden, indem Sie Abhängigkeiten zwischen dem Aufrufer und dem untergeordneten Prozess auswerten.  

In den letzten beiden Beispielen in diesem Abschnitt wird die <xref:System.Diagnostics.Process.Start%2A>-Methode verwendet, um eine ausführbare Datei namens *Write500Lines. exe*zu starten. Das folgende Beispiel enthält den Quellcode.

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

Im folgenden Beispiel wird gezeigt, wie Sie aus einem umgeleiteten Stream lesen und warten, bis der untergeordnete Prozess beendet wird. Das Beispiel vermeidet eine Deadlockbedingung, indem `p.StandardOutput.ReadToEnd` vor `p.WaitForExit`aufgerufen wird. Ein Deadlockzustand kann auftreten, wenn der übergeordnete Prozess `p.WaitForExit` vor `p.StandardOutput.ReadToEnd` aufruft und der untergeordnete Prozess genug Text schreibt, um den umgeleiteten Stream auszufüllen. Der übergeordnete Prozess wartet unbegrenzt, bis der untergeordnete Prozess beendet wird. Der untergeordnete Prozess wartet unbegrenzt, bis das übergeordnete Element aus dem vollständigen <xref:System.Diagnostics.Process.StandardOutput%2A> Stream gelesen wird.  

[!code-csharp[Reading synchronously from a redirected output stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-sync.cs)]  
[!code-vb[Reading synchronously from a redirected output stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-sync.vb)]  

Es gibt ein ähnliches Problem, wenn Sie den gesamten Text sowohl aus der Standardausgabe als auch aus den Standardfehlerstreams lesen. Im folgenden Beispiel wird ein Lesevorgang für beide Streams durchführt. Die Deadlockbedingung wird vermieden, indem asynchrone Lesevorgänge für den <xref:System.Diagnostics.Process.StandardError%2A> Stream durchgeführt werden. Eine Deadlockbedingung ergibt sich, wenn der übergeordnete Prozess `p.StandardOutput.ReadToEnd` gefolgt von `p.StandardError.ReadToEnd` aufruft und der untergeordnete Prozess genug Text schreibt, um den Fehler Datenstrom auszufüllen. Der übergeordnete Prozess wartet unbegrenzt, bis der untergeordnete Prozess seinen <xref:System.Diagnostics.Process.StandardOutput%2A> Stream schließt. Der untergeordnete Prozess wartet unbegrenzt, bis das übergeordnete Element aus dem vollständigen <xref:System.Diagnostics.Process.StandardError%2A> Stream gelesen wird.   
[!code-csharp[Reading from a redirected output and error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]  
[!code-vb[Reading from a redirected output and error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]    
  
 Sie können asynchrone Lesevorgänge verwenden, um diese Abhängigkeiten und ihr Deadlockpotenzial zu vermeiden. Alternativ können Sie die Deadlockbedingung vermeiden, indem Sie zwei Threads erstellen und die Ausgabe der einzelnen Datenströme in einem separaten Thread lesen.  
  
> [!NOTE]
>  Asynchrone und synchrone Lesevorgänge können nicht in einem umgeleiteten Stream gemischt werden. Sobald der umgeleitete Stream einer <xref:System.Diagnostics.Process> entweder im asynchronen oder im synchronen Modus geöffnet ist, müssen sich alle weiteren Lesevorgänge in diesem Stream im gleichen Modus befinden. Befolgen Sie z. b. <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> nicht, wenn Sie <xref:System.IO.StreamReader.ReadLine%2A> im <xref:System.Diagnostics.Process.StandardOutput%2A> Stream aufrufen oder umgekehrt. Sie können jedoch zwei verschiedene Streams in verschiedenen Modi lesen. Beispielsweise können Sie <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> aufzurufen und dann <xref:System.IO.StreamReader.ReadLine%2A> für den <xref:System.Diagnostics.Process.StandardError%2A> Stream aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Befehl "ipconfig. exe" ausgeführt und die Standardausgabe an das Konsolenfenster des Beispiels umgeleitet.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wurde nicht für die Umleitung definiert. Stellen Sie sicher, dass <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> auf <see langword="true" /> und <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> auf <see langword="false" /> festgelegt ist.  
  
- oder - 
Der <see cref="P:System.Diagnostics.Process.StandardOutput" />-Stream wurde für asynchrone Lesevorgänge mit <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> geöffnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet eine Prozessressource und ordnet sie einer <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet die von der <see cref="P:System.Diagnostics.Process.StartInfo" />-Eigenschaft dieser <see cref="T:System.Diagnostics.Process" />-Komponente angegebene Prozessressource (oder verwendet sie erneut) und ordnet diese der Komponente zu.</summary>
        <returns><see langword="true" />, wenn eine Prozessressource gestartet wird. <see langword="false" />, wenn keine neue Prozessressource gestartet wird, sondern z. B. eine vorhandene Prozessressource wiederverwendet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Prozess Ressource zu starten und Sie der aktuellen <xref:System.Diagnostics.Process> Komponente zuzuordnen. Der Rückgabewert `true` gibt an, dass eine neue Prozess Ressource gestartet wurde. Wenn die Prozess Ressource, die vom <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Element der Eigenschaft <xref:System.Diagnostics.Process.StartInfo%2A> angegeben wird, bereits auf dem Computer ausgeführt wird, wird keine zusätzliche Prozess Ressource gestartet. Stattdessen wird die laufende Prozess Ressource wieder verwendet und `false` zurückgegeben.  
  
 Sie können eine ClickOnce-Anwendung starten, indem Sie den Speicherort angeben (z. b. eine Webadresse), von dem Sie die Anwendung ursprünglich installiert haben. Starten Sie keine ClickOnce-Anwendung, indem Sie den installierten Speicherort auf der Festplatte angeben.  
  
> [!NOTE]
>  Wenn Sie Visual Studio verwenden, handelt es sich bei dieser Überladung der <xref:System.Diagnostics.Process.Start%2A>-Methode um die Methode, die Sie in den Code einfügen, nachdem Sie eine <xref:System.Diagnostics.Process> Komponente auf den Designer gezogen haben. Erweitern Sie im Fenster `Properties` die Kategorie `StartInfo`, und schreiben Sie den entsprechenden Wert in die Eigenschaft `FileName`. Ihre Änderungen werden in der `InitializeComponent` Prozedur des Formulars angezeigt.  
  
 Diese Überladung von <xref:System.Diagnostics.Process.Start%2A> ist keine `static` Methode. Sie müssen Sie aus einer Instanz der <xref:System.Diagnostics.Process>-Klasse abrufen. Vor dem Aufrufen von <xref:System.Diagnostics.Process.Start%2A>müssen Sie zuerst <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschafts Informationen für diese <xref:System.Diagnostics.Process> Instanz angeben, da diese Informationen verwendet werden, um die zu startenden Prozess Ressourcen zu bestimmen.  
  
 Die anderen über Ladungen der <xref:System.Diagnostics.Process.Start%2A>-Methode sind `static` Member. Sie müssen keine Instanz der <xref:System.Diagnostics.Process> Komponente erstellen, bevor Sie diese über Ladungen der-Methode aufzurufen. Stattdessen können Sie <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Klasse selbst und eine neue <xref:System.Diagnostics.Process> Komponente erstellen, wenn der Prozess gestartet wurde. Oder `null` zurückgegeben wird, wenn ein Prozess wieder verwendet wurde. Die Prozess Ressource wird automatisch der neuen <xref:System.Diagnostics.Process> Komponente zugeordnet, die von der <xref:System.Diagnostics.Process.Start%2A>-Methode zurückgegeben wird.  
  
 Die <xref:System.Diagnostics.Process.StartInfo%2A> Elemente können verwendet werden, um die Funktionalität des Dialog Felds "`Run`" im Menü "Windows-`Start`" zu duplizieren. Alle Elemente, die in eine Befehlszeile eingegeben werden können, können gestartet werden, indem die entsprechenden Werte in der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft festgelegt werden. Die einzige <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft, die festgelegt werden muss, ist die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Eigenschaft. Die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Eigenschaft muss keine ausführbare Datei sein. Dabei kann es sich um einen beliebigen Dateityp handeln, für den die Erweiterung einer Anwendung zugeordnet wurde, die auf dem System installiert ist. Die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Eigenschaft kann z. b. die Erweiterung ". txt" aufweisen, wenn Sie Textdateien mit einem Editor (z. b. Notepad) verknüpft haben, oder wenn Sie doc-Dateien mit einem Textverarbeitungs Tool verknüpft haben, z. b. Microsoft Word.  
  
 In der Befehlszeile können Sie Aktionen angeben, die für bestimmte Dateitypen ausgeführt werden sollen. Beispielsweise können Sie Dokumente drucken oder Textdateien bearbeiten. Geben Sie diese Aktionen mit dem <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>-Member der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft an. Für andere Dateitypen können Sie Befehlszeilenargumente angeben, wenn Sie die Datei über das Dialogfeld "`Run`" starten. Sie können z. b. eine URL als Argument übergeben, wenn Sie Ihren Browser als <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>angeben. Diese Argumente können im <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Member der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft angegeben werden.  
  
 Wenn Sie über eine in Ihrem System deklarierte Pfad Variable mit Anführungszeichen verfügen, müssen Sie diesen Pfad vollständig qualifizieren, wenn Sie einen Prozess starten, der an diesem Speicherort gefunden wird. Andernfalls findet das System den Pfad nicht. Wenn `c:\mypath` z. b. nicht in Ihrem Pfad vorhanden ist und Sie ihn mit Anführungszeichen hinzufügen: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess in `c:\mypath` vollständig qualifizieren, wenn Sie ihn starten.  
  
> [!NOTE]
>  ASP.NET Webseiten-und Server Steuerelement Code werden im Kontext des ASP.NET-Workerprozesses auf dem Webserver ausgeführt.  Wenn Sie die <xref:System.Diagnostics.Process.Start%2A>-Methode in einer ASP.NET-Webseite oder einem Server Steuerelement verwenden, wird der neue Prozess auf dem Webserver mit eingeschränkten Berechtigungen ausgeführt. Der Prozess startet nicht in demselben Kontext wie der Client Browser und hat keinen Zugriff auf den Benutzer Desktop.  
  
 Wenn Sie <xref:System.Diagnostics.Process.Start%2A> verwenden, um einen Prozess zu starten, müssen Sie ihn möglicherweise schließen, oder Sie riskieren, dass Sie die Systemressourcen verlieren. Schließen Prozesse, die mithilfe von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft.  
  
 Hier ist ein Hinweis zu Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> in der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft der Prozess Komponente `true` ist, stellen Sie sicher, dass Sie ein Threading Modell für Ihre Anwendung festgelegt haben, indem Sie das-Attribut `[STAThread]` für die `main()`-Methode festlegen. Andernfalls kann sich ein verwalteter Thread in einem `unknown` Zustand befinden oder in den Zustand "`MTA`" versetzt werden, der in Konflikt mit <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true`ist. Für einige Methoden ist es erforderlich, dass der Apartment Zustand nicht `unknown`wird. Wenn der Zustand nicht explizit festgelegt ist und die Anwendung auf eine solche Methode stößt, wird standardmäßig `MTA`, und sobald Sie festgelegt ist, kann der Apartment Zustand nicht geändert werden. `MTA` bewirkt jedoch, dass eine Ausnahme ausgelöst wird, wenn die Betriebssystemshell den Thread verwaltet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz der <xref:System.Diagnostics.Process>-Klasse verwendet, um einen Prozess zu starten.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In <see cref="T:System.Diagnostics.Process" /> der Komponente <see cref="P:System.Diagnostics.Process.StartInfo" /> wurde kein Dateiname angegeben.
Oder das <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Member der <see cref="P:System.Diagnostics.Process.StartInfo" />-Eigenschaft ist <see langword="true" />, während <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> oder <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> <see langword="true" /> ist.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Methode, die von Betriebssystemen ohne Shellunterstützung wie z.B. Nano Server nicht unterstützt wird (nur .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">Die <see cref="T:System.Diagnostics.ProcessStartInfo" />, die die Informationen zum Starten des Prozesses enthält, einschließlich Dateiname und Befehlszeilenargumente.</param>
        <summary>Startet die Prozessressource, die durch den Parameter mit den Startinformationen für den Prozess angegeben wird (z. B. den Dateinamen des zu startenden Prozesses), und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Prozess Ressource zu starten, indem Sie eine <xref:System.Diagnostics.ProcessStartInfo> Instanz angeben. Die-Überladung ordnet die Ressource einem neuen <xref:System.Diagnostics.Process>-Objekt zu.  
  
> [!NOTE]
>  Wenn die Adresse der zu startenden ausführbaren Datei eine URL ist, wird der Prozess nicht gestartet und `null` zurückgegeben.  
  
 Diese Überladung ermöglicht es Ihnen, einen Prozess zu starten, ohne zuerst eine neue <xref:System.Diagnostics.Process> Instanz zu erstellen. Die Verwendung dieser Überladung mit einem <xref:System.Diagnostics.ProcessStartInfo>-Parameter ist eine Alternative zu den expliziten Schritten zum Erstellen einer neuen <xref:System.Diagnostics.Process> Instanz, zum Festlegen der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaften und zum Aufrufen von <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Wenn Sie eine <xref:System.Diagnostics.ProcessStartInfo> Instanz als Parameter verwenden, können Sie <xref:System.Diagnostics.Process.Start%2A> mit der höchsten Kontrolle darüber aufrufen, was an den-Befehl übergeben wird, um den Prozess zu starten. Wenn nur ein Dateiname oder ein Dateiname und Argumente übergeben werden müssen, ist es nicht erforderlich, eine neue <xref:System.Diagnostics.ProcessStartInfo>-Instanz zu erstellen, obwohl dies eine Option ist. Die einzige <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> Eigenschaft, die festgelegt werden muss, ist die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Eigenschaft. Die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Eigenschaft muss keine ausführbare Datei darstellen. Dabei kann es sich um einen beliebigen Dateityp handeln, für den die Erweiterung einer Anwendung zugeordnet wurde, die auf dem System installiert ist. Die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Eigenschaft kann z. b. die Erweiterung ". txt" aufweisen, wenn Sie Textdateien mit einem Editor (z. b. Notepad) verknüpft haben, oder wenn Sie doc-Dateien mit einem Textverarbeitungs Tool verknüpft haben, z. b. Microsoft Word.  
  
 Sie können eine ClickOnce-Anwendung starten, indem Sie den Speicherort angeben (z. b. eine Webadresse), von dem Sie die Anwendung ursprünglich installiert haben. Starten Sie keine ClickOnce-Anwendung, indem Sie den installierten Speicherort auf der Festplatte angeben.  
  
 Wenn die Eigenschaften <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> und <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> der <xref:System.Diagnostics.Process.StartInfo%2A> Instanz festgelegt sind, wird die nicht verwaltete `CreateProcessWithLogonW` Funktion aufgerufen, die den Prozess in einem neuen Fenster startet, auch wenn der Wert der <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType>-Eigenschaft `true` ist oder der Wert der <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType>-Eigenschaft @no__ t_7_ .<xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType> Wenn die <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType>-Eigenschaft `null`ist, muss die <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>-Eigenschaft im UPN-Format ( *User*@*DNS_domain_name*lauten.   
  
 Im Gegensatz zu den anderen über Ladungen ist die Überladung von <xref:System.Diagnostics.Process.Start%2A>, die keine Parameter aufweist, kein `static` Member. Verwenden Sie diese Überladung, wenn Sie bereits eine <xref:System.Diagnostics.Process> Instanz erstellt, Startinformationen (einschließlich des Datei namens) angegeben haben und eine Prozess Ressource starten und der vorhandenen <xref:System.Diagnostics.Process> Instanz zuordnen möchten. Verwenden Sie eine der `static` Überladungen, wenn Sie eine neue <xref:System.Diagnostics.Process> Komponente erstellen möchten, anstatt einen Prozess für eine vorhandene Komponente zu starten. Diese Überladung und die-Überladung, die über keine Parameter verfügt, ermöglichen es Ihnen, die Startinformationen für die Prozess Ressource mithilfe einer <xref:System.Diagnostics.ProcessStartInfo> Instanz anzugeben.  
  
 Wenn Sie über eine in Ihrem System deklarierte Pfad Variable mit Anführungszeichen verfügen, müssen Sie diesen Pfad vollständig qualifizieren, wenn Sie einen Prozess starten, der an diesem Speicherort gefunden wird. Andernfalls findet das System den Pfad nicht. Wenn `c:\mypath` z. b. nicht in Ihrem Pfad vorhanden ist und Sie ihn mit Anführungszeichen hinzufügen: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess in `c:\mypath` vollständig qualifizieren, wenn Sie ihn starten.  
  
> [!NOTE]
>  ASP.NET Webseiten-und Server Steuerelement Code werden im Kontext des ASP.NET-Workerprozesses auf dem Webserver ausgeführt.  Wenn Sie die <xref:System.Diagnostics.Process.Start%2A>-Methode in einer ASP.NET-Webseite oder einem Server Steuerelement verwenden, wird der neue Prozess auf dem Webserver mit eingeschränkten Berechtigungen ausgeführt. Der Prozess startet nicht in demselben Kontext wie der Client Browser und hat keinen Zugriff auf den Benutzer Desktop.  
  
 Wenn Sie <xref:System.Diagnostics.Process.Start%2A> verwenden, um einen Prozess zu starten, müssen Sie ihn möglicherweise schließen, oder Sie riskieren, dass Sie die Systemressourcen verlieren. Schließen Prozesse, die mithilfe von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft.  
  
 Hier ist ein Hinweis zu Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> auf dem `startInfo`-Parameter `true` wird, stellen Sie sicher, dass Sie ein Threading Modell für Ihre Anwendung festgelegt haben, indem Sie das-Attribut `[STAThread]` für die `main()`-Methode festlegen. Andernfalls kann sich ein verwalteter Thread in einem `unknown` Zustand befinden oder in den Zustand "`MTA`" versetzt werden, der in Konflikt mit <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true`ist. Für einige Methoden ist es erforderlich, dass der Apartment Zustand nicht `unknown`wird. Wenn der Zustand nicht explizit festgelegt ist und die Anwendung auf eine solche Methode stößt, wird standardmäßig `MTA`, und sobald Sie festgelegt ist, kann der Apartment Zustand nicht geändert werden. `MTA` bewirkt jedoch, dass eine Ausnahme ausgelöst wird, wenn die Betriebssystemshell den Thread verwaltet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zunächst eine Instanz von Internet Explorer erzeugt und der Inhalt des Ordners "Favoriten" im Browser angezeigt. Anschließend werden einige andere Instanzen von Internet Explorer gestartet und einige bestimmte Seiten oder Websites angezeigt. Schließlich wird Internet Explorer gestartet, wobei das Fenster beim Navigieren zu einer bestimmten Site minimiert wird.  
  
 Weitere Beispiele für die Verwendung dieser Methode finden Sie in den einzelnen Eigenschaften der <xref:System.Diagnostics.ProcessStartInfo>-Klasse.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In der <paramref name="startInfo" />-Eigenschaft des <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Parameters wurde kein Dateiname angegeben.  
  
- oder - 
Die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft des <paramref name="startInfo" />-Parameters ist <see langword="true" />, und die <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />-, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />- oder <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />-Eigenschaft ist ebenfalls <see langword="true" />.  
  
- oder - 
Die <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />-Eigenschaft des <paramref name="startInfo" />-Parameters ist <see langword="true" />, und die <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" />-Eigenschaft ist nicht <see langword="null" /> oder leer, oder die <see cref="P:System.Diagnostics.ProcessStartInfo.Password" />-Eigenschaft ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="startInfo" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.  

- oder - 
Die in der <paramref name="startInfo" />-Eigenschaft des <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />-Parameters angegebene Datei wurde nicht gefunden.
          
- oder - 
Die Summe aus der Länge der Argumente und der Länge des vollständigen Pfads des Prozesses überschreitet 2080. Die dieser Ausnahme zugeordnete Fehlermeldung kann wie folgt lauten: "Der an einen Systemaufruf weitergegebene Datenbereich ist zu klein." oder "Zugriff verweigert".</exception>
        <exception cref="T:System.PlatformNotSupportedException">Methode, die von Betriebssystemen ohne Shellunterstützung wie z.B. Nano Server nicht unterstützt wird (nur .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name eines Dokuments oder einer Anwendungsdatei, das bzw. die im Prozess ausgeführt werden soll.</param>
        <summary>Startet eine Prozessressource, indem der Name eines Dokuments oder einer Anwendungsdatei angegeben wird, und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Prozess Ressource zu starten, indem Sie den Dateinamen angeben. Die-Überladung ordnet die Ressource einem neuen <xref:System.Diagnostics.Process>-Objekt zu.  
  
> [!NOTE]
>  Wenn die Adresse der zu startenden ausführbaren Datei eine URL ist, wird der Prozess nicht gestartet und `null` zurückgegeben.  
  
 Diese Überladung ermöglicht es Ihnen, einen Prozess zu starten, ohne zuerst eine neue <xref:System.Diagnostics.Process> Instanz zu erstellen. Die-Überladung ist eine Alternative zu den expliziten Schritten zum Erstellen einer neuen <xref:System.Diagnostics.Process>-Instanz, zum Festlegen des <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Members der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft und zum Aufrufen von <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Sie können eine ClickOnce-Anwendung starten, indem Sie den `fileName`-Parameter auf den Speicherort (z. b. eine Webadresse) festlegen, von dem aus Sie die Anwendung ursprünglich installiert haben. Starten Sie keine ClickOnce-Anwendung, indem Sie den installierten Speicherort auf der Festplatte angeben.  
  
 Das Starten eines Prozesses, indem der Dateiname angegeben wird, ähnelt dem Eingeben der Informationen im Dialogfeld `Run` des Menüs Windows `Start`. Daher muss der Dateiname keine ausführbare Datei darstellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung mit einer Anwendung, die auf dem System installierten zugeordnet wurde. Der Dateiname kann z. b. die Erweiterung ". txt" aufweisen, wenn Sie Textdateien mit einem Editor (z. b. Editor) verknüpft haben, oder wenn Sie doc-Dateien mit einem Textverarbeitungs Tool verknüpft haben, z. b. Microsoft Word. Ebenso wie das Dialogfeld `Run` den Namen einer ausführbaren Datei mit oder ohne Erweiterung. exe akzeptieren kann, ist die Erweiterung. exe im Parameter `fileName` optional. Beispielsweise können Sie den `fileName`-Parameter entweder auf "Notepad. exe" oder "Notepad" festlegen.  
  
 Diese Überladung lässt keine Befehlszeilenargumente für den Prozess zu. Wenn Sie mindestens ein Befehlszeilenargument für den Prozess angeben müssen, verwenden Sie die <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>-oder <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> Überladungen.  
  
 Im Gegensatz zu den anderen über Ladungen ist die Überladung von <xref:System.Diagnostics.Process.Start%2A>, die keine Parameter aufweist, kein `static` Member. Verwenden Sie diese Überladung, wenn Sie bereits eine <xref:System.Diagnostics.Process> Instanz erstellt, Startinformationen (einschließlich des Datei namens) angegeben haben und eine Prozess Ressource starten und der vorhandenen <xref:System.Diagnostics.Process> Instanz zuordnen möchten. Verwenden Sie eine der `static` Überladungen, wenn Sie eine neue <xref:System.Diagnostics.Process> Komponente erstellen möchten, anstatt einen Prozess für eine vorhandene Komponente zu starten. Mit dieser Überladung und der Überladung ohne Parameter können Sie den Dateinamen der zu startenden Prozess Ressource angeben.  
  
 Wenn Sie über eine in Ihrem System deklarierte Pfad Variable mit Anführungszeichen verfügen, müssen Sie diesen Pfad vollständig qualifizieren, wenn Sie einen Prozess starten, der an diesem Speicherort gefunden wird. Andernfalls findet das System den Pfad nicht. Wenn `c:\mypath` z. b. nicht in Ihrem Pfad vorhanden ist und Sie ihn mit Anführungszeichen hinzufügen: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess in `c:\mypath` vollständig qualifizieren, wenn Sie ihn starten.  
  
> [!NOTE]
>  ASP.NET Webseiten-und Server Steuerelement Code werden im Kontext des ASP.NET-Workerprozesses auf dem Webserver ausgeführt.  Wenn Sie die <xref:System.Diagnostics.Process.Start%2A>-Methode in einer ASP.NET-Webseite oder einem Server Steuerelement verwenden, wird der neue Prozess auf dem Webserver mit eingeschränkten Berechtigungen ausgeführt. Der Prozess startet nicht in demselben Kontext wie der Client Browser und hat keinen Zugriff auf den Benutzer Desktop.  
  
 Wenn Sie <xref:System.Diagnostics.Process.Start%2A> verwenden, um einen Prozess zu starten, müssen Sie ihn möglicherweise schließen, oder Sie riskieren, dass Sie die Systemressourcen verlieren. Schließen Prozesse, die mithilfe von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft.  
  
 Hier ist ein Hinweis zu Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> in der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft der Prozess Komponente `true` ist, stellen Sie sicher, dass Sie ein Threading Modell für Ihre Anwendung festgelegt haben, indem Sie das-Attribut `[STAThread]` für die `main()`-Methode festlegen. Andernfalls kann sich ein verwalteter Thread in einem `unknown` Zustand befinden oder in den Zustand "`MTA`" versetzt werden, der in Konflikt mit <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true`ist. Für einige Methoden ist es erforderlich, dass der Apartment Zustand nicht `unknown`wird. Wenn der Zustand nicht explizit festgelegt ist und die Anwendung auf eine solche Methode stößt, wird standardmäßig `MTA`, und sobald Sie festgelegt ist, kann der Apartment Zustand nicht geändert werden. `MTA` bewirkt jedoch, dass eine Ausnahme ausgelöst wird, wenn die Betriebssystemshell den Thread verwaltet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zunächst eine Instanz von Internet Explorer erzeugt und der Inhalt des Ordners "Favoriten" im Browser angezeigt. Anschließend werden einige andere Instanzen von Internet Explorer gestartet und einige bestimmte Seiten oder Websites angezeigt. Schließlich wird Internet Explorer gestartet, wobei das Fenster beim Navigieren zu einer bestimmten Site minimiert wird.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.

- oder -

Die in <paramref name="fileName" /> angegebene Datei konnte nicht gefunden werden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die PATH-Umgebungsvariable weist eine Zeichenfolge mit Anführungszeichen auf.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Anwendungsdatei, die in dem Prozess ausgeführt werden soll.</param>
        <param name="arguments">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <summary>Startet eine Prozessressource durch Angeben des Namens einer Anwendung und einer Reihe von Befehlszeilenargumenten und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Prozess Ressource zu starten, indem Sie den Dateinamen und die Befehlszeilenargumente angeben. Die-Überladung ordnet die Ressource einem neuen <xref:System.Diagnostics.Process>-Objekt zu.  
  
> [!NOTE]
>  Wenn die Adresse der zu startenden ausführbaren Datei eine URL ist, wird der Prozess nicht gestartet und `null` zurückgegeben.  
  
 Diese Überladung ermöglicht es Ihnen, einen Prozess zu starten, ohne zuerst eine neue <xref:System.Diagnostics.Process> Instanz zu erstellen. Die-Überladung ist eine Alternative zu den expliziten Schritten zum Erstellen einer neuen <xref:System.Diagnostics.Process>-Instanz, zum Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> und <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Member der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft und zum Aufrufen von <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Das Starten eines Prozesses durch Angabe des Datei namens und der Argumente ähnelt der Eingabe des Datei namens und der Befehlszeilenargumente im Dialogfeld "`Run`" im Menü "Windows-`Start`". Daher muss der Dateiname keine ausführbare Datei darstellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung mit einer Anwendung, die auf dem System installierten zugeordnet wurde. Der Dateiname kann z. b. die Erweiterung ". txt" aufweisen, wenn Sie Textdateien mit einem Editor (z. b. Editor) verknüpft haben, oder wenn Sie doc-Dateien mit einem Textverarbeitungs Tool verknüpft haben, z. b. Microsoft Word. Ebenso wie das Dialogfeld `Run` den Namen einer ausführbaren Datei mit oder ohne Erweiterung. exe akzeptieren kann, ist die Erweiterung. exe im Parameter `fileName` optional. Beispielsweise können Sie den `fileName`-Parameter entweder auf "Notepad. exe" oder "Notepad" festlegen. Wenn der `fileName`-Parameter eine ausführbare Datei darstellt, stellt der `arguments`-Parameter möglicherweise eine Datei dar, auf die er reagieren soll, z. b. die Textdatei in `Notepad.exe myfile.txt`. Wenn der `fileName`-Parameter eine Befehlsdatei (. cmd) darstellt, muss der `arguments` Parameter entweder ein Argument vom Typ "`/c`" oder "`/k`" enthalten, um anzugeben, ob das Befehlsfenster nach Abschluss beendet oder beibehalten wird.  
  
 Im Gegensatz zu den anderen über Ladungen ist die Überladung von <xref:System.Diagnostics.Process.Start%2A>, die keine Parameter aufweist, kein `static` Member. Verwenden Sie diese Überladung, wenn Sie bereits eine <xref:System.Diagnostics.Process> Instanz erstellt, Startinformationen (einschließlich des Datei namens) angegeben haben und eine Prozess Ressource starten und der vorhandenen <xref:System.Diagnostics.Process> Instanz zuordnen möchten. Verwenden Sie eine der `static` Überladungen, wenn Sie eine neue <xref:System.Diagnostics.Process> Komponente erstellen möchten, anstatt einen Prozess für eine vorhandene Komponente zu starten. Mit dieser Überladung und der Überladung ohne Parameter können Sie den Dateinamen der zu startenden Prozess Ressource und die zu über gebenden Befehlszeilenargumente angeben.  
  
 Wenn Sie über eine in Ihrem System deklarierte Pfad Variable mit Anführungszeichen verfügen, müssen Sie diesen Pfad vollständig qualifizieren, wenn Sie einen Prozess starten, der an diesem Speicherort gefunden wird. Andernfalls findet das System den Pfad nicht. Wenn `c:\mypath` z. b. nicht in Ihrem Pfad vorhanden ist und Sie ihn mit Anführungszeichen hinzufügen: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess in `c:\mypath` vollständig qualifizieren, wenn Sie ihn starten.  
  
> [!NOTE]
>  ASP.NET Webseiten-und Server Steuerelement Code werden im Kontext des ASP.NET-Workerprozesses auf dem Webserver ausgeführt.  Wenn Sie die <xref:System.Diagnostics.Process.Start%2A>-Methode in einer ASP.NET-Webseite oder einem Server Steuerelement verwenden, wird der neue Prozess auf dem Webserver mit eingeschränkten Berechtigungen ausgeführt. Der Prozess startet nicht in demselben Kontext wie der Client Browser und hat keinen Zugriff auf den Benutzer Desktop.  
  
 Wenn Sie <xref:System.Diagnostics.Process.Start%2A> verwenden, um einen Prozess zu starten, müssen Sie ihn möglicherweise schließen, oder Sie riskieren, dass Sie die Systemressourcen verlieren. Schließen Prozesse, die mithilfe von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft. 
  
 Hier ist ein Hinweis zu Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> in der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft der Prozess Komponente `true` ist, stellen Sie sicher, dass Sie ein Threading Modell für Ihre Anwendung festgelegt haben, indem Sie das-Attribut `[STAThread]` für die `main()`-Methode festlegen. Andernfalls kann sich ein verwalteter Thread in einem `unknown` Zustand befinden oder in den Zustand "`MTA`" versetzt werden, der in Konflikt mit <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> `true`ist. Für einige Methoden ist es erforderlich, dass der Apartment Zustand nicht `unknown`wird. Wenn der Zustand nicht explizit festgelegt ist und die Anwendung auf eine solche Methode stößt, wird standardmäßig `MTA`, und sobald Sie festgelegt ist, kann der Apartment Zustand nicht geändert werden. `MTA` bewirkt jedoch, dass eine Ausnahme ausgelöst wird, wenn die Betriebssystemshell den Thread verwaltet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zunächst eine Instanz von Internet Explorer erzeugt und der Inhalt des Ordners "Favoriten" im Browser angezeigt. Anschließend werden einige andere Instanzen von Internet Explorer gestartet und einige bestimmte Seiten oder Websites angezeigt. Schließlich wird Internet Explorer gestartet, wobei das Fenster beim Navigieren zu einer bestimmten Site minimiert wird.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <paramref name="fileName" />-Parameter oder der <paramref name="arguments" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.  

- oder -

Die in <paramref name="fileName" /> angegebene Datei konnte nicht gefunden werden.
  
- oder - 
Die Summe aus der Länge der Argumente und der Länge des vollständigen Pfads des Prozesses überschreitet 2080. Die dieser Ausnahme zugeordnete Fehlermeldung kann wie folgt lauten: "Der an einen Systemaufruf weitergegebene Datenbereich ist zu klein." oder "Zugriff verweigert".</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die PATH-Umgebungsvariable weist eine Zeichenfolge mit Anführungszeichen auf.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="userName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="domain" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Anwendungsdatei, die in dem Prozess ausgeführt werden soll.</param>
        <param name="userName">Der beim Starten des Prozesses zu verwendende Benutzername.</param>
        <param name="password">Eine <see cref="T:System.Security.SecureString" />, die das beim Starten des Prozesses zu verwendende Kennwort enthält.</param>
        <param name="domain">Die Domäne, die beim Starten des Prozesses verwendet werden soll.</param>
        <summary>Startet eine Prozessressource durch Angeben des Namens einer Anwendung, eines Benutzernamens und einer Domäne und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um einen neuen Prozess und seinen primären Thread zu erstellen, indem Sie den Dateinamen, den Benutzernamen, das Kennwort und die Domäne angeben. Der neue Prozess führt dann die angegebene ausführbare Datei im Sicherheitskontext der angegebenen Anmelde Informationen (Benutzer, Domäne und Kennwort) aus.  
  
> [!NOTE]
>  Wenn sich die ausführbare Datei auf einem Remote Laufwerk befindet, müssen Sie die Netzwerkfreigabe mit einem URI (Uniform Resource Identifier) identifizieren, nicht mit einem verknüpften Laufwerk Buchstaben.  
  
> [!NOTE]
>  Wenn die Adresse der zu startenden ausführbaren Datei eine URL ist, wird der Prozess nicht gestartet und `null` zurückgegeben.  
  
 Diese Überladung ermöglicht es Ihnen, einen Prozess zu starten, ohne zuerst eine neue <xref:System.Diagnostics.Process> Instanz zu erstellen. Die-Überladung ist eine Alternative zu den expliziten Schritten zum Erstellen einer neuen <xref:System.Diagnostics.Process>-Instanz, zum Festlegen der Eigenschaften für <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>und <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft und zum Aufrufen von <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Ebenso wie das Dialogfeld " **Ausführen** " einen Namen einer ausführbaren Datei mit oder ohne die Erweiterung ". exe" akzeptieren kann, ist die Erweiterung ". exe" im `fileName`-Parameter optional. Beispielsweise können Sie den `fileName`-Parameter entweder auf "Notepad. exe" oder "Notepad" festlegen. Wenn der `fileName`-Parameter eine ausführbare Datei darstellt, stellt der `arguments`-Parameter möglicherweise eine Datei dar, auf die er reagieren soll, z. b. die Textdatei in `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Der Dateiname muss eine ausführbare Datei in den <xref:System.Diagnostics.Process.Start%2A> Überladungen darstellen, die `userName`-, `password`-und `domain`-Parameter aufweisen.  
  
 Wenn Sie <xref:System.Diagnostics.Process.Start%2A> verwenden, um einen Prozess zu starten, müssen Sie ihn möglicherweise schließen, oder Sie riskieren, dass Sie die Systemressourcen verlieren. Schließen Prozesse, die mithilfe von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft. 
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieser Überladung zum Starten einer ausführbaren Datei veranschaulicht. Außerdem wird veranschaulicht, wie eine <xref:System.ComponentModel.Win32Exception> ausgelöst wird, wenn versucht wird, eine Anwendung zu starten, die einer nicht ausführbaren Datei zugeordnet ist.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde kein Dateiname angegeben.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.

- oder -

Die in <paramref name="fileName" /> angegebene Datei konnte nicht gefunden werden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Dieser Member, die unter Linux oder macOS nicht unterstützt wird (nur .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="arguments" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="userName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="domain" Type="System.String" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name einer Anwendungsdatei, die in dem Prozess ausgeführt werden soll.</param>
        <param name="arguments">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <param name="userName">Der beim Starten des Prozesses zu verwendende Benutzername.</param>
        <param name="password">Eine <see cref="T:System.Security.SecureString" />, die das beim Starten des Prozesses zu verwendende Kennwort enthält.</param>
        <param name="domain">Die Domäne, die beim Starten des Prozesses verwendet werden soll.</param>
        <summary>Startet eine Prozessressource durch Angeben des Namens einer Anwendung und einer Reihe von Befehlszeilenargumenten, eines Benutzernamens, eines Kennworts und einer Domäne und ordnet die Ressource einer neuen <see cref="T:System.Diagnostics.Process" />-Komponente zu.</summary>
        <returns>Ein neuer <see cref="T:System.Diagnostics.Process" />, der der Prozessressource zugeordnet ist, oder <see langword="null" />, wenn keine Prozessressource gestartet wurde. Beachten Sie, dass ein neuer Prozess, der parallel zu bereits ausgeführten Instanzen des gleichen Prozesses gestartet wird, unabhängig von den anderen Instanzen ist. Außerdem gibt „Start“ möglicherweise einen nicht leeren (nicht NULL) Prozess zurück, dessen Eigenschaft <see cref="P:System.Diagnostics.Process.HasExited" /> bereits auf <see langword="true" /> festgelegt ist. In diesem Fall hat der gestartete Prozess möglicherweise eine vorhandene Instanz seiner selbst aktiviert und sich dann beendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um einen neuen Prozess und seinen primären Thread zu erstellen, indem Sie den Dateinamen, die Befehlszeilenargumente, den Benutzernamen, das Kennwort und die Domäne angeben. Der neue Prozess führt dann die angegebene ausführbare Datei im Sicherheitskontext der angegebenen Anmelde Informationen (Benutzer, Domäne und Kennwort) aus.  
  
> [!NOTE]
>  Wenn sich die ausführbare Datei auf einem Remote Laufwerk befindet, müssen Sie die Netzwerkfreigabe mit einem URI (Uniform Resource Identifier) identifizieren, nicht mit einem verknüpften Laufwerk Buchstaben.  
  
> [!NOTE]
>  Wenn die Adresse der zu startenden ausführbaren Datei eine URL ist, wird der Prozess nicht gestartet und `null` zurückgegeben.  
  
 Diese Überladung ermöglicht es Ihnen, einen Prozess zu starten, ohne zuerst eine neue <xref:System.Diagnostics.Process> Instanz zu erstellen. Die-Überladung ist eine Alternative zu den expliziten Schritten zum Erstellen einer neuen <xref:System.Diagnostics.Process>-Instanz, zum Festlegen der Eigenschaften <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>und <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft und zum Aufrufen von <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Ebenso wie das Dialogfeld " **Ausführen** " einen Namen einer ausführbaren Datei mit oder ohne die Erweiterung ". exe" akzeptieren kann, ist die Erweiterung ". exe" im `fileName`-Parameter optional. Beispielsweise können Sie den `fileName`-Parameter entweder auf "Notepad. exe" oder "Notepad" festlegen. Wenn der `fileName`-Parameter eine ausführbare Datei darstellt, stellt der `arguments`-Parameter möglicherweise eine Datei dar, auf die er reagieren soll, z. b. die Textdatei in `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Der Dateiname muss eine ausführbare Datei in den <xref:System.Diagnostics.Process.Start%2A> Überladungen darstellen, die `userName`-, `password`-und `domain`-Parameter aufweisen.  
  
 Wenn Sie <xref:System.Diagnostics.Process.Start%2A> verwenden, um einen Prozess zu starten, müssen Sie ihn möglicherweise schließen, oder Sie riskieren, dass Sie die Systemressourcen verlieren. Schließen Prozesse, die mithilfe von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde kein Dateiname angegeben.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Öffnen der zugehörigen Datei ist ein Fehler aufgetreten.  

- oder -

Die in <paramref name="fileName" /> angegebene Datei konnte nicht gefunden werden.
  
- oder - 
Die Summe aus der Länge der Argumente und der Länge des vollständigen Pfads zur zugehörigen Datei überschreitet 2080. Die dieser Ausnahme zugeordnete Fehlermeldung kann wie folgt lauten: "Der an einen Systemaufruf weitergegebene Datenbereich ist zu klein." oder "Zugriff verweigert".</exception>
        <exception cref="T:System.ObjectDisposedException">Das Prozessobjekt wurde bereits verworfen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Dieser Member, die unter Linux oder macOS nicht unterstützt wird (nur .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Eigenschaften ab, die an die <see cref="M:System.Diagnostics.Process.Start" />-Methode von <see cref="T:System.Diagnostics.Process" /> übergeben werden sollen, oder legt diese fest.</summary>
        <value>Die <see cref="T:System.Diagnostics.ProcessStartInfo" />, die die Daten darstellt, mit denen der Prozess gestartet werden soll. Diese Argumente beinhalten den Namen der ausführbaren Datei oder des Dokuments, das zum Starten des Prozesses verwendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> die den Satz von Parametern darstellt, der zum Starten eines Prozesses verwendet werden soll. Wenn <xref:System.Diagnostics.Process.Start%2A> aufgerufen wird, wird der <xref:System.Diagnostics.Process.StartInfo%2A> verwendet, um den zu Startvorgang anzugeben. Der einzige erforderliche <xref:System.Diagnostics.Process.StartInfo%2A> Member, der festgelegt werden muss, ist die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Eigenschaft. Das Starten eines Prozesses durch Angeben der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Eigenschaft ähnelt dem Eingeben der Informationen im Dialogfeld " **Ausführen** " im Windows- **Startmenü** . Daher muss die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Eigenschaft keine ausführbare Datei darstellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung mit einer Anwendung, die auf dem System installierten zugeordnet wurde. Beispielsweise kann die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> über die Erweiterung ". txt" verfügen, wenn Sie Textdateien mit einem Editor (z. b. Editor) verknüpft haben, oder wenn Sie eine doc-Datei mit einem Textverarbeitungs Tool (z. b. Microsoft Word) verknüpft haben. Ebenso wie das Dialogfeld " **Ausführen** " einen Namen einer ausführbaren Datei mit oder ohne die Erweiterung ". exe" akzeptieren kann, ist die Erweiterung ". exe" im <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Element optional. Beispielsweise können Sie die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Eigenschaft entweder auf "Notepad. exe" oder "Notepad" festlegen.  
  
 Sie können eine ClickOnce-Anwendung starten, indem Sie die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Eigenschaft auf den Speicherort (z. b. eine Webadresse) festlegen, von dem aus Sie die Anwendung ursprünglich installiert haben. Starten Sie keine ClickOnce-Anwendung, indem Sie den installierten Speicherort auf der Festplatte angeben.  
  
 Wenn der Dateiname eine nicht ausführbare Datei (z. b. eine doc-Datei) umfasst, können Sie ein Verb einschließen, in dem die für die Datei auszuführende Aktion angegeben ist. Beispielsweise können Sie für eine Datei, die mit der Erweiterung. doc endet, die <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> auf "Drucken" festlegen. Der Dateiname, der in der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Eigenschaft angegeben ist, muss keine Erweiterung aufweisen, wenn Sie manuell einen Wert für die <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>-Eigenschaft eingeben. Wenn Sie jedoch die <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>-Eigenschaft verwenden, um zu bestimmen, welche Verben verfügbar sind, müssen Sie die Erweiterung einschließen.  
  
 Sie können die in der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft angegebenen Parameter bis zu dem Zeitpunkt ändern, zu dem Sie die <xref:System.Diagnostics.Process.Start%2A>-Methode für den Prozess aufgerufen haben. Wenn Sie den Vorgang gestartet haben, wirkt sich das Ändern der <xref:System.Diagnostics.Process.StartInfo%2A> Werte nicht auf den zugeordneten Prozess aus oder startet ihn nicht neu. Wenn Sie die <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>-Methode aufrufen, bei der die <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>-und <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> Eigenschaften festgelegt sind, wird die nicht verwaltete `CreateProcessWithLogonW`-Funktion aufgerufen, die den Prozess in einem neuen Fenster startet, auch wenn der Wert der <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>-Eigenschaft `true` ist oder der Wert der <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>-Eigenschaft <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Sie sollten nur auf die <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft für ein <xref:System.Diagnostics.Process> Objekt zugreifen, das von der <xref:System.Diagnostics.Process.Start%2A>-Methode zurückgegeben wird. Sie sollten z. b. nicht auf die <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft für ein <xref:System.Diagnostics.Process> Objekt zugreifen, das von <xref:System.Diagnostics.Process.GetProcesses%2A>zurückgegeben wird. Andernfalls löst die <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft auf .net Core eine <xref:System.InvalidOperationException> aus und gibt auf .NET Framework ein Dummy<xref:System.Diagnostics.ProcessStartInfo> Objekt zurück.
  
 Wenn der Prozess gestartet wird, ist der Dateiname die Datei, die die (schreibgeschützte) <xref:System.Diagnostics.Process.MainModule%2A>-Eigenschaft auffüllt. Wenn Sie die ausführbare Datei abrufen möchten, die dem Prozess zugeordnet ist, nachdem der Prozess gestartet wurde, verwenden Sie die <xref:System.Diagnostics.Process.MainModule%2A>-Eigenschaft. Wenn Sie die ausführbare Datei einer <xref:System.Diagnostics.Process>-Instanz festlegen möchten, für die ein zugeordneter Prozess nicht gestartet wurde, verwenden Sie den <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Member der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft. Da die Elemente der <xref:System.Diagnostics.Process.StartInfo%2A>-Eigenschaft Argumente sind, die an die <xref:System.Diagnostics.Process.Start%2A>-Methode eines Prozesses übermittelt werden, wird durch das Ändern der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>-Eigenschaft nach dem Start des zugeordneten Prozesses die <xref:System.Diagnostics.Process.MainModule%2A>-Eigenschaft nicht zurückgesetzt. Diese Eigenschaften werden nur verwendet, um den zugeordneten Prozess zu initialisieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Diagnostics.Process.StartInfo%2A> mit der auszuführenden Datei, der darauf ausgeführten Aktion und der Anzeige einer Benutzeroberfläche aufgefüllt. Weitere Beispiele finden Sie auf den Referenzseiten für Eigenschaften der <xref:System.Diagnostics.ProcessStartInfo>-Klasse.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert, der die <see cref="P:System.Diagnostics.Process.StartInfo" /> angibt, ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Diagnostics.Process.Start" />-Methode wurde nicht verwendet, um den Prozess zu starten.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeit ab, zu der der zugeordnete Prozess gestartet wurde.</summary>
        <value>Ein Objekt, das angibt, wann der zugeordnete Prozess gestartet wurde. Eine Ausnahme wird ausgelöst, wenn der Prozess nicht ausgeführt wird.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.StartTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wurde beendet.  
  
 - oder -  
  
 Der Prozess wurde nicht gestartet.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Beim Aufruf der Windows-Funktion ist ein Fehler aufgetreten.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das zum Marshallen der Ereignishandleraufrufe verwendet wird, die als Ergebnis eines Prozessbeendigungsereignisses ausgegeben werden, oder legt dieses fest.</summary>
        <value>Das <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, das zum Marshallen von Ereignishandleraufrufen verwendet wird, die als Ergebnis eines <see cref="E:System.Diagnostics.Process.Exited" />-Ereignisses des Prozesses ausgegeben werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> `null`ist, werden Methoden, die das <xref:System.Diagnostics.Process.Exited>-Ereignis behandeln, in einem Thread aus dem Thread Pool des Systems aufgerufen. Weitere Informationen zu System Thread Pools finden Sie unter <xref:System.Threading.ThreadPool>.  
  
 Wenn das <xref:System.Diagnostics.Process.Exited> Ereignis von einer Visual Windows Forms-Komponente behandelt wird, wie z. b. einem <xref:System.Windows.Forms.Button>, funktioniert der Zugriff auf die Komponente über den System Thread Pool möglicherweise nicht, oder es kann zu einer Ausnahme kommen. Vermeiden Sie dies, indem Sie <xref:System.Diagnostics.Process.SynchronizingObject%2A> auf eine Windows Forms Komponente festlegen, die bewirkt, dass die Methoden, die das <xref:System.Diagnostics.Process.Exited> Ereignis verarbeiten, in demselben Thread aufgerufen werden, auf dem die Komponente erstellt wurde.  
  
 Wenn die <xref:System.Diagnostics.Process> innerhalb [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in einem Windows Forms-Designer verwendet wird, wird <xref:System.Diagnostics.Process.SynchronizingObject%2A> automatisch auf das Steuerelement festgelegt, das die <xref:System.Diagnostics.Process>enthält. Wenn Sie z. b. eine <xref:System.Diagnostics.Process> in einem Designer für `Form1` platzieren (der von <xref:System.Windows.Forms.Form>erbt), wird die <xref:System.Diagnostics.Process.SynchronizingObject%2A>-Eigenschaft von <xref:System.Diagnostics.Process> auf die Instanz von `Form1`festgelegt:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 In der Regel wird diese Eigenschaft festgelegt, wenn die Komponente in einem Steuerelement oder Formular abgelegt wird, da diese Komponenten an einen bestimmten Thread gebunden sind.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gruppe von Threads ab, die im zugeordneten Prozess ausgeführt werden.</summary>
        <value>Ein Array vom Typ <see cref="T:System.Diagnostics.ProcessThread" />, das die Threads des Betriebssystems darstellt, die gegenwärtig im zugeordneten Prozess ausgeführt werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread führt Code in einem Prozess aus. Jeder Prozess wird mit einem einzelnen Thread, dem primären Thread, gestartet. Jeder Thread kann zusätzliche Threads generieren. Threads innerhalb eines Prozesses verwenden den Adressraum des Prozesses gemeinsam.  
  
 Verwenden Sie <xref:System.Diagnostics.ProcessThread>, um alle Threads, die dem aktuellen Prozess zugeordnet sind, zu erhalten. Der primäre Thread hat nicht unbedingt den Index NULL im Array.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Für den Prozess ist kein <see cref="P:System.Diagnostics.Process.Id" /> vorhanden, oder der <see cref="T:System.Diagnostics.Process" />-Instanz ist kein Prozess zugeordnet.  
  
- oder - 
Der zugeordnete Prozess wurde beendet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Formatiert den Prozessnamen als Zeichenfolge, ggf. kombiniert mit dem Typ der übergeordneten Komponente.</summary>
        <returns>Der <see cref="P:System.Diagnostics.Process.ProcessName" /> kombiniert mit dem <see cref="M:System.Object.ToString" />-Rückgabewert der Basiskomponente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode des Prozesses an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamte Prozessorzeit für diesen Prozess ab.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, während der der zugeordnete Prozess die CPU verwendet hat. Dieser Wert ist die Summe von <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> und <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode des Prozesses an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.TotalProcessorTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Benutzerprozessorzeit für diesen Prozess ab.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, während der der zugeordnete Prozess Code innerhalb der Anwendung des Prozesses (nicht im Betriebssystemkern) ausgeführt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode des Prozesses an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Sie versuchen, auf die <see cref="P:System.Diagnostics.Process.UserProcessorTime" />-Eigenschaft für einen Prozess zuzugreifen, der auf einem Remotecomputer ausgeführt wird. Diese Eigenschaft ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des virtuellen Speichers für diesen Prozess in Bytes ab.</summary>
        <value>Die virtuelle Speicher in Bytes, der vom zugehörigen Prozess angefordert wurde.</value>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des virtuellen Speichers, der für den zugeordneten Prozess belegt wird, in Bytes ab.</summary>
        <value>Die Größe des virtuellen Speichers in Bytes, der für den zugeordneten Prozess belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des vom Prozess verwendeten virtuellen Speichers in Bytes dar. Das Betriebssystem ordnet den virtuellen Adressraum für jeden Prozess entweder den Seiten, die in den physischen Speicher geladen werden, oder den in der Auslagerungs Datei des virtuellen Arbeitsspeichers gespeicherten Seiten zu.  
  
 Diese Eigenschaft kann verwendet werden, um die Speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren zu überwachen. Der-Eigenschafts Wert entspricht dem Leistungsdaten Wert für **Virtuelle Bytes** für den-Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz der Notepad-Anwendung gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode und die maximale Speicher Statistik an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt die Zeitspanne für das Warten auf die Beendigung des zugeordneten Prozesses fest und blockiert den aktuellen Ausführungsthread, bis die Zeit verstrichen oder der Prozess beendet ist. Verwenden Sie das Ereignis <see cref="E:System.Diagnostics.Process.Exited" />, um ein Blockieren des aktuellen Threads zu verhindern.  
  
Codebeispiele finden Sie auf den Referenzseiten zu den Eigenschaften <see cref="P:System.Diagnostics.Process.StandardError" /> und <see cref="P:System.Diagnostics.Process.ExitCode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Weist die <see cref="T:System.Diagnostics.Process" />-Komponente an, unbestimmte Zeit zu warten, bis der zugeordnete Prozess beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> bewirkt, dass der aktuelle Thread wartet, bis der zugeordnete Prozess beendet wird.  Er sollte aufgerufen werden, nachdem alle anderen Methoden für den Prozess aufgerufen wurden. Verwenden Sie das Ereignis <xref:System.Diagnostics.Process.Exited>, um ein Blockieren des aktuellen Threads zu verhindern.  
  
 Diese Methode weist die <xref:System.Diagnostics.Process> Komponente an, einen unbegrenzten Zeitraum zu warten, bis der Prozess und die Ereignishandler beendet werden. Dies kann dazu führen, dass eine Anwendung nicht mehr reagiert. Wenn Sie z. b. <xref:System.Diagnostics.Process.CloseMainWindow%2A> für einen Prozess mit einer Benutzeroberfläche aufzurufen, wird die Anforderung an das Betriebssystem, den zugeordneten Prozess zu beenden, möglicherweise nicht verarbeitet, wenn der Prozess so geschrieben wird, dass er nie in seine Nachrichten Schleife eintritt.  
  
> [!NOTE]
>  In der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] und früheren Versionen wartete die <xref:System.Diagnostics.Process.WaitForExit> Überladung auf <xref:System.Int32.MaxValue> Millisekunden (ungefähr 24 Tage), nicht unbegrenzt. Außerdem haben frühere Versionen nicht darauf gewartet, dass die Ereignishandler beendet werden, wenn die vollständige <xref:System.Int32.MaxValue> Zeit erreicht wurde.  
  
 Diese Überladung stellt sicher, dass die gesamte Verarbeitung abgeschlossen wurde, einschließlich der Behandlung von asynchronen Ereignissen für die umgeleitete Standardausgabe. Sie sollten diese Überladung nach einem Aufrufen der <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> Überladung verwenden, wenn die Standardausgabe zu asynchronen Ereignis Handlern umgeleitet wurde.  
  
 Wenn ein zugeordneter Prozess beendet wird (d. h. beim Beenden durch das Betriebssystem durch eine normale oder ungewöhnliche Beendigung), speichert das System administrative Informationen zum Prozess und kehrt zu der Komponente zurück, die <xref:System.Diagnostics.Process.WaitForExit>aufgerufen hat. Die <xref:System.Diagnostics.Process> Komponente kann dann auf die Informationen zugreifen, einschließlich der <xref:System.Diagnostics.Process.ExitTime%2A>, indem Sie die <xref:System.Diagnostics.Process.Handle%2A> für den verlassen-Prozess verwendet.  
  
 Da der zugeordnete Prozess beendet wurde, verweist die <xref:System.Diagnostics.Process.Handle%2A>-Eigenschaft der Komponente nicht mehr auf eine vorhandene Prozess Ressource. Stattdessen kann das Handle nur für den Zugriff auf die Informationen des Betriebssystems über die Prozess Ressource verwendet werden. Das System kennt Handles, die nicht von <xref:System.Diagnostics.Process> Komponenten freigegeben wurden, und behält die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.Handle%2A> Informationen im Arbeitsspeicher bei, bis die <xref:System.Diagnostics.Process> Komponente die Ressourcen explizit freigibt. Wenn Sie <xref:System.Diagnostics.Process.Start%2A> für eine <xref:System.Diagnostics.Process> Instanz aufzurufen, müssen Sie <xref:System.Diagnostics.Process.Close%2A>, wenn der zugehörige Prozess beendet wurde und Sie keine administrativen Informationen mehr benötigen. <xref:System.Diagnostics.Process.Close%2A> Gibt den für den beendeten Prozess belegten Arbeitsspeicher frei.  
  
   
  
## Examples  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" auf der <xref:System.Diagnostics.Process.StandardError%2A> Eigenschaften Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Auf die Wait-Einstellung konnte nicht zugegriffen werden.</exception>
        <exception cref="T:System.SystemException">Es wurde kein Prozess <see cref="P:System.Diagnostics.Process.Id" /> festgelegt, und ein <see cref="P:System.Diagnostics.Process.Handle" />, aus dem die <see cref="P:System.Diagnostics.Process.Id" />-Eigenschaft bestimmt werden kann, ist nicht vorhanden.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.  
  
- oder - 
Sie versuchen, <see cref="M:System.Diagnostics.Process.WaitForExit" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Diese Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Die Zeitspanne in Millisekunden, die auf die Beendigung des zugeordneten Prozesses gewartet werden soll. Der Höchstwert ist der größtmögliche Wert einer 32-Bit-Ganzzahl, der für das Betriebssystem unendlich bedeutet.</param>
        <summary>Weist die <see cref="T:System.Diagnostics.Process" />-Komponente an, für die Dauer von angegebenen Millisekunden zu warten, bis der zugeordnete Prozess beendet wird.</summary>
        <returns><see langword="true" />, wenn der zugeordnete Prozess beendet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> bewirkt, dass der aktuelle Thread wartet, bis der zugeordnete Prozess beendet wird. Er sollte aufgerufen werden, nachdem alle anderen Methoden für den Prozess aufgerufen wurden. Verwenden Sie das Ereignis <xref:System.Diagnostics.Process.Exited>, um ein Blockieren des aktuellen Threads zu verhindern.  
  
 Diese Methode weist die <xref:System.Diagnostics.Process> Komponente an, einen begrenzten Zeitraum zu warten, bis der Prozess beendet wird. Wenn der zugeordnete Prozess nicht bis zum Ende des Intervalls beendet wird, weil die Anforderung zum Beenden verweigert wird, wird `false` an die aufrufende Prozedur zurückgegeben. Sie können <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für `milliseconds`angeben, und <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> verhält sich wie die <xref:System.Diagnostics.Process.WaitForExit> Überladung. Wenn Sie 0 (null) an die-Methode übergeben, wird `true` nur zurückgegeben, wenn der Prozess bereits beendet wurde. Andernfalls wird sofort `false`zurückgegeben.  
  
> [!NOTE]
>  Wenn `milliseconds` in der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] und früheren Versionen-1 war, hat die <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> Überladung <xref:System.Int32.MaxValue> Millisekunden (ungefähr 24 Tage) gewartet, nicht unbegrenzt.  
  
 Wenn die Standardausgabe zu asynchronen Ereignis Handlern umgeleitet wurde, ist es möglich, dass die Ausgabe Verarbeitung nicht abgeschlossen ist, wenn diese Methode zurückgegeben wird. Um sicherzustellen, dass die asynchrone Ereignisverarbeitung abgeschlossen ist, müssen Sie die <xref:System.Diagnostics.Process.WaitForExit>-Überladung aufrufen, die nach dem Empfang einer `true` von dieser Überladung keinen Parameter annimmt. Um sicherzustellen, dass das <xref:System.Diagnostics.Process.Exited> Ereignis ordnungsgemäß in Windows Forms Anwendungen behandelt wird, legen Sie die Eigenschaft <xref:System.Diagnostics.Process.SynchronizingObject%2A> fest.  
  
 Wenn ein zugeordneter Prozess beendet wird (wird vom Betriebssystem durch eine normale oder ungewöhnliche Beendigung heruntergefahren), speichert das System administrative Informationen zum Prozess und kehrt zu der Komponente zurück, die <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>aufgerufen hat. Die <xref:System.Diagnostics.Process> Komponente kann dann auf die Informationen zugreifen, einschließlich der <xref:System.Diagnostics.Process.ExitTime%2A>, indem Sie die <xref:System.Diagnostics.Process.Handle%2A> für den verlassen-Prozess verwendet.  
  
 Da der zugeordnete Prozess beendet wurde, verweist die <xref:System.Diagnostics.Process.Handle%2A>-Eigenschaft der Komponente nicht mehr auf eine vorhandene Prozess Ressource. Stattdessen kann das Handle nur für den Zugriff auf die Informationen des Betriebssystems über die Prozess Ressource verwendet werden. Das System kennt Handles, die nicht von <xref:System.Diagnostics.Process> Komponenten freigegeben wurden, und behält die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.Handle%2A> Informationen im Arbeitsspeicher bei, bis die <xref:System.Diagnostics.Process> Komponente die Ressourcen explizit freigibt. Wenn Sie <xref:System.Diagnostics.Process.Start%2A> für eine <xref:System.Diagnostics.Process> Instanz aufzurufen, müssen Sie <xref:System.Diagnostics.Process.Close%2A>, wenn der zugehörige Prozess beendet wurde und Sie keine administrativen Informationen mehr benötigen. <xref:System.Diagnostics.Process.Close%2A> Gibt den für den beendeten Prozess belegten Arbeitsspeicher frei.  
  
   
  
## Examples  
 Weitere Informationen finden Sie im Codebeispiel für die <xref:System.Diagnostics.Process.ExitCode%2A>-Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Auf die Wait-Einstellung konnte nicht zugegriffen werden.</exception>
        <exception cref="T:System.SystemException">Es wurde kein Prozess <see cref="P:System.Diagnostics.Process.Id" /> festgelegt, und ein <see cref="P:System.Diagnostics.Process.Handle" />, aus dem die <see cref="P:System.Diagnostics.Process.Id" />-Eigenschaft bestimmt werden kann, ist nicht vorhanden.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.  
  
- oder - 
Sie versuchen, <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> für einen Prozess aufzurufen, der auf einem Remotecomputer ausgeführt wird. Diese Methode ist nur für Prozesse verfügbar, die auf dem lokalen Computer ausgeführt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="milliseconds" /> ist eine negative Zahl, jedoch nicht -1, was einen unbeschränkten Timeout darstellt.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bewirkt, dass die <see cref="T:System.Diagnostics.Process" />-Komponente wartet, bis der zugeordnete Prozess in den Leerlauf wechselt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bewirkt, dass die <see cref="T:System.Diagnostics.Process" />-Komponente unbegrenzt wartet, bis der zugeordnete Prozess in den Leerlauf wechselt. Diese Überladung ist nur für Prozesse mit einer Benutzeroberfläche und einer Nachrichtenschleife gültig.</summary>
        <returns><see langword="true" />, wenn der zugehörige Prozess in den Leerlauf wechselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Diagnostics.Process.WaitForInputIdle>, um zu erzwingen, dass die Verarbeitung der Anwendung wartet, bis die Nachrichten Schleife wieder in den Leerlauf wechselt. Wenn ein Prozess mit einer Benutzeroberfläche ausgeführt wird, wird die Nachrichten Schleife jedes Mal ausgeführt, wenn vom Betriebssystem eine Windows-Meldung an den Prozess gesendet wird. Der Prozess kehrt dann zur Nachrichten Schleife zurück. Ein Prozess befindet sich im Leerlauf, wenn er auf Nachrichten innerhalb einer Nachrichten Schleife wartet. Dieser Status ist beispielsweise hilfreich, wenn die Anwendung auf den Startvorgang warten muss, bis die Erstellung des Hauptfensters abgeschlossen ist, bevor die Anwendung mit diesem Fenster kommuniziert.  
  
 Wenn ein Prozess keine Nachrichten Schleife hat, löst <xref:System.Diagnostics.Process.WaitForInputIdle> eine <xref:System.InvalidOperationException>aus.  
  
 Die <xref:System.Diagnostics.Process.WaitForInputIdle> Überladung weist die <xref:System.Diagnostics.Process> Komponente an, unbegrenzt zu warten, bis der Prozess in der Nachrichten Schleife in den Leerlauf versetzt wird. Diese Anweisung kann dazu führen, dass eine Anwendung nicht mehr reagiert. Wenn z. b. der Prozess so geschrieben wird, dass die Nachrichten Schleife immer sofort beendet wird, wie im Code Fragment `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess verfügt nicht über eine grafische Benutzeroberfläche.  
  
- oder - 
Es ist ein unbekannter Fehler aufgetreten. Der Prozess konnte nicht in den Leerlauf wechseln.  
  
- oder - 
Der Prozess wurde bereits beendet.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Der Wert 1 für <see cref="F:System.Int32.MaxValue" />, der die Zeitspanne in Millisekunden angibt, die gewartet werden soll, bis sich der zugehörige Prozess im Leerlauf befindet. Der Wert 0 gibt eine sofortige Rückgabe an, der Wert -1 gibt eine unendliche Wartezeit an.</param>
        <summary>Bewirkt, dass die <see cref="T:System.Diagnostics.Process" />-Komponente die Dauer von angegebenen Millisekunden wartet, bis der zugeordnete Prozess in den Leerlauf wechselt. Diese Überladung ist nur für Prozesse mit einer Benutzeroberfläche und einer Nachrichtenschleife gültig.</summary>
        <returns><see langword="true" />, wenn der zugeordnete Prozess in den Leerlauf wechselt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>, um zu erzwingen, dass die Verarbeitung der Anwendung wartet, bis die Nachrichten Schleife wieder in den Leerlauf wechselt. Wenn ein Prozess mit einer Benutzeroberfläche ausgeführt wird, wird die Nachrichten Schleife jedes Mal ausgeführt, wenn vom Betriebssystem eine Windows-Meldung an den Prozess gesendet wird. Der Prozess kehrt dann zur Nachrichten Schleife zurück. Ein Prozess befindet sich im Leerlauf, wenn er auf Nachrichten innerhalb einer Nachrichten Schleife wartet. Dieser Status ist beispielsweise hilfreich, wenn die Anwendung auf den Startvorgang warten muss, bis die Erstellung des Hauptfensters abgeschlossen ist, bevor die Anwendung mit diesem Fenster kommuniziert.  
  
 Wenn ein Prozess keine Nachrichten Schleife hat, löst <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> eine <xref:System.InvalidOperationException>aus.  
  
 Die <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> Überladung weist die <xref:System.Diagnostics.Process> Komponente an, einen begrenzten Zeitraum zu warten, bis der Prozess in der Nachrichten Schleife in den Leerlauf versetzt wird. Wenn der zugeordnete Prozess bis zum Ende des Intervalls nicht in den Leerlauf versetzt wurde, weil die Schleife immer noch Nachrichten verarbeitet, wird `false` an die aufrufende Prozedur zurückgegeben.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Prozess verfügt nicht über eine grafische Benutzeroberfläche.  
  
- oder - 
Es ist ein unbekannter Fehler aufgetreten. Der Prozess konnte nicht in den Leerlauf wechseln.  
  
- oder - 
Der Prozess wurde bereits beendet.  
  
- oder - 
Diesem <see cref="T:System.Diagnostics.Process" />-Objekt ist kein Prozess zugeordnet.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Belegung des physischen Speichers durch den zugeordneten Prozess in Bytes ab.</summary>
        <value>Der Gesamtgröße des vom zugeordneten Prozess verwendeten physischen Speichers in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des Arbeits Satz Arbeitsspeichers dar, der vom Prozess verwendet wird (in Bytes). Das Workingset eines Prozesses ist der Satz von Speicherseiten, die derzeit für den Prozess im physischen RAM-Arbeitsspeicher sichtbar sind. Diese Seiten sind residente und können für eine Anwendung verwendet werden, ohne dass ein Seiten Fehler ausgelöst wird.  
  
 Das Workingset enthält sowohl freigegebene als auch private Daten. Die freigegebenen Daten enthalten die Seiten, die alle vom Prozess ausgeführten Anweisungen enthalten, einschließlich der Prozessmodule und der Systembibliotheken.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses wird angezeigt.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des physischen Speichers in Bytes ab, der für den zugeordneten Prozess belegt wird.</summary>
        <value>Die Größe des physischen Speichers in Bytes, der für den zugeordneten Prozess belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des Arbeits Satz Arbeitsspeichers dar, der vom Prozess verwendet wird (in Bytes). Das Workingset eines Prozesses ist der Satz von Speicherseiten, die derzeit für den Prozess im physischen RAM-Arbeitsspeicher sichtbar sind. Diese Seiten sind residente und können für eine Anwendung verwendet werden, ohne dass ein Seiten Fehler ausgelöst wird.  
  
 Das Workingset enthält sowohl freigegebene als auch private Daten. Die freigegebenen Daten enthalten die Seiten, die alle vom Prozess ausgeführten Anweisungen enthalten, einschließlich Anweisungen in den Prozessmodulen und den Systembibliotheken.  
  
 Diese Eigenschaft kann verwendet werden, um die Speicherauslastung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren zu überwachen. Der-Eigenschafts Wert entspricht dem-Workingset-Leistungs Leistungs **Bearbeiter** für den-Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz der Notepad-Anwendung gestartet. Im Beispiel werden dann die verschiedenen Eigenschaften des zugeordneten Prozesses abgerufen und angezeigt. Das Beispiel erkennt, wenn der Prozess beendet wird, und zeigt den Exitcode und die maximale Speicher Statistik an.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>
