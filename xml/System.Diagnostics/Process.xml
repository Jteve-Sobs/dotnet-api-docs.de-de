<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="58cf5f02c19c3c52ac8d26e1ed52e28a450d7b17" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36676167" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides access to local and remote processes and enables you to start and stop local system processes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Diagnostics.Process> Komponente bietet Zugriff auf einen Prozess, der auf einem Computer ausgeführt wird. Ein Prozess ist das einfachste ausgedrückt, eine ausgeführte app. Ein Thread ist die grundlegende Einheit, zu der das Betriebssystem Prozessorzeit reserviert. Ein Thread ausgeführt werden kann einen beliebigen Teil der Code des Prozesses, einschließlich der Teile, die derzeit von einem anderen Thread ausgeführt wird.  
  
 Die <xref:System.Diagnostics.Process> Komponente ist ein nützliches Werkzeug zum Starten, beenden, steuern und Überwachen von apps. Sie können die <xref:System.Diagnostics.Process> -Komponente, um eine Liste der Prozesse abzurufen, die ausgeführt werden, oder Sie können einen neuen Prozess starten. Ein <xref:System.Diagnostics.Process> Komponente wird verwendet, um Systemprozesse zugreifen. Nach einer <xref:System.Diagnostics.Process> Komponente initialisiert wurde, können sie zum Abrufen von Informationen über den laufenden Prozess verwendet werden. Dazu gehören die Gruppe von Threads, die geladenen Module (DLL- und .exe-Dateien), und Leistungsinformationen z. B. die Größe des Arbeitsspeichers des Prozesses verwendet.  
  
 Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mithilfe des Typs abgeschlossen haben, sollten Sie es entweder direkt oder indirekt freigeben. Aufrufen, um den Typ direkt zu verwerfen, dessen <xref:System.IDisposable.Dispose%2A> Methode in einer `try` / `catch` Block. Um es indirekt freizugeben, verwenden Sie ein Sprachkonstrukt z. B. `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "Verwenden eines Objekts, implementiert IDisposable" in der <xref:System.IDisposable> Thema zur Schnittstelle.  
  
> [!NOTE]
>  32-Bit-Prozesse können nicht die Module eines 64-Bit-Prozesses zugreifen. Wenn Sie versuchen, erhalten Informationen zu einem 64-Bit-Prozess von einem 32-Bit-Prozess, erhalten Sie eine <xref:System.ComponentModel.Win32Exception> Ausnahme. Ein 64-Bit-Prozess kann hingegen, die Module von einer 32-Bit-Prozess zugreifen.  
  
 Die Process-Komponente ruft Informationen über eine Gruppe von Eigenschaften, die alle auf einmal ab. Nach der <xref:System.Diagnostics.Process> Komponente Informationen über ein Mitglied der Gruppe "Jeder" erhalten hat, wird die Werte für die anderen Eigenschaften in dieser Gruppe zwischengespeichert und neue Informationen zu den anderen Mitgliedern der Gruppe "nicht abgerufen werden, erst nach dem Aufruf der <xref:System.Diagnostics.Process.Refresh%2A> Methode. Aus diesem Grund ein Eigenschaftswert ist nicht unbedingt aktueller als der letzte Aufruf von der <xref:System.Diagnostics.Process.Refresh%2A> Methode. Die Einteilung der Gruppen sind abhängig vom Betriebssystem an.  
  
 Wenn Sie eine Path-Variablen, die in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie, dass der Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad, und fügen Sie ihn in Anführungszeichen gesetzt: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess im vollständig qualifizieren `c:\mypath` beim Starten.  
  
 Ein Systemprozess ist auf dem System durch die Prozess-ID eindeutig identifiziert. Wie viele Windows-Ressourcen ist ein Prozess auch von seinem Handle identifiziert, die nicht auf dem Computer eindeutig sein. Ein Handle ist der Oberbegriff für einen Bezeichner einer Ressource. Das Betriebssystem behält das Prozesshandle, die über zugegriffen wird die <xref:System.Diagnostics.Process.Handle%2A> Eigenschaft von der <xref:System.Diagnostics.Process> Komponente, selbst wenn der Prozess beendet wurde. Daher können Sie den Prozess administrativen Informationen abrufen, wie z. B. die <xref:System.Diagnostics.Process.ExitCode%2A> (in der Regel entweder 0 (null) für den Erfolg oder ein Fehlercode ungleich null) und die <xref:System.Diagnostics.Process.ExitTime%2A>. Handles sind Handles gelangen mehr als Speicherverlust bösartig ist eine äußerst wertvolle Ressourcen.  
  
> [!NOTE]
>  Diese Klasse enthält einen Linkaufruf und einer vererbungsanforderung auf Klassenebene, die für alle Member gilt. Ein <xref:System.Security.SecurityException> wird ausgelöst, wenn nicht für den unmittelbaren Aufrufer oder die abgeleitete Klasse volle Vertrauenswürdigkeit verfügt. Weitere Informationen zu sicherheitsforderungen, finden Sie unter [Verknüpfungsaufrufe](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Hinweise  
 In .NET Framework die <xref:System.Diagnostics.Process> Klasse verwendet standardmäßig <xref:System.Console> Codierungen, die in der Regel sind code codepagecodierungen für die Eingabe, Ausgabe und Fehler Streams. Beispielcode hierzu auf Systemen mit der Kultur Englisch (Vereinigte Staaten), wird die Codepage 437 die standardcodierung für die <xref:System.Console> Klasse. Allerdings [!INCLUDE[net_core](~/includes/net-core-md.md)] kann nur eine beschränkte Teilmenge dieser Codierungen verfügbar machen. Wenn dies der Fall ist, verwendet er <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> als die standardcodierung.  
  
 Wenn eine <xref:System.Diagnostics.Process> Objekt auf bestimmte codepagecodierungen abhängig ist, können Sie weiterhin sie verfügbar machen, indem Sie die folgenden *vor* rufen Sie eine <xref:System.Diagnostics.Process> Methoden:  
  
1.  Fügen Sie einen Verweis auf die Assembly System.Text.Encoding.CodePages.dll zu Ihrem Projekt ein.  
  
2.  Abrufen der <xref:System.Text.EncodingProvider> -Objekt aus der <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> Eigenschaft.  
  
3.  Übergeben der <xref:System.Text.EncodingProvider> -Objekt an die <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> Methode zum Erstellen von zusätzlichen Codierungen, die von der Codierung verfügbaren Anbieter unterstützt.  
  
 Die <xref:System.Diagnostics.Process> Klasse automatisch verwendet dann das System standardcodierung anstatt UTF8, vorausgesetzt, dass Sie die codierungsanbieter registriert haben, bevor er einen <xref:System.Diagnostics.Process> Methoden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von der <xref:System.Diagnostics.Process> Klasse, um einen Prozess zu starten.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 Im folgenden Beispiel wird die <xref:System.Diagnostics.Process> selbst und eine statische Klasse <xref:System.Diagnostics.Process.Start%2A> Methode zum Starten eines Prozesses.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 Das folgende Beispiel f# definiert eine `runProc` -Funktion, die einen Prozess startet erfasst alle Ausgabe und Fehler, und zeichnet die Anzahl der Millisekunden, die der Prozess ausgeführt wurde.  Die `runProc` Funktion verfügt über drei Parameter: den Namen der Anwendung zu starten, die Argumente, um die Anwendung und das Startverzeichnis bereit.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Der Code für die `runProc` Funktion wurde von geschrieben [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) und steht unter der [Microsoft Public License](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Diese Klasse kann nicht von teilweise vertrauenswürdigem Code verwendet werden.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Diese Klasse kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Process" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie keinen angeben der <xref:System.Diagnostics.Process.MachineName%2A> -Eigenschaft, die Standardeinstellung ist der lokale Computer (".").  
  
 Sie haben zwei Möglichkeiten zum Zuordnen eines neuen <xref:System.Diagnostics.Process> Komponente mit einem Prozess auf dem Computer. Die erste Möglichkeit besteht, mit dem Konstruktor zum Erstellen der <xref:System.Diagnostics.Process> Komponente, legen Sie die entsprechenden Member der der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, und rufen <xref:System.Diagnostics.Process.Start%2A> Zuordnen der <xref:System.Diagnostics.Process> mit einem neuen Systemprozess. Die zweite Möglichkeit besteht in der Zuordnung der <xref:System.Diagnostics.Process> mit einem laufenden Systemprozess mit <xref:System.Diagnostics.Process.GetProcessById%2A> mindestens eine der <xref:System.Diagnostics.Process.GetProcesses%2A> Rückgabewerte.  
  
 Bei Verwendung einer `static` Überladung von der <xref:System.Diagnostics.Process.Start%2A> Methode zum Starten eines neuen System-Prozesses, die Methode erstellt ein neues <xref:System.Diagnostics.Process> Komponente und ordnet diese den Prozess.  
  
 Wenn die <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> Eigenschaft auf den Standardwert festgelegt ist `true`, Starten von Anwendungen und Dokumente in einer Weise, die ähnlich wie die `Run` Dialogfeld des Windows- `Start` Menü. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> ist `false`, können Sie nur die ausführbaren Dateien starten.  
  
 Jede ausführbare Datei, die Sie, über die Befehlszeile aufrufen können kann auf zwei Arten gestartet werden: durch Festlegen der entsprechenden Member der der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft und der Aufruf der <xref:System.Diagnostics.Process.Start%2A> -Methode ohne Parameter oder durch Übergeben des entsprechenden Parameters an den `static` <xref:System.Diagnostics.Process.Start%2A> Member.  
  
 Können Sie erstellen eine <xref:System.Diagnostics.Process> -Komponente mithilfe des Konstruktors und die statische <xref:System.Diagnostics.Process.Start%2A> Überladungen und keines der <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, oder <xref:System.Diagnostics.Process.GetProcessesByName%2A> Methoden. Wenn Sie dies getan haben, müssen Sie einen Einblick in den zugeordneten Prozess. Dies ist eine dynamische Ansicht, die sich selbst automatisch aktualisiert, wenn die Prozesseigenschaften im Arbeitsspeicher geändert haben. Sie müssen stattdessen Aufrufen <xref:System.Diagnostics.Process.Refresh%2A> für die zu aktualisierende Komponente der <xref:System.Diagnostics.Process> Eigenschaftsinformationen in Ihrer Anwendung.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the base priority of the associated process.</summary>
        <value>Die Basispriorität, die anhand der <see cref="P:System.Diagnostics.Process.PriorityClass" /> des zugeordneten Prozesses berechnet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.BasePriority%2A> des Prozesses ist die Startpriorität für Threads, die innerhalb des zugeordneten Prozesses erstellt. Sie können Informationen über die Basispriorität, die über den Systemmonitor Priorität Basiszähler anzeigen.  
  
 Basierend auf der Zeit, die verstrichene anderen Prozessen, das Betriebssystem die Basispriorität ändern können, wenn ein Prozess vor anderen platziert werden soll.  
  
 Die <xref:System.Diagnostics.Process.BasePriority%2A> -Eigenschaft können Sie die an einen Prozess zugewiesene Startpriorität anzeigen. Jedoch, da er schreibgeschützt ist, können keine der <xref:System.Diagnostics.Process.BasePriority%2A> zum Festlegen der Priorität des Prozesses. Verwenden Sie zum Ändern der Priorität der <xref:System.Diagnostics.Process.PriorityClass%2A> Eigenschaft. Der <xref:System.Diagnostics.Process.BasePriority%2A> angezeigt werden der Systemmonitor dagegen die <xref:System.Diagnostics.Process.PriorityClass%2A> nicht. Sowohl die <xref:System.Diagnostics.Process.BasePriority%2A> und <xref:System.Diagnostics.Process.PriorityClass%2A> können programmgesteuert angezeigt werden. Die folgende Tabelle zeigt die Beziehung zwischen <xref:System.Diagnostics.Process.BasePriority%2A> Werte und <xref:System.Diagnostics.Process.PriorityClass%2A> Werte.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process has exited.  -or-  The process has not started, so there is no process ID.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.StandardError%2A> Stream gelesen werden kann, synchron oder asynchron. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, und <xref:System.IO.StreamReader.ReadToEnd%2A> führen synchrone Lesevorgänge auf den Fehlerausgabestream des Prozesses. Diese synchrone Vorgänge werden abgeschlossen, bis das zugeordnete lesen <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardError%2A> stream oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> startet asynchrone Lesevorgänge auf die <xref:System.Diagnostics.Process.StandardError%2A> Stream. Diese Methode ermöglicht es dem angegebenen Ereignishandler für die Streamausgabe und an den Aufrufer, der andere Aufgaben ausführen kann, während die Streamausgabe an den Ereignishandler geleitet wird sofort zurückgegeben.  
  
 Führen Sie folgende Schritte für asynchrone Lesevorgänge ausführen <xref:System.Diagnostics.Process.StandardError%2A> für eine <xref:System.Diagnostics.Process> :  
  
1.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> auf `false` fest.  
  
2.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> auf `true` fest.  
  
3.  Fügen Sie den Ereignishandler an das <xref:System.Diagnostics.Process.ErrorDataReceived> Ereignis. Der Ereignishandler übereinstimmen muss die <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> Signatur des Delegaten.  
  
4.  Starten Sie den <xref:System.Diagnostics.Process>.  
  
5.  Rufen Sie <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> für die <xref:System.Diagnostics.Process>. Dieser Aufruf startet asynchrone Lesevorgänge auf <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Wenn asynchrone Lesevorgänge Start und der Ereignishandler aufgerufen wird jedes Mal, wenn die zugeordnete <xref:System.Diagnostics.Process> schreibt eine Textzeile zu seiner <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Sie können einen asynchronen Lesevorgang "Abbrechen", durch den Aufruf <xref:System.Diagnostics.Process.CancelErrorRead%2A>. Der Lesevorgang kann vom Aufrufer oder vom Ereignishandler abgebrochen werden. Sie können nach dem Abbruch Aufrufen <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> erneut aus, um asynchrone Lesevorgänge fortsetzen.  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge im umgeleiteten-Stream nicht mischen. Einmal im umgeleiteten Stream eine <xref:System.Diagnostics.Process> geöffnet wird im asynchronen oder synchronen Modus alle weiterlesen Vorgänge für diesen Datenstrom müssen sich im gleichen Modus beziehen. Folgen Sie z. B. nicht <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> mit einem Aufruf von <xref:System.IO.StreamReader.ReadLine%2A> auf die <xref:System.Diagnostics.Process.StandardError%2A> Stream, oder umgekehrt. Allerdings können Sie zwei verschiedene Streams in unterschiedlichen Modi lesen. Sie können z. B. Aufrufen <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> und rufen dann <xref:System.IO.StreamReader.ReadLine%2A> für die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `net view` Befehl aus, um die Liste der verfügbaren Netzwerkressourcen auf einem Remotecomputer befindet. Der Benutzer gibt den Namen des Zielcomputers als Befehlszeilenargument an. Die Benutzer kann auch einen Dateinamen für die Fehlerausgabe angeben. Im Beispiel wird die Ausgabe des net-Befehl, der wartet, bis der Prozess abgeschlossen ist, und führt die Ausgabe an die Konsole schreibt erfasst. Wenn der Benutzer die optionale Fehlerdatei bereitstellt, schreibt das Beispiel Fehler in die Datei an.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is <see langword="false" />.  \- or -  An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been used by a synchronous read operation.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream gelesen werden kann, synchron oder asynchron. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, und <xref:System.IO.StreamReader.ReadToEnd%2A> führen synchrone Lesevorgänge im Ausgabestream des Prozesses. Diese synchrone Vorgänge werden abgeschlossen, bis das zugeordnete lesen <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardOutput%2A> stream oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> startet asynchrone Lesevorgänge auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Diese Methode ermöglicht es einen angegebenen Ereignishandler für die Streamausgabe und an den Aufrufer, der andere Aufgaben ausführen kann, während die Streamausgabe an den Ereignishandler geleitet wird sofort zurückgegeben.  
  
 Führen Sie folgende Schritte für asynchrone Lesevorgänge ausführen <xref:System.Diagnostics.Process.StandardOutput%2A> für eine <xref:System.Diagnostics.Process> :  
  
1.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> auf `false` fest.  
  
2.  Legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> auf `true` fest.  
  
3.  Fügen Sie den Ereignishandler an das <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis. Der Ereignishandler übereinstimmen muss die <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> Signatur des Delegaten.  
  
4.  Starten Sie den <xref:System.Diagnostics.Process>.  
  
5.  Rufen Sie <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> für die <xref:System.Diagnostics.Process>. Dieser Aufruf startet asynchrone Lesevorgänge auf <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Wenn asynchrone Lesevorgänge Start und der Ereignishandler aufgerufen wird jedes Mal, wenn die zugeordnete <xref:System.Diagnostics.Process> schreibt eine Textzeile zu seiner <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  
  
 Sie können einen asynchronen Lesevorgang "Abbrechen", durch den Aufruf <xref:System.Diagnostics.Process.CancelOutputRead%2A>. Der Lesevorgang kann vom Aufrufer oder vom Ereignishandler abgebrochen werden. Sie können nach dem Abbruch Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> erneut aus, um asynchrone Lesevorgänge fortsetzen.  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge im umgeleiteten-Stream nicht mischen. Einmal im umgeleiteten Stream eine <xref:System.Diagnostics.Process> geöffnet wird im asynchronen oder synchronen Modus alle weiterlesen Vorgänge für diesen Datenstrom müssen sich im gleichen Modus beziehen. Folgen Sie z. B. nicht <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> mit einem Aufruf von <xref:System.IO.StreamReader.ReadLine%2A> auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, oder umgekehrt. Allerdings können Sie zwei verschiedene Streams in unterschiedlichen Modi lesen. Sie können z. B. Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> und rufen dann <xref:System.IO.StreamReader.ReadLine%2A> für die <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie asynchrone Lesevorgänge im umgeleiteten auszuführenden <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, der die `sort` Befehl. Die `sort` Befehl ist eine Konsolenanwendung, liest und Texteingabe sortiert.  
  
 Das Beispiel erstellt einen Delegaten für die `SortOutputHandler` Ereignishandler und ordnet sie der <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis. Der Ereignishandler empfängt Textzeilen vom umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, den Text formatiert und schreibt den Text auf dem Bildschirm.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> property is <see langword="false" />.  \- or -  An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been used by a synchronous read operation.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of an application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Startet einen asynchronen Lesevorgang auf der <xref:System.Diagnostics.Process.StandardError%2A> Stream. <xref:System.Diagnostics.Process.CancelErrorRead%2A> beendet den asynchronen Lesevorgang.  
  
 Nach dem Abbruch können Sie durch Aufrufen den asynchronen Lesevorgang fortsetzen <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> erneut aus.  
  
 Beim Aufruf <xref:System.Diagnostics.Process.CancelErrorRead%2A>, werden alle in Bearbeitung Lesevorgänge für <xref:System.Diagnostics.Process.StandardError%2A> werden abgeschlossen, und klicken Sie dann der Ereignishandler deaktiviert ist. Alle weiteren Ausgabe umgeleitet <xref:System.Diagnostics.Process.StandardError%2A> in einem Puffer gespeichert ist. Wenn Sie den Ereignishandler mit einem Aufruf von wieder aktivieren <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, wird die gespeicherte Ausgabe an den Ereignishandler gesendet, und asynchrone Lesevorgänge fortsetzen. Wenn Sie den Ereignishandler zu ändern, bevor Sie asynchrone Lesevorgänge fortsetzen möchten, müssen Sie den vorhandenen Ereignishandler entfernen, vor dem Hinzufügen des neuen Ereignishandler:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge im umgeleiteten nicht Mischen <xref:System.Diagnostics.Process.StandardError%2A> Stream. Einmal im umgeleiteten Stream eine <xref:System.Diagnostics.Process> geöffnet wird im asynchronen oder synchronen Modus alle weiterlesen Vorgänge für diesen Datenstrom müssen sich im gleichen Modus beziehen. Wenn Sie den Vorgang Abbrechen eines asynchronen Lesevorgang auf <xref:System.Diagnostics.Process.StandardError%2A> und müssen aus dem Stream gelesenen erneut, verwenden Sie <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> asynchrone Lesevorgänge fortgesetzt. Führen Sie nicht <xref:System.Diagnostics.Process.CancelErrorRead%2A> durch einen Aufruf der synchronen Methoden für das Lesen von <xref:System.Diagnostics.Process.StandardError%2A> wie z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, oder <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel startet der `nmake` -Befehl mit der Benutzer die angegebenen Argumente. Die Ausgaben des Fehler- und -Streams werden asynchron gelesen. die erfassten Textzeilen werden in der Konsole angezeigt als auch in eine Protokolldatei geschrieben. Wenn die Ausgabe des Befehls eine angegebene Anzahl von Zeilen überschreitet, werden die asynchrone Lesevorgänge abgebrochen.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream is not enabled for asynchronous read operations.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of an application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Startet einen asynchronen Lesevorgang auf der <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. <xref:System.Diagnostics.Process.CancelOutputRead%2A> beendet den asynchronen Lesevorgang.  
  
 Nach dem Abbruch können Sie asynchrone Lesevorgänge fortsetzen, indem Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> erneut aus.  
  
 Beim Aufruf <xref:System.Diagnostics.Process.CancelOutputRead%2A>, werden alle in Bearbeitung Lesevorgänge für <xref:System.Diagnostics.Process.StandardOutput%2A> werden abgeschlossen, und klicken Sie dann der Ereignishandler deaktiviert ist. Alle weiteren Ausgabe umgeleitet <xref:System.Diagnostics.Process.StandardOutput%2A> in einem Puffer gespeichert ist. Wenn Sie den Ereignishandler mit einem Aufruf von wieder aktivieren <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, wird die gespeicherte Ausgabe an den Ereignishandler gesendet, und asynchrone Lesevorgänge fortsetzen. Wenn Sie den Ereignishandler zu ändern, bevor Sie asynchrone Lesevorgänge fortsetzen möchten, müssen Sie den vorhandenen Ereignishandler entfernen, vor dem Hinzufügen des neuen Ereignishandler:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge im umgeleiteten nicht Mischen <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Einmal im umgeleiteten Stream eine <xref:System.Diagnostics.Process> geöffnet wird im asynchronen oder synchronen Modus alle weiterlesen Vorgänge für diesen Datenstrom müssen sich im gleichen Modus beziehen. Wenn Sie den Vorgang Abbrechen eines asynchronen Lesevorgang auf <xref:System.Diagnostics.Process.StandardOutput%2A> und müssen aus dem Stream gelesenen erneut, verwenden Sie <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> asynchrone Lesevorgänge fortgesetzt. Führen Sie nicht <xref:System.Diagnostics.Process.CancelOutputRead%2A> durch einen Aufruf der synchronen Methoden für das Lesen von <xref:System.Diagnostics.Process.StandardOutput%2A> wie z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, oder <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel startet der `nmake` -Befehl mit der Benutzer die angegebenen Argumente. Die Ausgaben des Fehler- und -Streams werden asynchron gelesen. die erfassten Textzeilen werden in der Konsole angezeigt als auch in eine Protokolldatei geschrieben. Wenn die Ausgabe des Befehls eine angegebene Anzahl von Zeilen überschreitet, werden die asynchrone Lesevorgänge abgebrochen.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream is not enabled for asynchronous read operations.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Frees all the resources that are associated with this component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.Close%2A> Methode bewirkt, dass den Prozess beendet wird, Warten beenden, wenn er gewartet wurde, schließt das Prozesshandle und löscht prozessspezifische Eigenschaften. <xref:System.Diagnostics.Process.Close%2A> standard-Ausgabe, Eingabe- und Reader und Writer schließt nicht für den Fall, dass sie extern verwiesen wird.  
  
> [!NOTE]
>  Die <xref:System.Diagnostics.Process.Dispose%2A>-Methode ruft <xref:System.Diagnostics.Process.Close%2A> auf. Platzieren der <xref:System.Diagnostics.Process> -Objekt in ein `using` Block verwirft Ressourcen aufrufen, ohne <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Anschließend wird die Auslastung des physischen Speichers des zugeordneten Prozesses abgerufen, bei 2-Sekunden-Intervallen für maximal 10 Sekunden. Im Beispiel wird ermittelt, ob der Prozess beendet wird, bevor 10 Sekunden vergangen sind. Im Beispiel wird der Prozess beendet, wenn er nach 10 Sekunden immer noch ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes a process that has a user interface by sending a close message to its main window.</summary>
        <returns>
          <see langword="true" /> if the close message was successfully sent; <see langword="false" /> if the associated process does not have a main window or if the main window is disabled (for example if a modal dialog is being shown).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Prozess ausgeführt wird, ist die Nachrichtenschleife in einen Wartezustand versetzt. Die Nachrichtenschleife führt jedes Mal, wenn eine Windows-Nachricht an den Prozess vom Betriebssystem gesendet wird. Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> sendet eine Anforderung zum nahe, die in eine wohlgeformte Anwendung wird die untergeordnete Fenster geschlossen, und hebt alle aktiven Nachrichtenschleifen für die Anwendung im Hauptfenster. Die Anforderung zum Beenden des Prozesses durch Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> erzwingt nicht die Anwendung zu beenden. Die Anwendung kann fragt nach der Überprüfung des Benutzers vor dem Beenden oder kann es ablehnen, um den Vorgang abzubrechen. Um die Anwendung beenden zu erzwingen, verwenden Sie die <xref:System.Diagnostics.Process.Kill%2A> Methode. Das Verhalten des <xref:System.Diagnostics.Process.CloseMainWindow%2A> ist identisch mit dem ein Benutzer eine Anwendung im Hauptfenster über das Menü "System" zu schließen. Aus diesem Grund erzwingt die Anforderung an den Prozess zu beenden, indem Sie das Hauptfenster schließen nicht die Anwendung sofort beendet.  
  
 Daten, die vom Prozess bearbeitet oder an den Prozess reservierten Ressourcen können verloren, wenn Sie aufrufen <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> bewirkt, dass eine nicht ordnungsgemäße Beendigung und sollte nur bei Bedarf verwendet werden. <xref:System.Diagnostics.Process.CloseMainWindow%2A> ermöglicht es eine ordnungsgemäße Beendigung des Prozesses, und schließt alle Fenster, damit für Anwendungen mit einer Schnittstelle zu bevorzugen ist. Wenn <xref:System.Diagnostics.Process.CloseMainWindow%2A> ein Fehler auftritt, können Sie <xref:System.Diagnostics.Process.Kill%2A> zum Beenden des Prozesses. <xref:System.Diagnostics.Process.Kill%2A> ist die einzige Möglichkeit, Prozesse zu beenden, die keine grafische Schnittstellen haben.  
  
 Sie können Aufrufen <xref:System.Diagnostics.Process.Kill%2A> und <xref:System.Diagnostics.Process.CloseMainWindow%2A> nur für Prozesse, die auf dem lokalen Computer ausgeführt werden. Sie können nicht dazu führen, dass Prozesse auf Remotecomputern zu beenden. Sie können nur für Prozesse, die auf Remotecomputern ausgeführte Informationen anzeigen.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Anschließend wird die Auslastung des physischen Speichers des zugeordneten Prozesses abgerufen, alle 2 Sekunden maximal 10 Sekunden. Im Beispiel wird ermittelt, ob der Prozess beendet wird, bevor 10 Sekunden vergangen sind. Im Beispiel wird der Prozess beendet, wenn er nach 10 Sekunden immer noch ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Release all resources used by this process.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets whether the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the process terminates.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="E:System.Diagnostics.Process.Exited" />-Ereignis ausgelöst werden soll, wenn der zugeordnete Prozess beendet wird (entweder durch Beenden oder einen Aufruf von <see cref="M:System.Diagnostics.Process.Kill" />); andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />. Beachten Sie, dass die <see cref="E:System.Diagnostics.Process.Exited" /> Ereignis wird ausgelöst, selbst wenn der Wert der <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> ist <see langword="false" /> Wenn während der Prozess beendet wird bzw. bevor der Benutzer führt eine <see cref="P:System.Diagnostics.Process.HasExited" /> überprüfen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft schlägt vor, ob die Komponente benachrichtigt werden soll, wenn das Betriebssystem einen Prozess beendet wurde. Die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft wird bei der asynchronen Verarbeitung verwendet, um Ihre Anwendung zu benachrichtigen, die ein Prozess beendet wurde. Ihre Anwendung synchron einen Exit-Ereignis warten (wodurch die Verarbeitung der Anwendung bis Exit-Ereignis aufgetreten ist) erzwingen, verwenden Sie die <xref:System.Diagnostics.Process.WaitForExit%2A> Methode.

> [!NOTE]
> Wenn Sie Visual Studio verwenden, und doppelklicken Sie auf eine <xref:System.Diagnostics.Process> -Komponente in Ihrem Projekt eine <xref:System.Diagnostics.Process.Exited> Ereignisdelegaten und Ereignishandler werden automatisch generiert. Kein zusätzlicher Code legt die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft `false`. Sie müssen diese Eigenschaft ändern `true` für einen Ereignishandler, der ausgeführt wird, wenn der zugeordnete Prozess beendet wird.

Wenn der Komponente <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Wert ist `true`, oder wenn <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> ist `false` und ein <xref:System.Diagnostics.Process.HasExited%2A> Kontrollkästchen wird aufgerufen, indem die Komponente, die Komponente über Zugriff auf die administrativen Informationen für den zugeordneten Prozess, die bleibt. durch das Betriebssystem gespeichert. Dazu gehören die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.ExitCode%2A>.

Nachdem der zugeordnete Prozess beendet wird, wird die <xref:System.Diagnostics.Process.Handle%2A> verweist nicht mehr von der Komponente auf eine vorhandene Prozessressource. Stattdessen können sie nur verwendet werden um das Betriebssystem Informationen über die Process-Ressource zuzugreifen. Das Betriebssystem ist, beachten Sie, dass die Handles für beendete Prozesse, die von veröffentlicht wurde noch nicht vorhanden sind <xref:System.Diagnostics.Process> Komponenten, sodass er verfolgt die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.Handle%2A> Informationen im Arbeitsspeicher.

Es ist ein gewisser Aufwand verbunden, mit dem für einen Prozess zu beenden. Wenn <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> ist `true`die <xref:System.Diagnostics.Process.Exited> Ereignis wird ausgelöst, wenn der zugeordnete Prozess beendet wird. Verfahren für die <xref:System.Diagnostics.Process.Exited> Ereignis zu diesem Zeitpunkt ausführen.

In einigen Fällen die Anwendung startet einen Prozess jedoch benötigt keine Benachrichtigung über dessen Beendigung. Die Anwendung kann z. B. Editor, dass der Benutzer Text bearbeiten, aber keine weiteren Nutzen der Editor-Anwendung starten. Sie können auswählen, um die Benachrichtigung zu vermeiden, wenn der Prozess beendet wird, da sie nicht relevant für die weitere Ausführung der Anwendung ist. Festlegen von <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> auf `false` Systemressourcen speichern können.

## Examples  
Das folgende Codebeispiel erstellt einen Prozess, der eine Datei ausgibt. Wird die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft dazu führen, dass den Prozess zum Auslösen der <xref:System.Diagnostics.Process.Exited> Ereignis aus, wenn er beendet wird. Die <xref:System.Diagnostics.Process.Exited> Ereignishandler zeigt Prozessinformationen.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Puts a <see cref="T:System.Diagnostics.Process" /> component in state to interact with operating system processes that run in a special mode by enabling the native property <see langword="SeDebugPrivilege" /> on the current thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Betriebssystem-Prozesse in einem speziellen Modus ausgeführt. Zum Lesen von Eigenschaften oder Anfügen an diese Prozesse versuchen, ist nicht möglich, es sei denn, Sie haben aufgerufen <xref:System.Diagnostics.Process.EnterDebugMode%2A> auf die Komponente. Rufen Sie <xref:System.Diagnostics.Process.LeaveDebugMode%2A> Wenn Sie nicht mehr benötigen Zugriff auf diese Prozesse, die in speziellen Modus ausgeführt.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an application writes to its redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.ErrorDataReceived> Ereignis gibt an, dass der zugeordnete Prozess in ihren umgeleiteten geschrieben hat <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Das Ereignis tritt nur während der asynchrone Lesevorgänge auf <xref:System.Diagnostics.Process.StandardError%2A>. Um asynchrone Lesevorgänge zu starten, müssen Sie Umleiten der <xref:System.Diagnostics.Process.StandardError%2A> Datenstrom von einer <xref:System.Diagnostics.Process>, den Ereignishandler zum Hinzufügen der <xref:System.Diagnostics.Process.ErrorDataReceived> Ereignis, und rufen <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. Danach ist die <xref:System.Diagnostics.Process.ErrorDataReceived> Ereignis signalisiert jedes Mal der Prozess eine Zeile in den umgeleiteten schreibt <xref:System.Diagnostics.Process.StandardError%2A> streamen, bis der Prozess beendet wird, oder ruft <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  Die Anwendung, die die asynchrone Ausgabe verarbeitet sollte Aufrufen der <xref:System.Diagnostics.Process.WaitForExit> Methode, um sicherzustellen, dass der Ausgabepuffer geleert wurde. Beachten Sie, dass die Angabe eines Timeouts mit der <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> Überladung ist *nicht* sicherzustellen, hat der Ausgabepuffer geleert wurden.
  
   
  
## Examples  
 Im folgenden Beispiel wird die `net view` Befehl aus, um die Liste der verfügbaren Netzwerkressourcen auf einem Remotecomputer befindet. Der Benutzer gibt den Namen des Zielcomputers als Befehlszeilenargument an. Die Benutzer kann auch einen Dateinamen für die Fehlerausgabe angeben. Im Beispiel wird die Ausgabe des net-Befehl, der wartet, bis der Prozess abgeschlossen ist, und führt die Ausgabe an die Konsole schreibt erfasst. Wenn der Benutzer die optionale Fehlerdatei bereitstellt, schreibt das Beispiel Fehler in die Datei an.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value that the associated process specified when it terminated.</summary>
        <value>Der Code, der vom zugeordneten Prozess beim Beenden angegeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Diagnostics.Process.ExitCode%2A> zum Abrufen des Status, die die Systemprozess zurückgegeben, wenn er beendet. Sie können den Exitcode viel verwenden, wie eine ganze Zahl Rückgabewert aus einer `main()` Prozedur.  
  
 Die <xref:System.Diagnostics.Process.ExitCode%2A> -Wert für ein Prozess die spezifische Konvention, die vom Anwendungsentwickler für diesen Prozess implementiert widerspiegelt. Wenn Sie den Exitcodewert für Entscheidungen in Ihrem Code verwenden, achten Sie darauf, dass Sie wissen, dass die Exit Code Konvention, die von der Anwendungsprozess verwendet.  
  
 Entwickler weisen normalerweise darauf hin durch einen erfolgreichen Beendigung einer <xref:System.Diagnostics.Process.ExitCode%2A> Wert 0 (null), und Bestimmen von Fehlern durch ungleich NULL-Werte, die die aufrufende Methode verwenden können, um die Ursache für eine nicht ordnungsgemäße Beendigung zu identifizieren. Es ist nicht notwendig, diese Richtlinien befolgen, aber sie sind der Konvention.  
  
 Wenn Sie versuchen, erhalten die <xref:System.Diagnostics.Process.ExitCode%2A> , bevor der Prozess beendet wurde, löst der Versuch eine Ausnahme aus. Überprüfen Sie die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft, um zu überprüfen, ob der zugeordnete Prozess beendet wurde.  
  
> [!NOTE]
>  Standardausgabe an asynchrone Ereignishandler umgeleitet wurde, es ist möglich, dass die Verarbeitung der Ausgabe nicht abgeschlossen, wenn <xref:System.Diagnostics.Process.HasExited%2A> gibt `true`. Um sicherzustellen, dass die asynchrone Ereignisbehandlung abgeschlossen wurde, rufen Sie die <xref:System.Diagnostics.Process.WaitForExit> Überladung, die keine Parameter, vor dem Einchecken akzeptiert <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Können Sie die <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder die <xref:System.Diagnostics.Process.Kill%2A> -Methode veranlassen Sie einen zugeordneten Prozess beendet.  
  
 Es gibt zwei Möglichkeiten, benachrichtigt werden, wenn der zugeordnete Prozess beendet wird: synchron und asynchron. Synchrone Benachrichtigung beruht auf Aufrufen der <xref:System.Diagnostics.Process.WaitForExit%2A> Methode, um die Verarbeitung Ihrer Anwendung anhalten, bis der zugeordnete Komponente beendet wird. Asynchrone Benachrichtigung beruht auf dem <xref:System.Diagnostics.Process.Exited> Ereignis. Wenn die asynchrone Benachrichtigung verwendet <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> muss festgelegt werden, um `true` für die <xref:System.Diagnostics.Process> Komponente, für die Benachrichtigung erhalten, die der Prozess beendet wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process has not exited.  -or-  The process <see cref="P:System.Diagnostics.Process.Handle" /> is not valid.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitCode" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a process exits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.Exited> Ereignis gibt an, dass der zugeordnete Prozess beendet. Dies bedeutet, das entweder, dass den Prozess abgebrochen "oder" wurde erfolgreich abgeschlossen. Dieses Ereignis kann nur auftreten, wenn der Wert der <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Eigenschaft ist `true`.  
  
 Es gibt zwei Möglichkeiten, benachrichtigt werden, wenn der zugeordnete Prozess beendet wird: synchron und asynchron. Synchrone Benachrichtigung bedeutet Aufrufen der <xref:System.Diagnostics.Process.WaitForExit%2A> Methode, um den aktuellen Thread zu blockieren, bis der Prozess beendet wird. Asynchrone Benachrichtigung verwendet die <xref:System.Diagnostics.Process.Exited> -Ereignis, das den aufrufenden Thread die Ausführung in der Zwischenzeit fortsetzen kann. Im letzteren Fall <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> muss festgelegt werden, um `true` für die aufrufende Anwendung das Exited-Ereignis empfangen.  
  
 Wenn das Betriebssystem einen Prozess heruntergefahren wird, wird benachrichtigt, alle anderen Prozesse, die Handler für das Ereignis Exited registriert wurden. Zu diesem Zeitpunkt an, die das Handle des Prozesses, der gerade beendet genutzt werden, einige Eigenschaften wie z. B. den Zugriff auf <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.HasExited%2A> , dass das Betriebssystem verwaltet, bis er vollständig dieses Handle freigibt.  
  
> [!NOTE]
>  Selbst wenn Sie ein Handle für einen beendeten Prozess haben, kann nicht aufgerufen <xref:System.Diagnostics.Process.Start%2A> erneut eine Verbindung mit den gleichen Prozess herzustellen. Aufrufen von <xref:System.Diagnostics.Process.Start%2A> automatisch der zugeordnete Prozess freigegeben und eine Verbindung mit einem Prozess mit derselben Datei, aber eine völlig neue <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Weitere Informationen zur Verwendung von der <xref:System.Diagnostics.Process.Exited> Ereignis in Windows Forms-Anwendungen finden Sie unter der <xref:System.Diagnostics.Process.SynchronizingObject%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Prozess, der eine Datei ausgibt. Es wird ausgelöst, die <xref:System.Diagnostics.Process.Exited> Ereignis aus, wenn der Prozess beendet wird, da die <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> -Eigenschaft wurde festgelegt, wenn der Prozess erstellt wurde. Die <xref:System.Diagnostics.Process.Exited> Ereignishandler zeigt Prozessinformationen.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the associated process exited.</summary>
        <value>Eine <see cref="T:System.DateTime" />, die angibt, wann der zugeordnete Prozess beendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Prozess nicht beendet wurde, wird beim Abrufen der <xref:System.Diagnostics.Process.ExitTime%2A> -Eigenschaft löst eine Ausnahme aus. Verwendung <xref:System.Diagnostics.Process.HasExited%2A> vor dem Abrufen der <xref:System.Diagnostics.Process.ExitTime%2A> Eigenschaft, um zu bestimmen, ob der zugeordnete Prozess beendet wurde.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Prozess, der eine Datei ausgibt. Der Vorgang löst die <xref:System.Diagnostics.Process.Exited> Ereignis aus, wenn er beendet wird, und der Ereignishandler zeigt die <xref:System.Diagnostics.Process.ExitTime%2A> -Eigenschaft und andere Informationen verarbeiten.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a new <see cref="T:System.Diagnostics.Process" /> component and associates it with the currently active process.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> component associated with the process resource that is running the calling application.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Erstellen eines neuen <xref:System.Diagnostics.Process> -Instanz und der Prozessressource auf dem lokalen Computer zuordnen.  
  
 Ähnlich wie <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, und <xref:System.Diagnostics.Process.GetProcesses%2A> Methoden <xref:System.Diagnostics.Process.GetCurrentProcess%2A> ordnet eine vorhandene Ressource einer neuen <xref:System.Diagnostics.Process> Komponente.  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component, and associates it with the existing process resource that you specify.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">The system-unique identifier of a process resource.</param>
        <summary>Returns a new <see cref="T:System.Diagnostics.Process" /> component, given the identifier of a process on the local computer.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> component that is associated with the local process resource identified by the <paramref name="processId" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Erstellen eines neuen <xref:System.Diagnostics.Process> Komponente und eine Prozessressource auf dem lokalen Computer zugeordnet. Die Prozessressource muss bereits auf dem Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> erstellt keine Systemressource, sondern eine Ressource mit einer Anwendung generierte zuordnet <xref:System.Diagnostics.Process> Komponente. Ein Prozess <xref:System.Diagnostics.Process.Id%2A> abgerufen werden können, nur für einen Prozess, die derzeit auf dem Computer ausgeführt wird. Nach Beendigung des Prozesses <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> löst eine Ausnahme aus, wenn Sie einen abgelaufenen Bezeichner übergeben.  
  
 Auf einem bestimmten Computer ist der Bezeichner eines Prozesses eindeutig. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> ein Prozess zurückgibt darf höchstens. Wenn Sie die Prozesse, die für die Ausführung einer bestimmten Anwendung verwenden abrufen möchten <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Wenn mehrere Prozesse auf dem Computer mit der angegebenen Anwendung vorhanden <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> gibt ein Array mit allen zugeordneten Prozessen. Sie können jeder dieser Prozesse wiederum für seinen Bezeichner abfragen. Die Prozess-ID angezeigt werden kann, dem `Processes` Bereich des Windows Task-Managers. Die `PID` Spalte zeigt die Prozess-ID, die an einen Prozess zugewiesen wird.  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The process specified by the <paramref name="processId" /> parameter is not running. The identifier might be expired.</exception>
        <exception cref="T:System.InvalidOperationException">The process was not started by this object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">The system-unique identifier of a process resource.</param>
        <param name="machineName">The name of a computer on the network.</param>
        <summary>Returns a new <see cref="T:System.Diagnostics.Process" /> component, given a process identifier and the name of a computer on the network.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> component that is associated with a remote process resource identified by the <paramref name="processId" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Erstellen eines neuen <xref:System.Diagnostics.Process> Komponente und eine Prozessressource auf einem Remotecomputer im Netzwerk zugeordnet. Die Prozessressource muss bereits auf dem angegebenen Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> erstellt keine Systemressource, sondern eine Ressource mit einer Anwendung generierte zuordnet <xref:System.Diagnostics.Process> Komponente. Ein Prozess <xref:System.Diagnostics.Process.Id%2A> abgerufen werden können, nur für einen Prozess, die derzeit auf dem Computer ausgeführt wird. Nach Beendigung des Prozesses <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> löst eine Ausnahme aus, wenn Sie einen abgelaufenen Bezeichner übergeben.  
  
 Auf einem bestimmten Computer ist der Bezeichner eines Prozesses eindeutig. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> ein Prozess zurückgibt darf höchstens. Wenn Sie die Prozesse, die für die Ausführung einer bestimmten Anwendung verwenden abrufen möchten <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Wenn mehrere Prozesse auf dem Computer mit der angegebenen Anwendung vorhanden <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> gibt ein Array mit allen zugeordneten Prozessen. Sie können jeder dieser Prozesse wiederum für seinen Bezeichner abfragen. Die Prozess-ID angezeigt werden kann, dem `Processes` Bereich des Windows Task-Managers. Die `PID` Spalte zeigt die Prozess-ID, die an einen Prozess zugewiesen wird.  
  
 Wenn Sie keinen angeben einer `machineName`, der lokale Computer verwendet. Alternativ können Sie den lokalen Computer angeben, durch Festlegen von `machineName` auf den Wert "." oder auf eine leere Zeichenfolge ("").  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The process specified by the <paramref name="processId" /> parameter is not running. The identifier might be expired.  -or-  The <paramref name="machineName" /> parameter syntax is invalid. The name might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The process was not started by this object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with existing process resources.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the local computer.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the local computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode ein Array von Erstellung neuer <xref:System.Diagnostics.Process> Komponenten und diese allen Prozessressourcen auf dem lokalen Computer zuordnen. Prozessressourcen müssen bereits auf dem lokalen Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcesses%2A> erstellt keine Systemressourcen verfügbar sind, sondern Ressourcen durch die Anwendung generierte zuordnet <xref:System.Diagnostics.Process> Komponenten. Da das Betriebssystem selbst Hintergrundprozesse ausgeführt wird, ist dieses Array nie leer.  
  
 Wenn Sie nicht alle auf dem Computer ausgeführten Prozesse abrufen möchten, können Sie deren Anzahl einschränken, indem Sie mit der <xref:System.Diagnostics.Process.GetProcessById%2A> oder <xref:System.Diagnostics.Process.GetProcessesByName%2A> Methode. <xref:System.Diagnostics.Process.GetProcessById%2A> erstellt eine <xref:System.Diagnostics.Process> Komponente, die der Prozess, durch die Prozess-ID, die Sie an die Methode übergeben, auf dem System identifiziert zugeordnet ist. <xref:System.Diagnostics.Process.GetProcessesByName%2A> erstellt ein Array von <xref:System.Diagnostics.Process> -Komponenten, deren zugeordnete Prozessressourcen gemeinsam, die ausführbare Datei nutzen, die Sie an die Methode übergeben.  
  
> [!NOTE]
>  Mehrere Windows-Dienste können innerhalb der gleichen Instanz des Dienst-Hostprozesses (svchost.exe) geladen werden. GetProcesses erkennt diese einzelne Dienste nicht; dazu finden Sie unter <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">The computer from which to read the list of processes.</param>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the specified computer.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the specified computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode ein Array von Erstellung neuer <xref:System.Diagnostics.Process> Komponenten und diese allen Prozessressourcen auf dem angegebenen (in der Regel remoten) Computer zuordnen. Prozessressourcen müssen bereits auf dem lokalen Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcesses%2A> erstellt keine Systemressourcen verfügbar sind, sondern Ressourcen durch die Anwendung generierte zuordnet <xref:System.Diagnostics.Process> Komponenten. Da das Betriebssystem selbst Hintergrundprozesse ausgeführt wird, ist dieses Array nie leer.  
  
 Wenn Sie nicht alle auf dem Computer ausgeführten Prozesse abrufen möchten, können Sie deren Anzahl einschränken, indem Sie mit der <xref:System.Diagnostics.Process.GetProcessById%2A> oder <xref:System.Diagnostics.Process.GetProcessesByName%2A> Methode. <xref:System.Diagnostics.Process.GetProcessById%2A> erstellt eine <xref:System.Diagnostics.Process> Komponente, die der Prozess, durch die Prozess-ID, die Sie an die Methode übergeben, auf dem System identifiziert zugeordnet ist. <xref:System.Diagnostics.Process.GetProcessesByName%2A> erstellt ein Array von <xref:System.Diagnostics.Process> -Komponenten, deren zugeordnete Prozessressourcen gemeinsam, die ausführbare Datei nutzen, die Sie an die Methode übergeben.  
  
 Diese Überladung von der <xref:System.Diagnostics.Process.GetProcesses%2A> Methode wird in der Regel zum Abrufen der Liste der Prozessressourcen auf einem Remotecomputer im Netzwerk ausgeführt, aber Sie können den lokalen Computer geben, indem ".".  
  
> [!NOTE]
>  Mehrere Windows-Dienste können innerhalb der gleichen Instanz des Dienst-Hostprozesses (svchost.exe) geladen werden. GetProcesses erkennt diese einzelne Dienste nicht; dazu finden Sie unter <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter syntax is invalid. It might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The operating system platform does not support this operation on remote computers.</exception>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A problem occurred accessing an underlying system API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with the existing process resources that all share the specified process name.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">The friendly name of the process.</param>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on the local computer that share the specified process name.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode ein Array von Erstellung neuer <xref:System.Diagnostics.Process> Komponenten und ordnen diese allen Prozessressourcen auf, die die gleiche ausführbare Datei auf dem lokalen Computer ausgeführt werden. Prozessressourcen müssen bereits auf dem Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcessesByName%2A> keine Systemressourcen erstellt, sondern vielmehr ordnet diese Anwendung generierte <xref:System.Diagnostics.Process> Komponenten. Ein `processName` kann für eine ausführbare Datei, die derzeit nicht auf dem lokalen Computer ausgeführt wird, sodass das Array der Methodenrückgabe leer sein kann angegeben werden.  
  
 Der Name des Prozesses ist, einen Anzeigenamen für den Prozess, z. B. Outlook, die der Erweiterung .exe oder den Pfad nicht enthalten. <xref:System.Diagnostics.Process.GetProcessesByName%2A> ist hilfreich zum Abrufen und Bearbeiten von alle Prozesse, die derselben ausführbaren Datei zugeordnet sind. Sie können z. B. den Namen einer ausführbaren Datei als übergeben der `processName` -Parameter, um alle ausgeführten Instanzen dieser ausführbaren Datei zu schließen.  
  
 Obwohl ein Prozess <xref:System.Diagnostics.Process.Id%2A> ist für eine einzelnes Prozessressource auf dem System eindeutig, mehrere Prozesse auf dem lokalen Computer können ausgeführt werden die angegebene Anwendung der `processName` Parameter. Aus diesem Grund <xref:System.Diagnostics.Process.GetProcessById%2A> gibt einen Prozess zurück, höchstens jedoch <xref:System.Diagnostics.Process.GetProcessesByName%2A> gibt ein Array mit allen zugeordneten Prozessen. Wenn Sie den Prozess über standard-API-Aufrufe bearbeiten müssen, können Sie jeder dieser Prozesse wiederum für seinen Bezeichner abfragen. Sie keinen Zugriff auf Prozessressourcen, durch den Namen des Prozesses allein jedoch, nachdem Sie ein Array von abgerufen haben <xref:System.Diagnostics.Process> Komponenten, die zugeordnet wurden Prozessressourcen, starten, beenden und die Systemressourcen auf andere Weise bearbeiten.  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">The friendly name of the process.</param>
        <param name="machineName">The name of a computer on the network.</param>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on a remote computer that share the specified process name.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode ein Array von Erstellung neuer <xref:System.Diagnostics.Process> Komponenten und ordnen diese allen Prozessressourcen auf, die die gleiche ausführbare Datei auf dem angegebenen Computer ausgeführt werden. Prozessressourcen müssen bereits auf dem Computer vorhanden, da <xref:System.Diagnostics.Process.GetProcessesByName%2A> keine Systemressourcen erstellt, sondern vielmehr ordnet diese Anwendung generierte <xref:System.Diagnostics.Process> Komponenten. Ein `processName` kann für eine ausführbare Datei, die derzeit nicht auf dem lokalen Computer ausgeführt wird, sodass das Array der Methodenrückgabe leer sein kann angegeben werden.  
  
 Der Name des Prozesses ist, einen Anzeigenamen für den Prozess, z. B. Outlook, die der Erweiterung .exe oder den Pfad nicht enthalten. <xref:System.Diagnostics.Process.GetProcessesByName%2A> ist hilfreich zum Abrufen und Bearbeiten von alle Prozesse, die derselben ausführbaren Datei zugeordnet sind. Sie können z. B. den Namen einer ausführbaren Datei als übergeben der `processName` -Parameter, um alle ausgeführten Instanzen dieser ausführbaren Datei zu schließen.  
  
 Obwohl ein Prozess <xref:System.Diagnostics.Process.Id%2A> ist für eine einzelnes Prozessressource auf dem System eindeutig, mehrere Prozesse auf dem lokalen Computer können ausgeführt werden die angegebene Anwendung der `processName` Parameter. Aus diesem Grund <xref:System.Diagnostics.Process.GetProcessById%2A> gibt einen Prozess zurück, höchstens jedoch <xref:System.Diagnostics.Process.GetProcessesByName%2A> gibt ein Array mit allen zugeordneten Prozessen. Wenn Sie den Prozess über standard-API-Aufrufe bearbeiten müssen, können Sie jeder dieser Prozesse wiederum für seinen Bezeichner abfragen. Sie keinen Zugriff auf Prozessressourcen, durch den Namen des Prozesses allein jedoch, nachdem Sie ein Array von abgerufen haben <xref:System.Diagnostics.Process> Komponenten, die zugeordnet wurden Prozessressourcen, starten, beenden und die Systemressourcen auf andere Weise bearbeiten.  
  
 Sie können diese Überladung verwenden, um Prozesse auf dem lokalen Computer sowie auf einem Remotecomputer abzurufen. Verwenden "." auf den lokalen Computer anzugeben. Eine andere Überladung vorhanden ist, die den lokalen Computer in der Standardeinstellung verwendet.  
  
 Sie können die Prozesse auf Remotecomputern nur zum Anzeigen von Informationen zu den Prozessen, z. B. Statistiken zugreifen. Sie können nicht schließen, und beenden (mit <xref:System.Diagnostics.Process.Kill%2A>), oder starten Sie Prozesse auf Remotecomputern.  
  
   
  
## Examples  
 Das folgende Beispiel ruft Informationen des aktuellen Prozesses aus, auf dem lokalen Computer, alle ausgeführten Instanzen von Editor auf dem lokalen Computer und einen bestimmten Prozess auf dem lokalen Computer ausgeführten Prozesse ab. Anschließend werden die Informationen für die gleichen Prozesse auf einem Remotecomputer abgerufen.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter syntax is invalid. It might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The operating system platform does not support this operation on remote computers.</exception>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A problem occurred accessing an underlying system API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle of the associated process.</summary>
        <value>Das Handle, das das Betriebssystem dem zugeordneten Prozess beim Starten des Prozesses zugewiesen hat. Das System verwendet dieses Handle zum Verfolgen der Prozessattribute.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendung kann ein Handle für einen Prozess abrufen, die als Parameter für viele Funktionen von Prozessinformationen und -Steuerelement verwendet werden kann. Verwenden Sie dieses Handle zum Initialisieren einer <xref:System.Threading.WaitHandle> oder aufrufen systemeigene Methoden mit einem Plattformaufruf aufgerufen werden soll.  
  
 Diese Prozesshandle ist privat zu einer Anwendung – also Handles können nicht gemeinsam genutzt werden. Ein Prozess verfügt auch über einen Prozess <xref:System.Diagnostics.Process.Id%2A> die im Gegensatz zu den <xref:System.Diagnostics.Process.Handle%2A>, ist eindeutig und somit im gesamten System gültig.  
  
 Nur Prozesse gestartet, durch einen Aufruf von <xref:System.Diagnostics.Process.Start%2A> legen Sie die <xref:System.Diagnostics.Process.Handle%2A> -Eigenschaft des entsprechenden <xref:System.Diagnostics.Process> Instanzen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process has not been started or has exited. The <see cref="P:System.Diagnostics.Process.Handle" /> property cannot be read because there is no process associated with this <see cref="T:System.Diagnostics.Process" /> instance.  -or-  The <see cref="T:System.Diagnostics.Process" /> instance has been attached to a running process but you do not have the necessary permissions to get a handle with full access rights.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.Handle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of handles opened by the process.</summary>
        <value>Die Anzahl der vom Prozess geöffneten Betriebssystemhandles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Handles bieten eine Möglichkeit für einen Prozess zum Verweisen auf Objekte. Ein Prozess kann Handles für Dateien, Ressourcen, Nachrichtenwarteschlangen und viele andere Objekte des Betriebssystems erhalten. Das Betriebssystem Gibt den Arbeitsspeicher frei nur, wenn die maximale Handleanzahl beträgt 0 (null) ist dem Prozess zugeordnet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the associated process has been terminated.</summary>
        <value>
          <see langword="true" />, wenn der Betriebssystemprozess, auf den die <see cref="T:System.Diagnostics.Process" />-Komponente verweist, beendet wurde; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert `true` für <xref:System.Diagnostics.Process.HasExited%2A> gibt an, dass der zugeordnete Prozess ordnungsgemäß oder nicht ordnungsgemäß beendet wurde. Sie können anfordern, oder Erzwingen der zugeordneten Prozess beendet durch Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Wenn ein Handle an den Prozess geöffnet ist, gibt das Betriebssystem den Prozessspeicher frei, wenn der Prozess wurde beendet, behält jedoch administrative Informationen über den Prozess, z. B. Handle, Exitcode und Beendigungszeit. Zum Abrufen dieser Informationen können Sie die <xref:System.Diagnostics.Process.ExitCode%2A> und <xref:System.Diagnostics.Process.ExitTime%2A> Eigenschaften. Diese Eigenschaften werden für Prozesse, die von dieser Komponente gestartet wurden, automatisch aufgefüllt. Verwaltungsinformationen wird freigegeben, wenn alle der <xref:System.Diagnostics.Process> Komponenten, die mit dem Systemprozess verknüpft sind beschädigt, und halten Sie keine weiteren Handles für den beendeten Prozess.  
  
 Ein Prozess kann unabhängig von Ihrem Code beendet. Wenn Sie den Prozess mit dieser Komponente gestartet, aktualisiert das System den Wert der <xref:System.Diagnostics.Process.HasExited%2A> automatisch, auch wenn der zugeordnete Prozess unabhängig voneinander beendet.  
  
> [!NOTE]
>  Standardausgabe an asynchrone Ereignishandler umgeleitet wurde, es ist möglich, dass die Verarbeitung der Ausgabe nicht abgeschlossen haben, wenn diese Eigenschaft gibt `true`. Um sicherzustellen, dass die asynchrone Ereignisbehandlung abgeschlossen wurde, rufen Sie die <xref:System.Diagnostics.Process.WaitForExit> Überladung, die keine Parameter, vor dem Einchecken akzeptiert <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Anschließend wird die Auslastung des physischen Speichers des zugeordneten Prozesses abgerufen, alle 2 Sekunden maximal 10 Sekunden. Im Beispiel wird ermittelt, ob der Prozess beendet wird, bevor 10 Sekunden vergangen sind. Im Beispiel wird der Prozess beendet, wenn er nach 10 Sekunden immer noch ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There is no process associated with the object.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The exit code for the process could not be retrieved.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.HasExited" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the unique identifier for the associated process.</summary>
        <value>Der vom System generierte eindeutige Bezeichner des Prozesses, auf den von dieser <see cref="T:System.Diagnostics.Process" />-Instanz verwiesen wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Prozess <xref:System.Diagnostics.Process.Id%2A> ist ungültig, wenn der zugeordnete Prozess nicht ausgeführt wird. Aus diesem Grund sollten Sie sicherstellen, dass der Prozess ausgeführt wird, bevor Sie versuchen, die zum Abrufen der <xref:System.Diagnostics.Process.Id%2A> Eigenschaft. Bis der Prozess beendet wird, identifiziert den Prozess im gesamten System die Prozess-ID eindeutig.  
  
 Sie verbinden einen Prozess, der auf einem Computer lokal oder remote auf einen neuen ausgeführt wird <xref:System.Diagnostics.Process> Instanz durch Übergeben der Prozess-ID, die <xref:System.Diagnostics.Process.GetProcessById%2A> Methode. <xref:System.Diagnostics.Process.GetProcessById%2A> ist eine `static` -Methode, eine neue Komponente erstellt, und legt der <xref:System.Diagnostics.Process.Id%2A> Eigenschaft für die neue <xref:System.Diagnostics.Process> Instanz automatisch.  
  
 Prozess-IDs können durch das System wiederverwendet werden. Die <xref:System.Diagnostics.Process.Id%2A> Eigenschaftswert ist nur während der zugeordnete Prozess ausgeführt wird. Nachdem der Prozess beendet wurde, kann das System Wiederverwenden der <xref:System.Diagnostics.Process.Id%2A> Eigenschaftswert für einen nicht verwandten Prozess.  
  
 Da der Bezeichner für das System eindeutig ist, können Sie es für andere Threads übergeben, als Alternative zum Übergeben einer <xref:System.Diagnostics.Process> Instanz. Dadurch kann Systemressourcen sparen trotzdem sicherstellen, dass der Prozess ordnungsgemäß identifiziert wird.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht das Abrufen der <xref:System.Diagnostics.Process.Id%2A> für alle Instanzen einer Anwendung ausführen. Der Code erstellt eine neue Instanz von Editor, listet Sie alle Instanzen von Editor und dann ermöglicht es dem Benutzer zur Eingabe der <xref:System.Diagnostics.Process.Id%2A> Zahl und eine bestimmte Instanz zu entfernen.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process's <see cref="P:System.Diagnostics.Process.Id" /> property has not been set.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Immediately stops the associated process.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> Erzwingt die Beendigung des Prozesses, während <xref:System.Diagnostics.Process.CloseMainWindow%2A> Beendigung lediglich anfordert. Wenn ein Prozess mit einer grafischen Benutzeroberfläche ausgeführt wird, ist die Nachrichtenschleife in einen Wartezustand versetzt. Die Nachrichtenschleife führt jedes Mal, wenn eine Windows-Nachricht an den Prozess vom Betriebssystem gesendet wird. Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> sendet eine Anforderung zum nahe, die in eine wohlgeformte Anwendung wird die untergeordnete Fenster geschlossen, und hebt alle aktiven Nachrichtenschleifen für die Anwendung im Hauptfenster. Die Anforderung zum Beenden des Prozesses durch Aufrufen von <xref:System.Diagnostics.Process.CloseMainWindow%2A> erzwingt nicht die Anwendung zu beenden. Die Anwendung kann fragt nach der Überprüfung des Benutzers vor dem Beenden oder kann es ablehnen, um den Vorgang abzubrechen. Um die Anwendung beenden zu erzwingen, verwenden Sie die <xref:System.Diagnostics.Process.Kill%2A> Methode. Das Verhalten des <xref:System.Diagnostics.Process.CloseMainWindow%2A> ist identisch mit dem ein Benutzer eine Anwendung im Hauptfenster über das Menü "System" zu schließen. Aus diesem Grund erzwingt die Anforderung an den Prozess zu beenden, indem Sie das Hauptfenster schließen nicht die Anwendung sofort beendet.  
  
> [!NOTE]
>  Die <xref:System.Diagnostics.Process.Kill%2A> Methode asynchron ausgeführt wird. Nach dem Aufruf der <xref:System.Diagnostics.Process.Kill%2A> -Methode, rufen die <xref:System.Diagnostics.Process.WaitForExit%2A> -Methode warten, für den Prozess zu beenden, oder überprüfen die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft, um zu bestimmen, ob der Prozess beendet wurde.  
  
 Daten, die vom Prozess bearbeitet oder an den Prozess reservierten Ressourcen können verloren, wenn Sie aufrufen <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> bewirkt, dass eine nicht ordnungsgemäße Beendigung und sollte nur bei Bedarf verwendet werden. <xref:System.Diagnostics.Process.CloseMainWindow%2A> ermöglicht es eine ordnungsgemäße Beendigung des Prozesses, und schließt alle Fenster, damit für Anwendungen mit einer Schnittstelle zu bevorzugen ist. Wenn <xref:System.Diagnostics.Process.CloseMainWindow%2A> ein Fehler auftritt, können Sie <xref:System.Diagnostics.Process.Kill%2A> zum Beenden des Prozesses. <xref:System.Diagnostics.Process.Kill%2A> ist die einzige Möglichkeit, Prozesse zu beenden, die keine grafische Schnittstellen haben.  
  
 Sie können Aufrufen <xref:System.Diagnostics.Process.Kill%2A> und <xref:System.Diagnostics.Process.CloseMainWindow%2A> nur für Prozesse, die auf dem lokalen Computer ausgeführt werden. Sie können nicht dazu führen, dass Prozesse auf Remotecomputern zu beenden. Sie können nur für Prozesse, die auf Remotecomputern ausgeführte Informationen anzeigen.  
  
> [!NOTE]
>  Wenn der Aufruf der <xref:System.Diagnostics.Process.Kill%2A> Methode erfolgt während der Prozess gerade beendet wird, eine <xref:System.ComponentModel.Win32Exception> wird ausgelöst, für den Zugriff verweigert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The associated process could not be terminated.  -or-  The process is terminating.  -or-  The associated process is a Win16 executable.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to call <see cref="M:System.Diagnostics.Process.Kill" /> for a process that is running on a remote computer. The method is available only for processes running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process has already exited.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Takes a <see cref="T:System.Diagnostics.Process" /> component out of the state that lets it interact with operating system processes that run in a special mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Betriebssystem-Prozesse in einem speziellen Modus ausgeführt. Zum Lesen von Eigenschaften oder Anfügen an diese Prozesse versuchen, ist nicht möglich, es sei denn, Sie haben aufgerufen <xref:System.Diagnostics.Process.EnterDebugMode%2A> auf die Komponente. Rufen Sie <xref:System.Diagnostics.Process.LeaveDebugMode%2A> Wenn Sie nicht mehr benötigen Zugriff auf diese Prozesse, die in speziellen Modus ausgeführt.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the computer the associated process is running on.</summary>
        <value>Der Name des Computers, auf dem der zugeordnete Prozess ausgeführt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können statistische Daten anzeigen und Prozessinformationen für Prozesse auf Remotecomputern, aber Sie kann nicht aufgerufen werden <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, oder <xref:System.Diagnostics.Process.Kill%2A> auf Remotecomputern.  
  
> [!NOTE]
>  Wenn der zugeordnete Prozess auf dem lokalen Computer ausgeführt wird, gibt diese Eigenschaft einen Punkt (".") für den Computernamen. Verwenden Sie die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft, um den richtigen Computernamen abzurufen.  
  
   
  
## Examples  
 Um verwenden das folgende Beispiel müssen Sie zuerst mindestens eine Instanz von Editor auf einem Remotecomputer starten. Im Beispiel fordert den Namen des Remotecomputers auf dem Editor ausgeführt wird, und zeigt dann die entsprechende <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, und <xref:System.Diagnostics.Process.MachineName%2A> Eigenschaften für jede Instanz.  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the main module for the associated process.</summary>
        <value>Das zum Starten des Prozesses verwendete <see cref="T:System.Diagnostics.ProcessModule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Prozessmodul stellt DLL- oder .exe-Datei, die in einem bestimmten Prozess geladen wird. Die <xref:System.Diagnostics.Process.MainModule%2A> -Eigenschaft können Sie die Informationen über die ausführbare Datei, die zum Starten des Prozesses, einschließlich der Modulname, Dateiname und Arbeitsspeicher Moduldetails anzuzeigen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainModule" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A 32-bit process is trying to access the modules of a 64-bit process.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the window handle of the main window of the associated process.</summary>
        <value>Das vom System generierte Fensterhandle des Hauptfensters des zugeordneten Prozesses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Hauptfenster ist das Fenster geöffnet, die durch den Prozess, der gerade den Fokus besitzt (die <xref:System.Windows.Forms.Form.TopLevel%2A> Form). Verwenden Sie die <xref:System.Diagnostics.Process.Refresh%2A> Methode zum Aktualisieren der <xref:System.Diagnostics.Process> Objekt, das die aktuelle im Hauptfenster Handle zu erhalten, wenn es geändert hat. Im Allgemeinen verwenden, da das Fensterhandle zwischengespeichert wird, <xref:System.Diagnostics.Process.Refresh%2A> im voraus, um sicherzustellen, dass das aktuelle Handle abgerufen werden müssen.  
  
 Sie erhalten die <xref:System.Diagnostics.Process.MainWindowHandle%2A> Eigenschaft nur für Prozesse, die auf dem lokalen Computer ausgeführt werden. Die <xref:System.Diagnostics.Process.MainWindowHandle%2A> Eigenschaft ist ein Wert, der das Fenster eindeutig bezeichnet, die dem Prozess zugeordnet ist.  
  
 Ein Prozess verfügt über ein Hauptfenster mit ihm verknüpft sind, nur, wenn der Prozess eine grafische Benutzeroberfläche verfügt. Wenn der zugeordnete Prozess nicht über ein Hauptfenster verfügt die <xref:System.Diagnostics.Process.MainWindowHandle%2A> Wert ist 0 (null). Der Wert ist auch, dass NULL für Prozesse, die ausgeblendet wurden, d. h. verarbeitet werden, die nicht in der Taskleiste sichtbar sind. Dies kann der Fall für Prozesse, die als Symbole im Infobereich ganz rechts in der Taskleiste angezeigt werden.  
  
 Wenn Sie einen Prozess gestartet haben und ihr Handle im Hauptfenster verwenden möchten, können Sie verwenden die <xref:System.Diagnostics.Process.WaitForInputIdle%2A> Methode, um der Prozess gestartet, abgeschlossen zuzulassen, um sicherzustellen, dass das Hauptfensterhandle erstellt wurde. Andernfalls wird eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> is not defined because the process has exited.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the caption of the main window of the process.</summary>
        <value>Der Titel des Hauptfensters des Prozesses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Prozess verfügt über ein Hauptfenster mit ihm verknüpft sind, nur, wenn der Prozess eine grafische Benutzeroberfläche verfügt. Wenn der zugeordnete Prozess nicht über ein Hauptfenster verfügt (sodass <xref:System.Diagnostics.Process.MainWindowHandle%2A> 0 (null)), <xref:System.Diagnostics.Process.MainWindowTitle%2A> ist eine leere Zeichenfolge (""). Wenn Sie einen Prozess gestartet haben und den Titel des Hauptfensters verwenden möchten, können Sie verwenden die <xref:System.Diagnostics.Process.WaitForInputIdle%2A> Methode, um der Prozess gestartet, abgeschlossen zuzulassen, um sicherzustellen, dass das Hauptfensterhandle erstellt wurde. Andernfalls löst das System eine Ausnahme aus.  
  
> [!NOTE]
>  Das Hauptfenster ist das Fenster, das gegenwärtig den Fokus besitzt. Beachten Sie, dass dies möglicherweise die primäre Fenster für den Prozess nicht. Verwenden Sie die <xref:System.Diagnostics.Process.Refresh%2A> Methode zum Aktualisieren der <xref:System.Diagnostics.Process> Objekt, das die aktuelle im Hauptfenster Handle zu erhalten, wenn es geändert hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von Editor gestartet und ruft die Beschriftung des Hauptfensters des Prozesses ab.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property is not defined because the process has exited.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum allowable working set size, in bytes, for the associated process.</summary>
        <value>Die im Speicher maximal zulässige Workingsetgröße für den Prozess in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die aktuell sichtbaren an den Prozess im physischen Arbeitsspeicher. Diese Seiten sind resident und einer Anwendung verwenden, ohne einen Seitenfehler auslösen zur Verfügung.  
  
 Das Workingset enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die alle Anweisungen, die die Anwendung ausführt enthalten, u. a. die Seiten in der DLL-Dateien und die Dateien "System.dll". Das Workingset größer wird, erhöht sich Speicherbedarf.  
  
 Ein Prozess verfügt Mindest- und Höchstwerte des Workingsets. Jedes Mal, wenn eine Prozessressource erstellt ist, reserviert das System die Größe des Arbeitsspeichers, die gleich der workingsetmindestgröße für den Prozess. Der virtuelle Speicher-Manager versucht, mindestens die Mindestmenge an Arbeitsspeicher zu behalten residenten, wenn der Prozess aktiv ist, jedoch nie mehr als die maximale Größe.  
  
 Das System legt die Größen für Workingsets. Sie können ändern, diese Größe mit der <xref:System.Diagnostics.Process.MaxWorkingSet%2A> und <xref:System.Diagnostics.Process.MinWorkingSet%2A> Elemente. Allerdings garantiert Werten nicht, ob der Speicher reserviert oder resident sind.  
  
> [!NOTE]
>  Wenn Sie die Größe des Workingsets eines Prozesses erhöhen, gelangen Sie physischen Arbeitsspeicher Weg von der Rest des Systems an. Stellen Sie sicher, dass keine minimale oder maximale Workingsetgröße angefordert werden, die zu groß ist, da dies die Systemleistung beeinträchtigen kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The maximum working set size is invalid. It must be greater than or equal to the minimum working set size.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Working set information cannot be retrieved from the associated process resource.  -or-  The process identifier or process handle is zero because the process has not been started.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the minimum allowable working set size, in bytes, for the associated process.</summary>
        <value>Die im Speicher mindestens erforderliche Workingsetgröße für den Prozess in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die aktuell sichtbaren an den Prozess im physischen Arbeitsspeicher. Diese Seiten sind resident und einer Anwendung verwenden, ohne einen Seitenfehler auslösen zur Verfügung.  
  
 Das Workingset enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die alle Anweisungen, die die Anwendung ausführt enthalten, u. a. die Seiten in der DLL-Dateien und die Dateien "System.dll". Das Workingset größer wird, erhöht sich Speicherbedarf.  
  
 Ein Prozess verfügt Mindest- und Höchstwerte des Workingsets. Jedes Mal, wenn eine Prozessressource erstellt ist, reserviert das System die Größe des Arbeitsspeichers, die gleich der workingsetmindestgröße für den Prozess. Der virtuelle Speicher-Manager versucht, mindestens die Mindestmenge an Arbeitsspeicher zu behalten residenten, wenn der Prozess aktiv ist, jedoch nie mehr als die maximale Größe.  
  
 Das System legt die Größen für Workingsets. Sie können ändern, diese Größe mit der <xref:System.Diagnostics.Process.MaxWorkingSet%2A> und <xref:System.Diagnostics.Process.MinWorkingSet%2A> Elemente. Allerdings garantiert Werten nicht, ob der Speicher reserviert oder resident sind.  
  
> [!NOTE]
>  Wenn Sie die Größe des Workingsets eines Prozesses erhöhen, gelangen Sie physischen Arbeitsspeicher Weg von der Rest des Systems an. Stellen Sie sicher, dass keine minimale oder maximale Workingsetgröße angefordert werden, die zu groß ist, da dies die Systemleistung beeinträchtigen kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The minimum working set size is invalid. It must be less than or equal to the maximum working set size.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Working set information cannot be retrieved from the associated process resource.  -or-  The process identifier or process handle is zero because the process has not been started.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the modules that have been loaded by the associated process.</summary>
        <value>Ein Array vom Typ <see cref="T:System.Diagnostics.ProcessModule" />, das die vom zugeordneten Prozess geladenen Module darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Prozessmodul stellt DLL- oder .exe-Datei, die in einem bestimmten Prozess geladen wird. Ein <xref:System.Diagnostics.ProcessModule> Instanz können Sie Informationen zu einem Modul, einschließlich der Modulname, Dateiname und Arbeitsspeicher Moduldetails anzeigen.  
  
 Ein Prozess kann mehrere Module in den Arbeitsspeicher geladen werden. Beispielsweise haben .exe-Dateien, die zusätzliche DLL-Dateien laden, mehrere Module.  
  
 Nach dem Starten des Prozesses, ist dieser Auflistung leer, bis das System den Prozess geladen wurden. Wenn der Prozess über ein Hauptfenster verfügt, können Sie aufrufen <xref:System.Diagnostics.Process.WaitForInputIdle%2A> vor dem Abrufen dieser Eigenschaft, um sicherzustellen, dass die Auflistung nicht leeren beim Abrufen der Liste.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for either the system process or the idle process. These processes do not have modules.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</summary>
        <value>Der Arbeitsspeicher in Bytes, den das System für den zugehörigen Prozess belegt hat und der nicht in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</summary>
        <value>Der Anteil am Systemspeicher in Bytes, der für den zugeordneten Prozess reserviert ist und der nicht in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des nicht ausgelagerten Systemspeichers verwendet, die für den Prozess in Bytes dar. Systemspeicher ist der vom Betriebssystem verwendeten physikalischen Speichers und Durchschnittswert unterteilt ist. Nicht ausgelagerte Arbeitsspeicher verbleiben im Arbeitsspeicher und nicht die Auslagerungsdatei des virtuellen Speichers ausgelagert werden.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **Auslagerungsseiten (Bytes) Pool** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Raises the <see cref="E:System.Diagnostics.Process.Exited" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> die API-Methode, die auslöst wird die <xref:System.Diagnostics.Process.Exited> Ereignis. Aufrufen <xref:System.Diagnostics.Process.OnExited%2A> bewirkt, dass die <xref:System.Diagnostics.Process.Exited> Ereignis auftreten und ist die einzige Möglichkeit zum Auslösen von dem Ereignis mit der <xref:System.Diagnostics.Process> Komponente. <xref:System.Diagnostics.Process.OnExited%2A> wird hauptsächlich verwendet, wenn Klassen von der Komponente abgeleitet.  
  
 Als Alternative zur <xref:System.Diagnostics.Process.OnExited%2A>, Sie können einen eigenen Ereignishandler schreiben. Erstellen Sie eine eigene Ereignishandlerdelegaten und eine eigene Methode für die Ereignisbehandlung.  
  
> [!NOTE]
>  Bei Verwendung von Visual Studio-Umgebung ein Ereignishandlerdelegat (AddOnExited) und eine Ereignisbehandlungsmethode (Process1_Exited) werden erstellt, wenn Sie ziehen ein <xref:System.Diagnostics.Process> -Komponente auf das Formular, und doppelklicken Sie auf das Symbol ". Der Code zum Ausführen beim Erstellen der <xref:System.Diagnostics.Process.Exited> Ereignis tritt auf, in der Prozedur Process1_Exited eingegeben wird. Sie ist nicht erforderlich, erstellen die <xref:System.Diagnostics.Process.OnExited%2A> Member auf, da es für Sie implementiert wird.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Diagnostics.Process.OnExited%2A> Methode in einer abgeleiteten Klasse.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs each time an application writes a line to its redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis gibt an, dass die zugeordnete <xref:System.Diagnostics.Process> %medialocationinfo;) eine Zeile mit einem neue Zeilenumbruchzeichen in ihren umgeleiteten beendet <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  
  
 Das Ereignis wird während der asynchrone Lesevorgänge aktiviert, auf <xref:System.Diagnostics.Process.StandardOutput%2A>. Um asynchrone Lesevorgänge zu starten, müssen Sie Umleiten der <xref:System.Diagnostics.Process.StandardOutput%2A> Datenstrom von einer <xref:System.Diagnostics.Process>, den Ereignishandler zum Hinzufügen der <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis, und rufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. Danach ist die <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis signalisiert jedes Mal der Prozess eine Zeile in den umgeleiteten schreibt <xref:System.Diagnostics.Process.StandardOutput%2A> streamen, bis der Prozess beendet wird, oder ruft <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  Die Anwendung, die die asynchrone Ausgabe verarbeitet sollte Aufrufen der <xref:System.Diagnostics.Process.WaitForExit%2A> Methode, um sicherzustellen, dass der Ausgabepuffer geleert wurde.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie asynchrone Lesevorgänge im umgeleiteten auszuführenden <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, der die `ipconfig` Befehl.  
  
 Das Beispiel erstellt einen Delegaten für die `OutputHandler` Ereignishandler und ordnet sie der <xref:System.Diagnostics.Process.OutputDataReceived> Ereignis. Der Ereignishandler empfängt Textzeilen vom umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, den Text formatiert und speichert sie in eine Ausgabezeichenfolge, die weiter unten im Konsolenfenster im Beispiel gezeigt wird.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of paged memory, in bytes, allocated for the associated process.</summary>
        <value>Der Arbeitsspeicher in Bytes, den der zugehörige Prozess belegt und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of paged memory, in bytes, allocated for the associated process.</summary>
        <value>Die Größe des Arbeitsspeichers in Bytes, der für den zugeordneten Prozess in der Auslagerungsdatei des virtuellen Arbeitsspeichers belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des Arbeitsspeichers in die Auslagerungsdatei des virtuellen Speichers durch den Prozess in Bytes verwendet. Das Betriebssystem verwendet die Auslagerungsdatei des virtuellen Speichers in Verbindung mit physischem Arbeitsspeicher zum Verwalten des virtuellen Adressraums für jeden Prozess. Wenn auslagerbare Arbeitsspeicher nicht verwendet wird, können sie die Auslagerungsdatei des virtuellen Arbeitsspeichers auf dem Datenträger übertragen werden. Verwenden Sie zum Abrufen der Größe des Arbeitsspeichers, die vom Betriebssystem für den Prozess verwendet die <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> Eigenschaft.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **Seite Dateibytes** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung wird gestartet und klicken Sie dann abgerufen und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of pageable system memory, in bytes, allocated for the associated process.</summary>
        <value>Der Arbeitsspeicher in Bytes, den das System für den zugehörigen Prozess belegt hat und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of pageable system memory, in bytes, allocated for the associated process.</summary>
        <value>Der Anteil am Systemspeicher in Bytes, der für den zugeordneten Prozess belegt wird und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des auslagerbaren Systemspeichers verwendet, die für den Prozess in Bytes dar. Systemspeicher ist der vom Betriebssystem verwendeten physikalischen Speichers und Durchschnittswert unterteilt ist. Wenn auslagerbare Arbeitsspeicher nicht verwendet wird, können sie die Auslagerungsdatei des virtuellen Arbeitsspeichers auf dem Datenträger übertragen werden. Verwenden Sie zum Abrufen der Größe des vom Prozess verwendeten Anwendung der <xref:System.Diagnostics.Process.PagedMemorySize64%2A> Eigenschaft.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **Auslagerungsseiten (Bytes) Pool** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</summary>
        <value>Der maximale Arbeitsspeicher in Bytes, den der zugehörige Prozess belegt und der in die Auslagerungsdatei des virtuellen Speichers geschrieben werden kann.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</summary>
        <value>Die maximale Größe des Arbeitsspeichers in Bytes, der seit dem Starten für den zugeordneten Prozess in der Auslagerungsdatei des virtuellen Arbeitsspeichers belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft zurückgegebene Wert stellt die maximale Größe des Arbeitsspeichers in die Auslagerungsdatei des virtuellen Speichers durch den Prozess verwendet werden, da er, in Bytes gestartet dar. Das Betriebssystem verwendet die Auslagerungsdatei des virtuellen Speichers in Verbindung mit physischem Arbeitsspeicher zum Verwalten des virtuellen Adressraums für jeden Prozess. Wenn auslagerbare Arbeitsspeicher nicht verwendet wird, können sie die Auslagerungsdatei des virtuellen Arbeitsspeichers auf dem Datenträger übertragen werden.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **Seite Datei Bytes Peak** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of virtual memory, in bytes, used by the associated process.</summary>
        <value>Die maximale virtuelle Speicher in Bytes, der vom zugehörigen Prozess angefordert wurde.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of virtual memory, in bytes, used by the associated process.</summary>
        <value>Die maximale Größe des virtuellen Arbeitsspeichers in Bytes, der für den zugeordneten Prozess seit dem Starten belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die maximale Größe des virtuellen Arbeitsspeichers, die vom Prozess verwendet werden, da er, in Bytes gestartet dar. Das Betriebssystem ordnet des virtuellen Adressraums für jeden Prozess auf Seiten im physischen Speicher oder zu Seiten, die in die Auslagerungsdatei des virtuellen Speichers auf dem Datenträger gespeicherten geladen hat.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **virtuelle Bytes (max.)** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the peak working set size for the associated process, in bytes.</summary>
        <value>Die maximale Größe des physischen Speichers in Bytes, den der zugeordnete Prozess gleichzeitig angefordert hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die aktuell sichtbaren an den Prozess im physischen Arbeitsspeicher. Diese Seiten sind resident und einer Anwendung verwenden, ohne einen Seitenfehler auslösen zur Verfügung.  
  
 Das Workingset enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die alle Anweisungen, die der Prozess ausgeführt wird enthalten, einschließlich Prozessmodule und der Systembibliotheken.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of physical memory, in bytes, used by the associated process.</summary>
        <value>Die maximale Größe des physischen Speichers in Bytes, der für den zugeordneten Prozess seit dem Starten belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die maximale Größe der Menge Arbeitsspeicher vom Prozess verwendet werden, da er, in Bytes gestartet dar. Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die aktuell sichtbaren an den Prozess im physischen Arbeitsspeicher. Diese Seiten sind resident und einer Anwendung verwenden, ohne einen Seitenfehler auslösen zur Verfügung.  
  
 Das Workingset enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die alle Anweisungen, die der Prozess ausgeführt wird enthalten, einschließlich Anweisungen über die Prozessmodule und der Systembibliotheken.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **maximale Größe der Arbeitsseiten** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the associated process priority should temporarily be boosted by the operating system when the main window has the focus.</summary>
        <value>
          <see langword="true" />, wenn die Prozesspriorität eines Prozesses dynamisch erhöht werden soll, wenn dieser den Wartezustand verlässt; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Thread in einem Prozess für die die Prioritätsklasse einer der Enumerationswerte dynamische Priorität wurde ausgeführt wird (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, oder <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), erhöht das System vorübergehend die Priorität des Threads, wenn es einen Wartezustand verlässt angenommen wird. Diese Aktion verhindert, dass andere Prozesse die Verarbeitung des aktuellen Threads zu unterbrechen. Die <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Einstellung wirkt sich auf alle vorhandenen Threads und alle Threads, die anschließend durch den Prozess erstellt. Um das normale Verhalten wiederherzustellen, legen die <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Eigenschaft `false`.  
  
> [!NOTE]
>  Die Priorität zu stark angehoben, kann Ressourcen von wichtigen Betriebssystem- und Netzwerkfunktionen abgezogen werden, verursacht Probleme mit anderer betriebssystemtasks abzuleiten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Priority boost information could not be retrieved from the associated process resource.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the overall priority category for the associated process.</summary>
        <value>Die Prioritätskategorie für den zugeordneten Prozess, aus der die <see cref="P:System.Diagnostics.Process.BasePriority" /> des Prozesses berechnet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prioritätsklasse eines Prozesses umfasst einen Bereich von Prioritätsstufen Thread. Threads mit unterschiedlichen Prioritäten, die im Prozess ausgeführt werden, die relativ zu die Prioritätsklasse des Prozesses ausgeführt werden. Win32 verwendet vier Prioritätsklassen mit sieben Basisprioritätsebenen pro Klasse. Dieser Prozess Prioritätsklassen werden erfasst, der <xref:System.Diagnostics.ProcessPriorityClass> -Enumeration, die Sie können die Prozesspriorität auf festgelegt <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, oder <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. Basierend auf dem Zeitpunkt verstrichene anderen Prozessen, die Basisprioritätsebene vom Betriebssystem nicht geändert werden können, wenn ein Prozess muss vor anderen für den Zugriff auf den Prozessor abgelegt werden. Sie können außerdem festlegen der <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> zeitweilig die Prioritätsstufe der Threads erhöht, die den Wartezustand verlässt ausgeführt wurden. Die Priorität wird zurückgesetzt, wenn der Prozess in den Wartezustand zurückkehrt.  
  
 Die <xref:System.Diagnostics.Process.BasePriority%2A> -Eigenschaft können Sie die Startpriorität anzeigen, die an einen Prozess zugewiesen wird. Jedoch, da er schreibgeschützt ist, können keine der <xref:System.Diagnostics.Process.BasePriority%2A> Eigenschaft, um die Priorität eines Prozesses festzulegen. Verwenden Sie zum Ändern der Priorität der <xref:System.Diagnostics.Process.PriorityClass%2A> -Eigenschaft, die die allgemeine Prioritätskategorie für den Prozess festlegt oder abruft.  
  
 Die Prioritätsklasse kann nicht mithilfe des Systemmonitors angezeigt werden. Die folgende Tabelle zeigt die Beziehung zwischen der <xref:System.Diagnostics.Process.BasePriority%2A> und <xref:System.Diagnostics.Process.PriorityClass%2A> Werte.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Process priority information could not be set or retrieved from the associated process resource.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityClass" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <exception cref="T:System.PlatformNotSupportedException">You have set the <see cref="P:System.Diagnostics.Process.PriorityClass" /> to <see langword="AboveNormal" /> or <see langword="BelowNormal" /> when using Windows 98 or Windows Millennium Edition (Windows Me). These platforms do not support those values for the priority class.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Priority class cannot be set because it does not use a valid value, as defined in the <see cref="T:System.Diagnostics.ProcessPriorityClass" /> enumeration.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of private memory, in bytes, allocated for the associated process.</summary>
        <value>Die Anzahl der vom zugeordneten Prozess reservierten Bytes, die nicht mit anderen Prozessen gemeinsam genutzt werden können.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of private memory, in bytes, allocated for the associated process.</summary>
        <value>Die Größe des Speichers in Bytes, der für den zugeordneten Prozess belegt wird und nicht mit anderen Prozessen gemeinsam genutzt werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des belegten durch den Prozess in Bytes, der mit anderen Prozessen gemeinsam genutzt werden kann.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **Private Bytes** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the privileged processor time for this process.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die angibt, wie lange der Prozess im Betriebssystemkern Code ausgeführt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the process.</summary>
        <value>Der Name, mit dem das System den Prozess für den Benutzer kennzeichnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.ProcessName%2A> Eigenschaft enthält den Namen einer ausführbaren Datei an, z. B. Outlook, die der Erweiterung .exe oder den Pfad nicht enthalten. Es ist hilfreich zum Abrufen und Bearbeiten von alle Prozesse, die derselben ausführbaren Datei zugeordnet sind.  
  
> [!NOTE]
>  Auf [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] Betriebssysteme, die <xref:System.Diagnostics.Process.ProcessName%2A> Eigenschaft möglicherweise und 15 Zeichen abgeschnitten, wenn die Prozessinformationen für das Modul kann nicht abgerufen werden.  
  
 Sie können Aufrufen <xref:System.Diagnostics.Process.GetProcessesByName%2A>, und übergeben sie den Namen einer ausführbaren Datei an, um ein Array abzurufen, die jede ausgeführte Instanz auf dem angegebenen Computer enthält. Dieses Array ab, z. B. können Sie um alle ausgeführten Instanzen der ausführbaren Datei zu schließen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have an identifier, or no process is associated with the <see cref="T:System.Diagnostics.Process" />.  -or-  The associated process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">The process is not on this computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the processors on which the threads in this process can be scheduled to run.</summary>
        <value>Eine Bitmaske, die angibt, auf welchen Prozessoren die Threads im zugeordneten Prozess ausgeführt werden können. Der Standardwert hängt von der Anzahl der Prozessoren des Computers ab. Der Standardwert ist 2 <sup>n</sup> 1, wobei n die Anzahl der Prozessoren.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Windows 2000 und höher kann ein Thread in einem Prozess nach Prozessor, bei jeder Migration der Prozessorcache migrieren. Bei starker Auslastung kann angeben, welcher Prozessor einen bestimmten Thread ausgeführt werden soll Umfang zur Leistungssteigerung durch Verringern der Anzahl der Häufigkeit, mit der, die Cache des Prozessors geladen wird. Die Zuordnung zwischen einem Prozessor und ein Thread wird als Prozessoraffinität bezeichnet.  
  
 Jeder Prozessor wird als ein bit dargestellt. Bit 0 stellt einen Prozessor, Bit 1 ist Prozessor 2 usw. Wenn Sie ein wenig mit dem Wert 1 festlegen, wird der entsprechenden Prozessor für die Threadzuweisung ausgewählt. Beim Festlegen der <xref:System.Diagnostics.Process.ProcessorAffinity%2A> Wert auf 0 (null), das Betriebssystem der Algorithmen festlegen die Threadaffinität planen. Wenn die <xref:System.Diagnostics.Process.ProcessorAffinity%2A> Wert auf einen Wert ungleich NULL festgelegt ist, wird der Wert als Bitmaske aus, die die infrage kommenden Prozessoren angibt interpretiert.  
  
 Die folgende Tabelle zeigt eine Auswahl von <xref:System.Diagnostics.Process.ProcessorAffinity%2A> Werte für ein System mit acht Prozessoren.  
  
|Bitmaske|Binärer Wert|Verfügbare Prozessoren|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 und 2|  
|0x0007|00000000 00000111|1, 2 und 3|  
|0x0009|00000000 00001001|1 bis 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 und 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> information could not be set or retrieved from the associated process resource.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> was not available.  -or-  The process has exited.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Discards any information about the associated process that has been cached inside the process component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem <xref:System.Diagnostics.Process.Refresh%2A> aufgerufen wird, um die erste Anforderung für Informationen über jede Eigenschaft führt dazu, dass der Process-Komponente, um einen neuen Wert aus den zugeordneten Prozess abzurufen.  
  
 Wenn eine <xref:System.Diagnostics.Process> Komponente bezieht sich auf eine Prozessressource, die Eigenschaftswerte der <xref:System.Diagnostics.Process> werden sofort nach dem Status des zugeordneten Prozesses aufgefüllt. Wenn die Informationen über den zugeordneten Prozess anschließend geändert wird, werden diese Änderungen nicht berücksichtigt die <xref:System.Diagnostics.Process> Komponente zwischengespeicherte Werte. Die <xref:System.Diagnostics.Process> Komponente ist eine Momentaufnahme der der Prozessressource, zu dem Zeitpunkt, der sie zugeordnet sind. Um die aktuellen Werte für den zugeordneten Prozess anzuzeigen, rufen die <xref:System.Diagnostics.Process.Refresh%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Anschließend wird die Auslastung des physischen Speichers des zugeordneten Prozesses abgerufen, alle 2 Sekunden maximal 10 Sekunden. Im Beispiel wird ermittelt, ob der Prozess beendet wird, bevor 10 Sekunden vergangen sind. Im Beispiel wird der Prozess beendet, wenn er nach 10 Sekunden immer noch ausgeführt wird.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the user interface of the process is responding.</summary>
        <value>
          <see langword="true" />, wenn die Benutzeroberfläche des zugeordneten Prozesses auf das System reagiert; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Prozess eine Benutzeroberfläche verfügt die <xref:System.Diagnostics.Process.Responding%2A> Eigenschaft kontaktiert die Benutzeroberfläche, um festzustellen, ob der Prozess auf Benutzereingaben reagiert. Wenn die Schnittstelle nicht sofort, reagiert die <xref:System.Diagnostics.Process.Responding%2A> -Eigenschaft gibt `false`. Verwenden Sie diese Eigenschaft, um zu bestimmen, ob die Benutzeroberfläche des zugeordneten Prozesses reagiert.  
  
 Wenn der Prozess keine <xref:System.Diagnostics.Process.MainWindowHandle%2A>, gibt diese Eigenschaft `true`.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.Responding" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle to this process.</summary>
        <value>Das systemeigene Handle dieses Prozesses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Handle ist nur verfügbar, wenn die aufrufende Komponente der Prozess gestartet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Terminal Services session identifier for the associated process.</summary>
        <value>Die Terminaldienste-Sitzungs-ID für den zugeordneten Prozess.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Diagnostics.Process.SessionId%2A> Eigenschaft identifiziert die Sitzung, in dem die Anwendung derzeit ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">There is no session associated with this process.</exception>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this session identifier.  -or-  The associated process is not on this machine.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The <see cref="P:System.Diagnostics.Process.SessionId" /> property is not supported on Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to read the error output of the application.</summary>
        <value>Ein <see cref="T:System.IO.StreamReader" /> zum Lesen des Standardfehlerstreams der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Diagnostics.Process> schreibt Text in seinen Stream Standardfehler Text normalerweise in der Konsole angezeigt wird. Durch das Umleiten der <xref:System.Diagnostics.Process.StandardError%2A> Stream, können Sie bearbeiten oder die Fehlerausgabe eines Prozesses zu unterdrücken. Sie können z. B. den Text zu filtern, unterschiedlich zu formatieren oder Schreiben der Ausgabe in der Konsole und einer angegebenen Protokolldatei.  
  
> [!NOTE]
>  Mit <xref:System.Diagnostics.Process.StandardError%2A>, müssen Sie festlegen <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> auf `false`, und legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> auf `true`. Lesen, andernfalls aus den <xref:System.Diagnostics.Process.StandardError%2A> Datenstrom löst eine Ausnahme aus.  
  
 Die umgeleiteten <xref:System.Diagnostics.Process.StandardError%2A> Stream gelesen werden kann, synchron oder asynchron. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, und <xref:System.IO.StreamReader.ReadToEnd%2A> führen synchrone Lesevorgänge auf den Fehlerausgabestream des Prozesses. Diese synchrone Vorgänge werden abgeschlossen, bis das zugeordnete lesen <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardError%2A> stream oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> startet asynchrone Lesevorgänge auf die <xref:System.Diagnostics.Process.StandardError%2A> Stream. Diese Methode ermöglicht es einen angegebenen Ereignishandler für die Streamausgabe und an den Aufrufer, der andere Aufgaben ausführen kann, während die Streamausgabe an den Ereignishandler geleitet wird sofort zurückgegeben.  
  
 Synchrone Lesevorgänge verursachen eine Abhängigkeit zwischen dem Aufrufer, die beim Lesen der <xref:System.Diagnostics.Process.StandardError%2A> Stream und das untergeordnete Element das Schreiben in diesem Datenstrom zu verarbeiten. Diese Abhängigkeiten können dazu führen, dass Deadlockbedingungen. Wenn der Aufrufer aus dem umgeleiteten Stream eines untergeordneten Prozesses liest, ist es das untergeordnete Element abhängig. Der Aufrufer wartet auf den Lesevorgang, bis das untergeordnete Element in den Stream schreibt oder den Stream schließt. Wenn der untergeordnete Prozess genügend Daten zum Füllen von dessen umgeleiteten Streams schreibt, ist es das übergeordnete Element abhängig. Der untergeordnete Prozess wartet auf die nächste Schreibvorgang, bis das übergeordnete Element aus dem vollständigen Stream gelesen oder den Stream schließt. Die Deadlockbedingung entsteht, wenn es sich bei dem Aufrufer und dem untergeordneten Prozess, auf einander warten, um einen Vorgang abzuschließen, und weder fortgesetzt werden kann. Sie können Deadlocks vermeiden, durch das Auswerten von Abhängigkeiten zwischen dem Aufrufer und dem untergeordneten Prozess.  
  
 Der folgende C#-Code veranschaulicht z. B. aus einem umgeleiteten Stream lesen und Warten auf den untergeordneten Prozess zu beenden.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 Im Codebeispiel wird eine Deadlockbedingung vermieden, durch den Aufruf `p.StandardError.ReadToEnd` vor `p.WaitForExit`. Eine Deadlock kann dazu führen, wenn das übergeordnete Element Aufrufe verarbeiten `p.WaitForExit` vor `p.StandardError.ReadToEnd` und der untergeordneten Prozess genug Text zum Füllen des umgeleiteten Streams schreibt. Der übergeordnete Prozess würde unbegrenzt warten, für den untergeordneten Prozess zu beenden. Der untergeordnete Prozess würde unbegrenzt warten, für das übergeordnete Element gelesen werden, die vollständige <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Es wird ein ähnliches Problem beim Lesen von Text in die Standardausgabe und der Standardfehler des Streams. Der folgende C#-Code, führt z. B. einen Lesevorgang für beide Streams.  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 Im Codebeispiel wird die Deadlockbedingung vermieden, indem asynchrone Lesevorgänge auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Eine Deadlock führt, wenn das übergeordnete Element Aufrufe verarbeiten `p.StandardOutput.ReadToEnd` gefolgt von `p.StandardError.ReadToEnd` und der untergeordneten Prozess genug Text zum Füllen des Fehlerstreams schreibt. Der übergeordnete Prozess würde unbegrenzt warten, für den untergeordneten Prozess zu schließen die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Der untergeordnete Prozess würde unbegrenzt warten, für das übergeordnete Element gelesen werden, die vollständige <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Sie können asynchrone Lesevorgänge verwenden, um diese Abhängigkeiten und deren potenzielle Deadlocks zu vermeiden. Alternativ können Sie die Deadlockbedingung vermeiden, indem zwei Threads erstellen und Lesen der Ausgabe der einzelnen Streams in einem separaten Thread.  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge im umgeleiteten-Stream nicht mischen. Einmal im umgeleiteten Stream eine <xref:System.Diagnostics.Process> geöffnet wird im asynchronen oder synchronen Modus alle weiterlesen Vorgänge für diesen Datenstrom müssen sich im gleichen Modus beziehen. Folgen Sie z. B. nicht <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> mit einem Aufruf von <xref:System.IO.StreamReader.ReadLine%2A> auf die <xref:System.Diagnostics.Process.StandardError%2A> Stream, oder umgekehrt. Allerdings können Sie zwei verschiedene Streams in unterschiedlichen Modi lesen. Sie können z. B. Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> und rufen dann <xref:System.IO.StreamReader.ReadLine%2A> für die <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `net use` Befehl zusammen mit einem Benutzer bereitgestellte Argument eine Netzwerkressource zugeordnet. Anschließend liest der Standardfehlerstream des Befehls net und in die Konsole schreibt.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to write the input of the application.</summary>
        <value>Ein <see cref="T:System.IO.StreamWriter" /> zum Schreiben des Standardeingabestreams der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Diagnostics.Process> seine Standardeingabestream in der Regel auf der Tastatur Eingabetext auslesen können. Durch das Umleiten der <xref:System.Diagnostics.Process.StandardInput%2A> Stream, können Sie die Eingabe programmgesteuert angeben. Beispielsweise können Sie anstelle von Tastatureingaben Text aus dem Inhalt einer angegebenen Datei oder die Ausgabe aus einer anderen Anwendung bereitstellen.  
  
> [!NOTE]
>  Mit <xref:System.Diagnostics.Process.StandardInput%2A>, müssen Sie festlegen <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> auf `false`, und legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> auf `true`. Andernfalls Schreiben in die <xref:System.Diagnostics.Process.StandardInput%2A> Datenstrom löst eine Ausnahme aus.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Umleiten der <xref:System.Diagnostics.Process.StandardInput%2A> Stream eines Prozesses. Das Beispiel beginnt die `sort` -Befehl mit umgeleiteter Eingabe. Anschließend fordert den Benutzer für den Text, und übergibt dieses an die `sort` Prozess über den umgeleiteten <xref:System.Diagnostics.Process.StandardInput%2A> Stream. Die `sort` Ergebnisse werden an den Benutzer in der Konsole angezeigt.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardInput" /> stream has not been defined because <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> is set to <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to read the textual output of the application.</summary>
        <value>Ein <see cref="T:System.IO.StreamReader" /> zum Lesen des Standardausgabestreams der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Diagnostics.Process> schreibt Text in seinen Standardstream Text normalerweise in der Konsole angezeigt wird. Durch das Umleiten der <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, können Sie bearbeiten oder die Ausgabe eines Prozesses zu unterdrücken. Sie können z. B. den Text zu filtern, unterschiedlich zu formatieren oder Schreiben der Ausgabe in der Konsole und einer angegebenen Protokolldatei.  
  
> [!NOTE]
>  Mit <xref:System.Diagnostics.Process.StandardOutput%2A>, müssen Sie festlegen <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> auf `false`, und legen Sie <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> auf `true`. Lesen, andernfalls aus den <xref:System.Diagnostics.Process.StandardOutput%2A> Datenstrom löst eine Ausnahme aus.  
  
 Die umgeleiteten <xref:System.Diagnostics.Process.StandardOutput%2A> Stream gelesen werden kann, synchron oder asynchron. Methoden, z. B. <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, und <xref:System.IO.StreamReader.ReadToEnd%2A> führen synchrone Lesevorgänge im Ausgabestream des Prozesses. Diese synchrone Vorgänge werden abgeschlossen, bis das zugeordnete lesen <xref:System.Diagnostics.Process> schreibt in seine <xref:System.Diagnostics.Process.StandardOutput%2A> stream oder schließt den Stream.  
  
 Im Gegensatz dazu <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> startet asynchrone Lesevorgänge auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Diese Methode ermöglicht es einen angegebenen Ereignishandler für die Streamausgabe und an den Aufrufer, der andere Aufgaben ausführen kann, während die Streamausgabe an den Ereignishandler geleitet wird sofort zurückgegeben.  
  
 Synchrone Lesevorgänge verursachen eine Abhängigkeit zwischen dem Aufrufer, die beim Lesen der <xref:System.Diagnostics.Process.StandardOutput%2A> Stream und das untergeordnete Element das Schreiben in diesem Datenstrom zu verarbeiten. Diese Abhängigkeiten können dazu führen, dass Deadlockbedingungen. Wenn der Aufrufer aus dem umgeleiteten Stream eines untergeordneten Prozesses liest, ist es das untergeordnete Element abhängig. Der Aufrufer wartet auf den Lesevorgang, bis das untergeordnete Element in den Stream schreibt oder den Stream schließt. Wenn der untergeordnete Prozess genügend Daten zum Füllen von dessen umgeleiteten Streams schreibt, ist es das übergeordnete Element abhängig. Der untergeordnete Prozess wartet auf die nächste Schreibvorgang, bis das übergeordnete Element aus dem vollständigen Stream gelesen oder den Stream schließt. Die Deadlockbedingung entsteht, wenn es sich bei dem Aufrufer und dem untergeordneten Prozess, auf einander warten, um einen Vorgang abzuschließen, und weder fortgesetzt werden kann. Sie können Deadlocks vermeiden, durch das Auswerten von Abhängigkeiten zwischen dem Aufrufer und dem untergeordneten Prozess.  
  
 Der folgende C#-Code veranschaulicht z. B. aus einem umgeleiteten Stream lesen und Warten auf den untergeordneten Prozess zu beenden.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 Im Codebeispiel wird eine Deadlockbedingung vermieden, durch den Aufruf `p.StandardOutput.ReadToEnd` vor `p.WaitForExit`. Eine Deadlock kann dazu führen, wenn das übergeordnete Element Aufrufe verarbeiten `p.WaitForExit` vor `p.StandardOutput.ReadToEnd` und der untergeordneten Prozess genug Text zum Füllen des umgeleiteten Streams schreibt. Der übergeordnete Prozess würde unbegrenzt warten, für den untergeordneten Prozess zu beenden. Der untergeordnete Prozess würde unbegrenzt warten, für das übergeordnete Element gelesen werden, die vollständige <xref:System.Diagnostics.Process.StandardOutput%2A> Stream.  
  
 Es wird ein ähnliches Problem beim Lesen von Text in die Standardausgabe und der Standardfehler des Streams. Der folgende C#-Code, führt z. B. einen Lesevorgang für beide Streams.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 Im Codebeispiel wird die Deadlockbedingung vermieden, indem asynchrone Lesevorgänge auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Eine Deadlock führt, wenn das übergeordnete Element Aufrufe verarbeiten `p.StandardOutput.ReadToEnd` gefolgt von `p.StandardError.ReadToEnd` und der untergeordneten Prozess genug Text zum Füllen des Fehlerstreams schreibt. Der übergeordnete Prozess würde unbegrenzt warten, für den untergeordneten Prozess zu schließen die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream. Der untergeordnete Prozess würde unbegrenzt warten, für das übergeordnete Element gelesen werden, die vollständige <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
 Sie können asynchrone Lesevorgänge verwenden, um diese Abhängigkeiten und deren potenzielle Deadlocks zu vermeiden. Alternativ können Sie die Deadlockbedingung vermeiden, indem zwei Threads erstellen und Lesen der Ausgabe der einzelnen Streams in einem separaten Thread.  
  
> [!NOTE]
>  Sie können asynchrone und synchrone Lesevorgänge im umgeleiteten-Stream nicht mischen. Einmal im umgeleiteten Stream eine <xref:System.Diagnostics.Process> geöffnet wird im asynchronen oder synchronen Modus alle weiterlesen Vorgänge für diesen Datenstrom müssen sich im gleichen Modus beziehen. Folgen Sie z. B. nicht <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> mit einem Aufruf von <xref:System.IO.StreamReader.ReadLine%2A> auf die <xref:System.Diagnostics.Process.StandardOutput%2A> Stream, oder umgekehrt. Allerdings können Sie zwei verschiedene Streams in unterschiedlichen Modi lesen. Sie können z. B. Aufrufen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> und rufen dann <xref:System.IO.StreamReader.ReadLine%2A> für die <xref:System.Diagnostics.Process.StandardError%2A> Stream.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das ipconfig.exe-Befehl ausgeführt und leitet die Standardausgabe Konsolenfenster das Beispiel.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Starts a process resource and associates it with a <see cref="T:System.Diagnostics.Process" /> component.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts (or reuses) the process resource that is specified by the <see cref="P:System.Diagnostics.Process.StartInfo" /> property of this <see cref="T:System.Diagnostics.Process" /> component and associates it with the component.</summary>
        <returns>
          <see langword="true" /> if a process resource is started; <see langword="false" /> if no new process resource is started (for example, if an existing process is reused).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Prozessressource gestartet, und ordnen es dem aktuellen <xref:System.Diagnostics.Process> Komponente. Der Rückgabewert `true` gibt an, dass eine neue Prozessressource gestartet wurde. Wenn die Prozessressource, wird angegeben die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Mitglied der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft bereits auf dem Computer ausgeführt wird, keine zusätzliche Prozessressource gestartet wird. Stattdessen die laufende Prozessressource wiederverwendet und `false` wird zurückgegeben.  
  
 Sie können eine ClickOnce-Anwendung starten, indem Sie die Angabe des Speicherorts (z. B. eine Webadresse), von dem Sie die Anwendung ursprünglich installiert. Starten Sie eine ClickOnce-Anwendung nicht durch Angabe der entsprechenden Speicherort auf der Festplatte freigeben.  
  
> [!NOTE]
>  Bei Verwendung von Visual Studio diese Überladung von der <xref:System.Diagnostics.Process.Start%2A> Methode ist dasjenige, das Sie in Ihren Code einzufügen, nachdem Sie ziehen ein <xref:System.Diagnostics.Process> -Komponente in den Designer. Verwenden der `Properties` Fenster zu erweitern die `StartInfo` Kategorie und Schreiben Sie den entsprechenden Wert in der `FileName` Eigenschaft. Ihre Änderungen werden angezeigt, in der Form `InitializeComponent` Prozedur.  
  
 Diese Überladung der <xref:System.Diagnostics.Process.Start%2A> ist eine `static` Methode. Sie müssen von einer Instanz von Aufrufen der <xref:System.Diagnostics.Process> Klasse. Vor dem Aufruf <xref:System.Diagnostics.Process.Start%2A>, müssen Sie zuerst angeben <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschafteninformationen für diese <xref:System.Diagnostics.Process> Instanz, da diese Informationen verwendet wird, um zu bestimmen, die Prozessressource gestartet.  
  
 Andere Überladungen der der <xref:System.Diagnostics.Process.Start%2A> Methode sind `static` Mitglieder. Sie müssen nicht zum Erstellen einer Instanz von der <xref:System.Diagnostics.Process> Komponente vor dem Aufrufen dieser Überladungen der Methode. Rufen Sie stattdessen <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> selbst und eine neue Klasse <xref:System.Diagnostics.Process> -Komponente erstellt wird, wenn der Prozess gestartet wurde. Oder, `null` wird zurückgegeben, wenn ein Prozess wiederverwendet wurde. Die Process-Ressource wird automatisch zugeordnet, mit dem neuen <xref:System.Diagnostics.Process> Komponente, die von zurückgegeben wird die <xref:System.Diagnostics.Process.Start%2A> Methode.  
  
 Die <xref:System.Diagnostics.Process.StartInfo%2A> Elemente können verwendet werden, die Funktionalität des Duplizieren der `Run` Dialogfeld des Windows- `Start` Menü. Elemente, die in einer Befehlszeile eingegeben werden, können die gestartet werden kann, durch Festlegen der entsprechenden Werte der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft. Die einzige <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft, die festgelegt werden muss, ist die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft. Die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft hat keine ausführbare Datei sein. Sie können einen beliebigen Dateityp werden für die die Erweiterung einer Anwendung zugeordnet wurde, die auf dem System installiert ist. Z. B. die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft kann die Erweiterung ".txt" aufweisen, wenn Sie Textdateien in einem Editor wie dem Editor zugeordnet oder die Erweiterung DOC haben DOC-Dateien mit einem Textverarbeitungsprogramm wie Microsoft Word.  
  
 In der Befehlszeile können Sie Aktionen an, die für bestimmte Typen von Dateien angeben. Sie können beispielsweise Drucken von Dokumenten oder Textdateien bearbeiten. Geben Sie diese Aktionen mit den <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Mitglied der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft. Für andere Typen von Dateien, können Sie Befehlszeilenargumente angeben, wenn Sie die Datei aus starten der `Run` (Dialogfeld). Angenommen, Sie können übergeben eine URL als Argument bei Angabe von Ihrem Browser als die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Diese Argumente können angegeben werden, der <xref:System.Diagnostics.Process.StartInfo%2A> der Eigenschaft <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Member.  
  
 Wenn Sie eine Path-Variablen, die in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie, dass der Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad, und fügen Sie ihn in Anführungszeichen gesetzt: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess im vollständig qualifizieren `c:\mypath` beim Starten.  
  
> [!NOTE]
>  ASP.NET Web Seiten- und Server-Steuerelement-Code wird im Rahmen der ASP.NET-Arbeitsprozess auf dem Webserver ausgeführt.  Bei Verwendung der <xref:System.Diagnostics.Process.Start%2A> Methode in einer ASP.NET-Webseite oder Serversteuerelement, der neue Prozess ausgeführt wird, auf dem Webserver mit eingeschränkten Berechtigungen. Der Prozess wird nicht in demselben Kontext wie der Clientbrowser gestartet und hat keinen Zugriff auf dem Desktop des Benutzers.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen sie zu schließen, oder Sie riskieren Systemressourcen verfügbar sind. Schließen Prozesse mit <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft.  
  
 Hier ist ein Hinweis zum Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true` in der Prozesskomponente <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, stellen Sie sicher, dass ein Threadingmodell für die Anwendung festgelegt haben, indem das Attribut `[STAThread]` auf die `main()` Methode. Andernfalls kann ein verwalteter Thread in ein `unknown` Zustand, oder fügen Sie in der `MTA` aufweist, was zu einem Konflikt mit letztere <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> wird `true`. Einige Methoden erfordern, dass der Apartmentzustand nicht `unknown`. Wenn der Zustand nicht explizit festgelegt wird, wenn die Anwendung eine solche Methode auftritt, wird standardmäßig `MTA`, einmal festgelegt, kann der Apartmentzustand geändert werden. Allerdings `MTA` löst eine Ausnahme ausgelöst wird, wenn die Betriebssystemshell, den Thread verwaltet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von der <xref:System.Diagnostics.Process> Klasse, um einen Prozess zu starten.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified in the <see cref="T:System.Diagnostics.Process" /> component's <see cref="P:System.Diagnostics.Process.StartInfo" />.
-or- The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> member of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property is <see langword="true" /> while <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that contains the information that is used to start the process, including the file name and any command-line arguments.</param>
        <summary>Starts the process resource that is specified by the parameter containing process start information (for example, the file name of the process to start) and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, starten Sie eine Prozessressource durch Angeben einer <xref:System.Diagnostics.ProcessStartInfo> Instanz. Die Überladung ordnet die Ressource einer neuen <xref:System.Diagnostics.Process> Objekt.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei, starten Sie eine URL ist, wird der Prozess nicht gestartet und `null` wird zurückgegeben.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne zuerst erstellt ein neues <xref:System.Diagnostics.Process> Instanz. Verwendung dieser Überladung mit einer <xref:System.Diagnostics.ProcessStartInfo> Parameter ist eine Alternative zu den einzelnen Schritten beim Erstellen eines neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen seiner <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaften, und der Aufruf <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Mithilfe einer <xref:System.Diagnostics.ProcessStartInfo> -Instanz als Parameter Sie die aufrufen können <xref:System.Diagnostics.Process.Start%2A> mit mehr Kontrolle über was an den Aufruf zum Starten des Prozesses übergeben wird. Wenn Sie nur einen Dateinamen oder einen Dateinamen und Argumente übergeben müssen, ist es nicht erforderlich, zum Erstellen eines neuen <xref:System.Diagnostics.ProcessStartInfo> Instanz, obwohl dies möglich ist. Die einzige <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> Eigenschaft, die festgelegt werden muss, ist die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft. Die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft muss es sich nicht um eine ausführbare Datei darzustellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung einer Anwendung zugeordnet wurde, die auf dem System installiert ist. Z. B. die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft kann die Erweiterung ".txt" aufweisen, wenn Sie Textdateien in einem Editor wie dem Editor zugeordnet oder die Erweiterung DOC haben DOC-Dateien mit einem Textverarbeitungsprogramm wie Microsoft Word.  
  
 Sie können eine ClickOnce-Anwendung starten, indem Sie die Angabe des Speicherorts (z. B. eine Webadresse), von dem Sie die Anwendung ursprünglich installiert. Starten Sie eine ClickOnce-Anwendung nicht durch Angabe der entsprechenden Speicherort auf der Festplatte freigeben.  
  
 Wenn die <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> und <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> Eigenschaften der <xref:System.Diagnostics.Process.StartInfo%2A> Instanz festgelegt werden, die nicht verwaltete `CreateProcessWithLogonW` Funktion aufgerufen wird, die den Prozess in einem neuen Fenster, selbst wenn startet die <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> Eigenschaftswert ist `true` oder die <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> Eigenschaftswert ist <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Wenn die <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> Eigenschaft ist `null`, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> -Eigenschaft muss im UPN-Format sein *Benutzer*@*DNS-Domänenname*.   
  
 Im Gegensatz zu anderen Überladungen, die Überladung der <xref:System.Diagnostics.Process.Start%2A> weist keine Parameter auf, die keine `static` Member. Verwenden Sie diese Überladung, wenn Sie bereits erstellt haben eine <xref:System.Diagnostics.Process> -Instanz werden angegebene Startinformationen (einschließlich des Dateinamens), und möchten eine Prozessressource gestartet, und verknüpfen Sie sie mit der vorhandenen <xref:System.Diagnostics.Process> Instanz. Gehen Sie die `static` überlädt, wenn Sie möchten, dass zum Erstellen eines neuen <xref:System.Diagnostics.Process> -Komponente statt Starten eines Prozesses für eine vorhandene Komponente. Diese Überladung und die Überladung, die keine Parameter hat ermöglichen Ihnen die Angabe der Startinformationen für den Process-Ressource mit einer <xref:System.Diagnostics.ProcessStartInfo> Instanz.  
  
 Wenn Sie eine Path-Variablen, die in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie, dass der Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad, und fügen Sie ihn in Anführungszeichen gesetzt: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess im vollständig qualifizieren `c:\mypath` beim Starten.  
  
> [!NOTE]
>  ASP.NET Web Seiten- und Server-Steuerelement-Code wird im Rahmen der ASP.NET-Arbeitsprozess auf dem Webserver ausgeführt.  Bei Verwendung der <xref:System.Diagnostics.Process.Start%2A> Methode in einer ASP.NET-Webseite oder Serversteuerelement, der neue Prozess ausgeführt wird, auf dem Webserver mit eingeschränkten Berechtigungen. Der Prozess wird nicht in demselben Kontext wie der Clientbrowser gestartet und hat keinen Zugriff auf dem Desktop des Benutzers.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen sie zu schließen, oder Sie riskieren Systemressourcen verfügbar sind. Schließen Prozesse mit <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft.  
  
 Hier ist ein Hinweis zum Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true` auf die `startInfo` Parameter, stellen Sie sicher, dass ein Threadingmodell für die Anwendung festgelegt haben, indem das Attribut `[STAThread]` auf die `main()` Methode. Andernfalls kann ein verwalteter Thread in ein `unknown` Zustand, oder fügen Sie in der `MTA` aufweist, was zu einem Konflikt mit letztere <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> wird `true`. Einige Methoden erfordern, dass der Apartmentzustand nicht `unknown`. Wenn der Zustand nicht explizit festgelegt wird, wenn die Anwendung eine solche Methode auftritt, wird standardmäßig `MTA`, einmal festgelegt, kann der Apartmentzustand geändert werden. Allerdings `MTA` löst eine Ausnahme ausgelöst wird, wenn die Betriebssystemshell, den Thread verwaltet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zunächst eine Instanz von Internet Explorer erzeugt und zeigt den Inhalt des Ordners Favoriten im Browser. Klicken Sie dann weitere Instanzen von Internet Explorer gestartet, und bestimmte Seiten oder Sites angezeigt. Schließlich wird Internet Explorer gestartet, mit dem Fenster beim Navigieren zu einem bestimmten Standort minimiert wird.  
  
 Weitere Beispiele für andere Verwendungen dieser Methode finden Sie in die einzelnen Eigenschaften der <xref:System.Diagnostics.ProcessStartInfo> Klasse.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property.  -or-  The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is also <see langword="true" />.  -or-  The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> property is not <see langword="null" /> or empty or the <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> property is not <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="startInfo" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property could not be found.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the process exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of a document or application file to run in the process.</param>
        <summary>Starts a process resource by specifying the name of a document or application file and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Prozessressource durch Angeben des Dateinamens zu starten. Die Überladung ordnet die Ressource einer neuen <xref:System.Diagnostics.Process> Objekt.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei, starten Sie eine URL ist, wird der Prozess nicht gestartet und `null` wird zurückgegeben.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne zuerst erstellt ein neues <xref:System.Diagnostics.Process> Instanz. Die Überladung ist eine Alternative zu den einzelnen Schritten für die Erstellung einer neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Mitglied der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, und der Aufruf <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Sie können eine ClickOnce-Anwendung starten, indem die `fileName` Parameter auf den Speicherort (z. B. eine Webadresse), die von der Sie die Anwendung ursprünglich installiert haben. Starten Sie eine ClickOnce-Anwendung nicht durch Angabe der entsprechenden Speicherort auf der Festplatte freigeben.  
  
 Starten eines Prozesses durch Angabe des Dateinamens ähnelt dem Eingeben der Informationen in den `Run` Dialogfeld des Windows- `Start` Menü. Aus diesem Grund muss der Dateiname nicht ausführbare Datei darstellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung mit einer Anwendung, die auf dem System installierten zugeordnet wurde. Kann z. B. der Dateinamen die Erweiterung ".txt" aufweisen, wenn Textdateien in einem Editor wie dem Editor zugeordnet oder die .doc haben DOC-Dateien mit einem Textverarbeitungsprogramm wie Microsoft Word. Auf ähnliche Weise, in der gleichen Weise wie die `Run` Dialogfeld Name einer ausführbaren Datei mit oder ohne die Erweiterung .exe akzeptiert, ist die Erweiterung .exe in optional die `fileName` Parameter. Sie können z. B. Festlegen der `fileName` Parameter für "Notepad.exe" oder "Editor".  
  
 Diese Überladung lässt keine Befehlszeilenargumente für den Prozess. Wenn Sie Befehlszeilenargumente für den Prozess angeben müssen, verwenden Sie die <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> oder <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> Überladungen.  
  
 Im Gegensatz zu anderen Überladungen, die Überladung der <xref:System.Diagnostics.Process.Start%2A> weist keine Parameter auf, die keine `static` Member. Verwenden Sie diese Überladung, wenn Sie bereits erstellt haben eine <xref:System.Diagnostics.Process> -Instanz werden angegebene Startinformationen (einschließlich des Dateinamens), und möchten eine Prozessressource gestartet, und verknüpfen Sie sie mit der vorhandenen <xref:System.Diagnostics.Process> Instanz. Gehen Sie die `static` überlädt, wenn Sie möchten, dass zum Erstellen eines neuen <xref:System.Diagnostics.Process> -Komponente statt Starten eines Prozesses für eine vorhandene Komponente. Diese Überladung und die Überladung, die keine Parameter hat ermöglichen Ihnen das Festlegen der Dateiname der der Prozessressource gestartet.  
  
 Wenn Sie eine Path-Variablen, die in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie, dass der Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad, und fügen Sie ihn in Anführungszeichen gesetzt: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess im vollständig qualifizieren `c:\mypath` beim Starten.  
  
> [!NOTE]
>  ASP.NET Web Seiten- und Server-Steuerelement-Code wird im Rahmen der ASP.NET-Arbeitsprozess auf dem Webserver ausgeführt.  Bei Verwendung der <xref:System.Diagnostics.Process.Start%2A> Methode in einer ASP.NET-Webseite oder Serversteuerelement, der neue Prozess ausgeführt wird, auf dem Webserver mit eingeschränkten Berechtigungen. Der Prozess wird nicht in demselben Kontext wie der Clientbrowser gestartet und hat keinen Zugriff auf dem Desktop des Benutzers.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen sie zu schließen, oder Sie riskieren Systemressourcen verfügbar sind. Schließen Prozesse mit <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft.  
  
 Hier ist ein Hinweis zum Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true` in der Prozesskomponente <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, stellen Sie sicher, dass ein Threadingmodell für die Anwendung festgelegt haben, indem das Attribut `[STAThread]` auf die `main()` Methode. Andernfalls kann ein verwalteter Thread in ein `unknown` Zustand, oder fügen Sie in der `MTA` aufweist, was zu einem Konflikt mit letztere <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> wird `true`. Einige Methoden erfordern, dass der Apartmentzustand nicht `unknown`. Wenn der Zustand nicht explizit festgelegt wird, wenn die Anwendung eine solche Methode auftritt, wird standardmäßig `MTA`, einmal festgelegt, kann der Apartmentzustand geändert werden. Allerdings `MTA` löst eine Ausnahme ausgelöst wird, wenn die Betriebssystemshell, den Thread verwaltet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zunächst eine Instanz von Internet Explorer erzeugt und zeigt den Inhalt des Ordners Favoriten im Browser. Klicken Sie dann weitere Instanzen von Internet Explorer gestartet, und bestimmte Seiten oder Sites angezeigt. Schließlich wird Internet Explorer gestartet, mit dem Fenster beim Navigieren zu einem bestimmten Standort minimiert wird.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The PATH environment variable has a string containing quotes.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="arguments">Command-line arguments to pass when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application and a set of command-line arguments, and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine Prozessressource durch Angeben der Dateiname und Befehlszeilenargumente starten. Die Überladung ordnet die Ressource einer neuen <xref:System.Diagnostics.Process> Objekt.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei, starten Sie eine URL ist, wird der Prozess nicht gestartet und `null` wird zurückgegeben.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne zuerst erstellt ein neues <xref:System.Diagnostics.Process> Instanz. Die Überladung ist eine Alternative zu den einzelnen Schritten für die Erstellung einer neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> und <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Mitglied der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, und der Aufruf <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Starten eines Prozesses durch Angabe des Dateinamens und der Argumente ähnelt dem Eingeben der Dateiname und Befehlszeilenargumente in die `Run` Dialogfeld des Windows- `Start` Menü. Aus diesem Grund muss der Dateiname nicht ausführbare Datei darstellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung mit einer Anwendung, die auf dem System installierten zugeordnet wurde. Kann z. B. der Dateinamen die Erweiterung ".txt" aufweisen, wenn Textdateien in einem Editor wie dem Editor zugeordnet oder die .doc haben DOC-Dateien mit einem Textverarbeitungsprogramm wie Microsoft Word. Auf ähnliche Weise, in der gleichen Weise wie die `Run` Dialogfeld Name einer ausführbaren Datei mit oder ohne die Erweiterung .exe akzeptiert, ist die Erweiterung .exe in optional die `fileName` Parameter. Sie können z. B. Festlegen der `fileName` Parameter für "Notepad.exe" oder "Editor". Wenn die `fileName` Parameter darstellt, eine ausführbare Datei der `arguments` Parameter zu reagieren, z. B. die Textdatei in eine Datei repräsentieren möglicherweise `Notepad.exe myfile.txt`. Wenn die `fileName` -Parameter stellt eine Befehlsdatei (cmd), die `arguments` Parameter muss entweder enthalten eine "`/c`"oder"`/k`" Argument, um anzugeben, ob das Befehlsfenster beendet wird, oder bleibt nach Abschluss des Vorgangs.  
  
 Im Gegensatz zu anderen Überladungen, die Überladung der <xref:System.Diagnostics.Process.Start%2A> weist keine Parameter auf, die keine `static` Member. Verwenden Sie diese Überladung, wenn Sie bereits erstellt haben eine <xref:System.Diagnostics.Process> -Instanz werden angegebene Startinformationen (einschließlich des Dateinamens), und möchten eine Prozessressource gestartet, und verknüpfen Sie sie mit der vorhandenen <xref:System.Diagnostics.Process> Instanz. Gehen Sie die `static` überlädt, wenn Sie möchten, dass zum Erstellen eines neuen <xref:System.Diagnostics.Process> -Komponente statt Starten eines Prozesses für eine vorhandene Komponente. Diese Überladung und die Überladung, die keine Parameter hat ermöglichen Ihnen das Festlegen der Dateiname der der Prozessressource gestartet und die Befehlszeilenargumente übergeben.  
  
 Wenn Sie eine Path-Variablen, die in Ihrem System mit Anführungszeichen deklariert haben, müssen Sie, dass der Pfad vollständig qualifizieren, wenn an diesem Speicherort gefundenen Prozess zu starten. Andernfalls wird das System den Pfad nicht gefunden. Z. B. wenn `c:\mypath` befindet sich nicht in Ihrem Pfad, und fügen Sie ihn in Anführungszeichen gesetzt: `path = %path%;"c:\mypath"`, müssen Sie jeden Prozess im vollständig qualifizieren `c:\mypath` beim Starten.  
  
> [!NOTE]
>  ASP.NET Web Seiten- und Server-Steuerelement-Code wird im Rahmen der ASP.NET-Arbeitsprozess auf dem Webserver ausgeführt.  Bei Verwendung der <xref:System.Diagnostics.Process.Start%2A> Methode in einer ASP.NET-Webseite oder Serversteuerelement, der neue Prozess ausgeführt wird, auf dem Webserver mit eingeschränkten Berechtigungen. Der Prozess wird nicht in demselben Kontext wie der Clientbrowser gestartet und hat keinen Zugriff auf dem Desktop des Benutzers.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen sie zu schließen, oder Sie riskieren Systemressourcen verfügbar sind. Schließen Prozesse mit <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft..  
  
 Hier ist ein Hinweis zum Apartmentzustände in verwalteten Threads erforderlich. Wenn <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> ist `true` in der Prozesskomponente <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, stellen Sie sicher, dass ein Threadingmodell für die Anwendung festgelegt haben, indem das Attribut `[STAThread]` auf die `main()` Methode. Andernfalls kann ein verwalteter Thread in ein `unknown` Zustand, oder fügen Sie in der `MTA` aufweist, was zu einem Konflikt mit letztere <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> wird `true`. Einige Methoden erfordern, dass der Apartmentzustand nicht `unknown`. Wenn der Zustand nicht explizit festgelegt wird, wenn die Anwendung eine solche Methode auftritt, wird standardmäßig `MTA`, einmal festgelegt, kann der Apartmentzustand geändert werden. Allerdings `MTA` löst eine Ausnahme ausgelöst wird, wenn die Betriebssystemshell, den Thread verwaltet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zunächst eine Instanz von Internet Explorer erzeugt und zeigt den Inhalt des Ordners Favoriten im Browser. Klicken Sie dann weitere Instanzen von Internet Explorer gestartet, und bestimmte Seiten oder Sites angezeigt. Schließlich wird Internet Explorer gestartet, mit dem Fenster beim Navigieren zu einem bestimmten Standort minimiert wird.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <paramref name="fileName" /> or <paramref name="arguments" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the process exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The PATH environment variable has a string containing quotes.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="userName">The user name to use when starting the process.</param>
        <param name="password">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</param>
        <param name="domain">The domain to use when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um einen neuen Prozess und seine primäre Thread durch Angabe des Dateinamens, Benutzername, Kennwort und Domäne zu erstellen. Der neue Prozess führt dann die angegebene ausführbare Datei im Sicherheitskontext der angegebenen Anmeldeinformationen (Benutzer, Domäne und Kennwort).  
  
> [!NOTE]
>  Wenn die ausführbare Datei auf einem remote-Laufwerk befindet, müssen Sie die Netzwerkfreigabe identifizieren, mit der ein uniform Resource Identifier (URI), keinen verknüpften Laufwerkbuchstaben.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei, starten Sie eine URL ist, wird der Prozess nicht gestartet und `null` wird zurückgegeben.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne zuerst erstellt ein neues <xref:System.Diagnostics.Process> Instanz. Die Überladung ist eine Alternative zu den einzelnen Schritten für die Erstellung einer neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, und <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> Eigenschaften der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, und der Aufruf <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Auf ähnliche Weise, in der gleichen Weise die **ausführen** Dialogfeld Name einer ausführbaren Datei mit oder ohne die Erweiterung .exe akzeptiert, ist die Erweiterung .exe in optional die `fileName` Parameter. Sie können z. B. Festlegen der `fileName` Parameter für "Notepad.exe" oder "Editor". Wenn die `fileName` Parameter darstellt, eine ausführbare Datei der `arguments` Parameter zu reagieren, z. B. die Textdatei in eine Datei repräsentieren möglicherweise `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Der Dateiname muss eine ausführbare Datei in darstellen der <xref:System.Diagnostics.Process.Start%2A> Überladungen `userName`, `password`, und `domain` Parameter.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen sie zu schließen, oder Sie riskieren Systemressourcen verfügbar sind. Schließen Prozesse mit <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft..  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung dieser Überladung zum Starten einer ausführbaren Datei und zeigt auch das Auslösen einer <xref:System.ComponentModel.Win32Exception> Wenn es versucht wird, zum Starten einer Anwendung eine nicht ausführbare Datei zugeordnet.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on Linux or macOS (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="arguments">Command-line arguments to pass when starting the process.</param>
        <param name="userName">The user name to use when starting the process.</param>
        <param name="password">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</param>
        <param name="domain">The domain to use when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application, a set of command-line arguments, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um einen neuen Prozess und seine primäre Thread durch Angabe des Dateinamens, Befehlszeilenargumente, Benutzername, Kennwort und Domäne zu erstellen. Der neue Prozess führt dann die angegebene ausführbare Datei im Sicherheitskontext der angegebenen Anmeldeinformationen (Benutzer, Domäne und Kennwort).  
  
> [!NOTE]
>  Wenn die ausführbare Datei auf einem remote-Laufwerk befindet, müssen Sie die Netzwerkfreigabe identifizieren, mit der ein uniform Resource Identifier (URI), keinen verknüpften Laufwerkbuchstaben.  
  
> [!NOTE]
>  Wenn die Adresse der ausführbaren Datei, starten Sie eine URL ist, wird der Prozess nicht gestartet und `null` wird zurückgegeben.  
  
 Mit dieser Überladung können Sie einen Prozess zu starten, ohne zuerst erstellt ein neues <xref:System.Diagnostics.Process> Instanz. Die Überladung ist eine Alternative zu den einzelnen Schritten für die Erstellung einer neuen <xref:System.Diagnostics.Process> -Instanz, Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, und <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> Eigenschaften der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft, und der Aufruf <xref:System.Diagnostics.Process.Start%2A> für die <xref:System.Diagnostics.Process> Instanz.  
  
 Auf ähnliche Weise, in der gleichen Weise die **ausführen** Dialogfeld Name einer ausführbaren Datei mit oder ohne die Erweiterung .exe akzeptiert, ist die Erweiterung .exe in optional die `fileName` Parameter. Sie können z. B. Festlegen der `fileName` Parameter für "Notepad.exe" oder "Editor". Wenn die `fileName` Parameter darstellt, eine ausführbare Datei der `arguments` Parameter zu reagieren, z. B. die Textdatei in eine Datei repräsentieren möglicherweise `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Der Dateiname muss eine ausführbare Datei in darstellen der <xref:System.Diagnostics.Process.Start%2A> Überladungen `userName`, `password`, und `domain` Parameter.  
  
 Bei Verwendung <xref:System.Diagnostics.Process.Start%2A> um einen Prozess zu starten, müssen sie zu schließen, oder Sie riskieren Systemressourcen verfügbar sind. Schließen Prozesse mit <xref:System.Diagnostics.Process.CloseMainWindow%2A> oder <xref:System.Diagnostics.Process.Kill%2A>. Sie können überprüfen, ob ein Prozess mit bereits geschlossen wurde die <xref:System.Diagnostics.Process.HasExited%2A> Eigenschaft..  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the associated file exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on Linux or macOS (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the properties to pass to the <see cref="M:System.Diagnostics.Process.Start" /> method of the <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>Die <see cref="T:System.Diagnostics.ProcessStartInfo" />, die die Daten darstellt, mit denen der Prozess gestartet werden soll. Diese Argumente beinhalten den Namen der ausführbaren Datei oder des Dokuments, das zum Starten des Prozesses verwendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> Stellt den Satz von Parametern zum Starten eines Prozesses verwendet. Wenn <xref:System.Diagnostics.Process.Start%2A> aufgerufen wird, die <xref:System.Diagnostics.Process.StartInfo%2A> wird verwendet, um den zu startenden Prozess angeben. Nur erforderliche <xref:System.Diagnostics.Process.StartInfo%2A> gehört zum Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft. Starten eines Prozesses durch Angabe der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft ähnelt dem Eingeben der Informationen in den **ausführen** Dialogfeld des Windows- **starten** Menü. Aus diesem Grund die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft muss es sich nicht um eine ausführbare Datei darzustellen. Sie können einen beliebigen Dateityp werden für die die Erweiterung mit einer Anwendung, die auf dem System installierten zugeordnet wurde. Zum Beispiel die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> kann die Erweiterung ".txt" aufweisen, wenn Textdateien in einem Editor wie dem Editor zugeordnet oder die .doc haben DOC-Dateien mit einem Textverarbeitungsprogramm wie Microsoft Word. Auf ähnliche Weise, in der gleichen Weise die **ausführen** Dialogfeld Name einer ausführbaren Datei mit oder ohne die Erweiterung .exe akzeptiert, ist die Erweiterung .exe in optional die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Member. Sie können z. B. Festlegen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft auf "Notepad.exe" oder "Editor".  
  
 Sie können eine ClickOnce-Anwendung starten, indem die <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft, um den Speicherort (z. B. eine Webadresse), die von der Sie die Anwendung ursprünglich installiert haben. Starten Sie eine ClickOnce-Anwendung nicht durch Angabe der entsprechenden Speicherort auf der Festplatte freigeben.  
  
 Wenn der Dateiname eine nicht ausführbare Datei, z. B. eine DOC-Datei umfasst, können Sie ein Verb an, welche Aktion für die Datei angeben einschließen. Sie können z. B. Festlegen der <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> "Drucken" für eine Datei mit der Erweiterung DOC. Die Datei im angegebenen Namen der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft muss nicht auf eine Erweiterung aufweisen, wenn Sie manuell einen Wert für die <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Eigenschaft. Allerdings bei Verwendung der <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> Eigenschaft, um zu bestimmen, welche Verben verfügbar sind, müssen Sie die Erweiterung einschließen.  
  
 Sie können die Parameter, die im angegebenen Ändern der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft bis zu der Zeit, die Sie Aufrufen der <xref:System.Diagnostics.Process.Start%2A> -Methode für den Prozess. Nachdem Sie den Prozess starten, ändern die <xref:System.Diagnostics.Process.StartInfo%2A> Werte nicht beeinflussen, und starten Sie den zugeordneten Prozess. Beim Aufrufen der <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> Methode mit der <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> und <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> festgelegten Eigenschaften, die nicht verwaltete `CreateProcessWithLogonW` Funktion aufgerufen wird, die den Prozess in einem neuen Fenster, selbst wenn startet die <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> Eigenschaftswert ist `true` oder die <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> Eigenschaftswert ist <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Wenn Sie nicht verwendet haben die <xref:System.Diagnostics.Process.Start%2A> Methode zum Starten eines Prozesses, der <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft reflektiert nicht die zum Starten des Prozesses verwendeten Parameter. Angenommen, Sie verwenden <xref:System.Diagnostics.Process.GetProcesses%2A> zum Abrufen eines Arrays auf dem Computer ausgeführten Prozesse auf die <xref:System.Diagnostics.Process.StartInfo%2A> -Eigenschaft jedes <xref:System.Diagnostics.Process> enthält nicht den ursprünglichen Dateinamen an oder die Argumente, die zum Starten des Prozesses verwendet.  
  
 Wenn der Prozess gestartet wird, wird der Dateiname ist die Datei, die die (schreibgeschützte) füllt <xref:System.Diagnostics.Process.MainModule%2A> Eigenschaft. Wenn Sie verwenden möchten, rufen Sie die ausführbare Datei, die mit dem Prozess zugeordnet ist, nachdem der Prozess gestartet wurde, verwenden die <xref:System.Diagnostics.Process.MainModule%2A> Eigenschaft. Wenn Sie die ausführbare Datei der festlegen möchten eine <xref:System.Diagnostics.Process> Instanz, für die ein zugeordnete Prozess nicht gestartet wurde, verwenden Sie die <xref:System.Diagnostics.Process.StartInfo%2A> der Eigenschaft <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Member. Da der Mitglieder der <xref:System.Diagnostics.Process.StartInfo%2A> Eigenschaft sind Argumente, die übergeben werden, der <xref:System.Diagnostics.Process.Start%2A> Methode eines Prozesses ändern der <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Eigenschaft nach dem Start des zugeordneten Prozess nicht zurückgesetzt, der <xref:System.Diagnostics.Process.MainModule%2A> Eigenschaft. Diese Eigenschaften dienen nur zum Initialisieren des zugeordneten Prozesses.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Diagnostics.Process.StartInfo%2A> mit der auszuführenden Datei, die Aktion ausgeführt werden, und gibt an, ob es sollte eine Benutzeroberfläche angezeigt. Weitere Beispiele finden Sie unter den Referenzseiten für Eigenschaften von der <xref:System.Diagnostics.ProcessStartInfo> Klasse.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value that specifies the <see cref="P:System.Diagnostics.Process.StartInfo" /> is <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the associated process was started.</summary>
        <value>Ein Objekt, das angibt, wann der zugeordnete Prozess gestartet wurde. Eine Ausnahme wird ausgelöst, wenn der Prozess nicht ausgeführt wird.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.StartTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process has exited.  -or-  The process has not been started.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred in the call to the Windows function.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the object used to marshal the event handler calls that are issued as a result of a process exit event.</summary>
        <value>Das <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, das zum Marshallen von Ereignishandleraufrufen verwendet wird, die als Ergebnis eines <see cref="E:System.Diagnostics.Process.Exited" />-Ereignisses des Prozesses ausgegeben werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> ist `null`, Methoden zum Behandeln der <xref:System.Diagnostics.Process.Exited> Ereignis in einem Thread aus dem Threadpool System aufgerufen werden. Weitere Informationen zu System Threadpools, finden Sie unter <xref:System.Threading.ThreadPool>.  
  
 Wenn die <xref:System.Diagnostics.Process.Exited> Ereignis erfolgt durch einen visuellen Windows Forms-Komponente, wie z. B. eine <xref:System.Windows.Forms.Button>, Zugriff auf die Komponente über den Threadpool System funktioniert möglicherweise nicht, oder wird unter Umständen eine Ausnahme ausgelöst. Vermeiden Sie dies, indem <xref:System.Diagnostics.Process.SynchronizingObject%2A> an eine Windows Forms-Komponente, durch die die Methoden zur Behandlung der <xref:System.Diagnostics.Process.Exited> Ereignis im selben Thread aufgerufen werden, auf dem die Komponente erstellt wurde.  
  
 Wenn die <xref:System.Diagnostics.Process> dient in [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in einem Windows Forms-Designer <xref:System.Diagnostics.Process.SynchronizingObject%2A> wird automatisch festgelegt, um das Steuerelement, enthält die <xref:System.Diagnostics.Process>. Angenommen, Sie Platzieren einer <xref:System.Diagnostics.Process> in einem Designer für `Form1` (geerbt von <xref:System.Windows.Forms.Form>) der <xref:System.Diagnostics.Process.SynchronizingObject%2A> Eigenschaft <xref:System.Diagnostics.Process> festgelegt ist, mit der Instanz von `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 In der Regel wird diese Eigenschaft festgelegt, wenn die Komponente in einem Steuerelement oder ein Formular platziert wird, da diese Komponenten an einen bestimmten Thread gebunden sind.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the set of threads that are running in the associated process.</summary>
        <value>Ein Array vom Typ <see cref="T:System.Diagnostics.ProcessThread" />, das die Threads des Betriebssystems darstellt, die gegenwärtig im zugeordneten Prozess ausgeführt werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Thread führt Code in einem Prozess. Jeder Prozess wird mit einem einzelnen Thread, dessen primäre Thread gestartet. Jeder Thread kann zusätzliche Threads generieren. Threads innerhalb eines Prozesses freigeben den Adressraum des Prozesses.  
  
 Verwendung <xref:System.Diagnostics.ProcessThread> zum Abrufen aller Threads, die dem aktuellen Prozess zugeordnet. Der primäre Thread ist nicht unbedingt am Index 0 (null) im Array.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">The process does not have an <see cref="P:System.Diagnostics.Process.Id" />, or no process is associated with the <see cref="T:System.Diagnostics.Process" /> instance.  -or-  The associated process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Formats the process's name as a string, combined with the parent component type, if applicable.</summary>
        <returns>The <see cref="P:System.Diagnostics.Process.ProcessName" />, combined with the base component's <see cref="M:System.Object.ToString" /> return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" /> is not supported on Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the total processor time for this process.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, während der der zugeordnete Prozess die CPU verwendet hat. Dieser Wert ist die Summe von <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> und <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the user processor time for this process.</summary>
        <value>Eine <see cref="T:System.TimeSpan" />, die die Zeitspanne angibt, während der der zugeordnete Prozess Code innerhalb der Anwendung des Prozesses (nicht im Betriebssystemkern) ausgeführt hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Exitcode des Prozesses angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the size of the process's virtual memory, in bytes.</summary>
        <value>Die virtuelle Speicher in Bytes, der vom zugehörigen Prozess angefordert wurde.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of the virtual memory, in bytes, allocated for the associated process.</summary>
        <value>Die Größe des virtuellen Speichers in Bytes, der für den zugeordneten Prozess belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe des virtuellen Speichers durch den Prozess in Bytes verwendet. Das Betriebssystem ordnet des virtuellen Adressraums für jeden Prozess auf Seiten im physischen Speicher oder zu Seiten, die in die Auslagerungsdatei des virtuellen Speichers auf dem Datenträger gespeicherten geladen hat.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **virtuelle Bytes** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the period of time to wait for the associated process to exit, and blocks the current thread of execution until the time has elapsed or the process has exited. To avoid blocking the current thread, use the <see cref="E:System.Diagnostics.Process.Exited" /> event.  For code examples, see the <see cref="P:System.Diagnostics.Process.StandardError" /> and the <see cref="P:System.Diagnostics.Process.ExitCode" /> property reference pages.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to exit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> wird den aktuellen Thread wartet, bis der zugeordnete Prozess beendet wird.  Es sollte aufgerufen werden, nachdem alle anderen Methoden für den Prozess aufgerufen werden. Verwenden Sie das Ereignis <xref:System.Diagnostics.Process.Exited>, um ein Blockieren des aktuellen Threads zu verhindern.  
  
 Diese Methode weist die <xref:System.Diagnostics.Process> -Komponente wartet, bis eine unendliche Zeitspanne für den Prozess und Ereignis-Handler zu beenden. Dies kann dazu führen, dass eine Anwendung nicht mehr reagiert. Angenommen, Sie rufen <xref:System.Diagnostics.Process.CloseMainWindow%2A> für einen Prozess, der über eine Benutzeroberfläche verfügt, die Anforderung an das Betriebssystem zum Beenden des zugeordneten Prozesses möglicherweise nicht behandelt werden, wenn der Prozess geschrieben wird, nie eine Meldungsschleife eingeben.  
  
> [!NOTE]
>  In der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] und früheren Versionen der <xref:System.Diagnostics.Process.WaitForExit> Überladung gewartet <xref:System.Int32.MaxValue> Millisekunden (ca. 24 Tage) nicht unbegrenzt. Vorgängerversionen außerdem nicht warten, für die Ereignishandler auf, wenn der Agent beendet das vollständige <xref:System.Int32.MaxValue> Uhrzeit wurde erreicht.  
  
 Diese Überladung wird sichergestellt, dass die gesamte Verarbeitung abgeschlossen wurde, einschließlich der Behandlung von asynchrone Ereignisse für die umgeleiteten Standardausgabe. Verwenden Sie diese Überladung nach einem Aufruf von der <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> Überladung, wenn die Standardausgabe an asynchrone Ereignishandler umgeleitet wurde.  
  
 Wenn der zugehörige Prozess beendet wird (das heißt, wenn es durch das Betriebssystem über eine Beendigung ordnungsgemäß oder nicht ordnungsgemäß heruntergefahren wird), speichert das System administrative Informationen über den Prozess und gibt Sie zurück an die Komponente, die aufgerufen wird, mussten <xref:System.Diagnostics.Process.WaitForExit>. Die <xref:System.Diagnostics.Process> Komponente kann dann die Informationen, darunter zugreifen der <xref:System.Diagnostics.Process.ExitTime%2A>, mithilfe der <xref:System.Diagnostics.Process.Handle%2A> für den beendeten Prozess.  
  
 Da der zugeordnete Prozess beendet wurde, die <xref:System.Diagnostics.Process.Handle%2A> Eigenschaft der Komponente verweist auf eine vorhandene Prozessressource nicht mehr darauf. Das Handle kann stattdessen verwendet werden, nur für das Betriebssystem-Informationen zu der Prozessressource zugreifen. Das System ist bewusst Handles für beendete Prozesse, die nicht freigegeben wurden, indem Sie <xref:System.Diagnostics.Process> Komponenten, sodass er verfolgt die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.Handle%2A> Informationen im Arbeitsspeicher, bis die <xref:System.Diagnostics.Process> Komponente speziell Gibt Ressourcen frei. Aus diesem Grund bei jedem Aufrufen <xref:System.Diagnostics.Process.Start%2A> für eine <xref:System.Diagnostics.Process> Instanz ist, rufen Sie <xref:System.Diagnostics.Process.Close%2A> Wenn der zugeordnete Prozess beendet wurde und Sie die entsprechenden administrativen Informationen nicht mehr benötigen. <xref:System.Diagnostics.Process.Close%2A> Gibt den für den beendeten Prozess belegten Arbeitsspeicher frei.  
  
   
  
## Examples  
 Finden Sie im Abschnitt "Hinweise" der <xref:System.Diagnostics.Process.StandardError%2A> Eigenschaft-Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The wait setting could not be accessed.</exception>
        <exception cref="T:System.SystemException">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.  -or-  You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit" /> for a process that is running on a remote computer. This method is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">The amount of time, in milliseconds, to wait for the associated process to exit. The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system.</param>
        <summary>Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to exit.</summary>
        <returns>
          <see langword="true" /> if the associated process has exited; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> wird den aktuellen Thread wartet, bis der zugeordnete Prozess beendet wird. Es sollte aufgerufen werden, nachdem alle anderen Methoden für den Prozess aufgerufen werden. Verwenden Sie das Ereignis <xref:System.Diagnostics.Process.Exited>, um ein Blockieren des aktuellen Threads zu verhindern.  
  
 Diese Methode weist die <xref:System.Diagnostics.Process> -Komponente wartet, bis eine begrenzte Zeitspanne für den Prozess zu beenden. Wenn der zugeordnete Prozess nicht am Ende des Intervalls beendet wird, da die Anforderung zum Beenden der Zugriff verweigert wird, `false` an die aufrufende Prozedur zurückgegeben wird. Sie können angeben, <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> für `milliseconds`, und <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> Verhalten sich identisch der <xref:System.Diagnostics.Process.WaitForExit> überladen. Wenn Sie 0 (null) an die Methode übergeben, gibt es `true` nur, wenn der Prozess bereits beendet wurde; andernfalls wird sofort zurückgegeben `false`.  
  
> [!NOTE]
>  In der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] und frühere Versionen, wenn `milliseconds` -1 ist, wurde die <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> Überladung gewartet <xref:System.Int32.MaxValue> Millisekunden (ca. 24 Tage) nicht unbegrenzt.  
  
 Wenn die Standardausgabe an asynchrone Ereignishandler umgeleitet wurde, ist es möglich, dass die Verarbeitung der Ausgabe wird nicht abgeschlossen haben, wenn diese Methode zurückgegeben. Stellen Sie sicher, dass die asynchrone Ereignisbehandlung abgeschlossen wurde, Aufrufen der <xref:System.Diagnostics.Process.WaitForExit> Überladung, die keine Parameter, nachdem annimmt eine `true` von dieser Überladung. Um sicherzustellen, dass die <xref:System.Diagnostics.Process.Exited> Ereignis in Windows Forms-Anwendung ordnungsgemäß verarbeitet wird, legen Sie die <xref:System.Diagnostics.Process.SynchronizingObject%2A> Eigenschaft.  
  
 Wenn ein zugeordnete Prozess beendet (heruntergefahren durch das Betriebssystem ordnungsgemäß oder nicht ordnungsgemäß beendet), das System speichert administrativen Informationen über den Prozess und gibt Sie zurück an die Komponente, die aufgerufen hat <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. Die <xref:System.Diagnostics.Process> Komponente kann dann die Informationen, darunter zugreifen der <xref:System.Diagnostics.Process.ExitTime%2A>, mithilfe der <xref:System.Diagnostics.Process.Handle%2A> für den beendeten Prozess.  
  
 Da der zugeordnete Prozess beendet wurde, die <xref:System.Diagnostics.Process.Handle%2A> Eigenschaft der Komponente verweist auf eine vorhandene Prozessressource nicht mehr darauf. Das Handle kann stattdessen verwendet werden, nur für das Betriebssystem-Informationen zu der Prozessressource zugreifen. Das System ist bewusst Handles für beendete Prozesse, die nicht freigegeben wurden, indem Sie <xref:System.Diagnostics.Process> Komponenten, sodass er verfolgt die <xref:System.Diagnostics.Process.ExitTime%2A> und <xref:System.Diagnostics.Process.Handle%2A> Informationen im Arbeitsspeicher, bis die <xref:System.Diagnostics.Process> Komponente speziell Gibt Ressourcen frei. Aus diesem Grund bei jedem Aufrufen <xref:System.Diagnostics.Process.Start%2A> für eine <xref:System.Diagnostics.Process> Instanz ist, rufen Sie <xref:System.Diagnostics.Process.Close%2A> Wenn der zugeordnete Prozess beendet wurde und Sie die entsprechenden administrativen Informationen nicht mehr benötigen. <xref:System.Diagnostics.Process.Close%2A> Gibt den für den beendeten Prozess belegten Arbeitsspeicher frei.  
  
   
  
## Examples  
 Finden Sie im Codebeispiel für die <xref:System.Diagnostics.Process.ExitCode%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The wait setting could not be accessed.</exception>
        <exception cref="T:System.SystemException">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.  -or-  You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> for a process that is running on a remote computer. This method is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait for the associated process to enter an idle state.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to enter an idle state. This overload applies only to processes with a user interface and, therefore, a message loop.</summary>
        <returns>
          <see langword="true" /> if the associated process has reached an idle state.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Diagnostics.Process.WaitForInputIdle> zu erzwingen, dass die Verarbeitung Ihrer Anwendung warten, bis die Nachrichtenschleife in den Leerlaufzustand zurückgegeben hat. Wenn ein Prozess mit einer Benutzeroberfläche ausgeführt wird, führt die Nachrichtenschleife jedes Mal, wenn eine Windows-Nachricht an den Prozess vom Betriebssystem gesendet wird. Der Prozess wird dann wieder an das die Meldungsschleife. Ein Prozess wird als im Leerlauf sein, wenn sie Nachrichten innerhalb einer Nachrichtenschleife wartet bezeichnet. Dieser Status ist z. B. dann sinnvoll, wenn Ihre Anwendung für einen Prozess ab, um den Vorgang abzuschließen, erstellen das Hauptfenster aus, bevor die Anwendung dieses Fensters kommuniziert warten muss.  
  
 Wenn ein Prozess nicht über eine Nachrichtenschleife verfügt <xref:System.Diagnostics.Process.WaitForInputIdle> löst eine <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Diagnostics.Process.WaitForInputIdle> Überladung weist das <xref:System.Diagnostics.Process> Komponente auf unbestimmte Zeit zu warten, bis der Prozess in der Nachrichtenschleife in den Leerlauf versetzt wird. Diese Anweisung kann dazu führen, dass eine Anwendung nicht mehr reagiert. Z. B. wenn der Prozess immer in geschrieben werden die Nachrichtenschleife unmittelbar beendet, wie das Codefragment `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have a graphical interface.  -or-  An unknown error occurred. The process failed to enter an idle state.  -or-  The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">A value of 1 to <see cref="F:System.Int32.MaxValue" /> that specifies the amount of time, in milliseconds, to wait for the associated process to become idle. A value of 0 specifies an immediate return, and a value of -1 specifies an infinite wait.</param>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to enter an idle state. This overload applies only to processes with a user interface and, therefore, a message loop.</summary>
        <returns>
          <see langword="true" /> if the associated process has reached an idle state; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> zu erzwingen, dass die Verarbeitung Ihrer Anwendung warten, bis die Nachrichtenschleife in den Leerlaufzustand zurückgegeben hat. Wenn ein Prozess mit einer Benutzeroberfläche ausgeführt wird, führt die Nachrichtenschleife jedes Mal, wenn eine Windows-Nachricht an den Prozess vom Betriebssystem gesendet wird. Der Prozess wird dann wieder an das die Meldungsschleife. Ein Prozess wird als im Leerlauf sein, wenn sie Nachrichten innerhalb einer Nachrichtenschleife wartet bezeichnet. Dieser Status ist z. B. dann sinnvoll, wenn Ihre Anwendung für einen Prozess ab, um den Vorgang abzuschließen, erstellen das Hauptfenster aus, bevor die Anwendung dieses Fensters kommuniziert warten muss.  
  
 Wenn ein Prozess nicht über eine Nachrichtenschleife verfügt <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> löst eine <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> Überladung weist das <xref:System.Diagnostics.Process> -Komponente wartet, bis eine begrenzte Zeitspanne für den Prozess in den Leerlauf in der Nachrichtenschleife. Wenn der zugeordnete Prozess nicht am Ende des Intervalls Leerlauf Schleife noch Nachrichten verarbeitet `false` an die aufrufende Prozedur zurückgegeben wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have a graphical interface.  -or-  An unknown error occurred. The process failed to enter an idle state.  -or-  The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the associated process's physical memory usage, in bytes.</summary>
        <value>Der Gesamtgröße des vom zugeordneten Prozess verwendeten physischen Speichers in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe der Menge Arbeitsspeicher verwendet, die für den Prozess in Bytes dar. Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die aktuell sichtbaren an den Prozess im physischen Arbeitsspeicher. Diese Seiten sind resident und einer Anwendung verwenden, ohne einen Seitenfehler auslösen zur Verfügung.  
  
 Das Workingset enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die alle Anweisungen, die der Prozess ausgeführt wird enthalten, z. B. die Prozessmodule und der Systembibliotheken.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Instanz von Editor gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und der Prozessexitcode angezeigt.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of physical memory, in bytes, allocated for the associated process.</summary>
        <value>Die Größe des physischen Speichers in Bytes, der für den zugeordneten Prozess belegt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene Wert stellt die aktuelle Größe der Menge Arbeitsspeicher verwendet, die für den Prozess in Bytes dar. Der Arbeitssatz eines Prozesses ist der Satz von Speicherseiten, die aktuell sichtbaren an den Prozess im physischen Arbeitsspeicher. Diese Seiten sind resident und einer Anwendung verwenden, ohne einen Seitenfehler auslösen zur Verfügung.  
  
 Das Workingset enthält die freigegebene und private Daten. Die freigegebene Datenquelle enthält Seiten, die alle Anweisungen, die der Prozess ausgeführt wird enthalten, einschließlich der Anweisungen in die Prozessmodule und der Systembibliotheken.  
  
 Diese Eigenschaft kann zur Überwachung der arbeitsspeichernutzung auf Computern mit 32-Bit-Prozessoren oder 64-Bit-Prozessoren verwendet werden. Der Eigenschaftswert ist gleichbedeutend mit der **Workingsets** Leistungsindikator für den Prozess.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz von Editor-Anwendung gestartet. Im Beispiel wird anschließend ruft ab und zeigt verschiedene Eigenschaften des zugeordneten Prozesses. Im Beispiel wird erkannt, wenn der Prozess beendet wird, und beenden Code und Spitzenwerte Arbeitsspeicherstatistik angezeigt.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>